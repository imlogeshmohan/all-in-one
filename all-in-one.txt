## File: .\all-in-one.txt



################################################################################

## File: .\create-all-in-one-file.py

import os

# Function to recursively navigate and collect file contents
def collect_code_to_file(output_file="all-in-one.txt"):
    # Open the output file in write mode (this will overwrite the file if it exists)
    with open(output_file, "w", encoding="utf-8") as out_file:
        # Walk through all directories and files starting from the current directory
        for root, dirs, files in os.walk("."):
            for file in files:
                # Only include certain file types (e.g., Python files, text files)
                if file.endswith(('.py', '.js', '.html', '.css', '.txt', '.ts')):
                    file_path = os.path.join(root, file)
                    try:
                        # Open each file and write its content to the output file
                        with open(file_path, "r", encoding="utf-8") as f:
                            out_file.write(f"## File: {file_path}\n\n")
                            out_file.write(f.read())
                            out_file.write("\n\n" + "#" * 80 + "\n\n")
                    except Exception as e:
                        print(f"Could not read file {file_path}: {e}")

if __name__ == "__main__":
    collect_code_to_file()


################################################################################

## File: .\jitsi-meet\.eslintrc.js

module.exports = {
    'extends': [
        '@jitsi/eslint-config'
    ],
    'ignorePatterns': [ '*.d.ts' ]
};


################################################################################

## File: .\jitsi-meet\app.js

/* application specific logic */

// Re-export jQuery
// FIXME: Remove this requirement from torture tests.
import $ from 'jquery';

window.$ = window.jQuery = $;

import '@matrix-org/olm';

import 'focus-visible';

// We need to setup the jitsi-local-storage as early as possible so that we can start using it.
// NOTE: If jitsi-local-storage is used before the initial setup is performed this will break the use case when we use
// the  local storage from the parent page when the localStorage is disabled. Also the setup is relying that
// window.location is not changed and still has all URL parameters.
import './react/features/base/jitsi-local-storage/setup';
import conference from './conference';
import API from './modules/API';
import UI from './modules/UI/UI';
import translation from './modules/translation/translation';

// Initialize Olm as early as possible.
if (window.Olm) {
    window.Olm.init().catch(e => {
        console.error('Failed to initialize Olm, E2EE will be disabled', e);
        delete window.Olm;
    });
}

window.APP = {
    API,
    conference,
    translation,
    UI
};

// TODO The execution of the mobile app starts from react/index.native.js.
// Similarly, the execution of the Web app should start from react/index.web.js
// for the sake of consistency and ease of understanding. Temporarily though
// because we are at the beginning of introducing React into the Web app, allow
// the execution of the Web app to start from app.js in order to reduce the
// complexity of the beginning step.
import './react';


################################################################################

## File: .\jitsi-meet\babel.config.js

module.exports = {
    presets: [ 'module:metro-react-native-babel-preset' ],
    env: {
        production: {
            plugins: [ 'react-native-paper/babel' ]
        }
    },
    plugins: [ 'optional-require' ]
};


################################################################################

## File: .\jitsi-meet\base.html

<base href="/" />


################################################################################

## File: .\jitsi-meet\body.html



################################################################################

## File: .\jitsi-meet\conference.js

/* global APP, JitsiMeetJS, config, interfaceConfig */

import { jitsiLocalStorage } from '@jitsi/js-utils';
import Logger from '@jitsi/logger';

import { ENDPOINT_TEXT_MESSAGE_NAME } from './modules/API/constants';
import mediaDeviceHelper from './modules/devices/mediaDeviceHelper';
import Recorder from './modules/recorder/Recorder';
import { createTaskQueue } from './modules/util/helpers';
import {
    createDeviceChangedEvent,
    createScreenSharingEvent,
    createStartSilentEvent,
    createTrackMutedEvent
} from './react/features/analytics/AnalyticsEvents';
import { sendAnalytics } from './react/features/analytics/functions';
import {
    maybeRedirectToWelcomePage,
    reloadWithStoredParams
} from './react/features/app/actions';
import { showModeratedNotification } from './react/features/av-moderation/actions';
import { shouldShowModeratedNotification } from './react/features/av-moderation/functions';
import {
    _conferenceWillJoin,
    authStatusChanged,
    conferenceFailed,
    conferenceJoinInProgress,
    conferenceJoined,
    conferenceLeft,
    conferenceSubjectChanged,
    conferenceTimestampChanged,
    conferenceUniqueIdSet,
    conferenceWillInit,
    conferenceWillLeave,
    dataChannelClosed,
    dataChannelOpened,
    e2eRttChanged,
    endpointMessageReceived,
    kickedOut,
    lockStateChanged,
    nonParticipantMessageReceived,
    onStartMutedPolicyChanged,
    p2pStatusChanged
} from './react/features/base/conference/actions';
import {
    AVATAR_URL_COMMAND,
    CONFERENCE_LEAVE_REASONS,
    EMAIL_COMMAND
} from './react/features/base/conference/constants';
import {
    commonUserJoinedHandling,
    commonUserLeftHandling,
    getConferenceOptions,
    sendLocalParticipant
} from './react/features/base/conference/functions';
import { getReplaceParticipant, getSsrcRewritingFeatureFlag } from './react/features/base/config/functions';
import { connect } from './react/features/base/connection/actions.web';
import {
    checkAndNotifyForNewDevice,
    getAvailableDevices,
    notifyCameraError,
    notifyMicError,
    updateDeviceList
} from './react/features/base/devices/actions.web';
import {
    areDevicesDifferent,
    filterIgnoredDevices,
    flattenAvailableDevices,
    getDefaultDeviceId,
    logDevices,
    setAudioOutputDeviceId
} from './react/features/base/devices/functions.web';
import {
    JitsiConferenceErrors,
    JitsiConferenceEvents,
    JitsiE2ePingEvents,
    JitsiMediaDevicesEvents,
    JitsiTrackEvents,
    browser
} from './react/features/base/lib-jitsi-meet';
import {
    gumPending,
    setAudioAvailable,
    setAudioMuted,
    setAudioUnmutePermissions,
    setInitialGUMPromise,
    setVideoAvailable,
    setVideoMuted,
    setVideoUnmutePermissions
} from './react/features/base/media/actions';
import { MEDIA_TYPE, VIDEO_TYPE } from './react/features/base/media/constants';
import {
    getStartWithAudioMuted,
    getStartWithVideoMuted,
    isVideoMutedByUser
} from './react/features/base/media/functions';
import { IGUMPendingState } from './react/features/base/media/types';
import {
    dominantSpeakerChanged,
    localParticipantAudioLevelChanged,
    localParticipantRoleChanged,
    participantKicked,
    participantMutedUs,
    participantPresenceChanged,
    participantRoleChanged,
    participantSourcesUpdated,
    participantUpdated,
    screenshareParticipantDisplayNameChanged,
    updateRemoteParticipantFeatures
} from './react/features/base/participants/actions';
import {
    getLocalParticipant,
    getNormalizedDisplayName,
    getParticipantByIdOrUndefined,
    getVirtualScreenshareParticipantByOwnerId
} from './react/features/base/participants/functions';
import { updateSettings } from './react/features/base/settings/actions';
import {
    addLocalTrack,
    createInitialAVTracks,
    destroyLocalTracks,
    displayErrorsForCreateInitialLocalTracks,
    replaceLocalTrack,
    setGUMPendingStateOnFailedTracks,
    toggleScreensharing as toggleScreensharingA,
    trackAdded,
    trackRemoved
} from './react/features/base/tracks/actions';
import {
    createLocalTracksF,
    getLocalJitsiAudioTrack,
    getLocalJitsiVideoTrack,
    getLocalTracks,
    getLocalVideoTrack,
    isLocalTrackMuted,
    isUserInteractionRequiredForUnmute
} from './react/features/base/tracks/functions';
import { downloadJSON } from './react/features/base/util/downloadJSON';
import { openLeaveReasonDialog } from './react/features/conference/actions.web';
import { showDesktopPicker } from './react/features/desktop-picker/actions';
import { appendSuffix } from './react/features/display-name/functions';
import { maybeOpenFeedbackDialog, submitFeedback } from './react/features/feedback/actions';
import { maybeSetLobbyChatMessageListener } from './react/features/lobby/actions.any';
import { setNoiseSuppressionEnabled } from './react/features/noise-suppression/actions';
import {
    hideNotification,
    showErrorNotification,
    showNotification,
    showWarningNotification
} from './react/features/notifications/actions';
import {
    DATA_CHANNEL_CLOSED_NOTIFICATION_ID,
    NOTIFICATION_TIMEOUT_TYPE
} from './react/features/notifications/constants';
import { isModerationNotificationDisplayed } from './react/features/notifications/functions';
import { mediaPermissionPromptVisibilityChanged } from './react/features/overlay/actions';
import { suspendDetected } from './react/features/power-monitor/actions';
import { initPrejoin, isPrejoinPageVisible } from './react/features/prejoin/functions';
import { disableReceiver, stopReceiver } from './react/features/remote-control/actions';
import { setScreenAudioShareState } from './react/features/screen-share/actions.web';
import { isScreenAudioShared } from './react/features/screen-share/functions';
import { toggleScreenshotCaptureSummary } from './react/features/screenshot-capture/actions';
import { AudioMixerEffect } from './react/features/stream-effects/audio-mixer/AudioMixerEffect';
import { createRnnoiseProcessor } from './react/features/stream-effects/rnnoise';
import { handleToggleVideoMuted } from './react/features/toolbox/actions.any';
import { transcriberJoined, transcriberLeft } from './react/features/transcribing/actions';
import { muteLocal } from './react/features/video-menu/actions.any';

const logger = Logger.getLogger(__filename);
let room;

/*
 * Logic to open a desktop picker put on the window global for
 * lib-jitsi-meet to detect and invoke
 */
window.JitsiMeetScreenObtainer = {
    openDesktopPicker(options, onSourceChoose) {
        APP.store.dispatch(showDesktopPicker(options, onSourceChoose));
    }
};

/**
 * Known custom conference commands.
 */
const commands = {
    AVATAR_URL: AVATAR_URL_COMMAND,
    CUSTOM_ROLE: 'custom-role',
    EMAIL: EMAIL_COMMAND,
    ETHERPAD: 'etherpad'
};

/**
 * Share data to other users.
 * @param command the command
 * @param {string} value new value
 */
function sendData(command, value) {
    if (!room) {
        return;
    }

    room.removeCommand(command);
    room.sendCommand(command, { value });
}

/**
 * Mute or unmute local audio stream if it exists.
 * @param {boolean} muted - if audio stream should be muted or unmuted.
 */
function muteLocalAudio(muted) {
    APP.store.dispatch(setAudioMuted(muted));
}

/**
 * Mute or unmute local video stream if it exists.
 * @param {boolean} muted if video stream should be muted or unmuted.
 *
 */
function muteLocalVideo(muted) {
    APP.store.dispatch(setVideoMuted(muted));
}

/**
 * A queue for the async replaceLocalTrack action so that multiple audio
 * replacements cannot happen simultaneously. This solves the issue where
 * replaceLocalTrack is called multiple times with an oldTrack of null, causing
 * multiple local tracks of the same type to be used.
 *
 * @private
 * @type {Object}
 */
const _replaceLocalAudioTrackQueue = createTaskQueue();

/**
 * A task queue for replacement local video tracks. This separate queue exists
 * so video replacement is not blocked by audio replacement tasks in the queue
 * {@link _replaceLocalAudioTrackQueue}.
 *
 * @private
 * @type {Object}
 */
const _replaceLocalVideoTrackQueue = createTaskQueue();

/**
 *
 */
class ConferenceConnector {
    /**
     *
     */
    constructor(resolve, reject, conference) {
        this._conference = conference;
        this._resolve = resolve;
        this._reject = reject;
        this.reconnectTimeout = null;
        room.on(JitsiConferenceEvents.CONFERENCE_JOINED,
            this._handleConferenceJoined.bind(this));
        room.on(JitsiConferenceEvents.CONFERENCE_FAILED,
            this._onConferenceFailed.bind(this));
    }

    /**
     *
     */
    _handleConferenceFailed(err) {
        this._unsubscribe();
        this._reject(err);
    }

    /**
     *
     */
    _onConferenceFailed(err, ...params) {
        APP.store.dispatch(conferenceFailed(room, err, ...params));
        logger.error('CONFERENCE FAILED:', err, ...params);

        switch (err) {

        case JitsiConferenceErrors.RESERVATION_ERROR: {
            const [ code, msg ] = params;

            APP.store.dispatch(showErrorNotification({
                descriptionArguments: {
                    code,
                    msg
                },
                descriptionKey: 'dialog.reservationErrorMsg',
                titleKey: 'dialog.reservationError'
            }, NOTIFICATION_TIMEOUT_TYPE.LONG));
            break;
        }

        case JitsiConferenceErrors.GRACEFUL_SHUTDOWN:
            APP.store.dispatch(showErrorNotification({
                descriptionKey: 'dialog.gracefulShutdown',
                titleKey: 'dialog.serviceUnavailable'
            }, NOTIFICATION_TIMEOUT_TYPE.LONG));
            break;

        // FIXME FOCUS_DISCONNECTED is a confusing event name.
        // What really happens there is that the library is not ready yet,
        // because Jicofo is not available, but it is going to give it another
        // try.
        case JitsiConferenceErrors.FOCUS_DISCONNECTED: {
            const [ focus, retrySec ] = params;

            APP.store.dispatch(showNotification({
                descriptionKey: focus,
                titleKey: retrySec
            }, NOTIFICATION_TIMEOUT_TYPE.SHORT));
            break;
        }

        case JitsiConferenceErrors.FOCUS_LEFT:
        case JitsiConferenceErrors.ICE_FAILED:
        case JitsiConferenceErrors.VIDEOBRIDGE_NOT_AVAILABLE:
        case JitsiConferenceErrors.OFFER_ANSWER_FAILED:
            APP.store.dispatch(conferenceWillLeave(room));

            // FIXME the conference should be stopped by the library and not by
            // the app. Both the errors above are unrecoverable from the library
            // perspective.
            room.leave(CONFERENCE_LEAVE_REASONS.UNRECOVERABLE_ERROR).then(() => APP.connection.disconnect());
            break;

        case JitsiConferenceErrors.INCOMPATIBLE_SERVER_VERSIONS:
            APP.store.dispatch(reloadWithStoredParams());
            break;

        default:
            this._handleConferenceFailed(err, ...params);
        }
    }

    /**
     *
     */
    _unsubscribe() {
        room.off(
            JitsiConferenceEvents.CONFERENCE_JOINED,
            this._handleConferenceJoined);
        room.off(
            JitsiConferenceEvents.CONFERENCE_FAILED,
            this._onConferenceFailed);
        if (this.reconnectTimeout !== null) {
            clearTimeout(this.reconnectTimeout);
        }
    }

    /**
     *
     */
    _handleConferenceJoined() {
        this._unsubscribe();
        this._resolve();
    }

    /**
     *
     */
    connect() {
        const replaceParticipant = getReplaceParticipant(APP.store.getState());

        // the local storage overrides here and in connection.js can be used by jibri
        room.join(jitsiLocalStorage.getItem('xmpp_conference_password_override'), replaceParticipant);
    }
}

/**
 * Disconnects the connection.
 * @returns resolved Promise. We need this in order to make the Promise.all
 * call in hangup() to resolve when all operations are finished.
 */
function disconnect() {
    const onDisconnected = () => {
        APP.API.notifyConferenceLeft(APP.conference.roomName);

        return Promise.resolve();
    };

    if (!APP.connection) {
        return onDisconnected();
    }

    return APP.connection.disconnect().then(onDisconnected, onDisconnected);
}

export default {
    /**
     * Flag used to delay modification of the muted status of local media tracks
     * until those are created (or not, but at that point it's certain that
     * the tracks won't exist).
     */
    _localTracksInitialized: false,

    /**
     * Flag used to prevent the creation of another local video track in this.muteVideo if one is already in progress.
     */
    isCreatingLocalTrack: false,

    isSharingScreen: false,

    /**
     * Returns an object containing a promise which resolves with the created tracks &
     * the errors resulting from that process.
     * @param {object} options
     * @param {boolean} options.startAudioOnly=false - if <tt>true</tt> then
     * only audio track will be created and the audio only mode will be turned
     * on.
     * @param {boolean} options.startScreenSharing=false - if <tt>true</tt>
     * should start with screensharing instead of camera video.
     * @param {boolean} options.startWithAudioMuted - will start the conference
     * without any audio tracks.
     * @param {boolean} options.startWithVideoMuted - will start the conference
     * without any video tracks.
     * @returns {Promise<JitsiLocalTrack[]>, Object}
     */
    createInitialLocalTracks(options = {}) {
        const errors = {};

        // Always get a handle on the audio input device so that we have statistics (such as "No audio input" or
        // "Are you trying to speak?" ) even if the user joins the conference muted.
        const initialDevices = config.startSilent || config.disableInitialGUM ? [] : [ MEDIA_TYPE.AUDIO ];
        const requestedAudio = !config.disableInitialGUM;
        let requestedVideo = false;

        if (!config.disableInitialGUM
                && !options.startWithVideoMuted
                && !options.startAudioOnly
                && !options.startScreenSharing) {
            initialDevices.push(MEDIA_TYPE.VIDEO);
            requestedVideo = true;
        }

        if (!config.disableInitialGUM) {
            JitsiMeetJS.mediaDevices.addEventListener(
                JitsiMediaDevicesEvents.PERMISSION_PROMPT_IS_SHOWN,
                browserName =>
                    APP.store.dispatch(
                        mediaPermissionPromptVisibilityChanged(true, browserName))
            );
        }

        let tryCreateLocalTracks = Promise.resolve([]);

        // On Electron there is no permission prompt for granting permissions. That's why we don't need to
        // spend much time displaying the overlay screen. If GUM is not resolved within 15 seconds it will
        // probably never resolve.
        const timeout = browser.isElectron() ? 15000 : 60000;
        const audioOptions = {
            devices: [ MEDIA_TYPE.AUDIO ],
            timeout,
            firePermissionPromptIsShownEvent: true
        };

        // Spot uses the _desktopSharingSourceDevice config option to use an external video input device label as
        // screenshare and calls getUserMedia instead of getDisplayMedia for capturing the media.
        if (options.startScreenSharing && config._desktopSharingSourceDevice) {
            tryCreateLocalTracks = this._createDesktopTrack()
                .then(([ desktopStream ]) => {
                    if (!requestedAudio) {
                        return [ desktopStream ];
                    }

                    return createLocalTracksF(audioOptions)
                        .then(([ audioStream ]) =>
                            [ desktopStream, audioStream ])
                        .catch(error => {
                            errors.audioOnlyError = error;

                            return [ desktopStream ];
                        });
                })
                .catch(error => {
                    logger.error('Failed to obtain desktop stream', error);
                    errors.screenSharingError = error;

                    return requestedAudio ? createLocalTracksF(audioOptions) : [];
                })
                .catch(error => {
                    errors.audioOnlyError = error;

                    return [];
                });
        } else if (requestedAudio || requestedVideo) {
            tryCreateLocalTracks = APP.store.dispatch(createInitialAVTracks({
                devices: initialDevices,
                timeout,
                firePermissionPromptIsShownEvent: true
            })).then(({ tracks, errors: pErrors }) => {
                Object.assign(errors, pErrors);

                return tracks;
            });
        }

        // Hide the permissions prompt/overlay as soon as the tracks are created. Don't wait for the connection to
        // be established, as in some cases like when auth is required, connection won't be established until the user
        // inputs their credentials, but the dialog would be overshadowed by the overlay.
        tryCreateLocalTracks.then(tracks => {
            APP.store.dispatch(mediaPermissionPromptVisibilityChanged(false));

            return tracks;
        });

        return {
            tryCreateLocalTracks,
            errors
        };
    },

    startConference(tracks) {
        tracks.forEach(track => {
            if ((track.isAudioTrack() && this.isLocalAudioMuted())
                || (track.isVideoTrack() && this.isLocalVideoMuted())) {
                const mediaType = track.getType();

                sendAnalytics(
                    createTrackMutedEvent(mediaType, 'initial mute'));
                logger.log(`${mediaType} mute: initially muted.`);
                track.mute();
            }
        });

        this._createRoom(tracks);

        // if user didn't give access to mic or camera or doesn't have
        // them at all, we mark corresponding toolbar buttons as muted,
        // so that the user can try unmute later on and add audio/video
        // to the conference
        if (!tracks.find(t => t.isAudioTrack())) {
            this.updateAudioIconEnabled();
        }

        if (!tracks.find(t => t.isVideoTrack())) {
            this.setVideoMuteStatus();
        }

        if (config.iAmRecorder) {
            this.recorder = new Recorder();
        }

        if (config.startSilent) {
            sendAnalytics(createStartSilentEvent());
            APP.store.dispatch(showNotification({
                descriptionKey: 'notify.startSilentDescription',
                titleKey: 'notify.startSilentTitle'
            }, NOTIFICATION_TIMEOUT_TYPE.LONG));
        }

        // XXX The API will take care of disconnecting from the XMPP
        // server (and, thus, leaving the room) on unload.
        return new Promise((resolve, reject) => {
            new ConferenceConnector(resolve, reject, this).connect();
        });
    },

    /**
     * Open new connection and join the conference when prejoin page is not enabled.
     * If prejoin page is enabled open an new connection in the background
     * and create local tracks.
     *
     * @param {{ roomName: string }} options
     * @returns {Promise}
     */
    async init({ roomName }) {
        const state = APP.store.getState();
        const initialOptions = {
            startAudioOnly: config.startAudioOnly,
            startScreenSharing: config.startScreenSharing,
            startWithAudioMuted: getStartWithAudioMuted(state) || isUserInteractionRequiredForUnmute(state),
            startWithVideoMuted: getStartWithVideoMuted(state) || isUserInteractionRequiredForUnmute(state)
        };

        logger.debug(`Executed conference.init with roomName: ${roomName}`);

        this.roomName = roomName;

        try {
            // Initialize the device list first. This way, when creating tracks based on preferred devices, loose label
            // matching can be done in cases where the exact ID match is no longer available, such as -
            // 1. When the camera device has switched USB ports.
            // 2. When in startSilent mode we want to start with audio muted
            await this._initDeviceList();
        } catch (error) {
            logger.warn('initial device list initialization failed', error);
        }

        // Filter out the local tracks based on various config options, i.e., when user joins muted or is muted by
        // focus. However, audio track will always be created even though it is not added to the conference since we
        // want audio related features (noisy mic, talk while muted, etc.) to work even if the mic is muted.
        const handleInitialTracks = (options, tracks) => {
            let localTracks = tracks;

            if (options.startWithAudioMuted) {
                // Always add the track on Safari because of a known issue where audio playout doesn't happen
                // if the user joins audio and video muted, i.e., if there is no local media capture.
                if (browser.isWebKitBased()) {
                    this.muteAudio(true, true);
                } else {
                    localTracks = localTracks.filter(track => track.getType() !== MEDIA_TYPE.AUDIO);
                }
            }

            return localTracks;
        };
        const { dispatch, getState } = APP.store;
        const { tryCreateLocalTracks, errors } = this.createInitialLocalTracks(initialOptions);

        dispatch(setInitialGUMPromise(tryCreateLocalTracks.then(async tr => {
            const tracks = handleInitialTracks(initialOptions, tr);

            this._initDeviceList(true);

            if (isPrejoinPageVisible(getState())) {
                dispatch(gumPending([ MEDIA_TYPE.AUDIO, MEDIA_TYPE.VIDEO ], IGUMPendingState.NONE));
                dispatch(setInitialGUMPromise());
                initPrejoin(tracks, errors, dispatch);
            } else {
                APP.store.dispatch(displayErrorsForCreateInitialLocalTracks(errors));
                setGUMPendingStateOnFailedTracks(tracks, APP.store.dispatch);
            }

            return {
                tracks,
                errors
            };
        })));

        if (!isPrejoinPageVisible(getState())) {
            logger.info('Dispatching connect from init since prejoin is not visible.');
            dispatch(connect());
        }
    },

    /**
     * Check if id is id of the local user.
     * @param {string} id id to check
     * @returns {boolean}
     */
    isLocalId(id) {
        return this.getMyUserId() === id;
    },

    /**
     * Tells whether the local video is muted or not.
     * @return {boolean}
     */
    isLocalVideoMuted() {
        // If the tracks are not ready, read from base/media state
        return this._localTracksInitialized
            ? isLocalTrackMuted(APP.store.getState()['features/base/tracks'], MEDIA_TYPE.VIDEO)
            : isVideoMutedByUser(APP.store);
    },

    /**
     * Verify if there is an ongoing system audio sharing session and apply to the provided track
     * as a AudioMixer effect.
     *
     * @param {*} localAudioTrack - track to which system audio track will be applied as an effect, most likely
     * microphone local audio track.
     */
    async _maybeApplyAudioMixerEffect(localAudioTrack) {

        // At the time of writing this comment there were two separate flows for toggling screen-sharing
        // and system audio sharing, the first is the legacy method using the functionality from conference.js
        // the second is used when both sendMultipleVideoStreams and sourceNameSignaling flags are set to true.
        // The second flow uses functionality from base/conference/middleware.web.js.
        // We check if system audio sharing was done using the first flow by verifying this._desktopAudioStream and
        // for the second by checking 'features/screen-share' state.
        const { desktopAudioTrack } = APP.store.getState()['features/screen-share'];
        const currentDesktopAudioTrack = this._desktopAudioStream || desktopAudioTrack;

        // If system audio is already being sent, mix it with the provided audio track.
        if (currentDesktopAudioTrack) {
            // In case system audio sharing was done in the absence of an initial mic audio track, there is no
            // AudioMixerEffect so we have to remove system audio track from the room before setting it as an effect.
            await room.replaceTrack(currentDesktopAudioTrack, null);
            this._mixerEffect = new AudioMixerEffect(currentDesktopAudioTrack);
            logger.debug('Mixing new audio track with existing screen audio track.');
            await localAudioTrack.setEffect(this._mixerEffect);
        }
    },

    /**
     * Simulates toolbar button click for audio mute. Used by shortcuts and API.
     *
     * @param {boolean} mute true for mute and false for unmute.
     * @param {boolean} [showUI] when set to false will not display any error
     * dialogs in case of media permissions error.
     * @returns {Promise}
     */
    async muteAudio(mute, showUI = true) {
        const state = APP.store.getState();

        if (!mute
            && isUserInteractionRequiredForUnmute(state)) {
            logger.error('Unmuting audio requires user interaction');

            return;
        }

        // check for A/V Moderation when trying to unmute
        if (!mute && shouldShowModeratedNotification(MEDIA_TYPE.AUDIO, state)) {
            if (!isModerationNotificationDisplayed(MEDIA_TYPE.AUDIO, state)) {
                APP.store.dispatch(showModeratedNotification(MEDIA_TYPE.AUDIO));
            }

            return;
        }

        // Not ready to modify track's state yet
        if (!this._localTracksInitialized) {
            // This will only modify base/media.audio.muted which is then synced
            // up with the track at the end of local tracks initialization.
            muteLocalAudio(mute);
            this.updateAudioIconEnabled();

            return;
        } else if (this.isLocalAudioMuted() === mute) {
            // NO-OP
            return;
        }

        const localAudio = getLocalJitsiAudioTrack(APP.store.getState());

        if (!localAudio && !mute) {
            const maybeShowErrorDialog = error => {
                showUI && APP.store.dispatch(notifyMicError(error));
            };

            APP.store.dispatch(gumPending([ MEDIA_TYPE.AUDIO ], IGUMPendingState.PENDING_UNMUTE));

            await createLocalTracksF({ devices: [ 'audio' ] })
                .then(([ audioTrack ]) => audioTrack)
                .catch(error => {
                    maybeShowErrorDialog(error);

                    // Rollback the audio muted status by using null track
                    return null;
                })
                .then(async audioTrack => {
                    await this._maybeApplyAudioMixerEffect(audioTrack);

                    return this.useAudioStream(audioTrack);
                })
                .finally(() => {
                    APP.store.dispatch(gumPending([ MEDIA_TYPE.AUDIO ], IGUMPendingState.NONE));
                });
        } else {
            muteLocalAudio(mute);
        }
    },

    /**
     * Returns whether local audio is muted or not.
     * @returns {boolean}
     */
    isLocalAudioMuted() {
        // If the tracks are not ready, read from base/media state
        return this._localTracksInitialized
            ? isLocalTrackMuted(
                APP.store.getState()['features/base/tracks'],
                MEDIA_TYPE.AUDIO)
            : Boolean(
                APP.store.getState()['features/base/media'].audio.muted);
    },

    /**
     * Simulates toolbar button click for audio mute. Used by shortcuts
     * and API.
     * @param {boolean} [showUI] when set to false will not display any error
     * dialogs in case of media permissions error.
     */
    toggleAudioMuted(showUI = true) {
        this.muteAudio(!this.isLocalAudioMuted(), showUI);
    },

    /**
     * Simulates toolbar button click for video mute. Used by shortcuts and API.
     * @param mute true for mute and false for unmute.
     * @param {boolean} [showUI] when set to false will not display any error
     * dialogs in case of media permissions error.
     */
    muteVideo(mute, showUI = true) {
        if (this.videoSwitchInProgress) {
            logger.warn('muteVideo - unable to perform operations while video switch is in progress');

            return;
        }

        const state = APP.store.getState();

        if (!mute
                && isUserInteractionRequiredForUnmute(state)) {
            logger.error('Unmuting video requires user interaction');

            return;
        }

        // check for A/V Moderation when trying to unmute and return early
        if (!mute && shouldShowModeratedNotification(MEDIA_TYPE.VIDEO, state)) {
            return;
        }

        // If not ready to modify track's state yet adjust the base/media
        if (!this._localTracksInitialized) {
            // This will only modify base/media.video.muted which is then synced
            // up with the track at the end of local tracks initialization.
            muteLocalVideo(mute);
            this.setVideoMuteStatus();

            return;
        } else if (this.isLocalVideoMuted() === mute) {
            // NO-OP
            return;
        }

        const localVideo = getLocalJitsiVideoTrack(state);

        if (!localVideo && !mute && !this.isCreatingLocalTrack) {
            const maybeShowErrorDialog = error => {
                showUI && APP.store.dispatch(notifyCameraError(error));
            };

            this.isCreatingLocalTrack = true;

            APP.store.dispatch(gumPending([ MEDIA_TYPE.VIDEO ], IGUMPendingState.PENDING_UNMUTE));

            // Try to create local video if there wasn't any.
            // This handles the case when user joined with no video
            // (dismissed screen sharing screen or in audio only mode), but
            // decided to add it later on by clicking on muted video icon or
            // turning off the audio only mode.
            //
            // FIXME when local track creation is moved to react/redux
            // it should take care of the use case described above
            createLocalTracksF({ devices: [ 'video' ] })
                .then(([ videoTrack ]) => videoTrack)
                .catch(error => {
                    // FIXME should send some feedback to the API on error ?
                    maybeShowErrorDialog(error);

                    // Rollback the video muted status by using null track
                    return null;
                })
                .then(videoTrack => {
                    logger.debug(`muteVideo: calling useVideoStream for track: ${videoTrack}`);

                    return this.useVideoStream(videoTrack);
                })
                .finally(() => {
                    this.isCreatingLocalTrack = false;
                    APP.store.dispatch(gumPending([ MEDIA_TYPE.VIDEO ], IGUMPendingState.NONE));
                });
        } else {
            // FIXME show error dialog if it fails (should be handled by react)
            muteLocalVideo(mute);
        }
    },

    /**
     * Simulates toolbar button click for video mute. Used by shortcuts and API.
     * @param {boolean} [showUI] when set to false will not display any error
     * dialogs in case of media permissions error.
     * @param {boolean} ensureTrack - True if we want to ensure that a new track is
     * created if missing.
     */
    toggleVideoMuted(showUI = true, ensureTrack = false) {
        const mute = !this.isLocalVideoMuted();

        APP.store.dispatch(handleToggleVideoMuted(mute, showUI, ensureTrack));
    },

    /**
     * Retrieve list of ids of conference participants (without local user).
     * @returns {string[]}
     */
    listMembersIds() {
        return room.getParticipants().map(p => p.getId());
    },

    /**
     * Checks whether the participant identified by id is a moderator.
     * @id id to search for participant
     * @return {boolean} whether the participant is moderator
     */
    isParticipantModerator(id) {
        const user = room.getParticipantById(id);

        return user && user.isModerator();
    },

    /**
     * Retrieve list of conference participants (without local user).
     * @returns {JitsiParticipant[]}
     *
     * NOTE: Used by jitsi-meet-torture!
     */
    listMembers() {
        return room.getParticipants();
    },

    /**
     * Used by Jibri to detect when it's alone and the meeting should be terminated.
     */
    get membersCount() {
        return room.getParticipants()
            .filter(p => !p.isHidden() || !(config.iAmRecorder && p.isHiddenFromRecorder())).length + 1;
    },

    /**
     * Get speaker stats that track total dominant speaker time.
     *
     * @returns {object} A hash with keys being user ids and values being the
     * library's SpeakerStats model used for calculating time as dominant
     * speaker.
     */
    getSpeakerStats() {
        return room.getSpeakerStats();
    },

    // used by torture currently
    isJoined() {
        return room && room.isJoined();
    },
    getConnectionState() {
        return room && room.getConnectionState();
    },

    /**
     * Obtains current P2P ICE connection state.
     * @return {string|null} ICE connection state or <tt>null</tt> if there's no
     * P2P connection
     */
    getP2PConnectionState() {
        return room && room.getP2PConnectionState();
    },

    /**
     * Starts P2P (for tests only)
     * @private
     */
    _startP2P() {
        try {
            room && room.startP2PSession();
        } catch (error) {
            logger.error('Start P2P failed', error);
            throw error;
        }
    },

    /**
     * Stops P2P (for tests only)
     * @private
     */
    _stopP2P() {
        try {
            room && room.stopP2PSession();
        } catch (error) {
            logger.error('Stop P2P failed', error);
            throw error;
        }
    },

    /**
     * Checks whether or not our connection is currently in interrupted and
     * reconnect attempts are in progress.
     *
     * @returns {boolean} true if the connection is in interrupted state or
     * false otherwise.
     */
    isConnectionInterrupted() {
        return room.isConnectionInterrupted();
    },

    /**
     * Finds JitsiParticipant for given id.
     *
     * @param {string} id participant's identifier(MUC nickname).
     *
     * @returns {JitsiParticipant|null} participant instance for given id or
     * null if not found.
     */
    getParticipantById(id) {
        return room ? room.getParticipantById(id) : null;
    },

    getMyUserId() {
        return room && room.myUserId();
    },

    /**
     * Will be filled with values only when config.debug is enabled.
     * Its used by torture to check audio levels.
     */
    audioLevelsMap: {},

    /**
     * Returns the stored audio level (stored only if config.debug is enabled)
     * @param id the id for the user audio level to return (the id value is
     *          returned for the participant using getMyUserId() method)
     */
    getPeerSSRCAudioLevel(id) {
        return this.audioLevelsMap[id];
    },

    /**
     * @return {number} the number of participants in the conference with at
     * least one track.
     */
    getNumberOfParticipantsWithTracks() {
        return room.getParticipants()
            .filter(p => p.getTracks().length > 0)
            .length;
    },

    /**
     * Returns the stats.
     */
    getStats() {
        return room.connectionQuality.getStats();
    },

    // end used by torture

    /**
     * Download logs, a function that can be called from console while
     * debugging.
     * @param filename (optional) specify target filename
     */
    saveLogs(filename = 'meetlog.json') {
        // this can be called from console and will not have reference to this
        // that's why we reference the global var
        const logs = APP.connection.getLogs();

        downloadJSON(logs, filename);
    },

    /**
     * Exposes a Command(s) API on this instance. It is necessitated by (1) the
     * desire to keep room private to this instance and (2) the need of other
     * modules to send and receive commands to and from participants.
     * Eventually, this instance remains in control with respect to the
     * decision whether the Command(s) API of room (i.e. lib-jitsi-meet's
     * JitsiConference) is to be used in the implementation of the Command(s)
     * API of this instance.
     */
    commands: {
        /**
         * Known custom conference commands.
         */
        defaults: commands,

        /**
         * Receives notifications from other participants about commands aka
         * custom events (sent by sendCommand or sendCommandOnce methods).
         * @param command {String} the name of the command
         * @param handler {Function} handler for the command
         */
        addCommandListener() {
            // eslint-disable-next-line prefer-rest-params
            room.addCommandListener(...arguments);
        },

        /**
         * Removes command.
         * @param name {String} the name of the command.
         */
        removeCommand() {
            // eslint-disable-next-line prefer-rest-params
            room.removeCommand(...arguments);
        },

        /**
         * Sends command.
         * @param name {String} the name of the command.
         * @param values {Object} with keys and values that will be sent.
         */
        sendCommand() {
            // eslint-disable-next-line prefer-rest-params
            room.sendCommand(...arguments);
        },

        /**
         * Sends command one time.
         * @param name {String} the name of the command.
         * @param values {Object} with keys and values that will be sent.
         */
        sendCommandOnce() {
            // eslint-disable-next-line prefer-rest-params
            room.sendCommandOnce(...arguments);
        }
    },

    /**
     * Used by the Breakout Rooms feature to join a breakout room or go back to the main room.
     */
    async joinRoom(roomName, options) {
        APP.store.dispatch(conferenceWillInit());

        // Restore initial state.
        this._localTracksInitialized = false;
        this.isSharingScreen = false;
        this.roomName = roomName;

        const { tryCreateLocalTracks, errors } = this.createInitialLocalTracks(options);
        const localTracks = await tryCreateLocalTracks;

        APP.store.dispatch(displayErrorsForCreateInitialLocalTracks(errors));
        localTracks.forEach(track => {
            if ((track.isAudioTrack() && this.isLocalAudioMuted())
                || (track.isVideoTrack() && this.isLocalVideoMuted())) {
                track.mute();
            }
        });
        this._createRoom(localTracks);

        return new Promise((resolve, reject) => {
            new ConferenceConnector(resolve, reject, this).connect();
        });
    },

    _createRoom(localTracks) {
        room = APP.connection.initJitsiConference(APP.conference.roomName, this._getConferenceOptions());

        // Filter out the tracks that are muted (except on Safari).
        let tracks = localTracks;

        if (!browser.isWebKitBased()) {
            const mutedTrackTypes = [];

            tracks = localTracks.filter(track => {
                if (!track.isMuted()) {
                    return true;
                }

                if (track.getVideoType() !== VIDEO_TYPE.DESKTOP) {
                    mutedTrackTypes.push(track.getType());
                }

                return false;
            });
            APP.store.dispatch(gumPending(mutedTrackTypes, IGUMPendingState.NONE));
        }

        this._room = room; // FIXME do not use this

        APP.store.dispatch(_conferenceWillJoin(room));

        this._setLocalAudioVideoStreams(tracks);

        sendLocalParticipant(APP.store, room);

        this._setupListeners();
    },

    /**
     * Sets local video and audio streams.
     * @param {JitsiLocalTrack[]} tracks=[]
     * @returns {Promise[]}
     * @private
     */
    _setLocalAudioVideoStreams(tracks = []) {
        const { dispatch } = APP.store;
        const pendingGUMDevicesToRemove = [];
        const promises = tracks.map(track => {
            if (track.isAudioTrack()) {
                pendingGUMDevicesToRemove.push(MEDIA_TYPE.AUDIO);

                return this.useAudioStream(track);
            } else if (track.isVideoTrack()) {
                logger.debug(`_setLocalAudioVideoStreams is calling useVideoStream with track: ${track}`);
                pendingGUMDevicesToRemove.push(MEDIA_TYPE.VIDEO);

                return this.useVideoStream(track);
            }

            logger.error('Ignored not an audio nor a video track: ', track);

            return Promise.resolve();

        });

        return Promise.allSettled(promises).then(() => {
            if (pendingGUMDevicesToRemove.length > 0) {
                dispatch(gumPending(pendingGUMDevicesToRemove, IGUMPendingState.NONE));
            }

            this._localTracksInitialized = true;
            logger.log(`Initialized with ${tracks.length} local tracks`);
        });
    },

    _getConferenceOptions() {
        const options = getConferenceOptions(APP.store.getState());

        options.createVADProcessor = createRnnoiseProcessor;

        return options;
    },

    /**
     * Start using provided video stream.
     * Stops previous video stream.
     * @param {JitsiLocalTrack} newTrack - new track to use or null
     * @returns {Promise}
     */
    useVideoStream(newTrack) {
        logger.debug(`useVideoStream: ${newTrack}`);

        return new Promise((resolve, reject) => {
            _replaceLocalVideoTrackQueue.enqueue(onFinish => {
                const state = APP.store.getState();
                const oldTrack = getLocalJitsiVideoTrack(state);

                logger.debug(`useVideoStream: Replacing ${oldTrack} with ${newTrack}`);

                if (oldTrack === newTrack || (!oldTrack && !newTrack)) {
                    resolve();
                    onFinish();

                    return;
                }

                // Add the track to the conference if there is no existing track, replace it otherwise.
                const trackAction = oldTrack
                    ? replaceLocalTrack(oldTrack, newTrack, room)
                    : addLocalTrack(newTrack);

                APP.store.dispatch(trackAction)
                    .then(() => {
                        this.setVideoMuteStatus();
                    })
                    .then(resolve)
                    .catch(error => {
                        logger.error(`useVideoStream failed: ${error}`);
                        reject(error);
                    })
                    .then(onFinish);
            });
        });
    },

    /**
     * Start using provided audio stream.
     * Stops previous audio stream.
     * @param {JitsiLocalTrack} newTrack - new track to use or null
     * @returns {Promise}
     */
    useAudioStream(newTrack) {
        return new Promise((resolve, reject) => {
            _replaceLocalAudioTrackQueue.enqueue(onFinish => {
                const oldTrack = getLocalJitsiAudioTrack(APP.store.getState());

                if (oldTrack === newTrack) {
                    resolve();
                    onFinish();

                    return;
                }

                APP.store.dispatch(replaceLocalTrack(oldTrack, newTrack, room))
                    .then(() => {
                        this.updateAudioIconEnabled();
                    })
                    .then(resolve)
                    .catch(reject)
                    .then(onFinish);
            });
        });
    },

    /**
     * Returns whether or not the conference is currently in audio only mode.
     *
     * @returns {boolean}
     */
    isAudioOnly() {
        return Boolean(APP.store.getState()['features/base/audio-only'].enabled);
    },

    videoSwitchInProgress: false,

    /**
     * This fields stores a handler which will create a Promise which turns off
     * the screen sharing and restores the previous video state (was there
     * any video, before switching to screen sharing ? was it muted ?).
     *
     * Once called this fields is cleared to <tt>null</tt>.
     * @type {Function|null}
     */
    _untoggleScreenSharing: null,

    /**
     * Creates a Promise which turns off the screen sharing and restores
     * the previous state described by the arguments.
     *
     * This method is bound to the appropriate values, after switching to screen
     * sharing and stored in {@link _untoggleScreenSharing}.
     *
     * @param {boolean} didHaveVideo indicates if there was a camera video being
     * used, before switching to screen sharing.
     * @param {boolean} ignoreDidHaveVideo indicates if the camera video should be
     * ignored when switching screen sharing off.
     * @return {Promise} resolved after the screen sharing is turned off, or
     * rejected with some error (no idea what kind of error, possible GUM error)
     * in case it fails.
     * @private
     */
    async _turnScreenSharingOff(didHaveVideo, ignoreDidHaveVideo) {
        this._untoggleScreenSharing = null;
        this.videoSwitchInProgress = true;

        APP.store.dispatch(stopReceiver());

        this._stopProxyConnection();

        APP.store.dispatch(toggleScreenshotCaptureSummary(false));
        const tracks = APP.store.getState()['features/base/tracks'];
        const duration = getLocalVideoTrack(tracks)?.jitsiTrack.getDuration() ?? 0;

        // If system audio was also shared stop the AudioMixerEffect and dispose of the desktop audio track.
        if (this._mixerEffect) {
            const localAudio = getLocalJitsiAudioTrack(APP.store.getState());

            await localAudio.setEffect(undefined);
            await this._desktopAudioStream.dispose();
            this._mixerEffect = undefined;
            this._desktopAudioStream = undefined;

        // In case there was no local audio when screen sharing was started the fact that we set the audio stream to
        // null will take care of the desktop audio stream cleanup.
        } else if (this._desktopAudioStream) {
            await room.replaceTrack(this._desktopAudioStream, null);
            this._desktopAudioStream.dispose();
            this._desktopAudioStream = undefined;
        }

        APP.store.dispatch(setScreenAudioShareState(false));
        let promise;

        if (didHaveVideo && !ignoreDidHaveVideo) {
            promise = createLocalTracksF({ devices: [ 'video' ] })
                .then(([ stream ]) => {
                    logger.debug(`_turnScreenSharingOff using ${stream} for useVideoStream`);

                    return this.useVideoStream(stream);
                })
                .catch(error => {
                    logger.error('failed to switch back to local video', error);

                    return this.useVideoStream(null).then(() =>

                        // Still fail with the original err
                        Promise.reject(error)
                    );
                });
        } else {
            promise = this.useVideoStream(null);
        }

        return promise.then(
            () => {
                this.videoSwitchInProgress = false;
                sendAnalytics(createScreenSharingEvent('stopped',
                    duration === 0 ? null : duration));
                logger.info('Screen sharing stopped.');
            },
            error => {
                this.videoSwitchInProgress = false;
                logger.error(`_turnScreenSharingOff failed: ${error}`);

                throw error;
            });
    },

    /**
     * Creates desktop (screensharing) {@link JitsiLocalTrack}
     *
     * @param {Object} [options] - Screen sharing options that will be passed to
     * createLocalTracks.
     * @param {Object} [options.desktopSharing]
     * @param {Object} [options.desktopStream] - An existing desktop stream to
     * use instead of creating a new desktop stream.
     * @return {Promise.<JitsiLocalTrack>} - A Promise resolved with
     * {@link JitsiLocalTrack} for the screensharing or rejected with
     * {@link JitsiTrackError}.
     *
     * @private
     */
    _createDesktopTrack(options = {}) {
        const didHaveVideo = !this.isLocalVideoMuted();

        const getDesktopStreamPromise = options.desktopStream
            ? Promise.resolve([ options.desktopStream ])
            : createLocalTracksF({
                desktopSharingSourceDevice: options.desktopSharingSources
                    ? null : config._desktopSharingSourceDevice,
                desktopSharingSources: options.desktopSharingSources,
                devices: [ 'desktop' ]
            });

        return getDesktopStreamPromise.then(desktopStreams => {
            // Stores the "untoggle" handler which remembers whether was
            // there any video before and whether was it muted.
            this._untoggleScreenSharing
                = this._turnScreenSharingOff.bind(this, didHaveVideo);

            const desktopVideoStream = desktopStreams.find(stream => stream.getType() === MEDIA_TYPE.VIDEO);
            const desktopAudioStream = desktopStreams.find(stream => stream.getType() === MEDIA_TYPE.AUDIO);

            if (desktopAudioStream) {
                desktopAudioStream.on(
                    JitsiTrackEvents.LOCAL_TRACK_STOPPED,
                    () => {
                        logger.debug(`Local screensharing audio track stopped. ${this.isSharingScreen}`);

                        // Handle case where screen share was stopped from  the browsers 'screen share in progress'
                        // window. If audio screen sharing is stopped via the normal UX flow this point shouldn't
                        // be reached.
                        isScreenAudioShared(APP.store.getState())
                            && this._untoggleScreenSharing
                            && this._untoggleScreenSharing();
                    }
                );
            }

            if (desktopVideoStream) {
                desktopVideoStream.on(
                    JitsiTrackEvents.LOCAL_TRACK_STOPPED,
                    () => {
                        logger.debug(`Local screensharing track stopped. ${this.isSharingScreen}`);

                        // If the stream was stopped during screen sharing
                        // session then we should switch back to video.
                        this.isSharingScreen
                            && this._untoggleScreenSharing
                            && this._untoggleScreenSharing();
                    }
                );
            }

            return desktopStreams;
        }, error => {
            throw error;
        });
    },

    /**
     * Setup interaction between conference and UI.
     */
    _setupListeners() {
        // add local streams when joined to the conference
        room.on(JitsiConferenceEvents.CONFERENCE_JOINED, () => {
            this._onConferenceJoined();
        });
        room.on(
            JitsiConferenceEvents.CONFERENCE_JOIN_IN_PROGRESS,
            () => APP.store.dispatch(conferenceJoinInProgress(room)));

        room.on(
            JitsiConferenceEvents.CONFERENCE_LEFT,
            (...args) => {
                APP.store.dispatch(conferenceTimestampChanged(0));
                APP.store.dispatch(conferenceLeft(room, ...args));
            });

        room.on(
            JitsiConferenceEvents.CONFERENCE_UNIQUE_ID_SET,
            (...args) => {
                // Preserve the sessionId so that the value is accessible even after room
                // is disconnected.
                room.sessionId = room.getMeetingUniqueId();
                APP.store.dispatch(conferenceUniqueIdSet(room, ...args));
            });

        // we want to ignore this event in case of tokenAuthUrl config
        // we are deprecating this and at some point will get rid of it
        if (!config.tokenAuthUrl) {
            room.on(
                JitsiConferenceEvents.AUTH_STATUS_CHANGED,
                (authEnabled, authLogin) =>
                    APP.store.dispatch(authStatusChanged(authEnabled, authLogin)));
        }

        room.on(JitsiConferenceEvents.PARTCIPANT_FEATURES_CHANGED, user => {
            APP.store.dispatch(updateRemoteParticipantFeatures(user));
        });
        room.on(JitsiConferenceEvents.USER_JOINED, (id, user) => {
            if (config.iAmRecorder && user.isHiddenFromRecorder()) {
                return;
            }

            // The logic shared between RN and web.
            commonUserJoinedHandling(APP.store, room, user);

            if (user.isHidden()) {
                return;
            }

            APP.store.dispatch(updateRemoteParticipantFeatures(user));
            logger.log(`USER ${id} connected:`, user);
            APP.UI.addUser(user);
        });

        room.on(JitsiConferenceEvents.USER_LEFT, (id, user) => {
            // The logic shared between RN and web.
            commonUserLeftHandling(APP.store, room, user);

            if (user.isHidden()) {
                return;
            }

            logger.log(`USER ${id} LEFT:`, user);
        });

        room.on(JitsiConferenceEvents.USER_STATUS_CHANGED, (id, status) => {
            APP.store.dispatch(participantPresenceChanged(id, status));

            const user = room.getParticipantById(id);

            if (user) {
                APP.UI.updateUserStatus(user, status);
            }
        });

        room.on(JitsiConferenceEvents.USER_ROLE_CHANGED, (id, role) => {
            if (this.isLocalId(id)) {
                logger.info(`My role changed, new role: ${role}`);

                if (role === 'moderator') {
                    APP.store.dispatch(maybeSetLobbyChatMessageListener());
                }

                APP.store.dispatch(localParticipantRoleChanged(role));
                APP.API.notifyUserRoleChanged(id, role);
            } else {
                APP.store.dispatch(participantRoleChanged(id, role));
            }
        });

        room.on(JitsiConferenceEvents.TRACK_ADDED, track => {
            if (!track || track.isLocal()) {
                return;
            }

            if (config.iAmRecorder) {
                const participant = room.getParticipantById(track.getParticipantId());

                if (participant.isHiddenFromRecorder()) {
                    return;
                }
            }

            APP.store.dispatch(trackAdded(track));
        });

        room.on(JitsiConferenceEvents.TRACK_REMOVED, track => {
            if (!track || track.isLocal()) {
                return;
            }

            APP.store.dispatch(trackRemoved(track));
        });

        room.on(JitsiConferenceEvents.TRACK_AUDIO_LEVEL_CHANGED, (id, lvl) => {
            const localAudio = getLocalJitsiAudioTrack(APP.store.getState());
            let newLvl = lvl;

            if (this.isLocalId(id)) {
                APP.store.dispatch(localParticipantAudioLevelChanged(lvl));
            }

            if (this.isLocalId(id) && localAudio?.isMuted()) {
                newLvl = 0;
            }

            if (config.debug) {
                this.audioLevelsMap[id] = newLvl;
                if (config.debugAudioLevels) {
                    logger.log(`AudioLevel:${id}/${newLvl}`);
                }
            }

            APP.UI.setAudioLevel(id, newLvl);
        });

        room.on(JitsiConferenceEvents.TRACK_MUTE_CHANGED, (track, participantThatMutedUs) => {
            if (participantThatMutedUs) {
                APP.store.dispatch(participantMutedUs(participantThatMutedUs, track));
                if (this.isSharingScreen && track.isVideoTrack()) {
                    logger.debug('TRACK_MUTE_CHANGED while screen sharing');
                    this._turnScreenSharingOff(false);
                }
            }
        });

        room.on(JitsiConferenceEvents.TRACK_UNMUTE_REJECTED, track => APP.store.dispatch(destroyLocalTracks(track)));

        room.on(JitsiConferenceEvents.SUBJECT_CHANGED,
            subject => APP.store.dispatch(conferenceSubjectChanged(subject)));

        room.on(
            JitsiConferenceEvents.LAST_N_ENDPOINTS_CHANGED,
            (leavingIds, enteringIds) =>
                APP.UI.handleLastNEndpoints(leavingIds, enteringIds));

        room.on(
            JitsiConferenceEvents.P2P_STATUS,
            (jitsiConference, p2p) =>
                APP.store.dispatch(p2pStatusChanged(p2p)));

        room.on(
            JitsiConferenceEvents.DOMINANT_SPEAKER_CHANGED,
            (dominant, previous, silence) => {
                APP.store.dispatch(dominantSpeakerChanged(dominant, previous, Boolean(silence), room));
            });

        room.on(
            JitsiConferenceEvents.CONFERENCE_CREATED_TIMESTAMP,
            conferenceTimestamp => {
                APP.store.dispatch(conferenceTimestampChanged(conferenceTimestamp));
                APP.API.notifyConferenceCreatedTimestamp(conferenceTimestamp);
            }
        );

        room.on(
            JitsiConferenceEvents.DISPLAY_NAME_CHANGED,
            (id, displayName) => {
                const formattedDisplayName
                    = getNormalizedDisplayName(displayName);
                const state = APP.store.getState();
                const {
                    defaultRemoteDisplayName
                } = state['features/base/config'];

                APP.store.dispatch(participantUpdated({
                    conference: room,
                    id,
                    name: formattedDisplayName
                }));

                const virtualScreenshareParticipantId = getVirtualScreenshareParticipantByOwnerId(state, id)?.id;

                if (virtualScreenshareParticipantId) {
                    APP.store.dispatch(
                        screenshareParticipantDisplayNameChanged(virtualScreenshareParticipantId, formattedDisplayName)
                    );
                }

                APP.API.notifyDisplayNameChanged(id, {
                    displayName: formattedDisplayName,
                    formattedDisplayName:
                        appendSuffix(
                            formattedDisplayName
                                || defaultRemoteDisplayName)
                });
            }
        );

        room.on(
            JitsiConferenceEvents.SILENT_STATUS_CHANGED,
            (id, isSilent) => {
                APP.store.dispatch(participantUpdated({
                    conference: room,
                    id,
                    isSilent
                }));
            }
        );

        room.on(
            JitsiConferenceEvents.BOT_TYPE_CHANGED,
            (id, botType) => {

                APP.store.dispatch(participantUpdated({
                    conference: room,
                    id,
                    botType
                }));
            }
        );

        room.on(
            JitsiConferenceEvents.TRANSCRIPTION_STATUS_CHANGED,
            (status, id, abruptly) => {
                if (status === JitsiMeetJS.constants.transcriptionStatus.ON) {
                    APP.store.dispatch(transcriberJoined(id));
                } else if (status === JitsiMeetJS.constants.transcriptionStatus.OFF) {
                    APP.store.dispatch(transcriberLeft(id, abruptly));
                }
            });

        room.on(
            JitsiConferenceEvents.ENDPOINT_MESSAGE_RECEIVED,
            (participant, data) => {
                APP.store.dispatch(endpointMessageReceived(participant, data));
                if (data?.name === ENDPOINT_TEXT_MESSAGE_NAME) {
                    APP.API.notifyEndpointTextMessageReceived({
                        senderInfo: {
                            jid: participant.getJid(),
                            id: participant.getId()
                        },
                        eventData: data
                    });
                }
            });

        room.on(
            JitsiConferenceEvents.NON_PARTICIPANT_MESSAGE_RECEIVED,
            (id, data) => {
                APP.store.dispatch(nonParticipantMessageReceived(id, data));
                APP.API.notifyNonParticipantMessageReceived(id, data);
            });

        room.on(
            JitsiConferenceEvents.LOCK_STATE_CHANGED,
            (...args) => APP.store.dispatch(lockStateChanged(room, ...args)));

        room.on(JitsiConferenceEvents.KICKED, (participant, reason, isReplaced) => {
            if (isReplaced) {
                // this event triggers when the local participant is kicked, `participant`
                // is the kicker. In replace participant case, kicker is undefined,
                // as the server initiated it. We mark in store the local participant
                // as being replaced based on jwt.
                const localParticipant = getLocalParticipant(APP.store.getState());

                APP.store.dispatch(participantUpdated({
                    conference: room,
                    id: localParticipant.id,
                    isReplaced
                }));

                // we send readyToClose when kicked participant is replace so that
                // embedding app can choose to dispose the iframe API on the handler.
                APP.API.notifyReadyToClose();
            }
            APP.store.dispatch(kickedOut(room, participant));
        });

        room.on(JitsiConferenceEvents.PARTICIPANT_KICKED, (kicker, kicked) => {
            APP.store.dispatch(participantKicked(kicker, kicked));
        });

        room.on(JitsiConferenceEvents.PARTICIPANT_SOURCE_UPDATED,
            jitsiParticipant => {
                APP.store.dispatch(participantSourcesUpdated(jitsiParticipant));
            });

        room.on(JitsiConferenceEvents.SUSPEND_DETECTED, () => {
            APP.store.dispatch(suspendDetected());
        });

        room.on(
            JitsiConferenceEvents.AUDIO_UNMUTE_PERMISSIONS_CHANGED,
            disableAudioMuteChange => {
                APP.store.dispatch(setAudioUnmutePermissions(disableAudioMuteChange));
            });
        room.on(
            JitsiConferenceEvents.VIDEO_UNMUTE_PERMISSIONS_CHANGED,
            disableVideoMuteChange => {
                APP.store.dispatch(setVideoUnmutePermissions(disableVideoMuteChange));
            });

        room.on(
            JitsiE2ePingEvents.E2E_RTT_CHANGED,
            (...args) => APP.store.dispatch(e2eRttChanged(...args)));

        room.addCommandListener(this.commands.defaults.ETHERPAD,
            ({ value }) => {
                APP.UI.initEtherpad(value);
            }
        );

        room.addCommandListener(this.commands.defaults.EMAIL, (data, from) => {
            APP.store.dispatch(participantUpdated({
                conference: room,
                id: from,
                email: data.value
            }));
        });

        room.addCommandListener(
            this.commands.defaults.AVATAR_URL,
            (data, from) => {
                const participant = getParticipantByIdOrUndefined(APP.store, from);

                // if already set from presence(jwt), skip the command processing
                if (!participant?.avatarURL) {
                    APP.store.dispatch(
                        participantUpdated({
                            conference: room,
                            id: from,
                            avatarURL: data.value
                        }));
                }
            });

        room.on(
            JitsiConferenceEvents.START_MUTED_POLICY_CHANGED,
            ({ audio, video }) => {
                APP.store.dispatch(
                    onStartMutedPolicyChanged(audio, video));
            }
        );
        room.on(JitsiConferenceEvents.STARTED_MUTED, () => {
            const audioMuted = room.isStartAudioMuted();
            const videoMuted = room.isStartVideoMuted();
            const localTracks = getLocalTracks(APP.store.getState()['features/base/tracks']);
            const promises = [];

            APP.store.dispatch(setAudioMuted(audioMuted));
            APP.store.dispatch(setVideoMuted(videoMuted));

            // Remove the tracks from the peerconnection.
            for (const track of localTracks) {
                // Always add the track on Safari because of a known issue where audio playout doesn't happen
                // if the user joins audio and video muted, i.e., if there is no local media capture.
                if (audioMuted && track.jitsiTrack?.getType() === MEDIA_TYPE.AUDIO && !browser.isWebKitBased()) {
                    promises.push(this.useAudioStream(null));
                }
                if (videoMuted && track.jitsiTrack?.getType() === MEDIA_TYPE.VIDEO) {
                    promises.push(this.useVideoStream(null));
                }
            }

            Promise.allSettled(promises)
                .then(() => {
                    APP.store.dispatch(showNotification({
                        titleKey: 'notify.mutedTitle',
                        descriptionKey: 'notify.muted'
                    }, NOTIFICATION_TIMEOUT_TYPE.SHORT));
                });
        });

        room.on(
            JitsiConferenceEvents.DATA_CHANNEL_OPENED, () => {
                APP.store.dispatch(dataChannelOpened());
                APP.store.dispatch(hideNotification(DATA_CHANNEL_CLOSED_NOTIFICATION_ID));
            }
        );

        room.on(
            JitsiConferenceEvents.DATA_CHANNEL_CLOSED, ev => {
                const state = APP.store.getState();
                const { dataChannelOpen } = state['features/base/conference'];
                const timeout = typeof dataChannelOpen === 'undefined' ? 15000 : 60000;

                // Show the notification only when the data channel connection doesn't get re-established in 60 secs if
                // it was already established at the beginning of the call, show it sooner otherwise. This notification
                // can be confusing and alarming to users even when there is no significant impact to user experience
                // if the the reconnect happens immediately.
                setTimeout(() => {
                    const { dataChannelOpen: open } = APP.store.getState()['features/base/conference'];

                    if (!open) {
                        const descriptionKey = getSsrcRewritingFeatureFlag(state)
                            ? 'notify.dataChannelClosedDescriptionWithAudio' : 'notify.dataChannelClosedDescription';
                        const titleKey = getSsrcRewritingFeatureFlag(state)
                            ? 'notify.dataChannelClosedWithAudio' : 'notify.dataChannelClosed';

                        APP.store.dispatch(dataChannelClosed(ev.code, ev.reason));
                        APP.store.dispatch(showWarningNotification({
                            descriptionKey,
                            titleKey,
                            uid: DATA_CHANNEL_CLOSED_NOTIFICATION_ID
                        }, NOTIFICATION_TIMEOUT_TYPE.STICKY));
                    }
                }, timeout);
            }
        );
    },

    /**
     * Handles audio device changes.
     *
     * @param {string} cameraDeviceId - The new device id.
     * @returns {Promise}
     */
    async onAudioDeviceChanged(micDeviceId) {
        const audioWasMuted = this.isLocalAudioMuted();

        // Disable noise suppression if it was enabled on the previous track.
        await APP.store.dispatch(setNoiseSuppressionEnabled(false));

        // When the 'default' mic needs to be selected, we need to pass the real device id to gUM instead of
        // 'default' in order to get the correct MediaStreamTrack from chrome because of the following bug.
        // https://bugs.chromium.org/p/chromium/issues/detail?id=997689.
        const isDefaultMicSelected = micDeviceId === 'default';
        const selectedDeviceId = isDefaultMicSelected
            ? getDefaultDeviceId(APP.store.getState(), 'audioInput')
            : micDeviceId;

        logger.info(`Switching audio input device to ${selectedDeviceId}`);
        sendAnalytics(createDeviceChangedEvent('audio', 'input'));
        createLocalTracksF({
            devices: [ 'audio' ],
            micDeviceId: selectedDeviceId
        })
        .then(([ stream ]) => {
            // if audio was muted before changing the device, mute
            // with the new device
            if (audioWasMuted) {
                return stream.mute()
                    .then(() => stream);
            }

            return stream;
        })
        .then(async stream => {
            await this._maybeApplyAudioMixerEffect(stream);

            return this.useAudioStream(stream);
        })
        .then(() => {
            const localAudio = getLocalJitsiAudioTrack(APP.store.getState());

            if (localAudio && isDefaultMicSelected) {
                // workaround for the default device to be shown as selected in the
                // settings even when the real device id was passed to gUM because of the
                // above mentioned chrome bug.
                localAudio._realDeviceId = localAudio.deviceId = 'default';
            }
        })
        .catch(err => {
            logger.error(`Failed to switch to selected audio input device ${selectedDeviceId}, error=${err}`);
            APP.store.dispatch(notifyMicError(err));
        });
    },

    /**
     * Handles video device changes.
     *
     * @param {string} cameraDeviceId - The new device id.
     * @returns {void}
     */
    onVideoDeviceChanged(cameraDeviceId) {
        const videoWasMuted = this.isLocalVideoMuted();
        const localVideoTrack = getLocalJitsiVideoTrack(APP.store.getState());

        if (localVideoTrack?.getDeviceId() === cameraDeviceId) {
            return;
        }

        sendAnalytics(createDeviceChangedEvent('video', 'input'));

        createLocalTracksF({
            devices: [ 'video' ],
            cameraDeviceId
        })
        .then(([ stream ]) => {
            // if we are in audio only mode or video was muted before
            // changing device, then mute
            if (this.isAudioOnly() || videoWasMuted) {
                return stream.mute()
                    .then(() => stream);
            }

            return stream;
        })
        .then(stream => {
            logger.info(`Switching the local video device to ${cameraDeviceId}.`);

            return this.useVideoStream(stream);
        })
        .catch(error => {
            logger.error(`Failed to switch to selected camera:${cameraDeviceId}, error:${error}`);

            return APP.store.dispatch(notifyCameraError(error));
        });
    },

    /**
     * Handles audio only changes.
     */
    onToggleAudioOnly() {
        // Immediately update the UI by having remote videos and the large video update themselves.
        const displayedUserId = APP.UI.getLargeVideoID();

        if (displayedUserId) {
            APP.UI.updateLargeVideo(displayedUserId, true);
        }
    },

    /**
     * Cleanups local conference on suspend.
     */
    onSuspendDetected() {
        // After wake up, we will be in a state where conference is left
        // there will be dialog shown to user.
        // We do not want video/audio as we show an overlay and after it
        // user need to rejoin or close, while waking up we can detect
        // camera wakeup as a problem with device.
        // We also do not care about device change, which happens
        // on resume after suspending PC.
        if (this.deviceChangeListener) {
            JitsiMeetJS.mediaDevices.removeEventListener(
                JitsiMediaDevicesEvents.DEVICE_LIST_CHANGED,
                this.deviceChangeListener);
        }
    },

    /**
     * Callback invoked when the conference has been successfully joined.
     * Initializes the UI and various other features.
     *
     * @private
     * @returns {void}
     */
    _onConferenceJoined() {
        const { dispatch } = APP.store;

        APP.UI.initConference();

        dispatch(conferenceJoined(room));

        const jwt = APP.store.getState()['features/base/jwt'];

        if (jwt?.user?.hiddenFromRecorder) {
            dispatch(muteLocal(true, MEDIA_TYPE.AUDIO));
            dispatch(muteLocal(true, MEDIA_TYPE.VIDEO));
            dispatch(setAudioUnmutePermissions(true, true));
            dispatch(setVideoUnmutePermissions(true, true));
        }
    },

    /**
     * Updates the list of current devices.
     * @param {boolean} setDeviceListChangeHandler - Whether to add the deviceList change handlers.
     * @private
     * @returns {Promise}
     */
    _initDeviceList(setDeviceListChangeHandler = false) {
        const { mediaDevices } = JitsiMeetJS;

        if (mediaDevices.isDeviceListAvailable()
                && mediaDevices.isDeviceChangeAvailable()) {
            if (setDeviceListChangeHandler) {
                this.deviceChangeListener = devices =>
                    window.setTimeout(() => this._onDeviceListChanged(devices), 0);
                mediaDevices.addEventListener(
                    JitsiMediaDevicesEvents.DEVICE_LIST_CHANGED,
                    this.deviceChangeListener);
            }

            const { dispatch } = APP.store;

            return dispatch(getAvailableDevices())
                .then(devices => {
                    APP.UI.onAvailableDevicesChanged(devices);
                });
        }

        return Promise.resolve();
    },

    /**
     * Event listener for JitsiMediaDevicesEvents.DEVICE_LIST_CHANGED to
     * handle change of available media devices.
     * @private
     * @param {MediaDeviceInfo[]} devices
     * @returns {Promise}
     */
    async _onDeviceListChanged(devices) {
        const state = APP.store.getState();
        const { filteredDevices, ignoredDevices } = filterIgnoredDevices(devices);
        const oldDevices = state['features/base/devices'].availableDevices;

        if (!areDevicesDifferent(flattenAvailableDevices(oldDevices), filteredDevices)) {
            return Promise.resolve();
        }

        logDevices(ignoredDevices, 'Ignored devices on device list changed:');

        const localAudio = getLocalJitsiAudioTrack(state);
        const localVideo = getLocalJitsiVideoTrack(state);

        APP.store.dispatch(updateDeviceList(filteredDevices));

        // Firefox users can choose their preferred device in the gUM prompt. In that case
        // we should respect that and not attempt to switch to the preferred device from
        // our settings.
        const newLabelsOnly = mediaDeviceHelper.newDeviceListAddedLabelsOnly(oldDevices, filteredDevices);
        const newDevices
            = mediaDeviceHelper.getNewMediaDevicesAfterDeviceListChanged(
                filteredDevices,
                localVideo,
                localAudio,
                newLabelsOnly);
        const promises = [];
        const requestedInput = {
            audio: Boolean(newDevices.audioinput),
            video: Boolean(newDevices.videoinput)
        };

        if (typeof newDevices.audiooutput !== 'undefined') {
            const { dispatch } = APP.store;
            const setAudioOutputPromise
                = setAudioOutputDeviceId(newDevices.audiooutput, dispatch)
                    .catch(err => {
                        logger.error(`Failed to set the audio output device to ${newDevices.audiooutput} - ${err}`);
                    });

            promises.push(setAudioOutputPromise);
        }

        // Handles the use case when the default device is changed (we are always stopping the streams because it's
        // simpler):
        // If the default device is changed we need to first stop the local streams and then call GUM. Otherwise GUM
        // will return a stream using the old default device.
        if (requestedInput.audio && localAudio) {
            localAudio.stopStream();
        }

        if (requestedInput.video && localVideo) {
            localVideo.stopStream();
        }

        // Let's handle unknown/non-preferred devices
        const newAvailDevices = APP.store.getState()['features/base/devices'].availableDevices;
        let newAudioDevices = [];
        let oldAudioDevices = [];

        if (typeof newDevices.audiooutput === 'undefined') {
            newAudioDevices = newAvailDevices.audioOutput;
            oldAudioDevices = oldDevices.audioOutput;
        }

        if (!requestedInput.audio) {
            newAudioDevices = newAudioDevices.concat(newAvailDevices.audioInput);
            oldAudioDevices = oldAudioDevices.concat(oldDevices.audioInput);
        }

        // check for audio
        if (newAudioDevices.length > 0) {
            APP.store.dispatch(checkAndNotifyForNewDevice(newAudioDevices, oldAudioDevices));
        }

        // check for video
        if (requestedInput.video) {
            APP.store.dispatch(checkAndNotifyForNewDevice(newAvailDevices.videoInput, oldDevices.videoInput));
        }

        // When the 'default' mic needs to be selected, we need to pass the real device id to gUM instead of 'default'
        // in order to get the correct MediaStreamTrack from chrome because of the following bug.
        // https://bugs.chromium.org/p/chromium/issues/detail?id=997689
        const hasDefaultMicChanged = newDevices.audioinput === 'default';

        // When the local video is muted and a preferred device is connected, update the settings and remove the track
        // from the conference. A new track will be created and replaced when the user unmutes their camera.
        if (requestedInput.video && this.isLocalVideoMuted()) {
            APP.store.dispatch(updateSettings({
                cameraDeviceId: newDevices.videoinput
            }));
            requestedInput.video = false;
            delete newDevices.videoinput;

            // Remove the track from the conference.
            if (localVideo) {
                await this.useVideoStream(null);
                logger.debug('_onDeviceListChanged: Removed the current video track.');
            }
        }

        // When the local audio is muted and a preferred device is connected, update the settings and remove the track
        // from the conference. A new track will be created and replaced when the user unmutes their mic.
        if (requestedInput.audio && this.isLocalAudioMuted()) {
            APP.store.dispatch(updateSettings({
                micDeviceId: newDevices.audioinput
            }));
            requestedInput.audio = false;
            delete newDevices.audioinput;

            // Remove the track from the conference.
            if (localAudio) {
                await this.useAudioStream(null);
                logger.debug('_onDeviceListChanged: Removed the current audio track.');
            }
        }

        // Create the tracks and replace them only if the user is unmuted.
        if (requestedInput.audio || requestedInput.video) {
            let tracks = [];
            const realAudioDeviceId = hasDefaultMicChanged
                ? getDefaultDeviceId(APP.store.getState(), 'audioInput') : newDevices.audioinput;

            try {
                tracks = await mediaDeviceHelper.createLocalTracksAfterDeviceListChanged(
                    createLocalTracksF,
                    requestedInput.video ? newDevices.videoinput : null,
                    requestedInput.audio ? realAudioDeviceId : null
                );
            } catch (error) {
                logger.error(`Track creation failed on device change, ${error}`);

                return Promise.reject(error);
            }

            for (const track of tracks) {
                if (track.isAudioTrack()) {
                    promises.push(
                        this.useAudioStream(track)
                            .then(() => {
                                hasDefaultMicChanged && (track._realDeviceId = track.deviceId = 'default');
                            }));
                } else {
                    promises.push(
                        this.useVideoStream(track));
                }
            }
        }

        return Promise.all(promises)
            .then(() => {
                APP.UI.onAvailableDevicesChanged(filteredDevices);
            });
    },

    /**
     * Determines whether or not the audio button should be enabled.
     */
    updateAudioIconEnabled() {
        const localAudio = getLocalJitsiAudioTrack(APP.store.getState());
        const audioMediaDevices = APP.store.getState()['features/base/devices'].availableDevices.audioInput;
        const audioDeviceCount = audioMediaDevices ? audioMediaDevices.length : 0;

        // The audio functionality is considered available if there are any
        // audio devices detected or if the local audio stream already exists.
        const available = audioDeviceCount > 0 || Boolean(localAudio);

        APP.store.dispatch(setAudioAvailable(available));
    },

    /**
     * Determines whether or not the video button should be enabled.
     */
    updateVideoIconEnabled() {
        const videoMediaDevices
            = APP.store.getState()['features/base/devices'].availableDevices.videoInput;
        const videoDeviceCount
            = videoMediaDevices ? videoMediaDevices.length : 0;
        const localVideo = getLocalJitsiVideoTrack(APP.store.getState());

        // The video functionality is considered available if there are any
        // video devices detected or if there is local video stream already
        // active which could be either screensharing stream or a video track
        // created before the permissions were rejected (through browser
        // config).
        const available = videoDeviceCount > 0 || Boolean(localVideo);

        APP.store.dispatch(setVideoAvailable(available));
        APP.API.notifyVideoAvailabilityChanged(available);
    },

    /**
     * Disconnect from the conference and optionally request user feedback.
     * @param {boolean} [requestFeedback=false] if user feedback should be
     * @param {string} [hangupReason] the reason for leaving the meeting
     * requested
     */
    hangup(requestFeedback = false, hangupReason) {
        APP.store.dispatch(disableReceiver());

        this._stopProxyConnection();

        APP.store.dispatch(destroyLocalTracks());
        this._localTracksInitialized = false;

        // Remove unnecessary event listeners from firing callbacks.
        if (this.deviceChangeListener) {
            JitsiMeetJS.mediaDevices.removeEventListener(
                JitsiMediaDevicesEvents.DEVICE_LIST_CHANGED,
                this.deviceChangeListener);
        }

        let feedbackResultPromise = Promise.resolve({});

        if (requestFeedback) {
            const feedbackDialogClosed = (feedbackResult = {}) => {
                if (!feedbackResult.wasDialogShown && hangupReason) {
                    return APP.store.dispatch(
                        openLeaveReasonDialog(hangupReason)).then(() => feedbackResult);
                }

                return Promise.resolve(feedbackResult);
            };

            feedbackResultPromise
                = APP.store.dispatch(maybeOpenFeedbackDialog(room, hangupReason))
                    .then(feedbackDialogClosed, feedbackDialogClosed);
        }

        const leavePromise = this.leaveRoom().catch(() => Promise.resolve());

        Promise.allSettled([ feedbackResultPromise, leavePromise ]).then(([ feedback, _ ]) => {
            this._room = undefined;
            room = undefined;

            /**
             * Don't call {@code notifyReadyToClose} if the promotional page flag is set
             * and let the page take care of sending the message, since there will be
             * a redirect to the page anyway.
             */
            if (!interfaceConfig.SHOW_PROMOTIONAL_CLOSE_PAGE) {
                APP.API.notifyReadyToClose();
            }

            APP.store.dispatch(maybeRedirectToWelcomePage(feedback.value ?? {}));
        });


    },

    /**
     * Leaves the room.
     *
     * @param {boolean} doDisconnect - Whether leaving the room should also terminate the connection.
     * @param {string} reason - reason for leaving the room.
     * @returns {Promise}
     */
    leaveRoom(doDisconnect = true, reason = '') {
        APP.store.dispatch(conferenceWillLeave(room));

        const maybeDisconnect = () => {
            if (doDisconnect) {
                return disconnect();
            }
        };

        if (room && room.isJoined()) {
            return room.leave(reason).then(() => maybeDisconnect())
            .catch(e => {
                logger.error(e);

                return maybeDisconnect();
            });
        }

        return maybeDisconnect();
    },

    /**
     * Changes the email for the local user
     * @param email {string} the new email
     */
    changeLocalEmail(email = '') {
        const formattedEmail = String(email).trim();

        APP.store.dispatch(updateSettings({
            email: formattedEmail
        }));

        sendData(commands.EMAIL, formattedEmail);
    },

    /**
     * Changes the avatar url for the local user
     * @param url {string} the new url
     */
    changeLocalAvatarUrl(url = '') {
        const formattedUrl = String(url).trim();

        APP.store.dispatch(updateSettings({
            avatarURL: formattedUrl
        }));

        sendData(commands.AVATAR_URL, url);
    },

    /**
     * Sends a message via the data channel.
     * @param {string} to the id of the endpoint that should receive the
     * message. If "" - the message will be sent to all participants.
     * @param {object} payload the payload of the message.
     * @throws NetworkError or InvalidStateError or Error if the operation
     * fails.
     */
    sendEndpointMessage(to, payload) {
        room.sendEndpointMessage(to, payload);
    },

    /**
     * Callback invoked by the external api create or update a direct connection
     * from the local client to an external client.
     *
     * @param {Object} event - The object containing information that should be
     * passed to the {@code ProxyConnectionService}.
     * @returns {void}
     */
    onProxyConnectionEvent(event) {
        if (!this._proxyConnection) {
            this._proxyConnection = new JitsiMeetJS.ProxyConnectionService({

                /**
                 * Pass the {@code JitsiConnection} instance which will be used
                 * to fetch TURN credentials.
                 */
                jitsiConnection: APP.connection,

                /**
                 * The proxy connection feature is currently tailored towards
                 * taking a proxied video stream and showing it as a local
                 * desktop screen.
                 */
                convertVideoToDesktop: true,

                /**
                 * Callback invoked when the connection has been closed
                 * automatically. Triggers cleanup of screensharing if active.
                 *
                 * @returns {void}
                 */
                onConnectionClosed: () => {
                    if (this._untoggleScreenSharing) {
                        this._untoggleScreenSharing();
                    }
                },

                /**
                 * Callback invoked to pass messages from the local client back
                 * out to the external client.
                 *
                 * @param {string} peerJid - The jid of the intended recipient
                 * of the message.
                 * @param {Object} data - The message that should be sent. For
                 * screensharing this is an iq.
                 * @returns {void}
                 */
                onSendMessage: (peerJid, data) =>
                    APP.API.sendProxyConnectionEvent({
                        data,
                        to: peerJid
                    }),

                /**
                 * Callback invoked when the remote peer of the proxy connection
                 * has provided a video stream, intended to be used as a local
                 * desktop stream.
                 *
                 * @param {JitsiLocalTrack} remoteProxyStream - The media
                 * stream to use as a local desktop stream.
                 * @returns {void}
                 */
                onRemoteStream: desktopStream => {
                    if (desktopStream.videoType !== 'desktop') {
                        logger.warn('Received a non-desktop stream to proxy.');
                        desktopStream.dispose();

                        return;
                    }

                    APP.store.dispatch(toggleScreensharingA(undefined, false, { desktopStream }));
                }
            });
        }

        this._proxyConnection.processMessage(event);
    },

    /**
     * Sets the video muted status.
     */
    setVideoMuteStatus() {
        APP.UI.setVideoMuted(this.getMyUserId());
    },

    /**
     * Dispatches the passed in feedback for submission. The submitted score
     * should be a number inclusively between 1 through 5, or -1 for no score.
     *
     * @param {number} score - a number between 1 and 5 (inclusive) or -1 for no
     * score.
     * @param {string} message - An optional message to attach to the feedback
     * in addition to the score.
     * @returns {void}
     */
    submitFeedback(score = -1, message = '') {
        if (score === -1 || (score >= 1 && score <= 5)) {
            APP.store.dispatch(submitFeedback(score, message, room));
        }
    },

    /**
     * Terminates any proxy screensharing connection that is active.
     *
     * @private
     * @returns {void}
     */
    _stopProxyConnection() {
        if (this._proxyConnection) {
            this._proxyConnection.stop();
        }

        this._proxyConnection = null;
    }
};


################################################################################

## File: .\jitsi-meet\config.js

/* eslint-disable comma-dangle, no-unused-vars, no-var, prefer-template, vars-on-top */

/*
 * NOTE: If you add a new option please remember to document it here:
 * https://jitsi.github.io/handbook/docs/dev-guide/dev-guide-configuration
 */

var subdir = '<!--# echo var="subdir" default="" -->';
var subdomain = '<!--# echo var="subdomain" default="" -->';

if (subdomain) {
    subdomain = subdomain.substr(0, subdomain.length - 1).split('.')
        .join('_')
        .toLowerCase() + '.';
}

// In case of no ssi provided by the webserver, use empty strings
if (subdir.startsWith('<!--')) {
    subdir = '';
}
if (subdomain.startsWith('<!--')) {
    subdomain = '';
}

var enableJaaS = false;

var config = {
    // Connection
    //

    hosts: {
        // XMPP domain.
        domain: 'jitsi-meet.example.com',

        // When using authentication, domain for guest users.
        // anonymousdomain: 'guest.example.com',

        // Domain for authenticated users. Defaults to <domain>.
        // authdomain: 'jitsi-meet.example.com',

        // Focus component domain. Defaults to focus.<domain>.
        // focus: 'focus.jitsi-meet.example.com',

        // XMPP MUC domain. FIXME: use XEP-0030 to discover it.
        muc: 'conference.' + subdomain + 'jitsi-meet.example.com',
    },

    // BOSH URL. FIXME: use XEP-0156 to discover it.
    bosh: 'https://jitsi-meet.example.com/' + subdir + 'http-bind',

    // Websocket URL (XMPP)
    // websocket: 'wss://jitsi-meet.example.com/' + subdir + 'xmpp-websocket',

    // Whether BOSH should be preferred over WebSocket if both are configured.
    // preferBosh: false,

    // The real JID of focus participant - can be overridden here
    // Do not change username - FIXME: Make focus username configurable
    // https://github.com/jitsi/jitsi-meet/issues/7376
    // focusUserJid: 'focus@auth.jitsi-meet.example.com',

    // Option to send conference requests to jicofo over http (requires nginx rule for it)
    // conferenceRequestUrl:
    //   'https://<!--# echo var="http_host" default="jitsi-meet.example.com" -->/' + subdir + 'conference-request/v1',

    // Options related to the bridge (colibri) data channel
    bridgeChannel: {
        // If the backend advertises multiple colibri websockets, this options allows
        // to filter some of them out based on the domain name. We use the first URL
        // which does not match ignoreDomain, falling back to the first one that matches
        // ignoreDomain. Has no effect if undefined.
        // ignoreDomain: 'example.com',

        // Prefer SCTP (WebRTC data channels over the media path) over a colibri websocket.
        // If SCTP is available in the backend it will be used instead of a WS. Defaults to
        // false (SCTP is used only if available and no WS are available).
        // preferSctp: false
    },

    // Testing / experimental features.
    //

    testing: {
        // Allows the setting of a custom bandwidth value from the UI.
        // assumeBandwidth: true,

        // Disables the End to End Encryption feature. Useful for debugging
        // issues related to insertable streams.
        // disableE2EE: false,

        // Enables the use of the codec selection API supported by the browsers .
        // enableCodecSelectionAPI: false,

        // P2P test mode disables automatic switching to P2P when there are 2
        // participants in the conference.
        // p2pTestMode: false,

        // Enables the test specific features consumed by jitsi-meet-torture
        // testMode: false,

        // Disables the auto-play behavior of *all* newly created video element.
        // This is useful when the client runs on a host with limited resources.
        // noAutoPlayVideo: false,

        // Experiment: Whether to skip interim transcriptions.
        // skipInterimTranscriptions: false,

        // Dump transcripts to a <transcript> element for debugging.
        // dumpTranscript: false,
    },

    // Disables moderator indicators.
    // disableModeratorIndicator: false,

    // Disables the reactions feature.
    // disableReactions: true,

    // Disables the reactions moderation feature.
    // disableReactionsModeration: false,

    // Disables polls feature.
    // disablePolls: false,

    // Disables demote button from self-view
    // disableSelfDemote: false,

    // Disables self-view tile. (hides it from tile view and from filmstrip)
    // disableSelfView: false,

    // Disables self-view settings in UI
    // disableSelfViewSettings: false,

    // screenshotCapture : {
    //      Enables the screensharing capture feature.
    //      enabled: false,
    //
    //      The mode for the screenshot capture feature.
    //      Can be either 'recording' - screensharing screenshots are taken
    //      only when the recording is also on,
    //      or 'always' - screensharing screenshots are always taken.
    //      mode: 'recording',
    // }

    // Disables ICE/UDP by filtering out local and remote UDP candidates in
    // signalling.
    // webrtcIceUdpDisable: false,

    // Disables ICE/TCP by filtering out local and remote TCP candidates in
    // signalling.
    // webrtcIceTcpDisable: false,


    // Media
    //

    // Audio

    // Disable measuring of audio levels.
    // disableAudioLevels: false,

    // audioLevelsInterval: 200,

    // Enabling this will run the lib-jitsi-meet no audio detection module which
    // will notify the user if the current selected microphone has no audio
    // input and will suggest another valid device if one is present.
    enableNoAudioDetection: true,

    // Enabling this will show a "Save Logs" link in the GSM popover that can be
    // used to collect debug information (XMPP IQs, SDP offer/answer cycles)
    // about the call.
    // enableSaveLogs: false,

    // Enabling this will hide the "Show More" link in the GSM popover that can be
    // used to display more statistics about the connection (IP, Port, protocol, etc).
    // disableShowMoreStats: true,

    // Enabling this will run the lib-jitsi-meet noise detection module which will
    // notify the user if there is noise, other than voice, coming from the current
    // selected microphone. The purpose it to let the user know that the input could
    // be potentially unpleasant for other meeting participants.
    enableNoisyMicDetection: true,

    // Start the conference in audio only mode (no video is being received nor
    // sent).
    // startAudioOnly: false,

    // Every participant after the Nth will start audio muted.
    // startAudioMuted: 10,

    // Start calls with audio muted. Unlike the option above, this one is only
    // applied locally. FIXME: having these 2 options is confusing.
    // startWithAudioMuted: false,

    // Enabling it (with #params) will disable local audio output of remote
    // participants and to enable it back a reload is needed.
    // startSilent: false,

    // Enables support for opus-red (redundancy for Opus).
    // enableOpusRed: false,

    // Specify audio quality stereo and opusMaxAverageBitrate values in order to enable HD audio.
    // Beware, by doing so, you are disabling echo cancellation, noise suppression and AGC.
    // Specify enableOpusDtx to enable support for opus-dtx where
    // audio packets won’t be transmitted while participant is silent or muted.
    // audioQuality: {
    //     stereo: false,
    //     opusMaxAverageBitrate: null, // Value to fit the 6000 to 510000 range.
    //     enableOpusDtx: false,
    // },

    // Noise suppression configuration. By default rnnoise is used. Optionally Krisp
    // can be used by enabling it below, but the Krisp JS SDK files must be supplied in your
    // installation. Specifically, these files are needed:
    //   - https://meet.example.com/libs/krisp/krisp.mjs
    //   - https://meet.example.com/libs/krisp/models/model_8.kw
    //   - https://meet.example.com/libs/krisp/models/model_16.kw
    //   - https://meet.example.com/libs/krisp/models/model_32.kw
    // NOTE: Krisp JS SDK v1.0.9 was tested.
    // noiseSuppression: {
    //     krisp: {
    //         enabled: false,
    //         logProcessStats: false,
    //         debugLogs: false,
    //     },
    // },

    // Video

    // Sets the default camera facing mode.
    // cameraFacingMode: 'user',

    // Sets the preferred resolution (height) for local video. Defaults to 720.
    // resolution: 720,

    // DEPRECATED. Please use raisedHands.disableRemoveRaisedHandOnFocus instead.
    // Specifies whether the raised hand will hide when someone becomes a dominant speaker or not
    // disableRemoveRaisedHandOnFocus: false,

    // Specifies which raised hand related config should be set.
    // raisedHands: {
    //     // Specifies whether the raised hand can be lowered by moderator.
    //     disableLowerHandByModerator: false,

    //     // Specifies whether there is a notification before hiding the raised hand
    //     // when someone becomes the dominant speaker.
    //     disableLowerHandNotification: true,

    //     // Specifies whether there is a notification when you are the next speaker in line.
    //     disableNextSpeakerNotification: false,

    //     // Specifies whether the raised hand will hide when someone becomes a dominant speaker or not.
    //     disableRemoveRaisedHandOnFocus: false,
    // },

    // speakerStats: {
    //     // Specifies whether the speaker stats is enable or not.
    //     disabled: false,

    //     // Specifies whether there will be a search field in speaker stats or not.
    //     disableSearch: false,

    //     // Specifies whether participants in speaker stats should be ordered or not, and with what priority.
    //     // 'role', <- Moderators on top.
    //     // 'name', <- Alphabetically by name.
    //     // 'hasLeft', <- The ones that have left in the bottom.
    //     order: [
    //         'role',
    //         'name',
    //         'hasLeft',
    //     ],
    // },

    // DEPRECATED. Please use speakerStats.disableSearch instead.
    // Specifies whether there will be a search field in speaker stats or not
    // disableSpeakerStatsSearch: false,

    // DEPRECATED. Please use speakerStats.order .
    // Specifies whether participants in speaker stats should be ordered or not, and with what priority
    // speakerStatsOrder: [
    //  'role', <- Moderators on top
    //  'name', <- Alphabetically by name
    //  'hasLeft', <- The ones that have left in the bottom
    // ], <- the order of the array elements determines priority

    // How many participants while in the tile view mode, before the receiving video quality is reduced from HD to SD.
    // Use -1 to disable.
    // maxFullResolutionParticipants: 2,

    // w3c spec-compliant video constraints to use for video capture. Currently
    // used by browsers that return true from lib-jitsi-meet's
    // util#browser#usesNewGumFlow. The constraints are independent from
    // this config's resolution value. Defaults to requesting an ideal
    // resolution of 720p.
    // constraints: {
    //     video: {
    //         height: {
    //             ideal: 720,
    //             max: 720,
    //             min: 240,
    //         },
    //     },
    // },

    // Enable / disable simulcast support.
    // disableSimulcast: false,

    // Every participant after the Nth will start video muted.
    // startVideoMuted: 10,

    // Start calls with video muted. Unlike the option above, this one is only
    // applied locally. FIXME: having these 2 options is confusing.
    // startWithVideoMuted: false,

    // Desktop sharing

    // Optional desktop sharing frame rate options. Default value: min:5, max:5.
    // desktopSharingFrameRate: {
    //     min: 5,
    //     max: 5,
    // },

    // Optional screenshare settings that give more control over screen capture in the browser.
    // screenShareSettings: {
    //      // Show users the current tab is the preferred capture source, default: false.
    //      desktopPreferCurrentTab: false,
    //      // Allow users to select system audio, default: include.
    //      desktopSystemAudio: 'include',
    //      // Allow users to seamlessly switch which tab they are sharing without having to select the tab again.
    //      desktopSurfaceSwitching: 'include',
    //      // Allow a user to be shown a preference for what screen is to be captured, default: unset.
    //      desktopDisplaySurface: undefined,
    //      // Allow users to select the current tab as a capture source, default: exclude.
    //      desktopSelfBrowserSurface: 'exclude'
    // },

    // Recording

    // DEPRECATED. Use recordingService.enabled instead.
    // fileRecordingsEnabled: false,

    // Enable the dropbox integration.
    // dropbox: {
    //     appKey: '<APP_KEY>', // Specify your app key here.
    //     // A URL to redirect the user to, after authenticating
    //     // by default uses:
    //     // 'https://jitsi-meet.example.com/static/oauth.html'
    //     redirectURI:
    //          'https://jitsi-meet.example.com/subfolder/static/oauth.html',
    // },

    // configuration for all things recording related. Existing settings will be migrated here in the future.
    // recordings: {
    //    // IF true (default) recording audio and video is selected by default in the recording dialog.
    //    // recordAudioAndVideo: true,
    //    // If true, shows a notification at the start of the meeting with a call to action button
    //    // to start recording (for users who can do so).
    //    // suggestRecording: true,
    //    // If true, shows a warning label in the prejoin screen to point out the possibility that
    //    // the call you're joining might be recorded.
    //    // showPrejoinWarning: true,
    // },

    // recordingService: {
    //     // When integrations like dropbox are enabled only that will be shown,
    //     // by enabling fileRecordingsServiceEnabled, we show both the integrations
    //     // and the generic recording service (its configuration and storage type
    //     // depends on jibri configuration)
    //     enabled: false,

    //     // Whether to show the possibility to share file recording with other people
    //     // (e.g. meeting participants), based on the actual implementation
    //     // on the backend.
    //     sharingEnabled: false,

    //     // Hide the warning that says we only store the recording for 24 hours.
    //     hideStorageWarning: false,
    // },

    // DEPRECATED. Use recordingService.enabled instead.
    // fileRecordingsServiceEnabled: false,

    // DEPRECATED. Use recordingService.sharingEnabled instead.
    // fileRecordingsServiceSharingEnabled: false,

    // Local recording configuration.
    // localRecording: {
    //     // Whether to disable local recording or not.
    //     disable: false,

    //     // Whether to notify all participants when a participant is recording locally.
    //     notifyAllParticipants: false,

    //     // Whether to disable the self recording feature (only local participant streams).
    //     disableSelfRecording: false,
    // },

    // Customize the Live Streaming dialog. Can be modified for a non-YouTube provider.
    // liveStreaming: {
    //    // Whether to enable live streaming or not.
    //    enabled: false,
    //    // Terms link
    //    termsLink: 'https://www.youtube.com/t/terms',
    //    // Data privacy link
    //    dataPrivacyLink: 'https://policies.google.com/privacy',
    //    // RegExp string that validates the stream key input field
    //    validatorRegExpString: '^(?:[a-zA-Z0-9]{4}(?:-(?!$)|$)){4}',
    //    // Documentation reference for the live streaming feature.
    //    helpLink: 'https://jitsi.org/live'
    // },

    // DEPRECATED. Use liveStreaming.enabled instead.
    // liveStreamingEnabled: false,

    // DEPRECATED. Use transcription.enabled instead.
    // transcribingEnabled: false,

    // DEPRECATED. Use transcription.useAppLanguage instead.
    // transcribeWithAppLanguage: true,

    // DEPRECATED. Use transcription.preferredLanguage instead.
    // preferredTranscribeLanguage: 'en-US',

    // DEPRECATED. Use transcription.autoTranscribeOnRecord instead.
    // autoCaptionOnRecord: false,

    // Transcription options.
    // transcription: {
    //     // Whether the feature should be enabled or not.
    //     enabled: false,

    //     // Translation languages.
    //     // Available languages can be found in
    //     // ./src/react/features/transcribing/translation-languages.json.
    //     translationLanguages: ['en', 'es', 'fr', 'ro'],

    //     // Important languages to show on the top of the language list.
    //     translationLanguagesHead: ['en'],

    //     // If true transcriber will use the application language.
    //     // The application language is either explicitly set by participants in their settings or automatically
    //     // detected based on the environment, e.g. if the app is opened in a chrome instance which
    //     // is using french as its default language then transcriptions for that participant will be in french.
    //     // Defaults to true.
    //     useAppLanguage: true,

    //     // Transcriber language. This settings will only work if "useAppLanguage"
    //     // is explicitly set to false.
    //     // Available languages can be found in
    //     // ./src/react/features/transcribing/transcriber-langs.json.
    //     preferredLanguage: 'en-US',

    //     // Enables automatic turning on transcribing when recording is started
    //     autoTranscribeOnRecord: false,
    // },

    // Misc

    // Default value for the channel "last N" attribute. -1 for unlimited.
    channelLastN: -1,

    // Connection indicators
    // connectionIndicators: {
    //     autoHide: true,
    //     autoHideTimeout: 5000,
    //     disabled: false,
    //     disableDetails: false,
    //     inactiveDisabled: false
    // },

    // Provides a way for the lastN value to be controlled through the UI.
    // When startLastN is present, conference starts with a last-n value of startLastN and channelLastN
    // value will be used when the quality level is selected using "Manage Video Quality" slider.
    // startLastN: 1,

    // Specify the settings for video quality optimizations on the client.
    // videoQuality: {
    //
    //    // Provides a way to set the codec preference on desktop based endpoints.
    //    codecPreferenceOrder: [ 'VP9', 'VP8', 'H264' ],
    //
    //    // Provides a way to set the codec for screenshare.
    //    screenshareCodec: 'AV1',
    //    mobileScreenshareCodec: 'VP8',
    //
    //    // Codec specific settings for scalability modes and max bitrates.
    //    av1: {
    //      maxBitratesVideo: {
    //          low: 100000,
    //          standard: 300000,
    //          high: 1000000,
    //          fullHd: 2000000,
    //          ultraHd: 4000000,
    //          ssHigh: 2500000
    //      },
    //      scalabilityModeEnabled: true,
    //      useSimulcast: false,
    //      useKSVC: true
    //    },
    //    h264: {
    //      maxBitratesVideo: {
    //          low: 200000,
    //          standard: 500000,
    //          high: 1500000,
    //          fullHd: 3000000,
    //          ultraHd: 6000000,
    //          ssHigh: 2500000
    //      },
    //      scalabilityModeEnabled: true
    //    },
    //    vp8: {
    //      maxBitratesVideo: {
    //          low: 200000,
    //          standard: 500000,
    //          high: 1500000,
    //          fullHd: 3000000,
    //          ultraHd: 6000000,
    //          ssHigh: 2500000
    //      },
    //      scalabilityModeEnabled: false
    //    },
    //    vp9: {
    //      maxBitratesVideo: {
    //          low: 100000,
    //          standard: 300000,
    //          high: 1200000,
    //          fullHd: 2500000,
    //          ultraHd: 5000000,
    //          ssHigh: 2500000
    //      },
    //      scalabilityModeEnabled: true,
    //      useSimulcast: false,
    //      useKSVC: true
    //    },
    //
    //    DEPRECATED! Use `codec specific settings` instead.
    //    // Provides a way to configure the maximum bitrates that will be enforced on the simulcast streams for
    //    // video tracks. The keys in the object represent the type of the stream (LD, SD or HD) and the values
    //    // are the max.bitrates to be set on that particular type of stream. The actual send may vary based on
    //    // the available bandwidth calculated by the browser, but it will be capped by the values specified here.
    //    // This is currently not implemented on app based clients on mobile.
    //    maxBitratesVideo: {
    //          H264: {
    //              low: 200000,
    //              standard: 500000,
    //              high: 1500000,
    //          },
    //          VP8 : {
    //              low: 200000,
    //              standard: 500000,
    //              high: 1500000,
    //          },
    //          VP9: {
    //              low: 100000,
    //              standard: 300000,
    //              high: 1200000,
    //          },
    //    },
    //
    //    // The options can be used to override default thresholds of video thumbnail heights corresponding to
    //    // the video quality levels used in the application. At the time of this writing the allowed levels are:
    //    //     'low' - for the low quality level (180p at the time of this writing)
    //    //     'standard' - for the medium quality level (360p)
    //    //     'high' - for the high quality level (720p)
    //    // The keys should be positive numbers which represent the minimal thumbnail height for the quality level.
    //    //
    //    // With the default config value below the application will use 'low' quality until the thumbnails are
    //    // at least 360 pixels tall. If the thumbnail height reaches 720 pixels then the application will switch to
    //    // the high quality.
    //    minHeightForQualityLvl: {
    //        360: 'standard',
    //        720: 'high',
    //    },
    //
    //    // Provides a way to set the codec preference on mobile devices, both on RN and mobile browser based endpoint
    //    mobileCodecPreferenceOrder: [ 'VP8', 'VP9', 'H264' ],
    //
    //    // DEPRECATED! Use `codecPreferenceOrder/mobileCodecPreferenceOrder` instead.
    //    // Provides a way to prevent a video codec from being negotiated on the JVB connection. The codec specified
    //    // here will be removed from the list of codecs present in the SDP answer generated by the client. If the
    //    // same codec is specified for both the disabled and preferred option, the disable settings will prevail.
    //    // Note that 'VP8' cannot be disabled since it's a mandatory codec, the setting will be ignored in this case.
    //    disabledCodec: 'H264',
    //
    //    // DEPRECATED! Use `codecPreferenceOrder/mobileCodecPreferenceOrder` instead.
    //    // Provides a way to set a preferred video codec for the JVB connection. If 'H264' is specified here,
    //    // simulcast will be automatically disabled since JVB doesn't support H264 simulcast yet. This will only
    //    // rearrange the the preference order of the codecs in the SDP answer generated by the browser only if the
    //    // preferred codec specified here is present. Please ensure that the JVB offers the specified codec for this
    //    // to take effect.
    //    preferredCodec: 'VP8',
    //
    // },

    // Notification timeouts
    // notificationTimeouts: {
    //     short: 2500,
    //     medium: 5000,
    //     long: 10000,
    // },

    // // Options for the recording limit notification.
    // recordingLimit: {
    //
    //    // The recording limit in minutes. Note: This number appears in the notification text
    //    // but doesn't enforce the actual recording time limit. This should be configured in
    //    // jibri!
    //    limit: 60,
    //
    //    // The name of the app with unlimited recordings.
    //    appName: 'Unlimited recordings APP',
    //
    //    // The URL of the app with unlimited recordings.
    //    appURL: 'https://unlimited.recordings.app.com/',
    // },

    // Disables or enables RTX (RFC 4588) (defaults to false).
    // disableRtx: false,

    // Moves all Jitsi Meet 'beforeunload' logic (cleanup, leaving, disconnecting, etc) to the 'unload' event.
    // disableBeforeUnloadHandlers: true,

    // Disables or enables TCC support in this client (default: enabled).
    // enableTcc: true,

    // Disables or enables REMB support in this client (default: enabled).
    // enableRemb: true,

    // Enables forced reload of the client when the call is migrated as a result of
    // the bridge going down.
    // enableForcedReload: true,

    // Use TURN/UDP servers for the jitsi-videobridge connection (by default
    // we filter out TURN/UDP because it is usually not needed since the
    // bridge itself is reachable via UDP)
    // useTurnUdp: false

    // Enable support for encoded transform in supported browsers. This allows
    // E2EE to work in Safari if the corresponding flag is enabled in the browser.
    // Experimental.
    // enableEncodedTransformSupport: false,

    // UI
    //

    // Disables responsive tiles.
    // disableResponsiveTiles: false,

    // DEPRECATED. Please use `securityUi?.hideLobbyButton` instead.
    // Hides lobby button.
    // hideLobbyButton: false,

    // DEPRECATED. Please use `lobby?.autoKnock` instead.
    // If Lobby is enabled starts knocking automatically.
    // autoKnockLobby: false,

    // DEPRECATED. Please use `lobby?.enableChat` instead.
    // Enable lobby chat.
    // enableLobbyChat: true,

    // DEPRECATED! Use `breakoutRooms.hideAddRoomButton` instead.
    // Hides add breakout room button
    // hideAddRoomButton: false,

    // Require users to always specify a display name.
    // requireDisplayName: true,

    // Enables webhid functionality for Audio.
    // enableWebHIDFeature: false,

    // DEPRECATED! Use 'welcomePage.disabled' instead.
    // Whether to use a welcome page or not. In case it's false a random room
    // will be joined when no room is specified.
    // enableWelcomePage: true,

    // Configs for welcome page.
    // welcomePage: {
    //     // Whether to disable welcome page. In case it's disabled a random room
    //     // will be joined when no room is specified.
    //     disabled: false,
    //     // If set, landing page will redirect to this URL.
    //     customUrl: ''
    // },

    // Configs for the lobby screen.
    // lobby: {
    //     // If Lobby is enabled, it starts knocking automatically. Replaces `autoKnockLobby`.
    //     autoKnock: false,
    //     // Enables the lobby chat. Replaces `enableLobbyChat`.
    //     enableChat: true,
    // },

    // Configs for the security related UI elements.
    // securityUi: {
    //     // Hides the lobby button. Replaces `hideLobbyButton`.
    //     hideLobbyButton: false,
    //     // Hides the possibility to set and enter a lobby password.
    //     disableLobbyPassword: false,
    // },

    // Disable app shortcuts that are registered upon joining a conference
    // disableShortcuts: false,

    // Disable initial browser getUserMedia requests.
    // This is useful for scenarios where users might want to start a conference for screensharing only
    // disableInitialGUM: false,

    // Enabling the close page will ignore the welcome page redirection when
    // a call is hangup.
    // enableClosePage: false,

    // Disable hiding of remote thumbnails when in a 1-on-1 conference call.
    // Setting this to null, will also disable showing the remote videos
    // when the toolbar is shown on mouse movements
    // disable1On1Mode: null | false | true,

    // Default local name to be displayed
    // defaultLocalDisplayName: 'me',

    // Default remote name to be displayed
    // defaultRemoteDisplayName: 'Fellow Jitster',

    // Hides the display name from the participant thumbnail
    // hideDisplayName: false,

    // Hides the dominant speaker name badge that hovers above the toolbox
    // hideDominantSpeakerBadge: false,

    // Default language for the user interface. Cannot be overwritten.
    // DEPRECATED! Use the `lang` iframe option directly instead.
    // defaultLanguage: 'en',

    // Disables profile and the edit of all fields from the profile settings (display name and email)
    // disableProfile: false,

    // Hides the email section under profile settings.
    // hideEmailInSettings: false,

    // When enabled the password used for locking a room is restricted to up to the number of digits specified
    // default: roomPasswordNumberOfDigits: false,
    // roomPasswordNumberOfDigits: 10,

    // Message to show the users. Example: 'The service will be down for
    // maintenance at 01:00 AM GMT,
    // noticeMessage: '',

    // Enables calendar integration, depends on googleApiApplicationClientID
    // and microsoftApiApplicationClientID
    // enableCalendarIntegration: false,

    // Configs for prejoin page.
    // prejoinConfig: {
    //     // When 'true', it shows an intermediate page before joining, where the user can configure their devices.
    //     // This replaces `prejoinPageEnabled`. Defaults to true.
    //     enabled: true,
    //     // Hides the participant name editing field in the prejoin screen.
    //     // If requireDisplayName is also set as true, a name should still be provided through
    //     // either the jwt or the userInfo from the iframe api init object in order for this to have an effect.
    //     hideDisplayName: false,
    //     // List of buttons to hide from the extra join options dropdown.
    //     hideExtraJoinButtons: ['no-audio', 'by-phone'],
    // },

    // When 'true', the user cannot edit the display name.
    // (Mainly useful when used in conjunction with the JWT so the JWT name becomes read only.)
    // readOnlyName: false,

    // If etherpad integration is enabled, setting this to true will
    // automatically open the etherpad when a participant joins.  This
    // does not affect the mobile app since opening an etherpad
    // obscures the conference controls -- it's better to let users
    // choose to open the pad on their own in that case.
    // openSharedDocumentOnJoin: false,

    // If true, shows the unsafe room name warning label when a room name is
    // deemed unsafe (due to the simplicity in the name) and a password is not
    // set or the lobby is not enabled.
    // enableInsecureRoomNameWarning: false,

    // Whether to automatically copy invitation URL after creating a room.
    // Document should be focused for this option to work
    // enableAutomaticUrlCopy: false,

    // Array with avatar URL prefixes that need to use CORS.
    // corsAvatarURLs: [ 'https://www.gravatar.com/avatar/' ],

    // Base URL for a Gravatar-compatible service. Defaults to Gravatar.
    // DEPRECATED! Use `gravatar.baseUrl` instead.
    // gravatarBaseURL: 'https://www.gravatar.com/avatar/',

    // Setup for Gravatar-compatible services.
    // gravatar: {
    //     // Defaults to Gravatar.
    //     baseUrl: 'https://www.gravatar.com/avatar/',
    //     // True if Gravatar should be disabled.
    //     disabled: false,
    // },

    // App name to be displayed in the invitation email subject, as an alternative to
    // interfaceConfig.APP_NAME.
    // inviteAppName: null,

    // Moved from interfaceConfig(TOOLBAR_BUTTONS).
    // The name of the toolbar buttons to display in the toolbar, including the
    // "More actions" menu. If present, the button will display. Exceptions are
    // "livestreaming" and "recording" which also require being a moderator and
    // some other values in config.js to be enabled. Also, the "profile" button will
    // not display for users with a JWT.
    // Notes:
    // - it's impossible to choose which buttons go in the "More actions" menu
    // - it's impossible to control the placement of buttons
    // - 'desktop' controls the "Share your screen" button
    // - if `toolbarButtons` is undefined, we fallback to enabling all buttons on the UI
    // toolbarButtons: [
    //    'camera',
    //    'chat',
    //    'closedcaptions',
    //    'desktop',
    //    'download',
    //    'embedmeeting',
    //    'etherpad',
    //    'feedback',
    //    'filmstrip',
    //    'fullscreen',
    //    'hangup',
    //    'help',
    //    'highlight',
    //    'invite',
    //    'linktosalesforce',
    //    'livestreaming',
    //    'microphone',
    //    'noisesuppression',
    //    'participants-pane',
    //    'profile',
    //    'raisehand',
    //    'recording',
    //    'security',
    //    'select-background',
    //    'settings',
    //    'shareaudio',
    //    'sharedvideo',
    //    'shortcuts',
    //    'stats',
    //    'tileview',
    //    'toggle-camera',
    //    'videoquality',
    //    'whiteboard',
    // ],

    // Holds values related to toolbar visibility control.
    // toolbarConfig: {
    //     // Moved from interfaceConfig.INITIAL_TOOLBAR_TIMEOUT
    //     // The initial number of milliseconds for the toolbar buttons to be visible on screen.
    //     initialTimeout: 20000,
    //     // Moved from interfaceConfig.TOOLBAR_TIMEOUT
    //     // Number of milliseconds for the toolbar buttons to be visible on screen.
    //     timeout: 4000,
    //     // Moved from interfaceConfig.TOOLBAR_ALWAYS_VISIBLE
    //     // Whether toolbar should be always visible or should hide after x milliseconds.
    //     alwaysVisible: false,
    //     // Indicates whether the toolbar should still autohide when chat is open
    //     autoHideWhileChatIsOpen: false,
    // },

    // Overrides the buttons displayed in the main toolbar. Depending on the screen size the number of displayed
    // buttons varies from 2 buttons to 8 buttons. Every array in the mainToolbarButtons array will replace the
    // corresponding default buttons configuration matched by the number of buttons specified in the array. Arrays with
    // more than 8 buttons or less then 2 buttons will be ignored. When there there isn't an override for a cerain
    // configuration (for example when 3 buttons are displayed) the default jitsi-meet configuration will be used.
    // The order of the buttons in the array is preserved.
    // mainToolbarButtons: [
    //     [ 'microphone', 'camera', 'desktop', 'chat', 'raisehand', 'reactions', 'participants-pane', 'tileview' ],
    //     [ 'microphone', 'camera', 'desktop', 'chat', 'raisehand', 'participants-pane', 'tileview' ],
    //     [ 'microphone', 'camera', 'desktop', 'chat', 'raisehand', 'participants-pane' ],
    //     [ 'microphone', 'camera', 'desktop', 'chat', 'participants-pane' ],
    //     [ 'microphone', 'camera', 'chat', 'participants-pane' ],
    //     [ 'microphone', 'camera', 'chat' ],
    //     [ 'microphone', 'camera' ]
    // ],

    // Toolbar buttons which have their click/tap event exposed through the API on
    // `toolbarButtonClicked`. Passing a string for the button key will
    // prevent execution of the click/tap routine; passing an object with `key` and
    // `preventExecution` flag on false will not prevent execution of the click/tap
    // routine. Below array with mixed mode for passing the buttons.
    // buttonsWithNotifyClick: [
    //     'camera',
    //     {
    //         key: 'chat',
    //         preventExecution: false
    //     },
    //     {
    //         key: 'closedcaptions',
    //         preventExecution: true
    //     },
    //     'desktop',
    //     'download',
    //     'embedmeeting',
    //     'end-meeting',
    //     'etherpad',
    //     'feedback',
    //     'filmstrip',
    //     'fullscreen',
    //     'hangup',
    //     'hangup-menu',
    //     'help',
    //     {
    //         key: 'invite',
    //         preventExecution: false
    //     },
    //     'livestreaming',
    //     'microphone',
    //     'mute-everyone',
    //     'mute-video-everyone',
    //     'noisesuppression',
    //     'participants-pane',
    //     'profile',
    //     {
    //         key: 'raisehand',
    //         preventExecution: true
    //     },
    //     'recording',
    //     'security',
    //     'select-background',
    //     'settings',
    //     'shareaudio',
    //     'sharedvideo',
    //     'shortcuts',
    //     'stats',
    //     'tileview',
    //     'toggle-camera',
    //     'videoquality',
    //     // The add passcode button from the security dialog.
    //     {
    //         key: 'add-passcode',
    //         preventExecution: false
    //     },
    //     'whiteboard',
    // ],

    // Participant context menu buttons which have their click/tap event exposed through the API on
    // `participantMenuButtonClick`. Passing a string for the button key will
    // prevent execution of the click/tap routine; passing an object with `key` and
    // `preventExecution` flag on false will not prevent execution of the click/tap
    // routine. Below array with mixed mode for passing the buttons.
    // participantMenuButtonsWithNotifyClick: [
    //     'allow-video',
    //     {
    //         key: 'ask-unmute',
    //         preventExecution: false
    //     },
    //     'conn-status',
    //     'flip-local-video',
    //     'grant-moderator',
    //     {
    //         key: 'kick',
    //         preventExecution: true
    //     },
    //     {
    //         key: 'hide-self-view',
    //         preventExecution: false
    //     },
    //     'mute',
    //     'mute-others',
    //     'mute-others-video',
    //     'mute-video',
    //     'pinToStage',
    //     'privateMessage',
    //     {
    //         key: 'remote-control',
    //         preventExecution: false
    //     },
    //     'send-participant-to-room',
    //     'verify',
    // ],

    // List of pre meeting screens buttons to hide. The values must be one or more of the 5 allowed buttons:
    // 'microphone', 'camera', 'select-background', 'invite', 'settings'
    // hiddenPremeetingButtons: [],

    // An array with custom option buttons for the participant context menu
    // type:  Array<{ icon: string; id: string; text: string; }>
    // customParticipantMenuButtons: [],

    // An array with custom option buttons for the toolbar
    // type:  Array<{ icon: string; id: string; text: string; backgroundColor?: string; }>
    // customToolbarButtons: [],

    // Stats
    //

    // Whether to enable stats collection or not in the TraceablePeerConnection.
    // This can be useful for debugging purposes (post-processing/analysis of
    // the webrtc stats) as it is done in the jitsi-meet-torture bandwidth
    // estimation tests.
    // gatherStats: false,

    // The interval at which PeerConnection.getStats() is called. Defaults to 10000
    // pcStatsInterval: 10000,

    // Enables sending participants' display names to stats
    // enableDisplayNameInStats: false,

    // Enables sending participants' emails (if available) to stats and other analytics
    // enableEmailInStats: false,

    // faceLandmarks: {
    //     // Enables sharing your face coordinates. Used for centering faces within a video.
    //     enableFaceCentering: false,

    //     // Enables detecting face expressions and sharing data with other participants
    //     enableFaceExpressionsDetection: false,

    //     // Enables displaying face expressions in speaker stats
    //     enableDisplayFaceExpressions: false,

    //     // Enable rtc stats for face landmarks
    //     enableRTCStats: false,

    //     // Minimum required face movement percentage threshold for sending new face centering coordinates data.
    //     faceCenteringThreshold: 10,

    //     // Milliseconds for processing a new image capture in order to detect face coordinates if they exist.
    //     captureInterval: 1000,
    // },

    // Controls the percentage of automatic feedback shown to participants.
    // The default value is 100%. If set to 0, no automatic feedback will be requested
    // feedbackPercentage: 100,

    // Privacy
    //

    // If third party requests are disabled, no other server will be contacted.
    // This means avatars will be locally generated and external stats integration
    // will not function.
    // disableThirdPartyRequests: false,


    // Peer-To-Peer mode: used (if enabled) when there are just 2 participants.
    //

    p2p: {
        // Enables peer to peer mode. When enabled the system will try to
        // establish a direct connection when there are exactly 2 participants
        // in the room. If that succeeds the conference will stop sending data
        // through the JVB and use the peer to peer connection instead. When a
        // 3rd participant joins the conference will be moved back to the JVB
        // connection.
        enabled: true,

        // Sets the ICE transport policy for the p2p connection. At the time
        // of this writing the list of possible values are 'all' and 'relay',
        // but that is subject to change in the future. The enum is defined in
        // the WebRTC standard:
        // https://www.w3.org/TR/webrtc/#rtcicetransportpolicy-enum.
        // If not set, the effective value is 'all'.
        // iceTransportPolicy: 'all',

        // Provides a way to set the codec preference on mobile devices, both on RN and mobile browser based
        // endpoints.
        // mobileCodecPreferenceOrder: [ 'H264', 'VP8', 'VP9' ],
        //
        // Provides a way to set the codec preference on desktop based endpoints.
        // codecPreferenceOrder: [ 'VP9', 'VP8', 'H264 ],

        // Provides a way to set the codec for screenshare.
        // screenshareCodec: 'AV1',
        // mobileScreenshareCodec: 'VP8',

        // How long we're going to wait, before going back to P2P after the 3rd
        // participant has left the conference (to filter out page reload).
        // backToP2PDelay: 5,

        // The STUN servers that will be used in the peer to peer connections
        stunServers: [

            // { urls: 'stun:jitsi-meet.example.com:3478' },
            { urls: 'stun:meet-jit-si-turnrelay.jitsi.net:443' },
        ],

        // DEPRECATED! Use `codecPreferenceOrder/mobileCodecPreferenceOrder` instead.
        // Provides a way to set the video codec preference on the p2p connection. Acceptable
        // codec values are 'VP8', 'VP9' and 'H264'.
        // preferredCodec: 'H264',

        // DEPRECATED! Use `codecPreferenceOrder/mobileCodecPreferenceOrder` instead.
        // Provides a way to prevent a video codec from being negotiated on the p2p connection.
        // disabledCodec: '',
    },

    analytics: {
        // True if the analytics should be disabled
        // disabled: false,

        // The Google Analytics Tracking ID:
        // googleAnalyticsTrackingId: 'your-tracking-id-UA-123456-1',

        // Matomo configuration:
        // matomoEndpoint: 'https://your-matomo-endpoint/',
        // matomoSiteID: '42',

        // The Amplitude APP Key:
        // amplitudeAPPKey: '<APP_KEY>',

        // Enables Amplitude UTM tracking:
        // Default value is false.
        // amplitudeIncludeUTM: false,

        // Obfuscates room name sent to analytics (amplitude, rtcstats)
        // Default value is false.
        // obfuscateRoomName: false,

        // Configuration for the rtcstats server:
        // By enabling rtcstats server every time a conference is joined the rtcstats
        // module connects to the provided rtcstatsEndpoint and sends statistics regarding
        // PeerConnection states along with getStats metrics polled at the specified
        // interval.
        // rtcstatsEnabled: false,
        // rtcstatsStoreLogs: false,

        // In order to enable rtcstats one needs to provide a endpoint url.
        // rtcstatsEndpoint: wss://rtcstats-server-pilot.jitsi.net/,

        // The interval at which rtcstats will poll getStats, defaults to 10000ms.
        // If the value is set to 0 getStats won't be polled and the rtcstats client
        // will only send data related to RTCPeerConnection events.
        // rtcstatsPollInterval: 10000,

        // This determines if rtcstats sends the SDP to the rtcstats server or replaces
        // all SDPs with an empty string instead.
        // rtcstatsSendSdp: false,

        // Array of script URLs to load as lib-jitsi-meet "analytics handlers".
        // scriptURLs: [
        //      "libs/analytics-ga.min.js", // google-analytics
        //      "https://example.com/my-custom-analytics.js",
        // ],

        // By enabling watchRTCEnabled option you would want to use watchRTC feature
        // This would also require to configure watchRTCConfigParams.
        // Please remember to keep rtcstatsEnabled disabled for watchRTC to work.
        // watchRTCEnabled: false,
    },

    // Logs that should go be passed through the 'log' event if a handler is defined for it
    // apiLogLevels: ['warn', 'log', 'error', 'info', 'debug'],

    // Information about the jitsi-meet instance we are connecting to, including
    // the user region as seen by the server.
    // deploymentInfo: {
    //     shard: "shard1",
    //     region: "europe",
    //     userRegion: "asia",
    // },

    // Array<string> of disabled sounds.
    // Possible values:
    // - 'ASKED_TO_UNMUTE_SOUND'
    // - 'E2EE_OFF_SOUND'
    // - 'E2EE_ON_SOUND'
    // - 'INCOMING_MSG_SOUND'
    // - 'KNOCKING_PARTICIPANT_SOUND'
    // - 'LIVE_STREAMING_OFF_SOUND'
    // - 'LIVE_STREAMING_ON_SOUND'
    // - 'NO_AUDIO_SIGNAL_SOUND'
    // - 'NOISY_AUDIO_INPUT_SOUND'
    // - 'OUTGOING_CALL_EXPIRED_SOUND'
    // - 'OUTGOING_CALL_REJECTED_SOUND'
    // - 'OUTGOING_CALL_RINGING_SOUND'
    // - 'OUTGOING_CALL_START_SOUND'
    // - 'PARTICIPANT_JOINED_SOUND'
    // - 'PARTICIPANT_LEFT_SOUND'
    // - 'RAISE_HAND_SOUND'
    // - 'REACTION_SOUND'
    // - 'RECORDING_OFF_SOUND'
    // - 'RECORDING_ON_SOUND'
    // - 'TALK_WHILE_MUTED_SOUND'
    // disabledSounds: [],

    // DEPRECATED! Use `disabledSounds` instead.
    // Decides whether the start/stop recording audio notifications should play on record.
    // disableRecordAudioNotification: false,

    // DEPRECATED! Use `disabledSounds` instead.
    // Disables the sounds that play when other participants join or leave the
    // conference (if set to true, these sounds will not be played).
    // disableJoinLeaveSounds: false,

    // DEPRECATED! Use `disabledSounds` instead.
    // Disables the sounds that play when a chat message is received.
    // disableIncomingMessageSound: false,

    // Information for the chrome extension banner
    // chromeExtensionBanner: {
    //     // The chrome extension to be installed address
    //     url: 'https://chrome.google.com/webstore/detail/jitsi-meetings/kglhbbefdnlheedjiejgomgmfplipfeb',
    //     edgeUrl: 'https://microsoftedge.microsoft.com/addons/detail/jitsi-meetings/eeecajlpbgjppibfledfihobcabccihn',

    //     // Extensions info which allows checking if they are installed or not
    //     chromeExtensionsInfo: [
    //         {
    //             id: 'kglhbbefdnlheedjiejgomgmfplipfeb',
    //             path: 'jitsi-logo-48x48.png',
    //         },
    //         // Edge extension info
    //         {
    //             id: 'eeecajlpbgjppibfledfihobcabccihn',
    //             path: 'jitsi-logo-48x48.png',
    //         },
    //     ]
    // },

    // e2ee: {
    //   labels: {
    //     description: '',
    //     label: '',
    //     tooltip: '',
    //     warning: '',
    //   },
    //   externallyManagedKey: false,
    // },

    // Options related to end-to-end (participant to participant) ping.
    // e2eping: {
    //   // Whether ene-to-end pings should be enabled.
    //   enabled: false,
    //
    //   // The number of responses to wait for.
    //   numRequests: 5,
    //
    //   // The max conference size in which e2e pings will be sent.
    //   maxConferenceSize: 200,
    //
    //   // The maximum number of e2e ping messages per second for the whole conference to aim for.
    //   // This is used to control the pacing of messages in order to reduce the load on the backend.
    //   maxMessagesPerSecond: 250,
    // },

    // If set, will attempt to use the provided video input device label when
    // triggering a screenshare, instead of proceeding through the normal flow
    // for obtaining a desktop stream.
    // NOTE: This option is experimental and is currently intended for internal
    // use only.
    // _desktopSharingSourceDevice: 'sample-id-or-label',

    // DEPRECATED! Use deeplinking.disabled instead.
    // If true, any checks to handoff to another application will be prevented
    // and instead the app will continue to display in the current browser.
    // disableDeepLinking: false,

    // The deeplinking config.
    // For information about the properties of
    // deeplinking.[ios/android].dynamicLink check:
    // https://firebase.google.com/docs/dynamic-links/create-manually
    // deeplinking: {
    //
    //     // The desktop deeplinking config, disabled by default.
    //     desktop: {
    //         appName: 'Jitsi Meet',
    //         appScheme: 'jitsi-meet,
    //         download: {
    //             linux:
    //               'https://github.com/jitsi/jitsi-meet-electron/releases/latest/download/jitsi-meet-x86_64.AppImage',
    //             macos: 'https://github.com/jitsi/jitsi-meet-electron/releases/latest/download/jitsi-meet.dmg',
    //             windows: 'https://github.com/jitsi/jitsi-meet-electron/releases/latest/download/jitsi-meet.exe'
    //         },
    //         enabled: false
    //     },
    //     // If true, any checks to handoff to another application will be prevented
    //     // and instead the app will continue to display in the current browser.
    //     disabled: false,

    //     // whether to hide the logo on the deep linking pages.
    //     hideLogo: false,

    //     // The ios deeplinking config.
    //     ios: {
    //         appName: 'Jitsi Meet',
    //         // Specify mobile app scheme for opening the app from the mobile browser.
    //         appScheme: 'org.jitsi.meet',
    //         // Custom URL for downloading ios mobile app.
    //         downloadLink: 'https://itunes.apple.com/us/app/jitsi-meet/id1165103905',
    //         dynamicLink: {
    //             apn: 'org.jitsi.meet',
    //             appCode: 'w2atb',
    //             customDomain: undefined,
    //             ibi: 'com.atlassian.JitsiMeet.ios',
    //             isi: '1165103905'
    //         }
    //     },

    //     // The android deeplinking config.
    //     android: {
    //         appName: 'Jitsi Meet',
    //         // Specify mobile app scheme for opening the app from the mobile browser.
    //         appScheme: 'org.jitsi.meet',
    //         // Custom URL for downloading android mobile app.
    //         downloadLink: 'https://play.google.com/store/apps/details?id=org.jitsi.meet',
    //         // Android app package name.
    //         appPackage: 'org.jitsi.meet',
    //         fDroidUrl: 'https://f-droid.org/en/packages/org.jitsi.meet/',
    //         dynamicLink: {
    //             apn: 'org.jitsi.meet',
    //             appCode: 'w2atb',
    //             customDomain: undefined,
    //             ibi: 'com.atlassian.JitsiMeet.ios',
    //             isi: '1165103905'
    //         }
    //     }
    // },

    // // The terms, privacy and help centre URL's.
    // legalUrls: {
    //     helpCentre: 'https://web-cdn.jitsi.net/faq/meet-faq.html',
    //     privacy: 'https://jitsi.org/meet/privacy',
    //     terms: 'https://jitsi.org/meet/terms'
    // },

    // A property to disable the right click context menu for localVideo
    // the menu has option to flip the locally seen video for local presentations
    // disableLocalVideoFlip: false,

    // A property used to unset the default flip state of the local video.
    // When it is set to 'true', the local(self) video will not be mirrored anymore.
    // doNotFlipLocalVideo: false,

    // Mainly privacy related settings

    // Disables all invite functions from the app (share, invite, dial out...etc)
    // disableInviteFunctions: true,

    // Disables storing the room name to the recents list. When in an iframe this is ignored and
    // the room is never stored in the recents list.
    // doNotStoreRoom: true,

    // Deployment specific URLs.
    // deploymentUrls: {
    //    // If specified a 'Help' button will be displayed in the overflow menu with a link to the specified URL for
    //    // user documentation.
    //    userDocumentationURL: 'https://docs.example.com/video-meetings.html',
    //    // If specified a 'Download our apps' button will be displayed in the overflow menu with a link
    //    // to the specified URL for an app download page.
    //    downloadAppsUrl: 'https://docs.example.com/our-apps.html',
    // },

    // Options related to the remote participant menu.
    // remoteVideoMenu: {
    //     // Whether the remote video context menu to be rendered or not.
    //     disabled: true,
    //     // If set to true the 'Switch to visitor' button will be disabled.
    //     disableDemote: true,
    //     // If set to true the 'Kick out' button will be disabled.
    //     disableKick: true,
    //     // If set to true the 'Grant moderator' button will be disabled.
    //     disableGrantModerator: true,
    //     // If set to true the 'Send private message' button will be disabled.
    //     disablePrivateChat: true,
    // },

    // Endpoint that enables support for salesforce integration with in-meeting resource linking
    // This is required for:
    // listing the most recent records - salesforceUrl/records/recents
    // searching records - salesforceUrl/records?text=${text}
    // retrieving record details - salesforceUrl/records/${id}?type=${type}
    // and linking the meeting - salesforceUrl/sessions/${sessionId}/records/${id}
    //
    // salesforceUrl: 'https://api.example.com/',

    // If set to true all muting operations of remote participants will be disabled.
    // disableRemoteMute: true,

    /**
     External API url used to receive branding specific information.
     If there is no url set or there are missing fields, the defaults are applied.
     The config file should be in JSON.
     None of the fields are mandatory and the response must have the shape:
    {
        // The domain url to apply (will replace the domain in the sharing conference link/embed section)
        inviteDomain: 'example-company.org,
        // The hex value for the colour used as background
        backgroundColor: '#fff',
        // The url for the image used as background
        backgroundImageUrl: 'https://example.com/background-img.png',
        // The anchor url used when clicking the logo image
        logoClickUrl: 'https://example-company.org',
        // The url used for the image used as logo
        logoImageUrl: 'https://example.com/logo-img.png',
        // Overwrite for pool of background images for avatars
        avatarBackgrounds: ['url(https://example.com/avatar-background-1.png)', '#FFF'],
        // The lobby/prejoin screen background
        premeetingBackground: 'url(https://example.com/premeeting-background.png)',
        // A list of images that can be used as video backgrounds.
        // When this field is present, the default images will be replaced with those provided.
        virtualBackgrounds: ['https://example.com/img.jpg'],
        // Object containing customized icons that should replace the default ones.
        // The keys need to be the exact same icon names used in here:
        // https://github.com/jitsi/jitsi-meet/blob/master/react/features/base/icons/svg/index.ts
        // To avoid having the icons trimmed or displayed in an unexpected way, please provide svg
        // files containing svg xml icons in the size that the default icons come in.
        customIcons: {
            IconArrowUp: 'https://example.com/arrow-up.svg',
            IconDownload: 'https://example.com/download.svg',
            IconRemoteControlStart: 'https://example.com/remote-start.svg',
        },
        // Object containing a theme's properties. It also supports partial overwrites of the main theme.
        // For a list of all possible theme tokens and their current defaults, please check:
        // https://github.com/jitsi/jitsi-meet/tree/master/resources/custom-theme/custom-theme.json
        // For a short explanations on each of the tokens, please check:
        // https://github.com/jitsi/jitsi-meet/blob/master/react/features/base/ui/Tokens.ts
        // IMPORTANT!: This is work in progress so many of the various tokens are not yet applied in code
        // or they are partially applied.
        customTheme: {
            palette: {
                ui01: "orange !important",
                ui02: "maroon",
                surface02: 'darkgreen',
                ui03: "violet",
                ui04: "magenta",
                ui05: "blueviolet",
                action01: 'green',
                action01Hover: 'lightgreen',
                disabled01: 'beige',
                success02: 'cadetblue',
                action02Hover: 'aliceblue',
            },
            typography: {
                labelRegular: {
                    fontSize: 25,
                    lineHeight: 30,
                    fontWeight: 500,
                }
            }
        }
    }
    */
    // dynamicBrandingUrl: '',

    // A list of allowed URL domains for shared video.
    //
    // NOTE:
    // '*' is allowed value and it will allow any URL to be used for shared video. We do not recommend using '*',
    // use it at your own risk!
    // sharedVideoAllowedURLDomains: [ ],

    // Options related to the participants pane.
    // participantsPane: {
    //     // Enables feature
    //     enabled: true,
    //     // Hides the moderator settings tab.
    //     hideModeratorSettingsTab: false,
    //     // Hides the more actions button.
    //     hideMoreActionsButton: false,
    //     // Hides the mute all button.
    //     hideMuteAllButton: false,
    // },

    // Options related to the breakout rooms feature.
    // breakoutRooms: {
    //     // Hides the add breakout room button. This replaces `hideAddRoomButton`.
    //     hideAddRoomButton: false,
    //     // Hides the auto assign participants button.
    //     hideAutoAssignButton: false,
    //     // Hides the join breakout room button.
    //     hideJoinRoomButton: false,
    // },

    // When true, virtual background feature will be disabled.
    // disableVirtualBackground: false,

    // When true the user cannot add more images to be used as virtual background.
    // Only the default ones from will be available.
    // disableAddingBackgroundImages: false,

    // Sets the background transparency level. '0' is fully transparent, '1' is opaque.
    // backgroundAlpha: 1,

    // The URL of the moderated rooms microservice, if available. If it
    // is present, a link to the service will be rendered on the welcome page,
    // otherwise the app doesn't render it.
    // moderatedRoomServiceUrl: 'https://moderated.jitsi-meet.example.com',

    // If true, tile view will not be enabled automatically when the participants count threshold is reached.
    // disableTileView: true,

    // If true, the tiles will be displayed contained within the available space rather than enlarged to cover it,
    // with a 16:9 aspect ratio (old behaviour).
    // disableTileEnlargement: true,

    // Controls the visibility and behavior of the top header conference info labels.
    // If a label's id is not in any of the 2 arrays, it will not be visible at all on the header.
    // conferenceInfo: {
    //     // those labels will not be hidden in tandem with the toolbox.
    //     alwaysVisible: ['recording', 'raised-hands-count'],
    //     // those labels will be auto-hidden in tandem with the toolbox buttons.
    //     autoHide: [
    //         'subject',
    //         'conference-timer',
    //         'participants-count',
    //         'e2ee',
    //         'video-quality',
    //         'insecure-room',
    //         'highlight-moment',
    //         'top-panel-toggle',
    //     ]
    // },

    // Hides the conference subject
    // hideConferenceSubject: false,

    // Hides the conference timer.
    // hideConferenceTimer: false,

    // Hides the recording label
    // hideRecordingLabel: false,

    // Hides the participants stats
    // hideParticipantsStats: true,

    // Sets the conference subject
    // subject: 'Conference Subject',

    // Sets the conference local subject
    // localSubject: 'Conference Local Subject',

    // This property is related to the use case when jitsi-meet is used via the IFrame API. When the property is true
    // jitsi-meet will use the local storage of the host page instead of its own. This option is useful if the browser
    // is not persisting the local storage inside the iframe.
    // useHostPageLocalStorage: true,

    // Etherpad ("shared document") integration.
    //
    // If set, add a "Open shared document" link to the bottom right menu that
    // will open an etherpad document.
    // etherpad_base: 'https://your-etherpad-installati.on/p/',

    // To enable information about dial-in access to meetings you need to provide
    // dialInNumbersUrl and dialInConfCodeUrl.
    // dialInNumbersUrl returns a json array of numbers that can be used for dial-in.
    // {"countryCode":"US","tollFree":false,"formattedNumber":"+1 123-456-7890"}
    // dialInConfCodeUrl is the conference mapper converting a meeting id to a PIN used for dial-in
    // or the other way around (more info in resources/cloud-api.swagger)

    // You can use external service for authentication that will redirect back passing a jwt token
    // You can use tokenAuthUrl config to point to a URL of such service.
    // The URL for the service supports few params which will be filled in by the code.
    // tokenAuthUrl:
    //      'https://myservice.com/auth/{room}?code_challenge_method=S256&code_challenge={code_challenge}&state={state}'
    // Supported parameters in tokenAuthUrl:
    //      {room} - will be replaced with the room name
    //      {code_challenge} - (A web only). A oauth 2.0 code challenge that will be sent to the service. See:
    //          https://datatracker.ietf.org/doc/html/rfc7636. The code verifier will be saved in the sessionStorage
    //          under key: 'code_verifier'.
    //      {state} - A json with the current state before redirecting. Keys that are included in the state:
    //          - room (The current room name as shown in the address bar)
    //          - roomSafe (the backend safe room name to use (lowercase), that is passed to the backend)
    //          - tenant (The tenant if any)
    //          - config.xxx (all config overrides)
    //          - interfaceConfig.xxx (all interfaceConfig overrides)
    //          - ios=true (in case ios mobile app is used)
    //          - android=true (in case android mobile app is used)
    //          - electron=true (when web is loaded in electron app)
    // If there is a logout service you can specify its URL with:
    // tokenLogoutUrl: 'https://myservice.com/logout'
    // You can enable tokenAuthUrlAutoRedirect which will detect that you have logged in successfully before
    // and will automatically redirect to the token service to get the token for the meeting.
    // tokenAuthUrlAutoRedirect: false

    // You can put an array of values to target different entity types in the invite dialog.
    // Valid values are "phone", "room", "sip", "user", "videosipgw" and "email"
    // peopleSearchQueryTypes: ["user", "email"],
    // Directory endpoint which is called for invite dialog autocomplete
    // peopleSearchUrl: "https://myservice.com/api/people",
    // Endpoint which is called to send invitation requests
    // inviteServiceUrl: "https://myservice.com/api/invite",

    // For external entities (e. g. email), the localStorage key holding the token value for directory authentication
    // peopleSearchTokenLocation: "mytoken",

    // List of undocumented settings used in jitsi-meet
    /**
     _immediateReloadThreshold
     debug
     debugAudioLevels
     deploymentInfo
     dialOutAuthUrl
     dialOutCodesUrl
     dialOutRegionUrl
     disableRemoteControl
     displayJids
     firefox_fake_device
     googleApiApplicationClientID
     iAmRecorder
     iAmSipGateway
     microsoftApiApplicationClientID
     requireDisplayName
     */

    /**
     * This property can be used to alter the generated meeting invite links (in combination with a branding domain
     * which is retrieved internally by jitsi meet) (e.g. https://meet.jit.si/someMeeting
     * can become https://brandedDomain/roomAlias)
     */
    // brandingRoomAlias: null,

    // List of undocumented settings used in lib-jitsi-meet
    /**
     _peerConnStatusOutOfLastNTimeout
     _peerConnStatusRtcMuteTimeout
     avgRtpStatsN
     desktopSharingSources
     disableAEC
     disableAGC
     disableAP
     disableHPF
     disableLocalStats
     disableNS
     enableTalkWhileMuted
     forceTurnRelay
     hiddenDomain
     hiddenFromRecorderFeatureEnabled
     ignoreStartMuted
     websocketKeepAlive
     websocketKeepAliveUrl
     */

    /**
     * Default interval (milliseconds) for triggering mouseMoved iframe API event
     */
    mouseMoveCallbackInterval: 1000,

    /**
        Use this array to configure which notifications will be shown to the user
        The items correspond to the title or description key of that notification
        Some of these notifications also depend on some other internal logic to be displayed or not,
        so adding them here will not ensure they will always be displayed

        A falsy value for this prop will result in having all notifications enabled (e.g null, undefined, false)
    */
    // notifications: [
    //     'connection.CONNFAIL', // shown when the connection fails,
    //     'dialog.cameraConstraintFailedError', // shown when the camera failed
    //     'dialog.cameraNotSendingData', // shown when there's no feed from user's camera
    //     'dialog.kickTitle', // shown when user has been kicked
    //     'dialog.liveStreaming', // livestreaming notifications (pending, on, off, limits)
    //     'dialog.lockTitle', // shown when setting conference password fails
    //     'dialog.maxUsersLimitReached', // shown when maximmum users limit has been reached
    //     'dialog.micNotSendingData', // shown when user's mic is not sending any audio
    //     'dialog.passwordNotSupportedTitle', // shown when setting conference password fails due to password format
    //     'dialog.recording', // recording notifications (pending, on, off, limits)
    //     'dialog.remoteControlTitle', // remote control notifications (allowed, denied, start, stop, error)
    //     'dialog.reservationError',
    //     'dialog.screenSharingFailedTitle', // shown when the screen sharing failed
    //     'dialog.serviceUnavailable', // shown when server is not reachable
    //     'dialog.sessTerminated', // shown when there is a failed conference session
    //     'dialog.sessionRestarted', // show when a client reload is initiated because of bridge migration
    //     'dialog.tokenAuthFailed', // show when an invalid jwt is used
    //     'dialog.tokenAuthFailedWithReasons', // show when an invalid jwt is used with the reason behind the error
    //     'dialog.transcribing', // transcribing notifications (pending, off)
    //     'dialOut.statusMessage', // shown when dial out status is updated.
    //     'liveStreaming.busy', // shown when livestreaming service is busy
    //     'liveStreaming.failedToStart', // shown when livestreaming fails to start
    //     'liveStreaming.unavailableTitle', // shown when livestreaming service is not reachable
    //     'lobby.joinRejectedMessage', // shown when while in a lobby, user's request to join is rejected
    //     'lobby.notificationTitle', // shown when lobby is toggled and when join requests are allowed / denied
    //     'notify.audioUnmuteBlockedTitle', // shown when mic unmute blocked
    //     'notify.chatMessages', // shown when receiving chat messages while the chat window is closed
    //     'notify.connectedOneMember', // show when a participant joined
    //     'notify.connectedThreePlusMembers', // show when more than 2 participants joined simultaneously
    //     'notify.connectedTwoMembers', // show when two participants joined simultaneously
    //     'notify.dataChannelClosed', // shown when the bridge channel has been disconnected
    //     'notify.hostAskedUnmute', // shown to participant when host asks them to unmute
    //     'notify.invitedOneMember', // shown when 1 participant has been invited
    //     'notify.invitedThreePlusMembers', // shown when 3+ participants have been invited
    //     'notify.invitedTwoMembers', // shown when 2 participants have been invited
    //     'notify.kickParticipant', // shown when a participant is kicked
    //     'notify.leftOneMember', // show when a participant left
    //     'notify.leftThreePlusMembers', // show when more than 2 participants left simultaneously
    //     'notify.leftTwoMembers', // show when two participants left simultaneously
    //     'notify.linkToSalesforce', // shown when joining a meeting with salesforce integration
    //     'notify.localRecordingStarted', // shown when the local recording has been started
    //     'notify.localRecordingStopped', // shown when the local recording has been stopped
    //     'notify.moderationInEffectCSTitle', // shown when user attempts to share content during AV moderation
    //     'notify.moderationInEffectTitle', // shown when user attempts to unmute audio during AV moderation
    //     'notify.moderationInEffectVideoTitle', // shown when user attempts to enable video during AV moderation
    //     'notify.moderator', // shown when user gets moderator privilege
    //     'notify.mutedRemotelyTitle', // shown when user is muted by a remote party
    //     'notify.mutedTitle', // shown when user has been muted upon joining,
    //     'notify.newDeviceAudioTitle', // prompts the user to use a newly detected audio device
    //     'notify.newDeviceCameraTitle', // prompts the user to use a newly detected camera
    //     'notify.noiseSuppressionFailedTitle', // shown when failed to start noise suppression
    //     'notify.participantWantsToJoin', // shown when lobby is enabled and participant requests to join meeting
    //     'notify.participantsWantToJoin', // shown when lobby is enabled and participants request to join meeting
    //     'notify.passwordRemovedRemotely', // shown when a password has been removed remotely
    //     'notify.passwordSetRemotely', // shown when a password has been set remotely
    //     'notify.raisedHand', // shown when a partcipant used raise hand,
    //     'notify.screenShareNoAudio', // shown when the audio could not be shared for the selected screen
    //     'notify.screenSharingAudioOnlyTitle', // shown when the best performance has been affected by screen sharing
    //     'notify.selfViewTitle', // show "You can always un-hide the self-view from settings"
    //     'notify.startSilentTitle', // shown when user joined with no audio
    //     'notify.suboptimalExperienceTitle', // show the browser warning
    //     'notify.unmute', // shown to moderator when user raises hand during AV moderation
    //     'notify.videoMutedRemotelyTitle', // shown when user's video is muted by a remote party,
    //     'notify.videoUnmuteBlockedTitle', // shown when camera unmute and desktop sharing are blocked
    //     'prejoin.errorDialOut',
    //     'prejoin.errorDialOutDisconnected',
    //     'prejoin.errorDialOutFailed',
    //     'prejoin.errorDialOutStatus',
    //     'prejoin.errorStatusCode',
    //     'prejoin.errorValidation',
    //     'recording.busy', // shown when recording service is busy
    //     'recording.failedToStart', // shown when recording fails to start
    //     'recording.unavailableTitle', // shown when recording service is not reachable
    //     'toolbar.noAudioSignalTitle', // shown when a broken mic is detected
    //     'toolbar.noisyAudioInputTitle', // shown when noise is detected for the current microphone
    //     'toolbar.talkWhileMutedPopup', // shown when user tries to speak while muted
    //     'transcribing.failed', // shown when transcribing fails
    // ],

    // List of notifications to be disabled. Works in tandem with the above setting.
    // disabledNotifications: [],

    // Prevent the filmstrip from autohiding when screen width is under a certain threshold
    // disableFilmstripAutohiding: false,

    // filmstrip: {
    //     // Disable the vertical/horizonal filmstrip.
    //     disabled: false,
    //     // Disables user resizable filmstrip. Also, allows configuration of the filmstrip
    //     // (width, tiles aspect ratios) through the interfaceConfig options.
    //     disableResizable: false,

    //     // Disables the stage filmstrip
    //     // (displaying multiple participants on stage besides the vertical filmstrip)
    //     disableStageFilmstrip: false,

    //     // Default number of participants that can be displayed on stage.
    //     // The user can change this in settings. Number must be between 1 and 6.
    //     stageFilmstripParticipants: 1,

    //     // Disables the top panel (only shown when a user is sharing their screen).
    //     disableTopPanel: false,

    //     // The minimum number of participants that must be in the call for
    //     // the top panel layout to be used.
    //     minParticipantCountForTopPanel: 50,
    // },

    // Tile view related config options.
    // tileView: {
    //     // Whether tileview should be disabled.
    //     disabled: false,
    //     // The optimal number of tiles that are going to be shown in tile view. Depending on the screen size it may
    //     // not be possible to show the exact number of participants specified here.
    //     numberOfVisibleTiles: 25,
    // },

    // Specifies whether the chat emoticons are disabled or not
    // disableChatSmileys: false,

    // Settings for the GIPHY integration.
    // giphy: {
    //     // Whether the feature is enabled or not.
    //     enabled: false,
    //     // SDK API Key from Giphy.
    //     sdkKey: '',
    //     // Display mode can be one of:
    //     // - tile: show the GIF on the tile of the participant that sent it.
    //     // - chat: show the GIF as a message in chat
    //     // - all: all of the above. This is the default option
    //     displayMode: 'all',
    //     // How long the GIF should be displayed on the tile (in milliseconds).
    //     tileTime: 5000,
    //     // Limit results by rating: g, pg, pg-13, r. Default value: g.
    //     rating: 'pg',
    // },

    // Logging
    // logging: {
    //      // Default log level for the app and lib-jitsi-meet.
    //      defaultLogLevel: 'trace',
    //      // Option to disable LogCollector.
    //      //disableLogCollector: true,
    //      // Individual loggers are customizable.
    //      loggers: {
    //      // The following are too verbose in their logging with the default level.
    //      'modules/RTC/TraceablePeerConnection.js': 'info',
    //      'modules/xmpp/strophe.util.js': 'log',
    // },

    // Application logo url
    // defaultLogoUrl: 'images/watermark.svg',

    // Settings for the Excalidraw whiteboard integration.
    // whiteboard: {
    //     // Whether the feature is enabled or not.
    //     enabled: true,
    //     // The server used to support whiteboard collaboration.
    //     // https://github.com/jitsi/excalidraw-backend
    //     collabServerBaseUrl: 'https://excalidraw-backend.example.com',
    //     // The user access limit to the whiteboard, introduced as a means
    //     // to control the performance.
    //     userLimit: 25,
    //     // The url for more info about the whiteboard and its usage limitations.
    //     limitUrl: 'https://example.com/blog/whiteboard-limits',
    // },

    // The watchRTC initialize config params as described :
    // https://testrtc.com/docs/installing-the-watchrtc-javascript-sdk/#h-set-up-the-sdk
    // https://www.npmjs.com/package/@testrtc/watchrtc-sdk
    // watchRTCConfigParams: {
    //         /** Watchrtc api key */
    //         rtcApiKey: string;
    //         /** Identifier for the session */
    //         rtcRoomId?: string;
    //         /** Identifier for the current peer */
    //         rtcPeerId?: string;
    //         /**
    //          * ["tag1", "tag2", "tag3"]
    //          * @deprecated use 'keys' instead
    //          */
    //         rtcTags?: string[];
    //         /** { "key1": "value1", "key2": "value2"} */
    //         keys?: any;
    //         /** Enables additional logging */
    //         debug?: boolean;
    //         rtcToken?: string;
    //         /**
    //          * @deprecated No longer needed. Use "proxyUrl" instead.
    //          */
    //         wsUrl?: string;
    //         proxyUrl?: string;
    //         console?: {
    //             level: string;
    //             override: boolean;
    //         };
    //         allowBrowserLogCollection?: boolean;
    //         collectionInterval?: number;
    //         logGetStats?: boolean;
    // },

    // Hide login button on auth dialog, you may want to enable this if you are using JWT tokens to authenticate users
    // hideLoginButton: true,
};

// Temporary backwards compatibility with old mobile clients.
config.flags = config.flags || {};
config.flags.sourceNameSignaling = true;
config.flags.sendMultipleVideoStreams = true;
config.flags.receiveMultipleVideoStreams = true;

// Set the default values for JaaS customers
if (enableJaaS) {
    config.dialInNumbersUrl = 'https://conference-mapper.jitsi.net/v1/access/dids';
    config.dialInConfCodeUrl = 'https://conference-mapper.jitsi.net/v1/access';
    config.roomPasswordNumberOfDigits = 10; // skip re-adding it (do not remove comment)
}


################################################################################

## File: .\jitsi-meet\custom.d.ts

declare module '*.svg' {
    const content: any;
    export default content;
}


################################################################################

## File: .\jitsi-meet\fonts.html



################################################################################

## File: .\jitsi-meet\globals.d.ts

import { IStore } from "./react/features/app/types";
import { IConfig } from "./react/features/base/config/configType";

export {};

declare global {
    const APP: {
        store: IStore;
        UI: any;
        API: any;
        conference: any;
        debugLogs: any;
    };
    const interfaceConfig: any;

    interface Window {
        config: IConfig;
        JITSI_MEET_LITE_SDK?: boolean;
        interfaceConfig?: any;
        JitsiMeetJS?: any;
        JitsiMeetElectron?: any;
        PressureObserver?: any;
        PressureRecord?: any;
        ReactNativeWebView?: any;
        // selenium tests handler
        _sharedVideoPlayer: any;
        alwaysOnTop: { api: any };
    }

    interface Document {
        mozCancelFullScreen?: Function;
        webkitExitFullscreen?: Function;
    }

    const config: IConfig;

    const JitsiMeetJS: any;

    interface HTMLMediaElement {
        setSinkId: (id: string) => Promise<undefined>;
        stop: () => void;
    }
}


################################################################################

## File: .\jitsi-meet\globals.native.d.ts

import { IConfig } from "./react/features/base/config/configType";

export {};

interface ILocation extends URL {
    assign(url: string);
    replace(url: string);
    reload();
};

interface IWindow {
    JITSI_MEET_LITE_SDK: boolean;
    JitsiMeetJS: any;
    config: IConfig;
    document: any;
    innerHeight: number;
    innerWidth: number;
    interfaceConfig: any;
    location: ILocation;
    PressureObserver?: any;
    PressureRecord?: any;
    ReactNativeWebView?: any;
    TextDecoder?: any;
    TextEncoder?: any;
    self: any;
    top: any;

    onerror: (event: string, source: any, lineno: any, colno: any, e: Error) => void;
    onunhandledrejection: (event: any) => void;

    setInterval: typeof setInterval;
    clearInterval: typeof clearInterval;
    setTimeout: typeof setTimeout;
    clearTimeout: typeof clearTimeout;
    setImmediate: typeof setImmediate;
    clearImmediate: typeof clearImmediate;
    addEventListener: Function;
    removeEventListener: Function;
}

interface INavigator {
    product: string;
}

declare global {
    const APP: any;
    const document: any;
    const interfaceConfig: any;
    const navigator: INavigator;
    const window: IWindow;
}


################################################################################

## File: .\jitsi-meet\head.html



################################################################################

## File: .\jitsi-meet\index.android.js

import './react/index.native';



################################################################################

## File: .\jitsi-meet\index.html

<html itemscope itemtype="http://schema.org/Product" prefix="og: http://ogp.me/ns#" xmlns="http://www.w3.org/1999/html">
  <head>
    <!--#include virtual="head.html" -->
    <meta charset="utf-8">
    <meta http-equiv="content-type" content="text/html;charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
    <meta name="theme-color" content="#2A3A4B">
    <!--#include virtual="base.html" -->

    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="stylesheet" href="css/all.css">
    <!--#include virtual="fonts.html"-->
    <link rel="manifest" id="manifest-placeholder">

    <script>
        function contextRoot(pathname) {
            const contextRootEndIndex = pathname.lastIndexOf('/');

            return (
                contextRootEndIndex === -1
                ? '/'
                : pathname.substring(0, contextRootEndIndex + 1)
            );
        }
        window.EXCALIDRAW_ASSET_PATH = 'libs/';
        // Dynamically generate the manifest location URL. It must be served from the document origin, and we may have
        // the base pointing to the CDN. This way we can generate a full URL which will bypass the base.
        document.querySelector('#manifest-placeholder').setAttribute('href', window.location.origin + contextRoot(window.location.pathname) + 'manifest.json');

        document.addEventListener('DOMContentLoaded', () => {
            if (!JitsiMeetJS.app) {
                return;
            }

            JitsiMeetJS.app.renderEntryPoint({
                Component: JitsiMeetJS.app.entryPoints.APP
            })

            const inIframe = () => {
                try {
                    return window.self !== window.top;
                } catch (e) {
                    return true;
                }
            };

            const isElectron = navigator.userAgent.includes('Electron');
            const shouldRegisterWorker = !isElectron && !inIframe() && 'serviceWorker' in navigator;

            if (shouldRegisterWorker) {
                navigator.serviceWorker
                    .register(window.location.origin + contextRoot(window.location.pathname) + 'pwa-worker.js')
                    .then(reg => {
                        console.log('Service worker registered.', reg);
                    })
                    .catch(err => {
                        console.log(err);
                    });
            }
        });
    </script>
    <script>
        // IE11 and earlier can be identified via their user agent and be
        // redirected to a page that is known to have no newer js syntax.
        if (window.navigator.userAgent.match(/(MSIE|Trident)/)) {
            var roomName = encodeURIComponent(window.location.pathname);
            window.location.pathname = 'static/recommendedBrowsers.html';
        }

        window.indexLoadedTime = window.performance.now();
        console.log("(TIME) index.html loaded:\t", indexLoadedTime);
        window.addEventListener('load', function() {
            window.loadedEventTime = window.performance.now();
            console.log("(TIME) window loaded event:\t", loadedEventTime);
        });

        // XXX the code below listeners for errors and displays an error message
        // in the document body when any of the required files fails to load.
        // The intention is to prevent from displaying broken page.
        var criticalFiles = [
            "config.js",
            "utils.js",
            "do_external_connect.js",
            "interface_config.js",
            "lib-jitsi-meet.min.js",
            "app.bundle.min.js",
            "all.css"
        ];
        var loadErrHandler = function(e) {
            var target = e.target;
            // Error on <script> and <link>(CSS)
            // <script> will have .src and <link> .href
            var fileRef = (target.src ? target.src : target.href);
            if (("SCRIPT" === target.tagName || "LINK" === target.tagName)
                && criticalFiles.some(
                    function(file) { return fileRef.indexOf(file) !== -1 })) {
                window.onload = function() {
                    // The whole complex part below implements page reloads with
                    // "exponential backoff". The retry attempt is passes as
                    // "rCounter" query parameter
                    var href = window.location.href;

                    var retryMatch = href.match(/.+(\?|&)rCounter=(\d+)/);
                    var retryCountStr = retryMatch ? retryMatch[2] : "0";
                    var retryCount = Number.parseInt(retryCountStr);

                    if (retryMatch == null) {
                        var separator = href.indexOf("?") === -1 ? "?" : "&";
                        var hashIdx = href.indexOf("#");

                        if (hashIdx === -1) {
                            href += separator + "rCounter=1";
                        } else {
                            var hashPart = href.substr(hashIdx);

                            href = href.substr(0, hashIdx)
                                + separator + "rCounter=1" + hashPart;
                        }
                    } else {
                        var separator = retryMatch[1];

                        href = href.replace(
                            /(\?|&)rCounter=(\d+)/,
                            separator + "rCounter=" + (retryCount + 1));
                    }

                    var delay = Math.pow(2, retryCount) * 2000;
                    if (isNaN(delay) || delay < 2000 || delay > 60000)
                        delay = 10000;

                    var showMoreText = "show more";
                    var showLessText = "show less";

                    document.body.innerHTML
                        = "<div style='"
                        + "position: absolute;top: 50%;left: 50%;"
                        + "text-align: center;"
                        + "font-size: medium;"
                        + "font-weight: 400;"
                        + "transform: translate(-50%, -50%)'>"
                        + "Uh oh! We couldn't fully download everything we needed :("
                        + "<br/> "
                        + "We will try again shortly. In the mean time, check for problems with your Internet connection!"
                        + "<br/><br/> "
                        + "<div id='moreInfo' style='"
                        + "display: none;'>" + "Missing " + fileRef
                        + "<br/><br/></div>"
                        + "<a id='showMore' style='"
                        + "text-decoration: underline;"
                        + "font-size:small;"
                        + "cursor: pointer'>" + showMoreText + "</a>"
                        + "&nbsp;&nbsp;&nbsp;"
                        + "<a id ='reloadLink' style='"
                        + "text-decoration: underline;"
                        + "font-size:small;"
                        + "'>reload now</a>"
                        + "</div>";

                    var reloadLink = document.getElementById('reloadLink');
                    reloadLink.setAttribute('href', href);

                    var showMoreElem = document.getElementById("showMore");
                    showMoreElem.addEventListener('click', function () {
                            var moreInfoElem
                                    = document.getElementById("moreInfo");

                            if (showMoreElem.innerHTML === showMoreText) {
                                moreInfoElem.setAttribute(
                                    "style",
                                    "display: block;"
                                    + "color:#FF991F;"
                                    + "font-size:small;"
                                    + "user-select:text;");
                                showMoreElem.innerHTML = showLessText;
                            }
                            else {
                                moreInfoElem.setAttribute(
                                    "style", "display: none;");
                                showMoreElem.innerHTML = showMoreText;
                            }
                        });

                    window.setTimeout(
                        function () { window.location.replace(href); }, delay);

                    // Call extra handler if defined.
                    if (typeof postLoadErrorHandler === "function") {
                        postLoadErrorHandler(fileRef);
                    }
                };
                window.removeEventListener(
                    'error', loadErrHandler, true /* capture phase */);
            }
        };
        window.addEventListener(
            'error', loadErrHandler, true /* capture phase type of listener */);
    </script>
    <script><!--#include virtual="/config.js" --></script><!-- adapt to your needs, i.e. set hosts and bosh path -->
    <script><!--#include virtual="/interface_config.js" --></script>
    <script src="libs/lib-jitsi-meet.min.js?v=139"></script>
    <script src="libs/app.bundle.min.js?v=139"></script>
    <!--#include virtual="title.html" -->
    <!--#include virtual="plugin.head.html" -->
    <!--#include virtual="static/welcomePageAdditionalContent.html" -->
    <!--#include virtual="static/welcomePageAdditionalCard.html" -->
    <!--#include virtual="static/settingsToolbarAdditionalContent.html" -->
  </head>
  <body>
    <noscript aria-hidden="true">
        <div>JavaScript is disabled. </br>For this site to work you have to enable JavaScript.</div>
    </noscript>
    <!--#include virtual="body.html" -->
    <div id="react" role="main"></div>
  </body>
</html>


################################################################################

## File: .\jitsi-meet\index.ios.js

import './react/index.native';



################################################################################

## File: .\jitsi-meet\inlang.config.js

/**
 * @type { import("@inlang/core/config").DefineConfig }
 */
export async function defineConfig(env) {
    const { default: i18nextPlugin } = await env.$import(
        'https://cdn.jsdelivr.net/npm/@inlang/plugin-i18next@2/dist/index.js'
    );

    const { default: standardLintRules } = await env.$import(
        'https://cdn.jsdelivr.net/npm/@inlang/plugin-standard-lint-rules@3/dist/index.js'
    );

    return {
        referenceLanguage: 'main',
        plugins: [
            i18nextPlugin({
                pathPattern: 'lang/{language}.json',
                ignore: [ 'languages.json', 'translation-languages.json' ]
            }),
            standardLintRules()
        ]
    };
}


################################################################################

## File: .\jitsi-meet\interface_config.js

/* eslint-disable no-unused-vars, no-var, max-len */
/* eslint sort-keys: ["error", "asc", {"caseSensitive": false}] */

/**
 * !!!IMPORTANT!!!
 *
 * This file is considered deprecated. All options will eventually be moved to
 * config.js, and no new options should be added here.
 */

var interfaceConfig = {
    APP_NAME: 'Jitsi Meet',
    AUDIO_LEVEL_PRIMARY_COLOR: 'rgba(255,255,255,0.4)',
    AUDIO_LEVEL_SECONDARY_COLOR: 'rgba(255,255,255,0.2)',

    /**
     * A UX mode where the last screen share participant is automatically
     * pinned. Valid values are the string "remote-only" so remote participants
     * get pinned but not local, otherwise any truthy value for all participants,
     * and any falsy value to disable the feature.
     *
     * Note: this mode is experimental and subject to breakage.
     */
    AUTO_PIN_LATEST_SCREEN_SHARE: 'remote-only',
    BRAND_WATERMARK_LINK: '',

    CLOSE_PAGE_GUEST_HINT: false, // A html text to be shown to guests on the close page, false disables it

    DEFAULT_BACKGROUND: '#040404',
    DEFAULT_WELCOME_PAGE_LOGO_URL: 'images/watermark.svg',

    DISABLE_DOMINANT_SPEAKER_INDICATOR: false,

    /**
     * If true, notifications regarding joining/leaving are no longer displayed.
     */
    DISABLE_JOIN_LEAVE_NOTIFICATIONS: false,

    /**
     * If true, presence status: busy, calling, connected etc. is not displayed.
     */
    DISABLE_PRESENCE_STATUS: false,

    /**
     * Whether the ringing sound in the call/ring overlay is disabled. If
     * {@code undefined}, defaults to {@code false}.
     *
     * @type {boolean}
     */
    DISABLE_RINGING: false,

    /**
     * Whether the speech to text transcription subtitles panel is disabled.
     * If {@code undefined}, defaults to {@code false}.
     *
     * @type {boolean}
     */
    DISABLE_TRANSCRIPTION_SUBTITLES: false,

    /**
     * Whether or not the blurred video background for large video should be
     * displayed on browsers that can support it.
     */
    DISABLE_VIDEO_BACKGROUND: false,

    DISPLAY_WELCOME_FOOTER: true,
    DISPLAY_WELCOME_PAGE_ADDITIONAL_CARD: false,
    DISPLAY_WELCOME_PAGE_CONTENT: false,
    DISPLAY_WELCOME_PAGE_TOOLBAR_ADDITIONAL_CONTENT: false,

    ENABLE_DIAL_OUT: true,

    // DEPRECATED. Animation no longer supported.
    // ENABLE_FEEDBACK_ANIMATION: false,

    FILM_STRIP_MAX_HEIGHT: 120,

    GENERATE_ROOMNAMES_ON_WELCOME_PAGE: true,

    /**
     * Hide the invite prompt in the header when alone in the meeting.
     */
    HIDE_INVITE_MORE_HEADER: false,

    JITSI_WATERMARK_LINK: 'https://jitsi.org',

    LANG_DETECTION: true, // Allow i18n to detect the system language
    LOCAL_THUMBNAIL_RATIO: 16 / 9, // 16:9

    /**
     * Maximum coefficient of the ratio of the large video to the visible area
     * after the large video is scaled to fit the window.
     *
     * @type {number}
     */
    MAXIMUM_ZOOMING_COEFFICIENT: 1.3,

    /**
     * Whether the mobile app Jitsi Meet is to be promoted to participants
     * attempting to join a conference in a mobile Web browser. If
     * {@code undefined}, defaults to {@code true}.
     *
     * @type {boolean}
     */
    MOBILE_APP_PROMO: true,

    // Names of browsers which should show a warning stating the current browser
    // has a suboptimal experience. Browsers which are not listed as optimal or
    // unsupported are considered suboptimal. Valid values are:
    // chrome, chromium, electron, firefox , safari, webkit
    OPTIMAL_BROWSERS: [ 'chrome', 'chromium', 'firefox', 'electron', 'safari', 'webkit' ],

    POLICY_LOGO: null,
    PROVIDER_NAME: 'Jitsi',

    /**
     * If true, will display recent list
     *
     * @type {boolean}
     */
    RECENT_LIST_ENABLED: true,
    REMOTE_THUMBNAIL_RATIO: 1, // 1:1

    SETTINGS_SECTIONS: [ 'devices', 'language', 'moderator', 'profile', 'calendar', 'sounds', 'more' ],

    /**
     * Specify which sharing features should be displayed. If the value is not set
     * all sharing features will be shown. You can set [] to disable all.
     */
    // SHARING_FEATURES: ['email', 'url', 'dial-in', 'embed'],

    SHOW_BRAND_WATERMARK: false,

    /**
     * Decides whether the chrome extension banner should be rendered on the landing page and during the meeting.
     * If this is set to false, the banner will not be rendered at all. If set to true, the check for extension(s)
     * being already installed is done before rendering.
     */
    SHOW_CHROME_EXTENSION_BANNER: false,

    SHOW_JITSI_WATERMARK: true,
    SHOW_POWERED_BY: false,
    SHOW_PROMOTIONAL_CLOSE_PAGE: false,

    /*
     * If indicated some of the error dialogs may point to the support URL for
     * help.
     */
    SUPPORT_URL: 'https://community.jitsi.org/',

    // Browsers, in addition to those which do not fully support WebRTC, that
    // are not supported and should show the unsupported browser page.
    UNSUPPORTED_BROWSERS: [],

    /**
     * Whether to show thumbnails in filmstrip as a column instead of as a row.
     */
    VERTICAL_FILMSTRIP: true,

    // Determines how the video would fit the screen. 'both' would fit the whole
    // screen, 'height' would fit the original video height to the height of the
    // screen, 'width' would fit the original video width to the width of the
    // screen respecting ratio, 'nocrop' would make the video as large as
    // possible and preserve aspect ratio without cropping.
    VIDEO_LAYOUT_FIT: 'both',

    /**
     * If true, hides the video quality label indicating the resolution status
     * of the current large video.
     *
     * @type {boolean}
     */
    VIDEO_QUALITY_LABEL_DISABLED: false,

    /**
     * How many columns the tile view can expand to. The respected range is
     * between 1 and 5.
     */
    // TILE_VIEW_MAX_COLUMNS: 5,

    // List of undocumented settings
    /**
     INDICATOR_FONT_SIZES
     PHONE_NUMBER_REGEX
    */

    // -----------------DEPRECATED CONFIGS BELOW THIS LINE-----------------------------

    /**
     * Specify URL for downloading ios mobile app.
     */
    // MOBILE_DOWNLOAD_LINK_IOS: 'https://itunes.apple.com/us/app/jitsi-meet/id1165103905',

    /**
     * Specify custom URL for downloading android mobile app.
     */
    // MOBILE_DOWNLOAD_LINK_ANDROID: 'https://play.google.com/store/apps/details?id=org.jitsi.meet',

    /**
     * Specify mobile app scheme for opening the app from the mobile browser.
     */
    // APP_SCHEME: 'org.jitsi.meet',

    // NATIVE_APP_NAME: 'Jitsi Meet',

    /**
     * Specify Firebase dynamic link properties for the mobile apps.
     */
    // MOBILE_DYNAMIC_LINK: {
    //    APN: 'org.jitsi.meet',
    //    APP_CODE: 'w2atb',
    //    CUSTOM_DOMAIN: undefined,
    //    IBI: 'com.atlassian.JitsiMeet.ios',
    //    ISI: '1165103905'
    // },

    /**
     * Hide the logo on the deep linking pages.
     */
    // HIDE_DEEP_LINKING_LOGO: false,

    /**
     * Specify the Android app package name.
     */
    // ANDROID_APP_PACKAGE: 'org.jitsi.meet',

    /**
     * Specify custom URL for downloading f droid app.
     */
    // MOBILE_DOWNLOAD_LINK_F_DROID: 'https://f-droid.org/en/packages/org.jitsi.meet/',

    // Connection indicators (
    // CONNECTION_INDICATOR_AUTO_HIDE_ENABLED,
    // CONNECTION_INDICATOR_AUTO_HIDE_TIMEOUT,
    // CONNECTION_INDICATOR_DISABLED) got moved to config.js.

    // Please use disableModeratorIndicator from config.js
    // DISABLE_FOCUS_INDICATOR: false,

    // Please use defaultLocalDisplayName from config.js
    // DEFAULT_LOCAL_DISPLAY_NAME: 'me',

    // Please use defaultLogoUrl from config.js
    // DEFAULT_LOGO_URL: 'images/watermark.svg',

    // Please use defaultRemoteDisplayName from config.js
    // DEFAULT_REMOTE_DISPLAY_NAME: 'Fellow Jitster',

    // Moved to config.js as `toolbarConfig.initialTimeout`.
    // INITIAL_TOOLBAR_TIMEOUT: 20000,

    // Please use `liveStreaming.helpLink` from config.js
    // Documentation reference for the live streaming feature.
    // LIVE_STREAMING_HELP_LINK: 'https://jitsi.org/live',

    // Moved to config.js as `toolbarConfig.alwaysVisible`.
    // TOOLBAR_ALWAYS_VISIBLE: false,

    // This config was moved to config.js as `toolbarButtons`.
    // TOOLBAR_BUTTONS: [],

    // Moved to config.js as `toolbarConfig.timeout`.
    // TOOLBAR_TIMEOUT: 4000,

    // Allow all above example options to include a trailing comma and
    // prevent fear when commenting out the last value.
    // eslint-disable-next-line sort-keys
    makeJsonParserHappy: 'even if last key had a trailing comma'

    // No configuration value should follow this line.
};

/* eslint-enable no-unused-vars, no-var, max-len */


################################################################################

## File: .\jitsi-meet\metro.config.js

/* eslint-disable */

const { getDefaultConfig, mergeConfig } = require('@react-native/metro-config');

/**
 * Metro configuration
 * https://reactnative.dev/docs/metro
 *
 * @type {import('metro-config').MetroConfig}
 */

const {
    resolver: {
        sourceExts,
        assetExts
    }
} = getDefaultConfig();

const config = {
    transformer: {
        babelTransformerPath: require.resolve('react-native-svg-transformer')
    },
    resolver: {
        assetExts: assetExts.filter(ext => ext !== 'svg'),
        sourceExts: [ ...sourceExts, 'svg' ]
    }
};

module.exports = mergeConfig(getDefaultConfig(__dirname), config);


################################################################################

## File: .\jitsi-meet\plugin.head.html



################################################################################

## File: .\jitsi-meet\pwa-worker.js

/*
Copyright 2015, 2019, 2020 Google LLC. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at
 http://www.apache.org/licenses/LICENSE-2.0
 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

const CACHE_NAME = 'offline';

// Customize this with a different URL if needed.
const OFFLINE_URL = 'static/offline.html';

self.addEventListener('install', event => {
    event.waitUntil(
    (async () => {
        const cache = await caches.open(CACHE_NAME);


        // Setting {cache: 'reload'} in the new request will ensure that the
        // response isn't fulfilled from the HTTP cache; i.e., it will be from
        // the network.
        await cache.add(new Request(OFFLINE_URL, { cache: 'reload' }));
    })()
    );

    // Force the waiting service worker to become the active service worker.
    self.skipWaiting();
});

self.addEventListener('activate', event => {
    event.waitUntil(
    (async () => {
        // Enable navigation preload if it's supported.
        // See https://developers.google.com/web/updates/2017/02/navigation-preload
        if ('navigationPreload' in self.registration) {
            await self.registration.navigationPreload.enable();
        }
    })()
    );

    // Tell the active service worker to take control of the page immediately.
    self.clients.claim();
});

self.addEventListener('fetch', event => {
    // We only want to call event.respondWith() if this is a navigation request
    // for an HTML page.
    if (event.request.mode === 'navigate') {
        event.respondWith((async () => {
            try {
                // First, try to use the navigation preload response if it's supported.
                const preloadResponse = await event.preloadResponse;

                if (preloadResponse) {
                    return preloadResponse;
                }

                // Always try the network first.
                const networkResponse = await fetch(event.request);

                return networkResponse;
            } catch (error) {
                // catch is only triggered if an exception is thrown, which is likely
                // due to a network error.
                // If fetch() returns a valid HTTP response with a response code in
                // the 4xx or 5xx range, the catch() will NOT be called.
                console.log('Fetch failed; returning offline page instead.', error);

                const cache = await caches.open(CACHE_NAME);
                const cachedResponse = await cache.match(OFFLINE_URL);

                return cachedResponse;
            }
        })());
    }

    // If our if() condition is false, then this fetch handler won't intercept the
    // request. If there are any other fetch handlers registered, they will get a
    // chance to call event.respondWith(). If no fetch handlers call
    // event.respondWith(), the request will be handled by the browser as if there
    // were no service worker involvement.
});


################################################################################

## File: .\jitsi-meet\react-native.config.js

/**
 * This is needed because the RN cli incorrectly detects the iOS app path as
 * jitsi-meet/ios/app and thus all pod references in the now dynamically generated
 * Podfile are wrong.
 */
module.exports = {
    // Exclude some dependencies from auto-linking for the lite SDK.
    dependencies: {
        '@giphy/react-native-sdk': {
            platforms: {
                ios: null
            }
        },
        '@react-native-google-signin/google-signin': {
            platforms: {
                ios: null
            }
        },
        'react-native-calendar-events': {
            platforms: {
                ios: null
            }
        },
        'react-native-watch-connectivity': {
            platforms: {
                ios: null
            }
        }
    }
};


################################################################################

## File: .\jitsi-meet\title.html

<title>Jitsi Meet</title>
<meta property="og:title" content="Jitsi Meet"/>
<meta property="og:image" content="images/jitsilogo.png?v=1"/>
<meta property="og:description" content="Join a WebRTC video conference powered by the Jitsi Videobridge"/>
<meta description="Join a WebRTC video conference powered by the Jitsi Videobridge"/>
<meta itemprop="name" content="Jitsi Meet"/>
<meta itemprop="description" content="Join a WebRTC video conference powered by the Jitsi Videobridge"/>
<meta itemprop="image" content="images/jitsilogo.png?v=1"/>
<link rel="icon" href="images/favicon.svg?v=1">

################################################################################

## File: .\jitsi-meet\webpack.config.js

/* global __dirname */

const CircularDependencyPlugin = require('circular-dependency-plugin');
const fs = require('fs');
const { join, resolve } = require('path');
const process = require('process');
const webpack = require('webpack');
const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');

/**
 * The URL of the Jitsi Meet deployment to be proxy to in the context of
 * development with webpack-dev-server.
 */
const devServerProxyTarget
    = process.env.WEBPACK_DEV_SERVER_PROXY_TARGET || 'https://alpha.jitsi.net';

/**
 * Build a Performance configuration object for the given size.
 * See: https://webpack.js.org/configuration/performance/
 *
 * @param {Object} options - options for the bundles configuration.
 * @param {boolean} options.analyzeBundle - whether the bundle needs to be analyzed for size.
 * @param {boolean} options.isProduction - whether this is a production build or not.
 * @param {number} size - the size limit to apply.
 * @returns {Object} a performance hints object.
 */
function getPerformanceHints(options, size) {
    const { analyzeBundle, isProduction } = options;

    return {
        hints: isProduction && !analyzeBundle ? 'error' : false,
        maxAssetSize: size,
        maxEntrypointSize: size
    };
}

/**
 * Build a BundleAnalyzerPlugin plugin instance for the given bundle name.
 *
 * @param {boolean} analyzeBundle - whether the bundle needs to be analyzed for size.
 * @param {string} name - the name of the bundle.
 * @returns {Array} a configured list of plugins.
 */
function getBundleAnalyzerPlugin(analyzeBundle, name) {
    if (!analyzeBundle) {
        return [];
    }

    return [ new BundleAnalyzerPlugin({
        analyzerMode: 'disabled',
        generateStatsFile: true,
        statsFilename: `${name}-stats.json`
    }) ];
}

/**
 * Determines whether a specific (HTTP) request is to bypass the proxy of
 * webpack-dev-server (i.e. is to be handled by the proxy target) and, if not,
 * which local file is to be served in response to the request.
 *
 * @param {Object} request - The (HTTP) request received by the proxy.
 * @returns {string|undefined} If the request is to be served by the proxy
 * target, undefined; otherwise, the path to the local file to be served.
 */
function devServerProxyBypass({ path }) {
    if (path.startsWith('/css/')
            || path.startsWith('/doc/')
            || path.startsWith('/fonts/')
            || path.startsWith('/images/')
            || path.startsWith('/lang/')
            || path.startsWith('/sounds/')
            || path.startsWith('/static/')
            || path.endsWith('.wasm')) {

        return path;
    }

    if (path.startsWith('/libs/')) {
        if (path.endsWith('.min.js') && !fs.existsSync(join(process.cwd(), path))) {
            return path.replace('.min.js', '.js');
        }

        return path;
    }
}

/**
 * The base Webpack configuration to bundle the JavaScript artifacts of
 * jitsi-meet such as app.bundle.js and external_api.js.
 *
 * @param {Object} options - options for the bundles configuration.
 * @param {boolean} options.detectCircularDeps - whether to detect circular dependencies or not.
 * @param {boolean} options.isProduction - whether this is a production build or not.
 * @returns {Object} the base config object.
 */
function getConfig(options = {}) {
    const { detectCircularDeps, isProduction } = options;

    return {
        devtool: isProduction ? 'source-map' : 'eval-source-map',
        mode: isProduction ? 'production' : 'development',
        module: {
            rules: [ {
                // Transpile ES2015 (aka ES6) to ES5. Accept the JSX syntax by React
                // as well.

                loader: 'babel-loader',
                options: {
                    // Avoid loading babel.config.js, since we only use it for React Native.
                    configFile: false,

                    // XXX The require.resolve below solves failures to locate the
                    // presets when lib-jitsi-meet, for example, is npm linked in
                    // jitsi-meet.
                    plugins: [
                        require.resolve('@babel/plugin-proposal-export-default-from')
                    ],
                    presets: [
                        [
                            require.resolve('@babel/preset-env'),

                            // Tell babel to avoid compiling imports into CommonJS
                            // so that webpack may do tree shaking.
                            {
                                modules: false,

                                // Specify our target browsers so no transpiling is
                                // done unnecessarily. For browsers not specified
                                // here, the ES2015+ profile will be used.
                                targets: {
                                    chrome: 80,
                                    electron: 10,
                                    firefox: 68,
                                    safari: 14
                                }

                            }
                        ],
                        require.resolve('@babel/preset-react')
                    ]
                },
                test: /\.jsx?$/
            }, {
                // Allow CSS to be imported into JavaScript.

                test: /\.css$/,
                use: [
                    'style-loader',
                    'css-loader'
                ]
            }, {
                test: /\.svg$/,
                use: [ {
                    loader: '@svgr/webpack',
                    options: {
                        dimensions: false,
                        expandProps: 'start'
                    }
                } ]
            }, {
                test: /\.tsx?$/,
                exclude: /node_modules/,
                loader: 'ts-loader',
                options: {
                    configFile: 'tsconfig.web.json',
                    transpileOnly: !isProduction // Skip type checking for dev builds.,
                }
            } ]
        },
        node: {
            // Allow the use of the real filename of the module being executed. By
            // default Webpack does not leak path-related information and provides a
            // value that is a mock (/index.js).
            __filename: true
        },
        optimization: {
            concatenateModules: isProduction,
            minimize: isProduction
        },
        output: {
            filename: `[name]${isProduction ? '.min' : ''}.js`,
            path: `${__dirname}/build`,
            publicPath: '/libs/',
            sourceMapFilename: '[file].map'
        },
        plugins: [
            detectCircularDeps
                && new CircularDependencyPlugin({
                    allowAsyncCycles: false,
                    exclude: /node_modules/,
                    failOnError: false
                })
        ].filter(Boolean),
        resolve: {
            alias: {
                'focus-visible': 'focus-visible/dist/focus-visible.min.js'
            },
            aliasFields: [
                'browser'
            ],
            extensions: [
                '.web.js',
                '.web.ts',
                '.web.tsx',

                // Typescript:
                '.tsx',
                '.ts',

                // Webpack defaults:
                '.js',
                '.json'
            ],
            fallback: {
                // Provide some empty Node modules (required by AtlasKit, olm).
                crypto: false,
                fs: false,
                path: false,
                process: false
            }
        }
    };
}

/**
 * Helper function to build the dev server config. It's necessary to split it in
 * Webpack 5 because only one devServer entry is supported, so we attach it to
 * the main bundle.
 *

 * @returns {Object} the dev server configuration.
 */
function getDevServerConfig() {
    return {
        client: {
            overlay: {
                errors: true,
                warnings: false
            }
        },
        host: '127.0.0.1',
        hot: true,
        proxy: {
            '/': {
                bypass: devServerProxyBypass,
                secure: false,
                target: devServerProxyTarget,
                headers: {
                    'Host': new URL(devServerProxyTarget).host
                }
            }
        },
        server: process.env.CODESPACES ? 'http' : 'https',
        static: {
            directory: process.cwd()
        }
    };
}

module.exports = (_env, argv) => {
    const analyzeBundle = Boolean(process.env.ANALYZE_BUNDLE);
    const mode = typeof argv.mode === 'undefined' ? 'production' : argv.mode;
    const isProduction = mode === 'production';
    const configOptions = {
        detectCircularDeps: Boolean(process.env.DETECT_CIRCULAR_DEPS),
        isProduction
    };
    const config = getConfig(configOptions);
    const perfHintOptions = {
        analyzeBundle,
        isProduction
    };

    return [
        Object.assign({}, config, {
            entry: {
                'app.bundle': './app.js'
            },
            devServer: isProduction ? {} : getDevServerConfig(),
            plugins: [
                ...config.plugins,
                ...getBundleAnalyzerPlugin(analyzeBundle, 'app'),
                new webpack.IgnorePlugin({
                    resourceRegExp: /^canvas$/,
                    contextRegExp: /resemblejs$/
                }),
                new webpack.IgnorePlugin({
                    resourceRegExp: /^\.\/locale$/,
                    contextRegExp: /moment$/
                }),
                new webpack.ProvidePlugin({
                    process: 'process/browser'
                })
            ],

            performance: getPerformanceHints(perfHintOptions, 5 * 1024 * 1024)

        }),
        Object.assign({}, config, {
            entry: {
                'alwaysontop': './react/features/always-on-top/index.tsx'
            },
            plugins: [
                ...config.plugins,
                ...getBundleAnalyzerPlugin(analyzeBundle, 'alwaysontop')
            ],
            performance: getPerformanceHints(perfHintOptions, 800 * 1024)
        }),
        Object.assign({}, config, {
            entry: {
                'analytics-ga': './react/features/analytics/handlers/GoogleAnalyticsHandler.ts'
            },
            plugins: [
                ...config.plugins,
                ...getBundleAnalyzerPlugin(analyzeBundle, 'analytics-ga')
            ],
            performance: getPerformanceHints(perfHintOptions, 5 * 1024)
        }),
        Object.assign({}, config, {
            entry: {
                'close3': './static/close3.js'
            },
            plugins: [
                ...config.plugins,
                ...getBundleAnalyzerPlugin(analyzeBundle, 'close3')
            ],
            performance: getPerformanceHints(perfHintOptions, 128 * 1024)
        }),

        Object.assign({}, config, {
            entry: {
                'external_api': './modules/API/external/index.js'
            },
            output: Object.assign({}, config.output, {
                library: 'JitsiMeetExternalAPI',
                libraryTarget: 'umd'
            }),
            plugins: [
                ...config.plugins,
                ...getBundleAnalyzerPlugin(analyzeBundle, 'external_api')
            ],
            performance: getPerformanceHints(perfHintOptions, 40 * 1024)
        }),
        Object.assign({}, config, {
            entry: {
                'face-landmarks-worker': './react/features/face-landmarks/faceLandmarksWorker.ts'
            },
            plugins: [
                ...config.plugins,
                ...getBundleAnalyzerPlugin(analyzeBundle, 'face-landmarks-worker')
            ],
            performance: getPerformanceHints(perfHintOptions, 1024 * 1024 * 2)
        }),
        Object.assign({}, config, {
            /**
             * The NoiseSuppressorWorklet is loaded in an audio worklet which doesn't have the same
             * context as a normal window, (e.g. self/window is not defined).
             * While running a production build webpack's boilerplate code doesn't introduce any
             * audio worklet "unfriendly" code however when running the dev server, hot module replacement
             * and live reload add javascript code that can't be ran by the worklet, so we explicitly ignore
             * those parts with the null-loader.
             * The dev server also expects a `self` global object that's not available in the `AudioWorkletGlobalScope`,
             * so we replace it.
             */
            entry: {
                'noise-suppressor-worklet':
                    './react/features/stream-effects/noise-suppression/NoiseSuppressorWorklet.ts'
            },

            module: { rules: [
                ...config.module.rules,
                {
                    test: resolve(__dirname, 'node_modules/webpack-dev-server/client'),
                    loader: 'null-loader'
                }
            ] },
            plugins: [
            ],
            performance: getPerformanceHints(perfHintOptions, 200 * 1024),

            output: {
                ...config.output,

                globalObject: 'AudioWorkletGlobalScope'
            }
        }),

        Object.assign({}, config, {
            entry: {
                'screenshot-capture-worker': './react/features/screenshot-capture/worker.ts'
            },
            plugins: [
                ...config.plugins,
                ...getBundleAnalyzerPlugin(analyzeBundle, 'screenshot-capture-worker')
            ],
            performance: getPerformanceHints(perfHintOptions, 4 * 1024)
        })
    ];
};


################################################################################

## File: .\jitsi-meet\doc\examples\api.html

<html itemscope itemtype="http://schema.org/Product" prefix="og: http://ogp.me/ns#" xmlns="http://www.w3.org/1999/html">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="content-type" content="text/html;charset=utf-8">
    </head>
    <body>
        <script src="https://meet.jit.si/external_api.js"></script>
        <script>
            var domain = "meet.jit.si";
            var options = {
                roomName: "JitsiMeetAPIExample",
                width: 700,
                height: 180,
                parentNode: undefined,
                configOverwrite: {},
                interfaceConfigOverwrite: {}
            }
            var api = new JitsiMeetExternalAPI(domain, options);
        </script>
    </body>
</html>


################################################################################

## File: .\jitsi-meet\doc\jaas\8x8.vc-config.js

</script>
<script src="https://8x8.vc/<!--# echo var="subdir" default="" -->config.js" onload="{
config.p2p.disabledCodec='VP9';
config.videoQuality.disabledCodec='VP9';
config.e2ee = { externallyManagedKey: true };
}"/>
<script>


################################################################################

## File: .\jitsi-meet\doc\jaas\index-jaas.html

<!DOCTYPE html>
<html>
    <head>
        <script src='external_api.js' async></script>
        <style>html, body, #jaas-container { height: 100%; }</style>
        <script type="text/javascript">
            function getRoomName(pathname) {
                const contextRootEndIndex = pathname.lastIndexOf('/');

                return pathname.substring(contextRootEndIndex + 1);
            }
            window.onload = () => {
                const jaasJwt = <!--#include virtual="/jaas-jwt" -->;
                const api = new JitsiMeetExternalAPI(
                    window.location.host, {
                        roomName: `${jaasJwt.tenant}/${jaasJwt.confId}`,
                        parentNode: document.querySelector('#jaas-container'),
                        jwt: jaasJwt.token,
                        e2eeKey: jaasJwt.e2eeKey
                    });
                api.addListener('videoConferenceJoined', () => {
                    if (jaasJwt.e2eeKey) {
                        console.info('Toggling e2ee on!')
                        api.executeCommand('toggleE2EE', true);
                    }
                });
            }
        </script>
    </head>
    <body>
        <div id="jaas-container" />
    </body>
</html>


################################################################################

## File: .\jitsi-meet\lang\update-translation.js

/* eslint-disable */

const fs = require('fs');
const process = require('process');
const traverse = require('traverse');
const mainLang = require('./main.json');

const [ targetLangFile ] = process.argv.slice(-1);

if (!targetLangFile) {
    console.log('No target language file specified');
    process.exit(1);
}

const targetLang = require(`./${targetLangFile}`);

const paths = traverse(mainLang).reduce(function(acc, item) {
    if (this.isLeaf) {
        acc.push(this.path);
    }

    return acc;
}, []);

const result = {};

for (const path of paths) {
    if (traverse(targetLang).has(path)) {
        traverse(result).set(path, traverse(targetLang).get(path));
    } else {
        //console.log(`${path.join('.')} is missing`);
        traverse(result).set(path, '');
    }
}

const data = JSON.stringify(result, undefined, 4);

fs.writeFileSync(`./${targetLangFile}`, data);


################################################################################

## File: .\jitsi-meet\metadata\en-US\full_description.txt

Jitsi Meet lets you stay in touch with all your teams, be they family, friends, or colleagues. Instant video conferences, efficiently adapting to your scale.

* Unlimited users: There are no artificial restrictions on the number of users or conference participants. Server power and bandwidth are the only limiting factors.
* No account needed.
* Lock-protected rooms: Control the access to your conferences with a password.
* Encrypted by default.
* High quality: Audio and video are delivered with the clarity and richness of Opus and VP8.
* Web browser ready: No downloads are required of your friends to join the conversation. Jitsi Meet works directly within their browsers as well. Simply share your conference URL with others to get started.
* 100% open source: Powered by awesome communities from all over the world. And your friends at 8x8.
* Invite by pretty URLs: You can meet at the easy to remember https://MySite.com/OurConf of your choice instead of joining the hard to remember rooms with seemingly random sequences of numbers and letters in their names.

################################################################################

## File: .\jitsi-meet\metadata\en-US\short_description.txt

Secure, Simple and Scalable Video Conferences with state-of-the-art video quality

################################################################################

## File: .\jitsi-meet\metadata\ru\full_description.txt

Jitsi Meet позволяет вам оставаться на связи со всеми вашими командами, будь то семья, друзья или коллеги. Мгновенные видеоконференции, эффективно адаптируемые к вашим нуждам.

* Неограниченные пользователи: нет искусственных ограничений на количество пользователей или участников конференции. Мощность сервера и пропускная способность являются единственными ограничивающими факторами.
* Учетная запись не требуется.
* Закрытые комнаты: управляйте доступом к вашим конференциям с помощью пароля.
* Зашифровано по умолчанию.
* Высокое качество: аудио и видео доставляются с чёткостью и возможностями кодеков Opus и VP8.
* Работает в веб браузере: вашим друзьям не требуются загрузка чтобы присоединиться к разговору. Jitsi Meet работает непосредственно в их браузерах. Чтобы начать просто поделитесь своей ссылкой на конференцию с другими.
* 100% открытый исходный код: поддерживается удивительными сообществами со всего мира. И вашими друзьями из 8x8.
* Приглашение по красивому адресу ссылки: вы можете встретиться с легко запоминаемым https://MySite.com/OurConf по своему выбору вместо случайных цифр.

################################################################################

## File: .\jitsi-meet\metadata\ru\short_description.txt

Защищённые, простые и масштабируемые видеоконференции с качественным видео

################################################################################

## File: .\jitsi-meet\modules\API\.eslintrc.js

module.exports = {
    'extends': '../../react/.eslintrc.js'
};


################################################################################

## File: .\jitsi-meet\modules\API\API.js

/* global APP */
import Logger from '@jitsi/logger';

import { createApiEvent } from '../../react/features/analytics/AnalyticsEvents';
import { sendAnalytics } from '../../react/features/analytics/functions';
import {
    approveParticipantAudio,
    approveParticipantVideo,
    rejectParticipantAudio,
    rejectParticipantVideo,
    requestDisableAudioModeration,
    requestDisableVideoModeration,
    requestEnableAudioModeration,
    requestEnableVideoModeration
} from '../../react/features/av-moderation/actions';
import { isEnabledFromState } from '../../react/features/av-moderation/functions';
import {
    endConference,
    sendTones,
    setAssumedBandwidthBps,
    setFollowMe,
    setFollowMeRecorder,
    setLocalSubject,
    setPassword,
    setSubject
} from '../../react/features/base/conference/actions';
import { getCurrentConference, isP2pActive } from '../../react/features/base/conference/functions';
import { overwriteConfig } from '../../react/features/base/config/actions';
import { getWhitelistedJSON } from '../../react/features/base/config/functions.any';
import { toggleDialog } from '../../react/features/base/dialog/actions';
import { isSupportedBrowser } from '../../react/features/base/environment/environment';
import { parseJWTFromURLParams } from '../../react/features/base/jwt/functions';
import JitsiMeetJS, { JitsiRecordingConstants } from '../../react/features/base/lib-jitsi-meet';
import { MEDIA_TYPE, VIDEO_TYPE } from '../../react/features/base/media/constants';
import { isVideoMutedByUser } from '../../react/features/base/media/functions';
import {
    grantModerator,
    kickParticipant,
    overwriteParticipantsNames,
    pinParticipant,
    raiseHand
} from '../../react/features/base/participants/actions';
import { LOCAL_PARTICIPANT_DEFAULT_ID } from '../../react/features/base/participants/constants';
import {
    getLocalParticipant,
    getNormalizedDisplayName,
    getParticipantById,
    getScreenshareParticipantIds,
    getVirtualScreenshareParticipantByOwnerId,
    hasRaisedHand,
    isLocalParticipantModerator,
    isParticipantModerator
} from '../../react/features/base/participants/functions';
import { updateSettings } from '../../react/features/base/settings/actions';
import { getDisplayName } from '../../react/features/base/settings/functions.web';
import { setCameraFacingMode } from '../../react/features/base/tracks/actions.web';
import { CAMERA_FACING_MODE_MESSAGE } from '../../react/features/base/tracks/constants';
import {
    getLocalVideoTrack,
    isLocalTrackMuted
} from '../../react/features/base/tracks/functions';
import {
    autoAssignToBreakoutRooms,
    closeBreakoutRoom,
    createBreakoutRoom,
    moveToRoom,
    removeBreakoutRoom,
    sendParticipantToRoom
} from '../../react/features/breakout-rooms/actions';
import { getBreakoutRooms, getRoomsInfo } from '../../react/features/breakout-rooms/functions';
import {
    sendMessage,
    setPrivateMessageRecipient,
    toggleChat
} from '../../react/features/chat/actions';
import { openChat } from '../../react/features/chat/actions.web';
import {
    processExternalDeviceRequest
} from '../../react/features/device-selection/functions';
import { appendSuffix } from '../../react/features/display-name/functions';
import { isEnabled as isDropboxEnabled } from '../../react/features/dropbox/functions';
import { setMediaEncryptionKey, toggleE2EE } from '../../react/features/e2ee/actions';
import {
    addStageParticipant,
    resizeFilmStrip,
    setFilmstripVisible,
    setVolume,
    togglePinStageParticipant
} from '../../react/features/filmstrip/actions.web';
import { getPinnedActiveParticipants, isStageFilmstripAvailable } from '../../react/features/filmstrip/functions.web';
import { invite } from '../../react/features/invite/actions.any';
import {
    selectParticipantInLargeVideo
} from '../../react/features/large-video/actions.any';
import {
    captureLargeVideoScreenshot,
    resizeLargeVideo
} from '../../react/features/large-video/actions.web';
import { answerKnockingParticipant, toggleLobbyMode } from '../../react/features/lobby/actions';
import { setNoiseSuppressionEnabled } from '../../react/features/noise-suppression/actions';
import { hideNotification, showNotification } from '../../react/features/notifications/actions';
import { NOTIFICATION_TIMEOUT_TYPE, NOTIFICATION_TYPE } from '../../react/features/notifications/constants';
import {
    close as closeParticipantsPane,
    open as openParticipantsPane
} from '../../react/features/participants-pane/actions';
import { getParticipantsPaneOpen, isForceMuted } from '../../react/features/participants-pane/functions';
import { startLocalVideoRecording, stopLocalVideoRecording } from '../../react/features/recording/actions.any';
import { RECORDING_METADATA_ID, RECORDING_TYPES } from '../../react/features/recording/constants';
import { getActiveSession, supportsLocalRecording } from '../../react/features/recording/functions';
import { startAudioScreenShareFlow, startScreenShareFlow } from '../../react/features/screen-share/actions';
import { isScreenAudioSupported } from '../../react/features/screen-share/functions';
import { toggleScreenshotCaptureSummary } from '../../react/features/screenshot-capture/actions';
import { isScreenshotCaptureEnabled } from '../../react/features/screenshot-capture/functions';
import SettingsDialog from '../../react/features/settings/components/web/SettingsDialog';
import { SETTINGS_TABS } from '../../react/features/settings/constants';
import { playSharedVideo, stopSharedVideo } from '../../react/features/shared-video/actions.any';
import { extractYoutubeIdOrURL } from '../../react/features/shared-video/functions';
import { setRequestingSubtitles, toggleRequestingSubtitles } from '../../react/features/subtitles/actions';
import { isAudioMuteButtonDisabled } from '../../react/features/toolbox/functions';
import { setTileView, toggleTileView } from '../../react/features/video-layout/actions.any';
import { muteAllParticipants } from '../../react/features/video-menu/actions';
import { setVideoQuality } from '../../react/features/video-quality/actions';
import { toggleBlurredBackgroundEffect } from '../../react/features/virtual-background/actions';
import { toggleWhiteboard } from '../../react/features/whiteboard/actions.web';
import { getJitsiMeetTransport } from '../transport';

import {
    API_ID,
    ENDPOINT_TEXT_MESSAGE_NAME
} from './constants';

const logger = Logger.getLogger(__filename);

/**
 * List of the available commands.
 */
let commands = {};

/**
 * The transport instance used for communication with external apps.
 *
 * @type {Transport}
 */
const transport = getJitsiMeetTransport();

/**
 * The current audio availability.
 *
 * @type {boolean}
 */
let audioAvailable = true;

/**
 * The current video availability.
 *
 * @type {boolean}
 */
let videoAvailable = true;

/**
 * Initializes supported commands.
 *
 * @returns {void}
 */
function initCommands() {
    commands = {
        'add-breakout-room': name => {
            if (!isLocalParticipantModerator(APP.store.getState())) {
                logger.error('Missing moderator rights to add breakout rooms');

                return;
            }
            APP.store.dispatch(createBreakoutRoom(name));
        },
        'answer-knocking-participant': (id, approved) => {
            APP.store.dispatch(answerKnockingParticipant(id, approved));
        },
        'approve-video': participantId => {
            if (!isLocalParticipantModerator(APP.store.getState())) {
                return;
            }

            APP.store.dispatch(approveParticipantVideo(participantId));
        },
        'ask-to-unmute': participantId => {
            if (!isLocalParticipantModerator(APP.store.getState())) {
                return;
            }

            APP.store.dispatch(approveParticipantAudio(participantId));
        },
        'auto-assign-to-breakout-rooms': () => {
            if (!isLocalParticipantModerator(APP.store.getState())) {
                logger.error('Missing moderator rights to auto-assign participants to breakout rooms');

                return;
            }
            APP.store.dispatch(autoAssignToBreakoutRooms());
        },
        'grant-moderator': participantId => {
            if (!isLocalParticipantModerator(APP.store.getState())) {
                logger.error('Missing moderator rights to grant moderator right to another participant');

                return;
            }
            APP.store.dispatch(grantModerator(participantId));
        },
        'display-name': displayName => {
            sendAnalytics(createApiEvent('display.name.changed'));
            APP.store.dispatch(updateSettings({ displayName: getNormalizedDisplayName(displayName) }));
        },
        'local-subject': localSubject => {
            sendAnalytics(createApiEvent('local.subject.changed'));
            APP.store.dispatch(setLocalSubject(localSubject));
        },
        'mute-everyone': mediaType => {
            const muteMediaType = mediaType ? mediaType : MEDIA_TYPE.AUDIO;

            sendAnalytics(createApiEvent('muted-everyone'));
            const localParticipant = getLocalParticipant(APP.store.getState());
            const exclude = [];

            if (localParticipant && isParticipantModerator(localParticipant)) {
                exclude.push(localParticipant.id);
            }

            APP.store.dispatch(muteAllParticipants(exclude, muteMediaType));
        },
        'toggle-lobby': isLobbyEnabled => {
            APP.store.dispatch(toggleLobbyMode(isLobbyEnabled));
        },
        'password': password => {
            const { conference, passwordRequired }
                = APP.store.getState()['features/base/conference'];

            if (passwordRequired) {
                sendAnalytics(createApiEvent('submit.password'));

                APP.store.dispatch(setPassword(
                    passwordRequired,
                    passwordRequired.join,
                    password
                ));
            } else {
                sendAnalytics(createApiEvent('password.changed'));

                APP.store.dispatch(setPassword(
                    conference,
                    conference.lock,
                    password
                ));
            }
        },
        'pin-participant': (id, videoType) => {
            const state = APP.store.getState();

            // if id not provided, unpin everybody.
            if (!id) {
                if (isStageFilmstripAvailable(state)) {
                    const pinnedParticipants = getPinnedActiveParticipants(state);

                    pinnedParticipants?.forEach(p => {
                        APP.store.dispatch(togglePinStageParticipant(p.participantId));
                    });
                } else {
                    APP.store.dispatch(pinParticipant());
                }

                return;
            }

            const participant = videoType === VIDEO_TYPE.DESKTOP
                ? getVirtualScreenshareParticipantByOwnerId(state, id) : getParticipantById(state, id);

            if (!participant) {
                logger.warn('Trying to pin a non-existing participant with pin-participant command.');

                return;
            }

            sendAnalytics(createApiEvent('participant.pinned'));

            const participantId = participant.id;

            if (isStageFilmstripAvailable(state)) {
                APP.store.dispatch(addStageParticipant(participantId, true));
            } else {
                APP.store.dispatch(pinParticipant(participantId));
            }
        },
        'proxy-connection-event': event => {
            APP.conference.onProxyConnectionEvent(event);
        },
        'reject-participant': (participantId, mediaType) => {
            if (!isLocalParticipantModerator(APP.store.getState())) {
                return;
            }

            const reject = mediaType === MEDIA_TYPE.VIDEO ? rejectParticipantVideo : rejectParticipantAudio;

            APP.store.dispatch(reject(participantId));
        },
        'remove-breakout-room': breakoutRoomJid => {
            if (!isLocalParticipantModerator(APP.store.getState())) {
                logger.error('Missing moderator rights to remove breakout rooms');

                return;
            }
            APP.store.dispatch(removeBreakoutRoom(breakoutRoomJid));
        },
        'resize-large-video': (width, height) => {
            sendAnalytics(createApiEvent('largevideo.resized'));
            APP.store.dispatch(resizeLargeVideo(width, height));
        },
        'send-tones': (options = {}) => {
            const { duration, tones, pause } = options;

            APP.store.dispatch(sendTones(tones, duration, pause));
        },
        'set-assumed-bandwidth-bps': value => {
            logger.debug('Set assumed bandwidth bps command received', value);

            if (typeof value !== 'number' || isNaN(value)) {
                logger.error('Assumed bandwidth bps must be a number.');

                return;
            }

            APP.store.dispatch(setAssumedBandwidthBps(value));
        },
        'set-blurred-background': blurType => {
            const tracks = APP.store.getState()['features/base/tracks'];
            const videoTrack = getLocalVideoTrack(tracks)?.jitsiTrack;
            const muted = tracks ? isLocalTrackMuted(tracks, MEDIA_TYPE.VIDEO) : isVideoMutedByUser(APP.store);

            APP.store.dispatch(toggleBlurredBackgroundEffect(videoTrack, blurType, muted));
        },
        'set-follow-me': (value, recorderOnly) => {

            if (value) {
                sendAnalytics(createApiEvent('follow.me.set', {
                    recorderOnly
                }));
            } else {
                sendAnalytics(createApiEvent('follow.me.unset', {
                    recorderOnly
                }));
            }

            APP.store.dispatch(recorderOnly ? setFollowMeRecorder(value) : setFollowMe(value));
        },
        'set-large-video-participant': (participantId, videoType) => {
            const { getState, dispatch } = APP.store;

            if (!participantId) {
                sendAnalytics(createApiEvent('largevideo.participant.set'));
                dispatch(selectParticipantInLargeVideo());

                return;
            }

            const state = getState();
            const participant = videoType === VIDEO_TYPE.DESKTOP
                ? getVirtualScreenshareParticipantByOwnerId(state, participantId)
                : getParticipantById(state, participantId);

            if (!participant) {
                logger.warn('Trying to select a non-existing participant with set-large-video-participant command.');

                return;
            }

            dispatch(setTileView(false));
            sendAnalytics(createApiEvent('largevideo.participant.set'));
            dispatch(selectParticipantInLargeVideo(participant.id));
        },
        'set-participant-volume': (participantId, volume) => {
            APP.store.dispatch(setVolume(participantId, volume));
        },
        'subject': subject => {
            sendAnalytics(createApiEvent('subject.changed'));
            APP.store.dispatch(setSubject(subject));
        },
        'submit-feedback': feedback => {
            sendAnalytics(createApiEvent('submit.feedback'));
            APP.conference.submitFeedback(feedback.score, feedback.message);
        },
        'toggle-audio': () => {
            sendAnalytics(createApiEvent('toggle-audio'));
            APP.conference.toggleAudioMuted(false /* no UI */);
        },
        'toggle-video': () => {
            sendAnalytics(createApiEvent('toggle-video'));
            APP.conference.toggleVideoMuted(false /* no UI */, true /* ensure track */);
        },
        'toggle-film-strip': () => {
            sendAnalytics(createApiEvent('film.strip.toggled'));
            const { visible } = APP.store.getState()['features/filmstrip'];

            APP.store.dispatch(setFilmstripVisible(!visible));
        },

        /*
         * @param {Object} options - Additional details of how to perform
         * the action.
         * @param {number} options.width - width value for film strip.
         */
        'resize-film-strip': (options = {}) => {
            sendAnalytics(createApiEvent('film.strip.resize'));
            APP.store.dispatch(resizeFilmStrip(options.width));
        },
        'toggle-camera': facingMode => {
            APP.store.dispatch(setCameraFacingMode(facingMode));
        },
        'toggle-camera-mirror': () => {
            const state = APP.store.getState();
            const { localFlipX: currentFlipX } = state['features/base/settings'];

            APP.store.dispatch(updateSettings({ localFlipX: !currentFlipX }));
        },
        'toggle-chat': () => {
            sendAnalytics(createApiEvent('chat.toggled'));
            APP.store.dispatch(toggleChat());
        },
        'toggle-moderation': (enabled, mediaType) => {
            const state = APP.store.getState();

            if (!isLocalParticipantModerator(state)) {
                return;
            }

            const enable = mediaType === MEDIA_TYPE.VIDEO
                ? requestEnableVideoModeration : requestEnableAudioModeration;
            const disable = mediaType === MEDIA_TYPE.VIDEO
                ? requestDisableVideoModeration : requestDisableAudioModeration;

            if (enabled) {
                APP.store.dispatch(enable());
            } else {
                APP.store.dispatch(disable());
            }
        },
        'toggle-participants-pane': enabled => {
            const toggleParticipantsPane = enabled
                ? openParticipantsPane : closeParticipantsPane;

            APP.store.dispatch(toggleParticipantsPane());
        },
        'toggle-raise-hand': () => {
            const localParticipant = getLocalParticipant(APP.store.getState());

            if (!localParticipant) {
                return;
            }
            const raisedHand = hasRaisedHand(localParticipant);

            sendAnalytics(createApiEvent('raise-hand.toggled'));
            APP.store.dispatch(raiseHand(!raisedHand));
        },
        'toggle-share-audio': () => {
            sendAnalytics(createApiEvent('audio.screen.sharing.toggled'));
            if (isScreenAudioSupported()) {
                APP.store.dispatch(startAudioScreenShareFlow());

                return;
            }

            logger.error('Audio screen sharing is not supported by the current platform!');
        },

        /**
         * Callback to invoke when the "toggle-share-screen" command is received.
         *
         * @param {Object} options - Additional details of how to perform
         * the action. Note this parameter is undocumented and experimental.
         * @param {boolean} options.enable - Whether trying to enable screen
         * sharing or to turn it off.
         * @returns {void}
         */
        'toggle-share-screen': (options = {}) => {
            sendAnalytics(createApiEvent('screen.sharing.toggled'));
            toggleScreenSharing(options.enable);
        },
        'set-noise-suppression-enabled': (options = {}) => {
            APP.store.dispatch(setNoiseSuppressionEnabled(options.enabled));
        },
        'toggle-subtitles': () => {
            APP.store.dispatch(toggleRequestingSubtitles());
        },
        'set-subtitles': (enabled, displaySubtitles, language) => {
            APP.store.dispatch(setRequestingSubtitles(enabled, displaySubtitles, language));
        },
        'toggle-tile-view': () => {
            sendAnalytics(createApiEvent('tile-view.toggled'));

            APP.store.dispatch(toggleTileView());
        },
        'set-tile-view': enabled => {
            APP.store.dispatch(setTileView(enabled));
        },
        'video-hangup': (showFeedbackDialog = true) => {
            sendAnalytics(createApiEvent('video.hangup'));
            APP.conference.hangup(showFeedbackDialog);
        },
        'email': email => {
            sendAnalytics(createApiEvent('email.changed'));
            APP.conference.changeLocalEmail(email);
        },
        'avatar-url': avatarUrl => { // @deprecated
            console.warn('Using command avatarUrl is deprecated. Use context.user.avatar in the jwt.');

            sendAnalytics(createApiEvent('avatar.url.changed'));
            APP.conference.changeLocalAvatarUrl(avatarUrl);
        },
        'send-chat-message': (message, to, ignorePrivacy = false) => {
            if (to) {
                const participant = getParticipantById(APP.store.getState(), to);

                if (participant) {
                    APP.store.dispatch(setPrivateMessageRecipient(participant));
                } else {
                    logger.error(`Participant with id ${to} not found!`);

                    return;
                }
            } else {
                APP.store.dispatch(setPrivateMessageRecipient());
            }

            APP.store.dispatch(sendMessage(message, ignorePrivacy));
        },
        'send-endpoint-text-message': (to, text) => {
            try {
                APP.conference.sendEndpointMessage(to, {
                    name: ENDPOINT_TEXT_MESSAGE_NAME,
                    text
                });
            } catch (err) {
                logger.error('Failed sending endpoint text message', err);
            }
        },
        'send-camera-facing-mode-message': (to, facingMode) => {
            if (!to) {
                logger.warn('Participant id not set');

                return;
            }

            APP.conference.sendEndpointMessage(to, {
                name: CAMERA_FACING_MODE_MESSAGE,
                facingMode
            });
        },
        'overwrite-names': participantList => {
            APP.store.dispatch(overwriteParticipantsNames(participantList));
        },
        'toggle-e2ee': enabled => {
            APP.store.dispatch(toggleE2EE(enabled));
        },
        'set-media-encryption-key': keyInfo => {
            APP.store.dispatch(setMediaEncryptionKey(JSON.parse(keyInfo)));
        },
        'set-video-quality': frameHeight => {
            sendAnalytics(createApiEvent('set.video.quality'));
            APP.store.dispatch(setVideoQuality(frameHeight));
        },
        'start-share-video': url => {
            sendAnalytics(createApiEvent('share.video.start'));
            const id = extractYoutubeIdOrURL(url);

            if (id) {
                APP.store.dispatch(playSharedVideo(id));
            }
        },
        'stop-share-video': () => {
            sendAnalytics(createApiEvent('share.video.stop'));
            APP.store.dispatch(stopSharedVideo());
        },

        /**
         * Shows a custom in-meeting notification.
         *
         * @param { string } arg.title - Notification title.
         * @param { string } arg.description - Notification description.
         * @param { string } arg.uid - Optional unique identifier for the notification.
         * @param { string } arg.type - Notification type, either `error`, `info`, `normal`, `success` or `warning`.
         * Defaults to "normal" if not provided.
         * @param { string } arg.timeout - Timeout type, either `short`, `medium`, `long` or `sticky`.
         * Defaults to "short" if not provided.
         * @returns {void}
         */
        'show-notification': ({
            title,
            description,
            uid,
            type = NOTIFICATION_TYPE.NORMAL,
            timeout = NOTIFICATION_TIMEOUT_TYPE.SHORT
        }) => {
            const validTypes = Object.values(NOTIFICATION_TYPE);
            const validTimeouts = Object.values(NOTIFICATION_TIMEOUT_TYPE);

            if (!validTypes.includes(type)) {
                logger.error(`Invalid notification type "${type}". Expecting one of ${validTypes}`);

                return;
            }

            if (!validTimeouts.includes(timeout)) {
                logger.error(`Invalid notification timeout "${timeout}". Expecting one of ${validTimeouts}`);

                return;
            }

            APP.store.dispatch(showNotification({
                uid,
                title,
                description,
                appearance: type
            }, timeout));
        },

        /**
         * Removes a notification given a unique identifier.
         *
         * @param { string } uid - Unique identifier for the notification to be removed.
         * @returns {void}
         */
        'hide-notification': uid => {
            APP.store.dispatch(hideNotification(uid));
        },

        /**
         * Starts a file recording or streaming session depending on the passed on params.
         * For RTMP streams, `rtmpStreamKey` must be passed on. `rtmpBroadcastID` is optional.
         * For youtube streams, `youtubeStreamKey` must be passed on. `youtubeBroadcastID` is optional.
         * For dropbox recording, recording `mode` should be `file` and a dropbox oauth2 token must be provided.
         * For file recording, recording `mode` should be `file` and optionally `shouldShare` could be passed on.
         * For local recording, recording `mode` should be `local` and optionally `onlySelf` could be passed on.
         * No other params should be passed.
         *
         * @param { string } arg.mode - Recording mode, either `local`, `file` or `stream`.
         * @param { string } arg.dropboxToken - Dropbox oauth2 token.
         * @param { boolean } arg.onlySelf - Whether to only record the local streams.
         * @param { string } arg.rtmpStreamKey - The RTMP stream key.
         * @param { string } arg.rtmpBroadcastID - The RTMP broadcast ID.
         * @param { boolean } arg.shouldShare - Whether the recording should be shared with the participants or not.
         * Only applies to certain jitsi meet deploys.
         * @param { string } arg.youtubeStreamKey - The youtube stream key.
         * @param { string } arg.youtubeBroadcastID - The youtube broadcast ID.
         * @param { Object } arg.extraMetadata - Any extra metadata params for file recording.
         * @param { boolean } arg.transcription - Whether a transcription should be started or not.
         * @returns {void}
         */
        'start-recording': ({
            mode,
            dropboxToken,
            onlySelf,
            shouldShare,
            rtmpStreamKey,
            rtmpBroadcastID,
            youtubeStreamKey,
            youtubeBroadcastID,
            extraMetadata = {},
            transcription
        }) => {
            const state = APP.store.getState();
            const conference = getCurrentConference(state);

            if (!conference) {
                logger.error('Conference is not defined');

                return;
            }

            if (dropboxToken && !isDropboxEnabled(state)) {
                logger.error('Failed starting recording: dropbox is not enabled on this deployment');

                return;
            }

            if (mode === JitsiRecordingConstants.mode.STREAM && !(youtubeStreamKey || rtmpStreamKey)) {
                logger.error('Failed starting recording: missing youtube or RTMP stream key');

                return;
            }

            if (mode === 'local') {
                const { localRecording } = state['features/base/config'];

                if (!localRecording?.disable && supportsLocalRecording()) {
                    APP.store.dispatch(startLocalVideoRecording(onlySelf));
                } else {
                    logger.error('Failed starting recording: local recording is either disabled or not supported');
                }

                return;
            }

            let recordingConfig;

            if (mode === JitsiRecordingConstants.mode.FILE) {
                const { recordingService } = state['features/base/config'];

                if (!recordingService.enabled && !dropboxToken) {
                    logger.error('Failed starting recording: the recording service is not enabled');

                    return;
                }
                if (dropboxToken) {
                    recordingConfig = {
                        mode: JitsiRecordingConstants.mode.FILE,
                        appData: JSON.stringify({
                            'file_recording_metadata': {
                                ...extraMetadata,
                                'upload_credentials': {
                                    'service_name': RECORDING_TYPES.DROPBOX,
                                    'token': dropboxToken
                                }
                            }
                        })
                    };
                } else {
                    recordingConfig = {
                        mode: JitsiRecordingConstants.mode.FILE,
                        appData: JSON.stringify({
                            'file_recording_metadata': {
                                ...extraMetadata,
                                'share': shouldShare
                            }
                        })
                    };
                }
            } else if (mode === JitsiRecordingConstants.mode.STREAM) {
                recordingConfig = {
                    broadcastId: youtubeBroadcastID || rtmpBroadcastID,
                    mode: JitsiRecordingConstants.mode.STREAM,
                    streamId: youtubeStreamKey || rtmpStreamKey
                };
            }

            if (isScreenshotCaptureEnabled(state, true, false)) {
                APP.store.dispatch(toggleScreenshotCaptureSummary(true));
            }

            // Start audio / video recording, if requested.
            if (typeof recordingConfig !== 'undefined') {
                conference.startRecording(recordingConfig);
            }

            if (transcription) {
                APP.store.dispatch(setRequestingSubtitles(true, false, null));
                conference.getMetadataHandler().setMetadata(RECORDING_METADATA_ID, {
                    isTranscribingEnabled: true
                });
            }
        },

        /**
         * Stops a recording or streaming in progress.
         *
         * @param {string} mode - `local`, `file` or `stream`.
         * @param {boolean} transcription - Whether the transcription needs to be stopped.
         * @returns {void}
         */
        'stop-recording': (mode, transcription) => {
            const state = APP.store.getState();
            const conference = getCurrentConference(state);

            if (!conference) {
                logger.error('Conference is not defined');

                return;
            }

            if (transcription) {
                APP.store.dispatch(setRequestingSubtitles(false, false, null));
                conference.getMetadataHandler().setMetadata(RECORDING_METADATA_ID, {
                    isTranscribingEnabled: false
                });
            }

            if (mode === 'local') {
                APP.store.dispatch(stopLocalVideoRecording());

                return;
            }

            if (![ JitsiRecordingConstants.mode.FILE, JitsiRecordingConstants.mode.STREAM ].includes(mode)) {
                logger.error('Invalid recording mode provided!');

                return;
            }

            const activeSession = getActiveSession(state, mode);

            if (activeSession && activeSession.id) {
                APP.store.dispatch(toggleScreenshotCaptureSummary(false));
                conference.stopRecording(activeSession.id);
            } else {
                logger.error('No recording or streaming session found');
            }
        },
        'initiate-private-chat': participantId => {
            const state = APP.store.getState();
            const participant = getParticipantById(state, participantId);

            if (participant) {
                const { isOpen: isChatOpen } = state['features/chat'];

                if (!isChatOpen) {
                    APP.store.dispatch(toggleChat());
                }
                APP.store.dispatch(openChat(participant));
            } else {
                logger.error('No participant found for the given participantId');
            }
        },
        'cancel-private-chat': () => {
            APP.store.dispatch(setPrivateMessageRecipient());
        },
        'close-breakout-room': roomId => {
            if (!isLocalParticipantModerator(APP.store.getState())) {
                logger.error('Missing moderator rights to close breakout rooms');

                return;
            }
            APP.store.dispatch(closeBreakoutRoom(roomId));
        },
        'join-breakout-room': roomId => {
            APP.store.dispatch(moveToRoom(roomId));
        },
        'send-participant-to-room': (participantId, roomId) => {
            if (!isLocalParticipantModerator(APP.store.getState())) {
                logger.error('Missing moderator rights to send participants to rooms');

                return;
            }

            APP.store.dispatch(sendParticipantToRoom(participantId, roomId));
        },
        'kick-participant': participantId => {
            APP.store.dispatch(kickParticipant(participantId));
        },
        'overwrite-config': config => {
            const whitelistedConfig = getWhitelistedJSON('config', config);

            APP.store.dispatch(overwriteConfig(whitelistedConfig));
        },
        'toggle-virtual-background': () => {
            APP.store.dispatch(toggleDialog(SettingsDialog, {
                defaultTab: SETTINGS_TABS.VIRTUAL_BACKGROUND }));
        },
        'end-conference': () => {
            APP.store.dispatch(endConference());
            const state = APP.store.getState();
            const conference = getCurrentConference(state);

            if (!conference) {
                logger.error('Conference not yet available');
            } else if (conference.isEndConferenceSupported()) {
                APP.store.dispatch(endConference());
            } else {
                logger.error(' End Conference not supported');
            }
        },
        'toggle-whiteboard': () => {
            APP.store.dispatch(toggleWhiteboard());
        }
    };
    transport.on('event', ({ data, name }) => {
        if (name && commands[name]) {
            logger.info(`API command received: ${name}`);
            commands[name](...data);

            return true;
        }

        return false;
    });
    transport.on('request', (request, callback) => {
        const { dispatch, getState } = APP.store;

        if (processExternalDeviceRequest(dispatch, getState, request, callback)) {
            return true;
        }

        const { name } = request;

        switch (name) {
        case 'capture-largevideo-screenshot' :
            APP.store.dispatch(captureLargeVideoScreenshot())
                .then(dataURL => {
                    let error;

                    if (!dataURL) {
                        error = new Error('No large video found!');
                    }

                    callback({
                        error,
                        dataURL
                    });
                });
            break;
        case 'deployment-info':
            callback(APP.store.getState()['features/base/config'].deploymentInfo);
            break;
        case 'invite': {
            const { invitees } = request;

            if (!Array.isArray(invitees) || invitees.length === 0) {
                callback({
                    error: new Error('Unexpected format of invitees')
                });

                break;
            }

            // The store should be already available because API.init is called
            // on appWillMount action.
            APP.store.dispatch(
                invite(invitees, true))
                .then(failedInvitees => {
                    let error;
                    let result;

                    if (failedInvitees.length) {
                        error = new Error('One or more invites failed!');
                    } else {
                        result = true;
                    }

                    callback({
                        error,
                        result
                    });
                });
            break;
        }
        case 'is-audio-muted':
            callback(APP.conference.isLocalAudioMuted());
            break;
        case 'is-audio-disabled':
            callback(isAudioMuteButtonDisabled(APP.store.getState()));
            break;
        case 'is-moderation-on': {
            const { mediaType } = request;
            const type = mediaType || MEDIA_TYPE.AUDIO;

            callback(isEnabledFromState(type, APP.store.getState()));
            break;
        }
        case 'is-participant-force-muted': {
            const state = APP.store.getState();
            const { participantId, mediaType } = request;
            const type = mediaType || MEDIA_TYPE.AUDIO;
            const participant = getParticipantById(state, participantId);

            callback(isForceMuted(participant, type, state));
            break;
        }
        case 'is-participants-pane-open': {
            callback(getParticipantsPaneOpen(APP.store.getState()));
            break;
        }
        case 'is-video-muted':
            callback(APP.conference.isLocalVideoMuted());
            break;
        case 'is-audio-available':
            callback(audioAvailable);
            break;
        case 'is-video-available':
            callback(videoAvailable);
            break;
        case 'is-sharing-screen':
            callback(Boolean(APP.conference.isSharingScreen));
            break;
        case 'is-start-silent':
            callback(Boolean(APP.store.getState()['features/base/config'].startSilent));
            break;
        case 'get-content-sharing-participants': {
            const sharingParticipantIds = getScreenshareParticipantIds(APP.store.getState());

            callback({
                sharingParticipantIds
            });
            break;
        }
        case 'get-livestream-url': {
            const state = APP.store.getState();
            const conference = getCurrentConference(state);
            let livestreamUrl;

            if (conference) {
                const activeSession = getActiveSession(state, JitsiRecordingConstants.mode.STREAM);

                livestreamUrl = activeSession?.liveStreamViewURL;
            } else {
                logger.error('Conference is not defined');
            }
            callback({
                livestreamUrl
            });
            break;
        }
        case 'get-custom-avatar-backgrounds' : {
            callback({
                avatarBackgrounds: APP.store.getState()['features/dynamic-branding'].avatarBackgrounds
            });
            break;
        }
        case 'list-breakout-rooms': {
            callback(getBreakoutRooms(APP.store.getState()));
            break;
        }
        case 'rooms-info': {
            callback(getRoomsInfo(APP.store.getState()));
            break;
        }
        case 'get-p2p-status': {
            callback(isP2pActive(APP.store.getState()));
            break;
        }
        case 'session-id': {
            const { conference } = APP.store.getState()['features/base/conference'];

            callback(conference?.getMeetingUniqueId() || '');
            break;
        }
        case '_new_electron_screensharing_supported': {
            callback(true);
            break;
        }
        default:
            callback({ error: new Error('UnknownRequestError') });

            return false;
        }

        return true;
    });
}

/**
 * Check whether the API should be enabled or not.
 *
 * @returns {boolean}
 */
function shouldBeEnabled() {
    return (
        typeof API_ID === 'number'

            // XXX Enable the API when a JSON Web Token (JWT) is specified in
            // the location/URL because then it is very likely that the Jitsi
            // Meet (Web) app is being used by an external/wrapping (Web) app
            // and, consequently, the latter will need to communicate with the
            // former. (The described logic is merely a heuristic though.)
            || parseJWTFromURLParams());
}

/**
 * Executes on toggle-share-screen command.
 *
 * @param {boolean} [enable] - Whether this toggle is to explicitly enable or
 * disable screensharing. If not defined, the application will automatically
 * attempt to toggle between enabled and disabled. This boolean is useful for
 * explicitly setting desired screensharing state.
 * @returns {void}
 */
function toggleScreenSharing(enable) {
    if (JitsiMeetJS.isDesktopSharingEnabled()) {
        APP.store.dispatch(startScreenShareFlow(enable));
    }
}

/**
 * Removes sensitive data from a mouse event.
 *
 * @param {MouseEvent} event - The mouse event to sanitize.
 * @returns {Object}
 */
function sanitizeMouseEvent(event) {
    const {
        clientX,
        clientY,
        movementX,
        movementY,
        offsetX,
        offsetY,
        pageX,
        pageY,
        x,
        y,
        screenX,
        screenY
    } = event;

    return {
        clientX,
        clientY,
        movementX,
        movementY,
        offsetX,
        offsetY,
        pageX,
        pageY,
        x,
        y,
        screenX,
        screenY
    };
}

/**
 * Implements API class that communicates with external API class and provides
 * interface to access Jitsi Meet features by external applications that embed
 * Jitsi Meet.
 */
class API {
    _enabled;

    /**
     * Initializes the API. Setups message event listeners that will receive
     * information from external applications that embed Jitsi Meet. It also
     * sends a message to the external application that API is initialized.
     *
     * @param {Object} options - Optional parameters.
     * @returns {void}
     */
    init() {
        if (!shouldBeEnabled()) {
            return;
        }

        /**
         * Current status (enabled/disabled) of API.
         *
         * @private
         * @type {boolean}
         */
        this._enabled = true;

        initCommands();

        this.notifyBrowserSupport(isSupportedBrowser());

        // Let the embedder know we are ready.
        this._sendEvent({ name: 'ready' });
    }

    /**
     * Notify external application (if API is enabled) that the large video
     * visibility changed.
     *
     * @param {boolean} isHidden - True if the large video is hidden and false
     * otherwise.
     * @returns {void}
     */
    notifyLargeVideoVisibilityChanged(isHidden) {
        this._sendEvent({
            name: 'large-video-visibility-changed',
            isVisible: !isHidden
        });
    }

    /**
     * Notifies the external application (spot) that the local jitsi-participant
     * has a status update.
     *
     * @param {Object} event - The message to pass onto spot.
     * @returns {void}
     */
    sendProxyConnectionEvent(event) {
        this._sendEvent({
            name: 'proxy-connection-event',
            ...event
        });
    }

    /**
     * Sends event to the external application.
     *
     * @param {Object} event - The event to be sent.
     * @returns {void}
     */
    _sendEvent(event = {}) {
        if (this._enabled) {
            try {
                transport.sendEvent(event);
            } catch (error) {
                logger.error('Failed to send and IFrame API event', error);
            }
        }
    }

    /**
     * Notify external application (if API is enabled) that the chat state has been updated.
     *
     * @param {number} unreadCount - The unread messages counter.
     * @param {boolean} isOpen - True if the chat panel is open.
     * @returns {void}
     */
    notifyChatUpdated(unreadCount, isOpen) {
        this._sendEvent({
            name: 'chat-updated',
            unreadCount,
            isOpen
        });
    }

    /**
     * Notify external application (if API is enabled) that message was sent.
     *
     * @param {string} message - Message body.
     * @param {boolean} privateMessage - True if the message was a private message.
     * @returns {void}
     */
    notifySendingChatMessage(message, privateMessage) {
        this._sendEvent({
            name: 'outgoing-message',
            message,
            privateMessage
        });
    }

    /**
     * Notify external application (if API is enabled) that the mouse has entered inside the iframe.
     *
     * @param {MouseEvent} event - The mousemove event.
     * @returns {void}
     */
    notifyMouseEnter(event) {
        this._sendEvent({
            name: 'mouse-enter',
            event: sanitizeMouseEvent(event)
        });
    }

    /**
     * Notify external application (if API is enabled) that the mouse has entered inside the iframe.
     *
     * @param {MouseEvent} event - The mousemove event.
     * @returns {void}
     */
    notifyMouseLeave(event) {
        this._sendEvent({
            name: 'mouse-leave',
            event: sanitizeMouseEvent(event)
        });
    }

    /**
     * Notify external application (if API is enabled) that the mouse has moved inside the iframe.
     *
     * @param {MouseEvent} event - The mousemove event.
     * @returns {void}
     */
    notifyMouseMove(event) {
        this._sendEvent({
            name: 'mouse-move',
            event: sanitizeMouseEvent(event)
        });
    }

    /**
     * Notify the external application that the moderation status has changed.
     *
     * @param {string} mediaType - Media type for which the moderation changed.
     * @param {boolean} enabled - Whether or not the new moderation status is enabled.
     * @returns {void}
     */
    notifyModerationChanged(mediaType, enabled) {
        this._sendEvent({
            name: 'moderation-status-changed',
            mediaType,
            enabled
        });
    }

    /**
     * Notify the external application that a participant was approved on moderation.
     *
     * @param {string} participantId - The ID of the participant that got approved.
     * @param {string} mediaType - Media type for which the participant was approved.
     * @returns {void}
     */
    notifyParticipantApproved(participantId, mediaType) {
        this._sendEvent({
            name: 'moderation-participant-approved',
            id: participantId,
            mediaType
        });
    }

    /**
     * Notify the external application that a participant was rejected on moderation.
     *
     * @param {string} participantId - The ID of the participant that got rejected.
     * @param {string} mediaType - Media type for which the participant was rejected.
     * @returns {void}
     */
    notifyParticipantRejected(participantId, mediaType) {
        this._sendEvent({
            name: 'moderation-participant-rejected',
            id: participantId,
            mediaType
        });
    }

    /**
     * Notify the external app that a notification has been triggered.
     *
     * @param {string} title - The notification title.
     * @param {string} description - The notification description.
     *
     * @returns {void}
     */
    notifyNotificationTriggered(title, description) {
        this._sendEvent({
            description,
            name: 'notification-triggered',
            title
        });
    }

    /**
     * Notify request desktop sources.
     *
     * @param {Object} options - Object with the options for desktop sources.
     * @returns {void}
     */
    requestDesktopSources(options) {
        return transport.sendRequest({
            name: '_request-desktop-sources',
            options
        });
    }

    /**
     * Notify external application that the video quality setting has changed.
     *
     * @param {number} videoQuality - The video quality. The number represents the maximum height of the video streams.
     * @returns {void}
     */
    notifyVideoQualityChanged(videoQuality) {
        this._sendEvent({
            name: 'video-quality-changed',
            videoQuality
        });
    }

    /**
     * Notify external application (if API is enabled) that message was
     * received.
     *
     * @param {Object} options - Object with the message properties.
     * @returns {void}
     */
    notifyReceivedChatMessage(
            { body, from, nick, privateMessage, ts } = {}) {
        if (APP.conference.isLocalId(from)) {
            return;
        }

        this._sendEvent({
            name: 'incoming-message',
            from,
            message: body,
            nick,
            privateMessage,
            stamp: ts
        });
    }

    /**
     * Notify external application (if API is enabled) that user joined the
     * conference.
     *
     * @param {string} id - User id.
     * @param {Object} props - The display name of the user.
     * @returns {void}
     */
    notifyUserJoined(id, props) {
        this._sendEvent({
            name: 'participant-joined',
            id,
            ...props
        });
    }

    /**
     * Notify external application (if API is enabled) that user left the
     * conference.
     *
     * @param {string} id - User id.
     * @returns {void}
     */
    notifyUserLeft(id) {
        this._sendEvent({
            name: 'participant-left',
            id
        });
    }

    /**
     * Notify external application (if API is enabled) that the user role
     * has changed.
     *
     * @param {string} id - User id.
     * @param {string} role - The new user role.
     * @returns {void}
     */
    notifyUserRoleChanged(id, role) {
        this._sendEvent({
            name: 'participant-role-changed',
            id,
            role
        });
    }

    /**
     * Notify external application (if API is enabled) that user changed their
     * avatar.
     *
     * @param {string} id - User id.
     * @param {string} avatarURL - The new avatar URL of the participant.
     * @returns {void}
     */
    notifyAvatarChanged(id, avatarURL) {
        this._sendEvent({
            name: 'avatar-changed',
            avatarURL,
            id
        });
    }

    /**
     * Notify external application (if API is enabled) that user received
     * a text message through datachannels.
     *
     * @param {Object} data - The event data.
     * @returns {void}
     */
    notifyEndpointTextMessageReceived(data) {
        this._sendEvent({
            name: 'endpoint-text-message-received',
            data
        });
    }

    /**
     * Notify external application (if API is enabled) that some face landmark data is available.
     *
     * @param {Object | undefined} faceBox - Detected face(s) bounding box (left, right, width).
     * @param {string} faceExpression - Detected face expression.
     * @returns {void}
     */
    notifyFaceLandmarkDetected(faceBox, faceExpression) {
        this._sendEvent({
            name: 'face-landmark-detected',
            faceBox,
            faceExpression
        });
    }

    /**
     * Notify external application (if API is enabled) that the list of sharing participants changed.
     *
     * @param {Object} data - The event data.
     * @returns {void}
     */
    notifySharingParticipantsChanged(data) {
        this._sendEvent({
            name: 'content-sharing-participants-changed',
            data
        });
    }

    /**
     * Notify external application (if API is enabled) that the device list has
     * changed.
     *
     * @param {Object} devices - The new device list.
     * @returns {void}
     */
    notifyDeviceListChanged(devices) {
        this._sendEvent({
            name: 'device-list-changed',
            devices
        });
    }

    /**
     * Notify external application (if API is enabled) that user changed their
     * nickname.
     *
     * @param {string} id - User id.
     * @param {string} displayname - User nickname.
     * @param {string} formattedDisplayName - The display name shown in Jitsi
     * meet's UI for the user.
     * @returns {void}
     */
    notifyDisplayNameChanged(
            id,
            { displayName, formattedDisplayName }) {
        this._sendEvent({
            name: 'display-name-change',
            displayname: displayName,
            formattedDisplayName,
            id
        });
    }

    /**
     * Notify external application (if API is enabled) that user changed their
     * email.
     *
     * @param {string} id - User id.
     * @param {string} email - The new email of the participant.
     * @returns {void}
     */
    notifyEmailChanged(
            id,
            { email }) {
        this._sendEvent({
            name: 'email-change',
            email,
            id
        });
    }

    /**
     * Notify external application (if API is enabled) that the an error has been logged.
     *
     * @param {string} logLevel - The message log level.
     * @param {Array<string>} args - Array of strings composing the log message.
     * @returns {void}
     */
    notifyLog(logLevel, args = []) {
        if (!Array.isArray(args)) {
            logger.error('notifyLog received wrong argument types!');

            return;
        }

        // Trying to convert arguments to strings. Otherwise in order to send the event the arguments will be formatted
        // with JSON.stringify which can throw an error because of circular objects and we will lose the whole log.
        const formattedArguments = [];

        args.forEach(arg => {
            let formattedArgument = '';

            if (arg instanceof Error) {
                formattedArgument += `${arg.toString()}: ${arg.stack}`;
            } else if (typeof arg === 'object') {
                // NOTE: The non-enumerable properties of the objects wouldn't be included in the string after
                // JSON.strigify. For example Map instance will be translated to '{}'. So I think we have to eventually
                // do something better for parsing the arguments. But since this option for strigify is part of the
                // public interface and I think it could be useful in some cases I will it for now.
                try {
                    formattedArgument += JSON.stringify(arg);
                } catch (error) {
                    formattedArgument += arg;
                }
            } else {
                formattedArgument += arg;
            }

            formattedArguments.push(formattedArgument);
        });

        this._sendEvent({
            name: 'log',
            logLevel,
            args: formattedArguments
        });
    }

    /**
     * Notify external application (if API is enabled) that the conference has
     * been joined.
     *
     * @param {string} roomName - The room name.
     * @param {string} id - The id of the local user.
     * @param {Object} props - The display name, the avatar URL of the local
     * user and the type of the room.
     * @returns {void}
     */
    notifyConferenceJoined(roomName, id, props) {
        this._sendEvent({
            name: 'video-conference-joined',
            roomName,
            id,
            ...props
        });
    }

    /**
     * Notify external application (if API is enabled) that local user has left the conference.
     *
     * @param {string} roomName - User id.
     * @returns {void}
     */
    notifyConferenceLeft(roomName) {
        this._sendEvent({
            name: 'video-conference-left',
            roomName
        });
    }

    /**
     * Notify external application that the data channel has been closed.
     *
     * @param {number} code - The close code.
     * @param {string} reason - The close reason.
     *
     * @returns {void}
     */
    notifyDataChannelClosed(code, reason) {
        this._sendEvent({
            name: 'data-channel-closed',
            code,
            reason
        });
    }

    /**
     * Notify external application that the data channel has been opened.
     *
     * @returns {void}
     */
    notifyDataChannelOpened() {
        this._sendEvent({ name: 'data-channel-opened' });
    }

    /**
     * Notify external application (if API is enabled) that we are ready to be
     * closed.
     *
     * @returns {void}
     */
    notifyReadyToClose() {
        this._sendEvent({ name: 'video-ready-to-close' });
    }

    /**
     * Notify external application (if API is enabled) that a suspend event in host computer.
     *
     * @returns {void}
     */
    notifySuspendDetected() {
        this._sendEvent({ name: 'suspend-detected' });
    }

    /**
     * Notify external application (if API is enabled) for audio muted status
     * changed.
     *
     * @param {boolean} muted - The new muted status.
     * @returns {void}
     */
    notifyAudioMutedStatusChanged(muted) {
        this._sendEvent({
            name: 'audio-mute-status-changed',
            muted
        });
    }

    /**
     * Notify external application (if API is enabled) for video muted status
     * changed.
     *
     * @param {boolean} muted - The new muted status.
     * @returns {void}
     */
    notifyVideoMutedStatusChanged(muted) {
        this._sendEvent({
            name: 'video-mute-status-changed',
            muted
        });
    }

    /**
     * Notify external application (if API is enabled) for audio availability
     * changed.
     *
     * @param {boolean} available - True if available and false otherwise.
     * @returns {void}
     */
    notifyAudioAvailabilityChanged(available) {
        audioAvailable = available;
        this._sendEvent({
            name: 'audio-availability-changed',
            available
        });
    }

    /**
     * Notify external application (if API is enabled) for video available
     * status changed.
     *
     * @param {boolean} available - True if available and false otherwise.
     * @returns {void}
     */
    notifyVideoAvailabilityChanged(available) {
        videoAvailable = available;
        this._sendEvent({
            name: 'video-availability-changed',
            available
        });
    }

    /**
     * Notify external application (if API is enabled) that the on stage
     * participant has changed.
     *
     * @param {string} id - User id of the new on stage participant.
     * @returns {void}
     */
    notifyOnStageParticipantChanged(id) {
        this._sendEvent({
            name: 'on-stage-participant-changed',
            id
        });
    }

    /**
     * Notify external application (if API is enabled) that the prejoin video
     * visibility had changed.
     *
     * @param {boolean} isVisible - Whether the prejoin video is visible.
     * @returns {void}
     */
    notifyPrejoinVideoVisibilityChanged(isVisible) {
        this._sendEvent({
            name: 'on-prejoin-video-changed',
            isVisible
        });
    }

    /**
     * Notify external application (if API is enabled) that the prejoin
     * screen was loaded.
     *
     * @returns {void}
     */
    notifyPrejoinLoaded() {
        const state = APP.store.getState();
        const { defaultLocalDisplayName } = state['features/base/config'];
        const displayName = getDisplayName(state);

        this._sendEvent({
            name: 'prejoin-screen-loaded',
            id: LOCAL_PARTICIPANT_DEFAULT_ID,
            displayName,
            formattedDisplayName: appendSuffix(displayName, defaultLocalDisplayName)
        });
    }

    /**
     * Notify external application of an unexpected camera-related error having
     * occurred.
     *
     * @param {string} type - The type of the camera error.
     * @param {string} message - Additional information about the error.
     * @returns {void}
     */
    notifyOnCameraError(type, message) {
        this._sendEvent({
            name: 'camera-error',
            type,
            message
        });
    }

    /**
     * Notify external application of an unexpected mic-related error having
     * occurred.
     *
     * @param {string} type - The type of the mic error.
     * @param {string} message - Additional information about the error.
     * @returns {void}
     */
    notifyOnMicError(type, message) {
        this._sendEvent({
            name: 'mic-error',
            type,
            message
        });
    }

    /**
     * Notify external application (if API is enabled) that conference feedback
     * has been submitted. Intended to be used in conjunction with the
     * submit-feedback command to get notified if feedback was submitted.
     *
     * @param {string} error - A failure message, if any.
     * @returns {void}
     */
    notifyFeedbackSubmitted(error) {
        this._sendEvent({
            name: 'feedback-submitted',
            error
        });
    }

    /**
     * Notify external application (if API is enabled) that the feedback prompt
     * has been displayed.
     *
     * @returns {void}
     */
    notifyFeedbackPromptDisplayed() {
        this._sendEvent({ name: 'feedback-prompt-displayed' });
    }

    /**
     * Notify external application (if API is enabled) that the display
     * configuration of the filmstrip has been changed.
     *
     * @param {boolean} visible - Whether or not the filmstrip has been set to
     * be displayed or hidden.
     * @returns {void}
     */
    notifyFilmstripDisplayChanged(visible) {
        this._sendEvent({
            name: 'filmstrip-display-changed',
            visible
        });
    }

    /**
     * Notify external application of a participant, remote or local, being
     * removed from the conference by another participant.
     *
     * @param {Object} kicked - The participant removed from the
     * conference.
     * @param {Object} kicker - The participant that removed the
     * other participant.
     * @returns {void}
     */
    notifyKickedOut(kicked, kicker) {
        this._sendEvent({
            name: 'participant-kicked-out',
            kicked,
            kicker
        });
    }

    /**
     * Notify external application of the current meeting requiring a password
     * to join.
     *
     * @returns {void}
     */
    notifyOnPasswordRequired() {
        this._sendEvent({ name: 'password-required' });
    }

    /**
     * Notify external application (if API is enabled) that the screen sharing
     * has been turned on/off.
     *
     * @param {boolean} on - True if screen sharing is enabled.
     * @param {Object} details - Additional information about the screen
     * sharing.
     * @param {string} details.sourceType - Type of device or window the screen
     * share is capturing.
     * @returns {void}
     */
    notifyScreenSharingStatusChanged(on, details) {
        this._sendEvent({
            name: 'screen-sharing-status-changed',
            on,
            details
        });
    }

    /**
     * Notify external application (if API is enabled) that the dominant speaker
     * has been turned on/off.
     *
     * @param {string} id - Id of the dominant participant.
     * @returns {void}
     */
    notifyDominantSpeakerChanged(id) {
        this._sendEvent({
            name: 'dominant-speaker-changed',
            id
        });
    }

    /**
     * Notify external application (if API is enabled) that the conference
     * changed their subject.
     *
     * @param {string} subject - Conference subject.
     * @returns {void}
     */
    notifySubjectChanged(subject) {
        this._sendEvent({
            name: 'subject-change',
            subject
        });
    }

    /**
     * Notify external application (if API is enabled) that tile view has been
     * entered or exited.
     *
     * @param {string} enabled - True if tile view is currently displayed, false
     * otherwise.
     * @returns {void}
     */
    notifyTileViewChanged(enabled) {
        this._sendEvent({
            name: 'tile-view-changed',
            enabled
        });
    }

    /**
     * Notify external application (if API is enabled) that the localStorage has changed.
     *
     * @param {string} localStorageContent - The new localStorageContent.
     * @returns {void}
     */
    notifyLocalStorageChanged(localStorageContent) {
        this._sendEvent({
            name: 'local-storage-changed',
            localStorageContent
        });
    }

    /**
     * Notify external application (if API is enabled) that user updated their hand raised.
     *
     * @param {string} id - User id.
     * @param {boolean} handRaised - Whether user has raised hand.
     * @returns {void}
     */
    notifyRaiseHandUpdated(id, handRaised) {
        this._sendEvent({
            name: 'raise-hand-updated',
            handRaised,
            id
        });
    }

    /**
     * Notify external application (if API is enabled) that recording has started or stopped.
     *
     * @param {boolean} on - True if recording is on, false otherwise.
     * @param {string} mode - Stream or file or local.
     * @param {string} error - Error type or null if success.
     * @param {boolean} transcription - True if a transcription is being recorded, false otherwise.
     * @returns {void}
     */
    notifyRecordingStatusChanged(on, mode, error, transcription) {
        this._sendEvent({
            name: 'recording-status-changed',
            on,
            mode,
            error,
            transcription
        });
    }

    /**
     * Notify external application (if API is enabled) that the current recording link is
     * available.
     *
     * @param {string} link - The recording download link.
     * @param {number} ttl - The recording download link time to live.
     * @returns {void}
     */
    notifyRecordingLinkAvailable(link, ttl) {
        this._sendEvent({
            name: 'recording-link-available',
            link,
            ttl
        });
    }

    /**
     * Notify external application (if API is enabled) that a participant is knocking in the lobby.
     *
     * @param {Object} participant - Participant data such as id and name.
     * @returns {void}
     */
    notifyKnockingParticipant(participant) {
        this._sendEvent({
            name: 'knocking-participant',
            participant
        });
    }

    /**
     * Notify external application (if API is enabled) that an error occurred.
     *
     * @param {Object} error - The error.
     * @returns {void}
     */
    notifyError(error) {
        this._sendEvent({
            name: 'error-occurred',
            error
        });
    }

    /**
     * Notify external application ( if API is enabled) that a toolbar button was clicked.
     *
     * @param {string} key - The key of the toolbar button.
     * @param {boolean} preventExecution - Whether execution of the button click was prevented or not.
     * @returns {void}
     */
    notifyToolbarButtonClicked(key, preventExecution) {
        this._sendEvent({
            name: 'toolbar-button-clicked',
            key,
            preventExecution
        });
    }

    /**
     * Notify external application (if API is enabled) that transcribing has started or stopped.
     *
     * @param {boolean} on - True if transcribing is on, false otherwise.
     * @returns {void}
     */
    notifyTranscribingStatusChanged(on) {
        this._sendEvent({
            name: 'transcribing-status-changed',
            on
        });
    }

    /**
     * Notify external application (if API is enabled) that the user received
     * a transcription chunk.
     *
     * @param {Object} data - The event data.
     * @returns {void}
     */
    notifyTranscriptionChunkReceived(data) {
        this._sendEvent({
            name: 'transcription-chunk-received',
            data
        });
    }

    /**
     * Notify external application (if API is enabled) whether the used browser is supported or not.
     *
     * @param {boolean} supported - If browser is supported or not.
     * @returns {void}
     */
    notifyBrowserSupport(supported) {
        this._sendEvent({
            name: 'browser-support',
            supported
        });
    }

    /**
     * Notify external application that the breakout rooms changed.
     *
     * @param {Array} rooms - Array containing the breakout rooms and main room.
     * @returns {void}
     */
    notifyBreakoutRoomsUpdated(rooms) {
        this._sendEvent({
            name: 'breakout-rooms-updated',
            rooms
        });
    }

    /**
     * Notify the external application that the state of the participants pane changed.
     *
     * @param {boolean} open - Whether the panel is open or not.
     * @returns {void}
     */
    notifyParticipantsPaneToggled(open) {
        this._sendEvent({
            name: 'participants-pane-toggled',
            open
        });
    }

    /**
     * Notify the external application that the audio or video is being shared by a participant.
     *
     * @param {string} mediaType - Whether the content which is being shared is audio or video.
     * @param {string} value - Whether the sharing is playing, pause or stop (on audio there is only playing and stop).
     * @param {string} participantId - Participant id of the participant which started or ended
     *  the video or audio sharing.
     * @returns {void}
     */
    notifyAudioOrVideoSharingToggled(mediaType, value, participantId) {
        this._sendEvent({
            name: 'audio-or-video-sharing-toggled',
            mediaType,
            value,
            participantId
        });
    }

    /**
     * Notify the external application that a PeerConnection lost connectivity. This event is fired only if
     * a PC `failed` but connectivity to the rtcstats server is still maintained signaling that there is a
     * problem establishing a link between the app and the JVB server or the remote peer in case of P2P.
     * Will only fire if rtcstats is enabled.
     *
     * @param {boolean} isP2P - Type of PC.
     * @param {boolean} wasConnected - Was this connection previously connected. If it was it could mean
     * that connectivity was disrupted, if not it most likely means that the app could not reach
     * the JVB server, or the other peer in case of P2P.
     *
     * @returns {void}
     */
    notifyPeerConnectionFailure(isP2P, wasConnected) {
        this._sendEvent({
            name: 'peer-connection-failure',
            isP2P,
            wasConnected
        });
    }

    /**
     * Notify external application ( if API is enabled) that a participant menu button was clicked.
     *
     * @param {string} key - The key of the participant menu button.
     * @param {string} participantId - The ID of the participant for whom the participant menu button was clicked.
     * @param {boolean} preventExecution - Whether execution of the button click was prevented or not.
     * @returns {void}
     */
    notifyParticipantMenuButtonClicked(key, participantId, preventExecution) {
        this._sendEvent({
            name: 'participant-menu-button-clicked',
            key,
            participantId,
            preventExecution
        });
    }

    /**
     * Notify external application (if API is enabled) if whiteboard state is
     * changed.
     *
     * @param {WhiteboardStatus} status - The new whiteboard status.
     * @returns {void}
     */
    notifyWhiteboardStatusChanged(status) {
        this._sendEvent({
            name: 'whiteboard-status-changed',
            status
        });
    }

    /**
     * Notify external application (if API is enabled) if non participant message
     * is received.
     *
     * @param {string} id - The resource id of the sender.
     * @param {Object} json - The json carried by the message.
     * @returns {void}
     */
    notifyNonParticipantMessageReceived(id, json) {
        this._sendEvent({
            name: 'non-participant-message-received',
            id,
            message: json
        });
    }


    /**
     * Notify external application (if API is enabled) the conference
     * start time.
     *
     * @param {number} timestamp - Timestamp conference was created.
     * @returns {void}
     */
    notifyConferenceCreatedTimestamp(timestamp) {
        this._sendEvent({
            name: 'conference-created-timestamp',
            timestamp
        });
    }


    /**
     * Notify the external application (if API is enabled) if the connection type changed.
     *
     * @param {boolean} isP2p - Whether the new connection is P2P.
     * @returns {void}
     */
    notifyP2pStatusChanged(isP2p) {
        this._sendEvent({
            name: 'p2p-status-changed',
            isP2p
        });
    }

    /**
     * Notify the external application (if API is enabled) when the compute pressure changed.
     *
     * @param {Array} records - The new pressure records.
     * @returns {void}
     */
    notifyComputePressureChanged(records) {
        this._sendEvent({
            name: 'compute-pressure-changed',
            records
        });
    }

    /**
     * Disposes the allocated resources.
     *
     * @returns {void}
     */
    dispose() {
        if (this._enabled) {
            this._enabled = false;
        }
    }
}

export default new API();


################################################################################

## File: .\jitsi-meet\modules\API\constants.js

// XXX The function parseURLParams is exported by the feature base/util (as
// defined in the terminology of react/). However, this file is (very likely)
// bundled in external_api in addition to app.bundle and, consequently, it is
// best to import as little as possible here (rather than the whole feature
// base/util) in order to minimize the amount of source code bundled into
// multiple bundles.
import { parseURLParams } from '../../react/features/base/util/parseURLParams';

/**
 * JitsiMeetExternalAPI id - unique for a webpage.
 * TODO: This shouldn't be computed here.
 */
let _apiID;

try {
    _apiID = parseURLParams(window.location).jitsi_meet_external_api_id;
} catch (_) { /* Ignore. */ }

export const API_ID = _apiID;

/**
 * The payload name for the datachannel/endpoint text message event.
 */
export const ENDPOINT_TEXT_MESSAGE_NAME = 'endpoint-text-message';

/**
 * The min value that can be set for the assumed bandwidth.
 * Setting it to this value means not assuming any bandwidth,
 * but rather allowing the estimations to take place.
 */
export const MIN_ASSUMED_BANDWIDTH_BPS = -1;


################################################################################

## File: .\jitsi-meet\modules\API\index.js

export default from './API';
export * from './constants';


################################################################################

## File: .\jitsi-meet\modules\API\external\external_api.js

import { jitsiLocalStorage } from '@jitsi/js-utils/jitsi-local-storage';
import EventEmitter from 'events';

import { urlObjectToString } from '../../../react/features/base/util/uri';
import {
    PostMessageTransportBackend,
    Transport
} from '../../transport';

import {
    getAvailableDevices,
    getCurrentDevices,
    isDeviceChangeAvailable,
    isDeviceListAvailable,
    isMultipleAudioInputSupported,
    setAudioInputDevice,
    setAudioOutputDevice,
    setVideoInputDevice
} from './functions';

const ALWAYS_ON_TOP_FILENAMES = [
    'css/all.css', 'libs/alwaysontop.min.js'
];

/**
 * Maps the names of the commands expected by the API with the name of the
 * commands expected by jitsi-meet.
 */
const commands = {
    addBreakoutRoom: 'add-breakout-room',
    answerKnockingParticipant: 'answer-knocking-participant',
    approveVideo: 'approve-video',
    askToUnmute: 'ask-to-unmute',
    autoAssignToBreakoutRooms: 'auto-assign-to-breakout-rooms',
    avatarUrl: 'avatar-url',
    cancelPrivateChat: 'cancel-private-chat',
    closeBreakoutRoom: 'close-breakout-room',
    displayName: 'display-name',
    endConference: 'end-conference',
    email: 'email',
    grantModerator: 'grant-moderator',
    hangup: 'video-hangup',
    hideNotification: 'hide-notification',
    initiatePrivateChat: 'initiate-private-chat',
    joinBreakoutRoom: 'join-breakout-room',
    localSubject: 'local-subject',
    kickParticipant: 'kick-participant',
    muteEveryone: 'mute-everyone',
    overwriteConfig: 'overwrite-config',
    overwriteNames: 'overwrite-names',
    password: 'password',
    pinParticipant: 'pin-participant',
    rejectParticipant: 'reject-participant',
    removeBreakoutRoom: 'remove-breakout-room',
    resizeFilmStrip: 'resize-film-strip',
    resizeLargeVideo: 'resize-large-video',
    sendCameraFacingMode: 'send-camera-facing-mode-message',
    sendChatMessage: 'send-chat-message',
    sendEndpointTextMessage: 'send-endpoint-text-message',
    sendParticipantToRoom: 'send-participant-to-room',
    sendTones: 'send-tones',
    setAssumedBandwidthBps: 'set-assumed-bandwidth-bps',
    setBlurredBackground: 'set-blurred-background',
    setFollowMe: 'set-follow-me',
    setLargeVideoParticipant: 'set-large-video-participant',
    setMediaEncryptionKey: 'set-media-encryption-key',
    setNoiseSuppressionEnabled: 'set-noise-suppression-enabled',
    setParticipantVolume: 'set-participant-volume',
    setSubtitles: 'set-subtitles',
    setTileView: 'set-tile-view',
    setVideoQuality: 'set-video-quality',
    showNotification: 'show-notification',
    startRecording: 'start-recording',
    startShareVideo: 'start-share-video',
    stopRecording: 'stop-recording',
    stopShareVideo: 'stop-share-video',
    subject: 'subject',
    submitFeedback: 'submit-feedback',
    toggleAudio: 'toggle-audio',
    toggleCamera: 'toggle-camera',
    toggleCameraMirror: 'toggle-camera-mirror',
    toggleChat: 'toggle-chat',
    toggleE2EE: 'toggle-e2ee',
    toggleFilmStrip: 'toggle-film-strip',
    toggleLobby: 'toggle-lobby',
    toggleModeration: 'toggle-moderation',
    toggleNoiseSuppression: 'toggle-noise-suppression',
    toggleParticipantsPane: 'toggle-participants-pane',
    toggleRaiseHand: 'toggle-raise-hand',
    toggleShareScreen: 'toggle-share-screen',
    toggleSubtitles: 'toggle-subtitles',
    toggleTileView: 'toggle-tile-view',
    toggleVirtualBackgroundDialog: 'toggle-virtual-background',
    toggleVideo: 'toggle-video',
    toggleWhiteboard: 'toggle-whiteboard'
};

/**
 * Maps the names of the events expected by the API with the name of the
 * events expected by jitsi-meet.
 */
const events = {
    'avatar-changed': 'avatarChanged',
    'audio-availability-changed': 'audioAvailabilityChanged',
    'audio-mute-status-changed': 'audioMuteStatusChanged',
    'audio-or-video-sharing-toggled': 'audioOrVideoSharingToggled',
    'breakout-rooms-updated': 'breakoutRoomsUpdated',
    'browser-support': 'browserSupport',
    'camera-error': 'cameraError',
    'chat-updated': 'chatUpdated',
    'compute-pressure-changed': 'computePressureChanged',
    'conference-created-timestamp': 'conferenceCreatedTimestamp',
    'content-sharing-participants-changed': 'contentSharingParticipantsChanged',
    'data-channel-closed': 'dataChannelClosed',
    'data-channel-opened': 'dataChannelOpened',
    'device-list-changed': 'deviceListChanged',
    'display-name-change': 'displayNameChange',
    'dominant-speaker-changed': 'dominantSpeakerChanged',
    'email-change': 'emailChange',
    'error-occurred': 'errorOccurred',
    'endpoint-text-message-received': 'endpointTextMessageReceived',
    'face-landmark-detected': 'faceLandmarkDetected',
    'feedback-submitted': 'feedbackSubmitted',
    'feedback-prompt-displayed': 'feedbackPromptDisplayed',
    'filmstrip-display-changed': 'filmstripDisplayChanged',
    'incoming-message': 'incomingMessage',
    'knocking-participant': 'knockingParticipant',
    'log': 'log',
    'mic-error': 'micError',
    'moderation-participant-approved': 'moderationParticipantApproved',
    'moderation-participant-rejected': 'moderationParticipantRejected',
    'moderation-status-changed': 'moderationStatusChanged',
    'mouse-enter': 'mouseEnter',
    'mouse-leave': 'mouseLeave',
    'mouse-move': 'mouseMove',
    'non-participant-message-received': 'nonParticipantMessageReceived',
    'notification-triggered': 'notificationTriggered',
    'outgoing-message': 'outgoingMessage',
    'p2p-status-changed': 'p2pStatusChanged',
    'participant-joined': 'participantJoined',
    'participant-kicked-out': 'participantKickedOut',
    'participant-left': 'participantLeft',
    'participant-role-changed': 'participantRoleChanged',
    'participants-pane-toggled': 'participantsPaneToggled',
    'password-required': 'passwordRequired',
    'peer-connection-failure': 'peerConnectionFailure',
    'prejoin-screen-loaded': 'prejoinScreenLoaded',
    'proxy-connection-event': 'proxyConnectionEvent',
    'raise-hand-updated': 'raiseHandUpdated',
    'ready': 'ready',
    'recording-link-available': 'recordingLinkAvailable',
    'recording-status-changed': 'recordingStatusChanged',
    'participant-menu-button-clicked': 'participantMenuButtonClick',
    'video-ready-to-close': 'readyToClose',
    'video-conference-joined': 'videoConferenceJoined',
    'video-conference-left': 'videoConferenceLeft',
    'video-availability-changed': 'videoAvailabilityChanged',
    'video-mute-status-changed': 'videoMuteStatusChanged',
    'video-quality-changed': 'videoQualityChanged',
    'screen-sharing-status-changed': 'screenSharingStatusChanged',
    'subject-change': 'subjectChange',
    'suspend-detected': 'suspendDetected',
    'tile-view-changed': 'tileViewChanged',
    'toolbar-button-clicked': 'toolbarButtonClicked',
    'transcribing-status-changed': 'transcribingStatusChanged',
    'transcription-chunk-received': 'transcriptionChunkReceived',
    'whiteboard-status-changed': 'whiteboardStatusChanged'
};

const requests = {
    '_request-desktop-sources': '_requestDesktopSources'
};

/**
 * Last id of api object.
 *
 * @type {number}
 */
let id = 0;

/**
 * Adds given number to the numberOfParticipants property of given APIInstance.
 *
 * @param {JitsiMeetExternalAPI} APIInstance - The instance of the API.
 * @param {int} number - The number of participants to be added to
 * numberOfParticipants property (this parameter can be negative number if the
 * numberOfParticipants should be decreased).
 * @returns {void}
 */
function changeParticipantNumber(APIInstance, number) {
    APIInstance._numberOfParticipants += number;
}

/**
 * Generates the URL for the iframe.
 *
 * @param {string} domain - The domain name of the server that hosts the
 * conference.
 * @param {string} [options] - Another optional parameters.
 * @param {Object} [options.configOverwrite] - Object containing configuration
 * options defined in config.js to be overridden.
 * @param {Object} [options.interfaceConfigOverwrite] - Object containing
 * configuration options defined in interface_config.js to be overridden.
 * @param {string} [options.jwt] - The JWT token if needed by jitsi-meet for
 * authentication.
 * @param {string} [options.lang] - The meeting's default language.
 * @param {string} [options.roomName] - The name of the room to join.
 * @returns {string} The URL.
 */
function generateURL(domain, options = {}) {
    return urlObjectToString({
        ...options,
        url: `https://${domain}/#jitsi_meet_external_api_id=${id}`
    });
}

/**
 * Parses the arguments passed to the constructor. If the old format is used
 * the function translates the arguments to the new format.
 *
 * @param {Array} args - The arguments to be parsed.
 * @returns {Object} JS object with properties.
 */
function parseArguments(args) {
    if (!args.length) {
        return {};
    }

    const firstArg = args[0];

    switch (typeof firstArg) {
    case 'string': // old arguments format
    case 'undefined': {
        // Not sure which format but we are trying to parse the old
        // format because if the new format is used everything will be undefined
        // anyway.
        const [
            roomName,
            width,
            height,
            parentNode,
            configOverwrite,
            interfaceConfigOverwrite,
            jwt,
            onload,
            lang
        ] = args;

        return {
            roomName,
            width,
            height,
            parentNode,
            configOverwrite,
            interfaceConfigOverwrite,
            jwt,
            onload,
            lang
        };
    }
    case 'object': // new arguments format
        return args[0];
    default:
        throw new Error('Can\'t parse the arguments!');
    }
}

/**
 * Compute valid values for height and width. If a number is specified it's
 * treated as pixel units. If the value is expressed in px, em, pt or
 * percentage, it's used as is.
 *
 * @param {any} value - The value to be parsed.
 * @returns {string|undefined} The parsed value that can be used for setting
 * sizes through the style property. If invalid value is passed the method
 * returns undefined.
 */
function parseSizeParam(value) {
    let parsedValue;

    // This regex parses values of the form 100px, 100em, 100pt, 100vh, 100vw or 100%.
    // Values like 100 or 100px are handled outside of the regex, and
    // invalid values will be ignored and the minimum will be used.
    const re = /([0-9]*\.?[0-9]+)(em|pt|px|((d|l|s)?v)(h|w)|%)$/;

    if (typeof value === 'string' && String(value).match(re) !== null) {
        parsedValue = value;
    } else if (typeof value === 'number') {
        parsedValue = `${value}px`;
    }

    return parsedValue;
}


/**
 * The IFrame API interface class.
 */
export default class JitsiMeetExternalAPI extends EventEmitter {
    /**
     * Constructs new API instance. Creates iframe and loads Jitsi Meet in it.
     *
     * @param {string} domain - The domain name of the server that hosts the
     * conference.
     * @param {Object} [options] - Optional arguments.
     * @param {string} [options.roomName] - The name of the room to join.
     * @param {number|string} [options.width] - Width of the iframe. Check
     * parseSizeParam for format details.
     * @param {number|string} [options.height] - Height of the iframe. Check
     * parseSizeParam for format details.
     * @param {DOMElement} [options.parentNode] - The node that will contain the
     * iframe.
     * @param {Object} [options.configOverwrite] - Object containing
     * configuration options defined in config.js to be overridden.
     * @param {Object} [options.interfaceConfigOverwrite] - Object containing
     * configuration options defined in interface_config.js to be overridden.
     * @param {IIceServers} [options.iceServers] - Object with rules that will be used to modify/remove the existing
     * ice server configuration.
     * NOTE: This property is currently experimental and may be removed in the future!
     * @param {string} [options.jwt] - The JWT token if needed by jitsi-meet for
     * authentication.
     * @param {string} [options.lang] - The meeting's default language.
     * @param {string} [options.onload] - The onload function that will listen
     * for iframe onload event.
     * @param {Array<Object>} [options.invitees] - Array of objects containing
     * information about new participants that will be invited in the call.
     * @param {Array<Object>} [options.devices] - Array of objects containing
     * information about the initial devices that will be used in the call.
     * @param {Object} [options.userInfo] - Object containing information about
     * the participant opening the meeting.
     * @param {string}  [options.e2eeKey] - The key used for End-to-End encryption.
     * THIS IS EXPERIMENTAL.
     * @param {string}  [options.release] - The key used for specifying release if enabled on the backend.
     * @param {string} [options.sandbox] - Sandbox directive for the created iframe, if desired.
     */
    constructor(domain, ...args) {
        super();
        const {
            roomName = '',
            width = '100%',
            height = '100%',
            parentNode = document.body,
            configOverwrite = {},
            interfaceConfigOverwrite = {},
            jwt = undefined,
            lang = undefined,
            onload = undefined,
            invitees,
            iceServers,
            devices,
            userInfo,
            e2eeKey,
            release,
            sandbox = ''
        } = parseArguments(args);
        const localStorageContent = jitsiLocalStorage.getItem('jitsiLocalStorage');

        this._parentNode = parentNode;
        this._url = generateURL(domain, {
            configOverwrite,
            iceServers,
            interfaceConfigOverwrite,
            jwt,
            lang,
            roomName,
            devices,
            userInfo,
            appData: {
                localStorageContent
            },
            release
        });

        this._createIFrame(height, width, sandbox);

        this._transport = new Transport({
            backend: new PostMessageTransportBackend({
                postisOptions: {
                    allowedOrigin: new URL(this._url).origin,
                    scope: `jitsi_meet_external_api_${id}`,
                    window: this._frame.contentWindow
                }
            })
        });

        if (Array.isArray(invitees) && invitees.length > 0) {
            this.invite(invitees);
        }

        this._onload = onload;
        this._tmpE2EEKey = e2eeKey;
        this._isLargeVideoVisible = false;
        this._isPrejoinVideoVisible = false;
        this._numberOfParticipants = 0;
        this._participants = {};
        this._myUserID = undefined;
        this._onStageParticipant = undefined;
        this._setupListeners();
        id++;
    }

    /**
     * Creates the iframe element.
     *
     * @param {number|string} height - The height of the iframe. Check
     * parseSizeParam for format details.
     * @param {number|string} width - The with of the iframe. Check
     * parseSizeParam for format details.
     * @param {string} sandbox - Sandbox directive for the created iframe, if desired.
     * @returns {void}
     *
     * @private
     */
    _createIFrame(height, width, sandbox) {
        const frameName = `jitsiConferenceFrame${id}`;

        this._frame = document.createElement('iframe');
        this._frame.allow = [
            'autoplay',
            'camera',
            'clipboard-write',
            'compute-pressure',
            'display-capture',
            'hid',
            'microphone',
            'screen-wake-lock',
            'speaker-selection'
        ].join('; ');
        this._frame.name = frameName;
        this._frame.id = frameName;
        this._setSize(height, width);
        this._frame.setAttribute('allowFullScreen', 'true');
        this._frame.style.border = 0;

        if (sandbox) {
            this._frame.sandbox = sandbox;
        }

        this._frame.src = this._url;

        this._frame = this._parentNode.appendChild(this._frame);
    }

    /**
     * Returns arrays with the all resources for the always on top feature.
     *
     * @returns {Array<string>}
     */
    _getAlwaysOnTopResources() {
        const iframeWindow = this._frame.contentWindow;
        const iframeDocument = iframeWindow.document;
        let baseURL = '';
        const base = iframeDocument.querySelector('base');

        if (base && base.href) {
            baseURL = base.href;
        } else {
            const { protocol, host } = iframeWindow.location;

            baseURL = `${protocol}//${host}`;
        }

        return ALWAYS_ON_TOP_FILENAMES.map(
            filename => new URL(filename, baseURL).href
        );
    }

    /**
     * Returns the formatted display name of a participant.
     *
     * @param {string} participantId - The id of the participant.
     * @returns {string} The formatted display name.
     */
    _getFormattedDisplayName(participantId) {
        const { formattedDisplayName }
            = this._participants[participantId] || {};

        return formattedDisplayName;
    }

    /**
     * Returns the id of the on stage participant.
     *
     * @returns {string} - The id of the on stage participant.
     */
    _getOnStageParticipant() {
        return this._onStageParticipant;
    }


    /**
     * Getter for the large video element in Jitsi Meet.
     *
     * @returns {HTMLElement|undefined} - The large video.
     */
    _getLargeVideo() {
        const iframe = this.getIFrame();

        if (!this._isLargeVideoVisible
                || !iframe
                || !iframe.contentWindow
                || !iframe.contentWindow.document) {
            return;
        }

        return iframe.contentWindow.document.getElementById('largeVideo');
    }

    /**
     * Getter for the prejoin video element in Jitsi Meet.
     *
     * @returns {HTMLElement|undefined} - The prejoin video.
     */
    _getPrejoinVideo() {
        const iframe = this.getIFrame();

        if (!this._isPrejoinVideoVisible
                || !iframe
                || !iframe.contentWindow
                || !iframe.contentWindow.document) {
            return;
        }

        return iframe.contentWindow.document.getElementById('prejoinVideo');
    }

    /**
     * Getter for participant specific video element in Jitsi Meet.
     *
     * @param {string|undefined} participantId - Id of participant to return the video for.
     *
     * @returns {HTMLElement|undefined} - The requested video. Will return the local video
     * by default if participantId is undefined.
     */
    _getParticipantVideo(participantId) {
        const iframe = this.getIFrame();

        if (!iframe
                || !iframe.contentWindow
                || !iframe.contentWindow.document) {
            return;
        }

        if (typeof participantId === 'undefined' || participantId === this._myUserID) {
            return iframe.contentWindow.document.getElementById('localVideo_container');
        }

        return iframe.contentWindow.document.querySelector(`#participant_${participantId} video`);
    }

    /**
     * Sets the size of the iframe element.
     *
     * @param {number|string} height - The height of the iframe.
     * @param {number|string} width - The with of the iframe.
     * @returns {void}
     *
     * @private
     */
    _setSize(height, width) {
        const parsedHeight = parseSizeParam(height);
        const parsedWidth = parseSizeParam(width);

        if (parsedHeight !== undefined) {
            this._height = height;
            this._frame.style.height = parsedHeight;
        }

        if (parsedWidth !== undefined) {
            this._width = width;
            this._frame.style.width = parsedWidth;
        }
    }

    /**
     * Setups listeners that are used internally for JitsiMeetExternalAPI.
     *
     * @returns {void}
     *
     * @private
     */
    _setupListeners() {
        this._transport.on('event', ({ name, ...data }) => {
            const userID = data.id;

            switch (name) {
            case 'ready': {
                // Fake the iframe onload event because it's not reliable.
                this._onload?.();

                break;
            }
            case 'video-conference-joined': {
                if (typeof this._tmpE2EEKey !== 'undefined') {

                    const hexToBytes = hex => {
                        const bytes = [];

                        for (let c = 0; c < hex.length; c += 2) {
                            bytes.push(parseInt(hex.substring(c, c + 2), 16));
                        }

                        return bytes;
                    };

                    this.executeCommand('setMediaEncryptionKey', JSON.stringify({
                        exportedKey: hexToBytes(this._tmpE2EEKey),
                        index: 0
                    }));

                    this._tmpE2EEKey = undefined;
                }

                this._myUserID = userID;
                this._participants[userID] = {
                    email: data.email,
                    avatarURL: data.avatarURL
                };
            }

            // eslint-disable-next-line no-fallthrough
            case 'participant-joined': {
                this._participants[userID] = this._participants[userID] || {};
                this._participants[userID].displayName = data.displayName;
                this._participants[userID].formattedDisplayName
                    = data.formattedDisplayName;
                changeParticipantNumber(this, 1);
                break;
            }
            case 'participant-left':
                changeParticipantNumber(this, -1);
                delete this._participants[userID];
                break;
            case 'display-name-change': {
                const user = this._participants[userID];

                if (user) {
                    user.displayName = data.displayname;
                    user.formattedDisplayName = data.formattedDisplayName;
                }
                break;
            }
            case 'email-change': {
                const user = this._participants[userID];

                if (user) {
                    user.email = data.email;
                }
                break;
            }
            case 'avatar-changed': {
                const user = this._participants[userID];

                if (user) {
                    user.avatarURL = data.avatarURL;
                }
                break;
            }
            case 'on-stage-participant-changed':
                this._onStageParticipant = userID;
                this.emit('largeVideoChanged');
                break;
            case 'large-video-visibility-changed':
                this._isLargeVideoVisible = data.isVisible;
                this.emit('largeVideoChanged');
                break;
            case 'prejoin-screen-loaded':
                this._participants[userID] = {
                    displayName: data.displayName,
                    formattedDisplayName: data.formattedDisplayName
                };
                break;
            case 'on-prejoin-video-changed':
                this._isPrejoinVideoVisible = data.isVisible;
                this.emit('prejoinVideoChanged');
                break;
            case 'video-conference-left':
                changeParticipantNumber(this, -1);
                delete this._participants[this._myUserID];
                break;
            case 'video-quality-changed':
                this._videoQuality = data.videoQuality;
                break;
            case 'breakout-rooms-updated':
                this.updateNumberOfParticipants(data.rooms);
                break;
            case 'local-storage-changed':
                jitsiLocalStorage.setItem('jitsiLocalStorage', data.localStorageContent);

                // Since this is internal event we don't need to emit it to the consumer of the API.
                return true;
            }

            const eventName = events[name];

            if (eventName) {
                this.emit(eventName, data);

                return true;
            }

            return false;
        });

        this._transport.on('request', (request, callback) => {
            const requestName = requests[request.name];
            const data = {
                ...request,
                name: requestName
            };

            if (requestName) {
                this.emit(requestName, data, callback);
            }
        });
    }

    /**
     * Update number of participants based on all rooms.
     *
     * @param {Object} rooms - Rooms available rooms in the conference.
     * @returns {void}
     */
    updateNumberOfParticipants(rooms) {
        if (!rooms || !Object.keys(rooms).length) {
            return;
        }

        const allParticipants = Object.keys(rooms).reduce((prev, roomItemKey) => {
            if (rooms[roomItemKey]?.participants) {
                return Object.keys(rooms[roomItemKey].participants).length + prev;
            }

            return prev;
        }, 0);

        this._numberOfParticipants = allParticipants;
    }

    /**
     * Returns the rooms info in the conference.
     *
     * @returns {Object} Rooms info.
     */
    async getRoomsInfo() {
        return this._transport.sendRequest({
            name: 'rooms-info'
        });
    }

    /**
     * Returns whether the conference is P2P.
     *
     * @returns {Promise}
     */
    isP2pActive() {
        return this._transport.sendRequest({
            name: 'get-p2p-status'
        });
    }

    /**
     * Adds event listener to Meet Jitsi.
     *
     * @param {string} event - The name of the event.
     * @param {Function} listener - The listener.
     * @returns {void}
     *
     * @deprecated
     * NOTE: This method is not removed for backward comatability purposes.
     */
    addEventListener(event, listener) {
        this.on(event, listener);
    }

    /**
     * Adds event listeners to Meet Jitsi.
     *
     * @param {Object} listeners - The object key should be the name of
     * the event and value - the listener.
     * Currently we support the following
     * events:
     * {@code log} - receives event notifications whenever information has
     * been logged and has a log level specified within {@code config.apiLogLevels}.
     * The listener will receive object with the following structure:
     * {{
     * logLevel: the message log level
     * arguments: an array of strings that compose the actual log message
     * }}
     * {@code chatUpdated} - receives event notifications about chat state being
     * updated. The listener will receive object with the following structure:
     * {{
     *  'unreadCount': unreadCounter, // the unread message(s) counter,
     *  'isOpen': isOpen, // whether the chat panel is open or not
     * }}
     * {@code incomingMessage} - receives event notifications about incoming
     * messages. The listener will receive object with the following structure:
     * {{
     *  'from': from,//JID of the user that sent the message
     *  'nick': nick,//the nickname of the user that sent the message
     *  'message': txt//the text of the message
     * }}
     * {@code outgoingMessage} - receives event notifications about outgoing
     * messages. The listener will receive object with the following structure:
     * {{
     *  'message': txt//the text of the message
     * }}
     * {@code displayNameChanged} - receives event notifications about display
     * name change. The listener will receive object with the following
     * structure:
     * {{
     * jid: jid,//the JID of the participant that changed his display name
     * displayname: displayName //the new display name
     * }}
     * {@code participantJoined} - receives event notifications about new
     * participant.
     * The listener will receive object with the following structure:
     * {{
     * jid: jid //the jid of the participant
     * }}
     * {@code participantLeft} - receives event notifications about the
     * participant that left the room.
     * The listener will receive object with the following structure:
     * {{
     * jid: jid //the jid of the participant
     * }}
     * {@code videoConferenceJoined} - receives event notifications about the
     * local user has successfully joined the video conference.
     * The listener will receive object with the following structure:
     * {{
     * roomName: room //the room name of the conference
     * }}
     * {@code videoConferenceLeft} - receives event notifications about the
     * local user has left the video conference.
     * The listener will receive object with the following structure:
     * {{
     * roomName: room //the room name of the conference
     * }}
     * {@code screenSharingStatusChanged} - receives event notifications about
     * turning on/off the local user screen sharing.
     * The listener will receive object with the following structure:
     * {{
     * on: on //whether screen sharing is on
     * }}
     * {@code dominantSpeakerChanged} - receives event notifications about
     * change in the dominant speaker.
     * The listener will receive object with the following structure:
     * {{
     * id: participantId //participantId of the new dominant speaker
     * }}
     * {@code suspendDetected} - receives event notifications about detecting suspend event in host computer.
     * {@code readyToClose} - all hangup operations are completed and Jitsi Meet
     * is ready to be disposed.
     * @returns {void}
     *
     * @deprecated
     * NOTE: This method is not removed for backward comatability purposes.
     */
    addEventListeners(listeners) {
        for (const event in listeners) { // eslint-disable-line guard-for-in
            this.addEventListener(event, listeners[event]);
        }
    }

    /**
     * Captures the screenshot of the large video.
     *
     * @returns {Promise<string>} - Resolves with a base64 encoded image data of the screenshot
     * if large video is detected, an error otherwise.
     */
    captureLargeVideoScreenshot() {
        return this._transport.sendRequest({
            name: 'capture-largevideo-screenshot'
        });
    }

    /**
     * Removes the listeners and removes the Jitsi Meet frame.
     *
     * @returns {void}
     */
    dispose() {
        this.emit('_willDispose');
        this._transport.dispose();
        this.removeAllListeners();
        if (this._frame && this._frame.parentNode) {
            this._frame.parentNode.removeChild(this._frame);
        }
    }

    /**
     * Executes command. The available commands are:
     * {@code displayName} - Sets the display name of the local participant to
     * the value passed in the arguments array.
     * {@code subject} - Sets the subject of the conference, the value passed
     * in the arguments array. Note: Available only for moderator.
     *
     * {@code toggleAudio} - Mutes / unmutes audio with no arguments.
     * {@code toggleVideo} - Mutes / unmutes video with no arguments.
     * {@code toggleFilmStrip} - Hides / shows the filmstrip with no arguments.
     *
     * If the command doesn't require any arguments the parameter should be set
     * to empty array or it may be omitted.
     *
     * @param {string} name - The name of the command.
     * @returns {void}
     */
    executeCommand(name, ...args) {
        if (!(name in commands)) {
            console.error('Not supported command name.');

            return;
        }
        this._transport.sendEvent({
            data: args,
            name: commands[name]
        });
    }

    /**
     * Executes commands. The available commands are:
     * {@code displayName} - Sets the display name of the local participant to
     * the value passed in the arguments array.
     * {@code toggleAudio} - Mutes / unmutes audio. No arguments.
     * {@code toggleVideo} - Mutes / unmutes video. No arguments.
     * {@code toggleFilmStrip} - Hides / shows the filmstrip. No arguments.
     * {@code toggleChat} - Hides / shows chat. No arguments.
     * {@code toggleShareScreen} - Starts / stops screen sharing. No arguments.
     *
     * @param {Object} commandList - The object with commands to be executed.
     * The keys of the object are the commands that will be executed and the
     * values are the arguments for the command.
     * @returns {void}
     */
    executeCommands(commandList) {
        for (const key in commandList) { // eslint-disable-line guard-for-in
            this.executeCommand(key, commandList[key]);
        }
    }

    /**
     * Returns Promise that resolves with a list of available devices.
     *
     * @returns {Promise}
     */
    getAvailableDevices() {
        return getAvailableDevices(this._transport);
    }

    /**
     * Gets a list of the currently sharing participant id's.
     *
     * @returns {Promise} - Resolves with the list of participant id's currently sharing.
     */
    getContentSharingParticipants() {
        return this._transport.sendRequest({
            name: 'get-content-sharing-participants'
        });
    }

    /**
     * Returns Promise that resolves with current selected devices.
     *
     * @returns {Promise}
     */
    getCurrentDevices() {
        return getCurrentDevices(this._transport);
    }

    /**
     * Returns any custom avatars backgrounds.
     *
     * @returns {Promise} - Resolves with the list of custom avatar backgrounds.
     */
    getCustomAvatarBackgrounds() {
        return this._transport.sendRequest({
            name: 'get-custom-avatar-backgrounds'
        });
    }

    /**
     * Returns the current livestream url.
     *
     * @returns {Promise} - Resolves with the current livestream URL if exists, with
     * undefined if not and rejects on failure.
     */
    getLivestreamUrl() {
        return this._transport.sendRequest({
            name: 'get-livestream-url'
        });
    }

    /**
     * Returns the conference participants information.
     *
     * @returns {Array<Object>} - Returns an array containing participants
     * information like participant id, display name, avatar URL and email.
     */
    getParticipantsInfo() {
        const participantIds = Object.keys(this._participants);
        const participantsInfo = Object.values(this._participants);

        participantsInfo.forEach((participant, idx) => {
            participant.participantId = participantIds[idx];
        });

        return participantsInfo;
    }

    /**
     * Returns the current video quality setting.
     *
     * @returns {number}
     */
    getVideoQuality() {
        return this._videoQuality;
    }

    /**
     * Check if the audio is available.
     *
     * @returns {Promise} - Resolves with true if the audio available, with
     * false if not and rejects on failure.
     */
    isAudioAvailable() {
        return this._transport.sendRequest({
            name: 'is-audio-available'
        });
    }

    /**
     * Returns Promise that resolves with true if the device change is available
     * and with false if not.
     *
     * @param {string} [deviceType] - Values - 'output', 'input' or undefined.
     * Default - 'input'.
     * @returns {Promise}
     */
    isDeviceChangeAvailable(deviceType) {
        return isDeviceChangeAvailable(this._transport, deviceType);
    }

    /**
     * Returns Promise that resolves with true if the device list is available
     * and with false if not.
     *
     * @returns {Promise}
     */
    isDeviceListAvailable() {
        return isDeviceListAvailable(this._transport);
    }

    /**
     * Returns Promise that resolves with true if multiple audio input is supported
     * and with false if not.
     *
     * @returns {Promise}
     */
    isMultipleAudioInputSupported() {
        return isMultipleAudioInputSupported(this._transport);
    }

    /**
     * Invite people to the call.
     *
     * @param {Array<Object>} invitees - The invitees.
     * @returns {Promise} - Resolves on success and rejects on failure.
     */
    invite(invitees) {
        if (!Array.isArray(invitees) || invitees.length === 0) {
            return Promise.reject(new TypeError('Invalid Argument'));
        }

        return this._transport.sendRequest({
            name: 'invite',
            invitees
        });
    }

    /**
     * Returns the audio mute status.
     *
     * @returns {Promise} - Resolves with the audio mute status and rejects on
     * failure.
     */
    isAudioMuted() {
        return this._transport.sendRequest({
            name: 'is-audio-muted'
        });
    }

    /**
     * Returns the audio disabled status.
     *
     * @returns {Promise} - Resolves with the audio disabled status and rejects on
     * failure.
     */
    isAudioDisabled() {
        return this._transport.sendRequest({
            name: 'is-audio-disabled'
        });
    }

    /**
     * Returns the moderation on status on the given mediaType.
     *
     * @param {string} mediaType - The media type for which to check moderation.
     * @returns {Promise} - Resolves with the moderation on status and rejects on
     * failure.
     */
    isModerationOn(mediaType) {
        return this._transport.sendRequest({
            name: 'is-moderation-on',
            mediaType
        });
    }

    /**
     * Returns force muted status of the given participant id for the given media type.
     *
     * @param {string} participantId - The id of the participant to check.
     * @param {string} mediaType - The media type for which to check.
     * @returns {Promise} - Resolves with the force muted status and rejects on
     * failure.
     */
    isParticipantForceMuted(participantId, mediaType) {
        return this._transport.sendRequest({
            name: 'is-participant-force-muted',
            participantId,
            mediaType
        });
    }

    /**
     * Returns whether the participants pane is open.
     *
     * @returns {Promise} - Resolves with true if the participants pane is open
     * and with false if not.
     */
    isParticipantsPaneOpen() {
        return this._transport.sendRequest({
            name: 'is-participants-pane-open'
        });
    }

    /**
     * Returns screen sharing status.
     *
     * @returns {Promise} - Resolves with screensharing status and rejects on failure.
     */
    isSharingScreen() {
        return this._transport.sendRequest({
            name: 'is-sharing-screen'
        });
    }

    /**
     * Returns whether meeting is started silent.
     *
     * @returns {Promise} - Resolves with start silent status.
     */
    isStartSilent() {
        return this._transport.sendRequest({
            name: 'is-start-silent'
        });
    }

    /**
     * Returns the avatar URL of a participant.
     *
     * @param {string} participantId - The id of the participant.
     * @returns {string} The avatar URL.
     */
    getAvatarURL(participantId) {
        const { avatarURL } = this._participants[participantId] || {};

        return avatarURL;
    }

    /**
     * Gets the deployment info.
     *
     * @returns {Promise} - Resolves with the deployment info object.
     */
    getDeploymentInfo() {
        return this._transport.sendRequest({
            name: 'deployment-info'
        });
    }

    /**
     * Returns the display name of a participant.
     *
     * @param {string} participantId - The id of the participant.
     * @returns {string} The display name.
     */
    getDisplayName(participantId) {
        const { displayName } = this._participants[participantId] || {};

        return displayName;
    }

    /**
     * Returns the email of a participant.
     *
     * @param {string} participantId - The id of the participant.
     * @returns {string} The email.
     */
    getEmail(participantId) {
        const { email } = this._participants[participantId] || {};

        return email;
    }

    /**
     * Returns the iframe that loads Jitsi Meet.
     *
     * @returns {HTMLElement} The iframe.
     */
    getIFrame() {
        return this._frame;
    }

    /**
     * Returns the number of participants in the conference from all rooms. The local
     * participant is included.
     *
     * @returns {int} The number of participants in the conference.
     */
    getNumberOfParticipants() {
        return this._numberOfParticipants;
    }

    /**
     * Return the conference`s sessionId.
     *
     * @returns {Promise} - Resolves with the conference`s sessionId.
     */
    getSessionId() {
        return this._transport.sendRequest({
            name: 'session-id'
        });
    }

    /**
     * Returns array of commands supported by executeCommand().
     *
     * @returns {Array<string>} Array of commands.
     */
    getSupportedCommands() {
        return Object.keys(commands);
    }

    /**
     * Returns array of events supported by addEventListener().
     *
     * @returns {Array<string>} Array of events.
     */
    getSupportedEvents() {
        return Object.values(events);
    }

    /**
     * Check if the video is available.
     *
     * @returns {Promise} - Resolves with true if the video available, with
     * false if not and rejects on failure.
     */
    isVideoAvailable() {
        return this._transport.sendRequest({
            name: 'is-video-available'
        });
    }

    /**
     * Returns the audio mute status.
     *
     * @returns {Promise} - Resolves with the audio mute status and rejects on
     * failure.
     */
    isVideoMuted() {
        return this._transport.sendRequest({
            name: 'is-video-muted'
        });
    }

    /**
     * Returns the list of breakout rooms.
     *
     * @returns {Promise} Resolves with the list of breakout rooms.
     */
    listBreakoutRooms() {
        return this._transport.sendRequest({
            name: 'list-breakout-rooms'
        });
    }

    /**
     * Returns the state of availability electron share screen via external api.
     *
     * @returns {Promise}
     */
    _isNewElectronScreensharingSupported() {
        return this._transport.sendRequest({
            name: '_new_electron_screensharing_supported'
        });
    }

    /**
     * Pins a participant's video on to the stage view.
     *
     * @param {string} participantId - Participant id (JID) of the participant
     * that needs to be pinned on the stage view.
     * @param {string} [videoType] - Indicates the type of thumbnail to be pinned when multistream support is enabled.
     * Accepts "camera" or "desktop" values. Default is "camera". Any invalid values will be ignored and default will
     * be used.
     * @returns {void}
     */
    pinParticipant(participantId, videoType) {
        this.executeCommand('pinParticipant', participantId, videoType);
    }

    /**
     * Removes event listener.
     *
     * @param {string} event - The name of the event.
     * @returns {void}
     *
     * @deprecated
     * NOTE: This method is not removed for backward comatability purposes.
     */
    removeEventListener(event) {
        this.removeAllListeners(event);
    }

    /**
     * Removes event listeners.
     *
     * @param {Array<string>} eventList - Array with the names of the events.
     * @returns {void}
     *
     * @deprecated
     * NOTE: This method is not removed for backward comatability purposes.
     */
    removeEventListeners(eventList) {
        eventList.forEach(event => this.removeEventListener(event));
    }

    /**
     * Resizes the large video container as per the dimensions provided.
     *
     * @param {number} width - Width that needs to be applied on the large video container.
     * @param {number} height - Height that needs to be applied on the large video container.
     * @returns {void}
     */
    resizeLargeVideo(width, height) {
        if (width <= this._width && height <= this._height) {
            this.executeCommand('resizeLargeVideo', width, height);
        }
    }

    /**
     * Passes an event along to the local conference participant to establish
     * or update a direct peer connection. This is currently used for developing
     * wireless screensharing with room integration and it is advised against to
     * use as its api may change.
     *
     * @param {Object} event - An object with information to pass along.
     * @param {Object} event.data - The payload of the event.
     * @param {string} event.from - The jid of the sender of the event. Needed
     * when a reply is to be sent regarding the event.
     * @returns {void}
     */
    sendProxyConnectionEvent(event) {
        this._transport.sendEvent({
            data: [ event ],
            name: 'proxy-connection-event'
        });
    }

    /**
     * Sets the audio input device to the one with the label or id that is
     * passed.
     *
     * @param {string} label - The label of the new device.
     * @param {string} deviceId - The id of the new device.
     * @returns {Promise}
     */
    setAudioInputDevice(label, deviceId) {
        return setAudioInputDevice(this._transport, label, deviceId);
    }

    /**
     * Sets the audio output device to the one with the label or id that is
     * passed.
     *
     * @param {string} label - The label of the new device.
     * @param {string} deviceId - The id of the new device.
     * @returns {Promise}
     */
    setAudioOutputDevice(label, deviceId) {
        return setAudioOutputDevice(this._transport, label, deviceId);
    }

    /**
     * Displays the given participant on the large video. If no participant id is specified,
     * dominant and pinned speakers will be taken into consideration while selecting the
     * the large video participant.
     *
     * @param {string} participantId - Jid of the participant to be displayed on the large video.
     * @param {string} [videoType] - Indicates the type of video to be set when multistream support is enabled.
     * Accepts "camera" or "desktop" values. Default is "camera". Any invalid values will be ignored and default will
     * be used.
     * @returns {void}
     */
    setLargeVideoParticipant(participantId, videoType) {
        this.executeCommand('setLargeVideoParticipant', participantId, videoType);
    }

    /**
     * Sets the video input device to the one with the label or id that is
     * passed.
     *
     * @param {string} label - The label of the new device.
     * @param {string} deviceId - The id of the new device.
     * @returns {Promise}
     */
    setVideoInputDevice(label, deviceId) {
        return setVideoInputDevice(this._transport, label, deviceId);
    }

    /**
     * Starts a file recording or streaming session depending on the passed on params.
     * For RTMP streams, `rtmpStreamKey` must be passed on. `rtmpBroadcastID` is optional.
     * For youtube streams, `youtubeStreamKey` must be passed on. `youtubeBroadcastID` is optional.
     * For dropbox recording, recording `mode` should be `file` and a dropbox oauth2 token must be provided.
     * For file recording, recording `mode` should be `file` and optionally `shouldShare` could be passed on.
     * No other params should be passed.
     *
     * @param {Object} options - An object with config options to pass along.
     * @param { string } options.mode - Recording mode, either `file` or `stream`.
     * @param { string } options.dropboxToken - Dropbox oauth2 token.
     * @param { boolean } options.shouldShare - Whether the recording should be shared with the participants or not.
     * Only applies to certain jitsi meet deploys.
     * @param { string } options.rtmpStreamKey - The RTMP stream key.
     * @param { string } options.rtmpBroadcastID - The RTMP broadcast ID.
     * @param { string } options.youtubeStreamKey - The youtube stream key.
     * @param { string } options.youtubeBroadcastID - The youtube broadcast ID.
     * @param {Object } options.extraMetadata - Any extra metadata params for file recording.
     * @param { boolean } arg.transcription - Whether a transcription should be started or not.
     * @returns {void}
     */
    startRecording(options) {
        this.executeCommand('startRecording', options);
    }

    /**
     * Stops a recording or streaming session that is in progress.
     *
     * @param {string} mode - `file` or `stream`.
     * @param {boolean} transcription - Whether the transcription needs to be stopped.
     * @returns {void}
     */
    stopRecording(mode, transcription) {
        this.executeCommand('stopRecording', mode, transcription);
    }

    /**
     * Sets e2ee enabled/disabled.
     *
     * @param {boolean} enabled - The new value for e2ee enabled.
     * @returns {void}
     */
    toggleE2EE(enabled) {
        this.executeCommand('toggleE2EE', enabled);
    }

    /**
     * Sets the key and keyIndex for e2ee.
     *
     * @param {Object} keyInfo - Json containing key information.
     * @param {CryptoKey} [keyInfo.encryptionKey] - The encryption key.
     * @param {number} [keyInfo.index] - The index of the encryption key.
     * @returns {void}
     */
    async setMediaEncryptionKey(keyInfo) {
        const { key, index } = keyInfo;

        if (key) {
            const exportedKey = await crypto.subtle.exportKey('raw', key);

            this.executeCommand('setMediaEncryptionKey', JSON.stringify({
                exportedKey: Array.from(new Uint8Array(exportedKey)),
                index }));
        } else {
            this.executeCommand('setMediaEncryptionKey', JSON.stringify({
                exportedKey: false,
                index }));
        }
    }
}


################################################################################

## File: .\jitsi-meet\modules\API\external\functions.js

import Logger from '@jitsi/logger';

const logger = Logger.getLogger(__filename);

/**
 * Returns Promise that resolves with result an list of available devices.
 *
 * @param {Transport} transport - The @code{Transport} instance responsible for
 * the external communication.
 * @returns {Promise}
 */
export function getAvailableDevices(transport) {
    return transport.sendRequest({
        type: 'devices',
        name: 'getAvailableDevices'
    }).catch(e => {
        logger.error(e);

        return {};
    });
}

/**
 * Returns Promise that resolves with current selected devices.
 *
 * @param {Transport} transport - The @code{Transport} instance responsible for
 * the external communication.
 * @returns {Promise}
 */
export function getCurrentDevices(transport) {
    return transport.sendRequest({
        type: 'devices',
        name: 'getCurrentDevices'
    }).catch(e => {
        logger.error(e);

        return {};
    });
}

/**
 * Returns Promise that resolves with true if the device change is available
 * and with false if not.
 *
 * @param {Transport} transport - The @code{Transport} instance responsible for
 * the external communication.
 * @param {string} [deviceType] - Values - 'output', 'input' or undefined.
 * Default - 'input'.
 * @returns {Promise}
 */
export function isDeviceChangeAvailable(transport, deviceType) {
    return transport.sendRequest({
        deviceType,
        type: 'devices',
        name: 'isDeviceChangeAvailable'
    });
}

/**
 * Returns Promise that resolves with true if the device list is available
 * and with false if not.
 *
 * @param {Transport} transport - The @code{Transport} instance responsible for
 * the external communication.
 * @returns {Promise}
 */
export function isDeviceListAvailable(transport) {
    return transport.sendRequest({
        type: 'devices',
        name: 'isDeviceListAvailable'
    });
}

/**
 * Returns Promise that resolves with true if multiple audio input is supported
 * and with false if not.
 *
 * @param {Transport} transport - The @code{Transport} instance responsible for
 * the external communication.
 * @returns {Promise}
 */
export function isMultipleAudioInputSupported(transport) {
    return transport.sendRequest({
        type: 'devices',
        name: 'isMultipleAudioInputSupported'
    });
}

/**
 * Sets the audio input device to the one with the label or id that is passed.
 *
 * @param {Transport} transport - The @code{Transport} instance responsible for
 * the external communication.
 * @param {string} label - The label of the new device.
 * @param {string} id - The id of the new device.
 * @returns {Promise}
 */
export function setAudioInputDevice(transport, label, id) {
    return _setDevice(transport, {
        id,
        kind: 'audioinput',
        label
    });
}

/**
 * Sets the audio output device to the one with the label or id that is passed.
 *
 * @param {Transport} transport - The @code{Transport} instance responsible for
 * the external communication.
 * @param {string} label - The label of the new device.
 * @param {string} id - The id of the new device.
 * @returns {Promise}
 */
export function setAudioOutputDevice(transport, label, id) {
    return _setDevice(transport, {
        id,
        kind: 'audiooutput',
        label
    });
}

/**
 * Sets the currently used device to the one that is passed.
 *
 * @param {Transport} transport - The @code{Transport} instance responsible for
 * the external communication.
 * @param {Object} device - The new device to be used.
 * @returns {Promise}
 */
function _setDevice(transport, device) {
    return transport.sendRequest({
        type: 'devices',
        name: 'setDevice',
        device
    });
}

/**
 * Sets the video input device to the one with the label or id that is passed.
 *
 * @param {Transport} transport - The @code{Transport} instance responsible for
 * the external communication.
 * @param {string} label - The label of the new device.
 * @param {string} id - The id of the new device.
 * @returns {Promise}
 */
export function setVideoInputDevice(transport, label, id) {
    return _setDevice(transport, {
        id,
        kind: 'videoinput',
        label
    });
}


################################################################################

## File: .\jitsi-meet\modules\API\external\index.js

// For legacy purposes, preserve the UMD of the public API of Jitsi Meet
// external API (a.k.a. JitsiMeetExternalAPI).
module.exports = require('./external_api').default;


################################################################################

## File: .\jitsi-meet\modules\devices\mediaDeviceHelper.js

/* global APP, JitsiMeetJS */

import {
    notifyCameraError,
    notifyMicError
} from '../../react/features/base/devices/actions.web';
import {
    flattenAvailableDevices,
    getAudioOutputDeviceId
} from '../../react/features/base/devices/functions.web';
import { updateSettings } from '../../react/features/base/settings/actions';
import {
    getUserSelectedCameraDeviceId,
    getUserSelectedMicDeviceId,
    getUserSelectedOutputDeviceId
} from '../../react/features/base/settings/functions';

/**
 * Determines if currently selected audio output device should be changed after
 * list of available devices has been changed.
 * @param {MediaDeviceInfo[]} newDevices
 * @returns {string|undefined} - ID of new audio output device to use, undefined
 *      if audio output device should not be changed.
 */
function getNewAudioOutputDevice(newDevices) {
    if (!JitsiMeetJS.mediaDevices.isDeviceChangeAvailable('output')) {
        return;
    }

    const selectedAudioOutputDeviceId = getAudioOutputDeviceId();
    const availableAudioOutputDevices = newDevices.filter(
        d => d.kind === 'audiooutput');

    // Switch to 'default' audio output device if we don't have the selected one
    // available anymore.
    if (selectedAudioOutputDeviceId !== 'default'
        && !availableAudioOutputDevices.find(d =>
            d.deviceId === selectedAudioOutputDeviceId)) {
        return 'default';
    }

    const preferredAudioOutputDeviceId = getUserSelectedOutputDeviceId(APP.store.getState());

    // if the preferred one is not the selected and is available in the new devices
    // we want to use it as it was just added
    if (preferredAudioOutputDeviceId
        && preferredAudioOutputDeviceId !== selectedAudioOutputDeviceId
        && availableAudioOutputDevices.find(d => d.deviceId === preferredAudioOutputDeviceId)) {
        return preferredAudioOutputDeviceId;
    }
}

/**
 * Determines if currently selected audio input device should be changed after
 * list of available devices has been changed.
 * @param {MediaDeviceInfo[]} newDevices
 * @param {JitsiLocalTrack} localAudio
 * @param {boolean} newLabel
 * @returns {string|undefined} - ID of new microphone device to use, undefined
 *      if audio input device should not be changed.
 */
function getNewAudioInputDevice(newDevices, localAudio, newLabel) {
    const availableAudioInputDevices = newDevices.filter(
        d => d.kind === 'audioinput');
    const selectedAudioInputDeviceId = getUserSelectedMicDeviceId(APP.store.getState());
    const selectedAudioInputDevice = availableAudioInputDevices.find(
        d => d.deviceId === selectedAudioInputDeviceId);
    const localAudioDeviceId = localAudio?.getDeviceId();
    const localAudioDevice = availableAudioInputDevices.find(
        d => d.deviceId === localAudioDeviceId);

    // Here we handle case when no device was initially plugged, but
    // then it's connected OR new device was connected when previous
    // track has ended.
    if (!localAudio || localAudio.disposed || localAudio.isEnded()) {
        // If we have new audio device and permission to use it was granted
        // (label is not an empty string), then we will try to use the first
        // available device.
        if (selectedAudioInputDevice && selectedAudioInputDeviceId) {
            return selectedAudioInputDeviceId;
        } else if (availableAudioInputDevices.length
            && availableAudioInputDevices[0].label !== '') {
            return availableAudioInputDevices[0].deviceId;
        }
    } else if (selectedAudioInputDevice
        && selectedAudioInputDeviceId !== localAudioDeviceId) {

        if (newLabel) {
            // If a Firefox user with manual permission prompt chose a different
            // device from what we have stored as the preferred device we accept
            // and store that as the new preferred device.
            APP.store.dispatch(updateSettings({
                userSelectedMicDeviceId: localAudioDeviceId,
                userSelectedMicDeviceLabel: localAudioDevice.label
            }));
        } else {
            // And here we handle case when we already have some device working,
            // but we plug-in a "preferred" (previously selected in settings, stored
            // in local storage) device.
            return selectedAudioInputDeviceId;
        }
    }
}

/**
 * Determines if currently selected video input device should be changed after
 * list of available devices has been changed.
 * @param {MediaDeviceInfo[]} newDevices
 * @param {JitsiLocalTrack} localVideo
 * @param {boolean} newLabel
 * @returns {string|undefined} - ID of new camera device to use, undefined
 *      if video input device should not be changed.
 */
function getNewVideoInputDevice(newDevices, localVideo, newLabel) {
    const availableVideoInputDevices = newDevices.filter(
        d => d.kind === 'videoinput');
    const selectedVideoInputDeviceId = getUserSelectedCameraDeviceId(APP.store.getState());
    const selectedVideoInputDevice = availableVideoInputDevices.find(
        d => d.deviceId === selectedVideoInputDeviceId);
    const localVideoDeviceId = localVideo?.getDeviceId();
    const localVideoDevice = availableVideoInputDevices.find(
        d => d.deviceId === localVideoDeviceId);

    // Here we handle case when no video input device was initially plugged,
    // but then device is connected OR new device was connected when
    // previous track has ended.
    if (!localVideo || localVideo.disposed || localVideo.isEnded()) {
        // If we have new video device and permission to use it was granted
        // (label is not an empty string), then we will try to use the first
        // available device.
        if (selectedVideoInputDevice && selectedVideoInputDeviceId) {
            return selectedVideoInputDeviceId;
        } else if (availableVideoInputDevices.length
            && availableVideoInputDevices[0].label !== '') {
            return availableVideoInputDevices[0].deviceId;
        }
    } else if (selectedVideoInputDevice
            && selectedVideoInputDeviceId !== localVideoDeviceId) {

        if (newLabel) {
            // If a Firefox user with manual permission prompt chose a different
            // device from what we have stored as the preferred device we accept
            // and store that as the new preferred device.
            APP.store.dispatch(updateSettings({
                userSelectedCameraDeviceId: localVideoDeviceId,
                userSelectedCameraDeviceLabel: localVideoDevice.label
            }));
        } else {
            // And here we handle case when we already have some device working,
            // but we plug-in a "preferred" (previously selected in settings, stored
            // in local storage) device.
            return selectedVideoInputDeviceId;
        }
    }
}

export default {
    /**
     * Determines if currently selected media devices should be changed after
     * list of available devices has been changed.
     * @param {MediaDeviceInfo[]} newDevices
     * @param {JitsiLocalTrack} localVideo
     * @param {JitsiLocalTrack} localAudio
     * @returns {{
     *  audioinput: (string|undefined),
     *  videoinput: (string|undefined),
     *  audiooutput: (string|undefined)
     *  }}
     */
    getNewMediaDevicesAfterDeviceListChanged( // eslint-disable-line max-params
            newDevices,
            localVideo,
            localAudio,
            newLabels) {
        return {
            audioinput: getNewAudioInputDevice(newDevices, localAudio, newLabels),
            videoinput: getNewVideoInputDevice(newDevices, localVideo, newLabels),
            audiooutput: getNewAudioOutputDevice(newDevices)
        };
    },

    /**
     * Checks if the only difference between an object of known devices compared
     * to an array of new devices are only the labels for the devices.
     * @param {Object} oldDevices
     * @param {MediaDeviceInfo[]} newDevices
     * @returns {boolean}
     */
    newDeviceListAddedLabelsOnly(oldDevices, newDevices) {
        const oldDevicesFlattend = flattenAvailableDevices(oldDevices);

        if (oldDevicesFlattend.length !== newDevices.length) {
            return false;
        }
        oldDevicesFlattend.forEach(oldDevice => {
            if (oldDevice.label !== '') {
                return false;
            }
            const newDevice = newDevices.find(nd => nd.deviceId === oldDevice.deviceId);

            if (!newDevice || newDevice.label === '') {
                return false;
            }
        });

        return true;
    },

    /**
     * Tries to create new local tracks for new devices obtained after device
     * list changed. Shows error dialog in case of failures.
     * @param {function} createLocalTracks
     * @param {string} (cameraDeviceId)
     * @param {string} (micDeviceId)
     * @returns {Promise.<JitsiLocalTrack[]>}
     */
    createLocalTracksAfterDeviceListChanged(
            createLocalTracks,
            cameraDeviceId,
            micDeviceId) {
        let audioTrackError;
        let videoTrackError;
        const audioRequested = Boolean(micDeviceId);
        const videoRequested = Boolean(cameraDeviceId);

        if (audioRequested && videoRequested) {
            // First we try to create both audio and video tracks together.
            return (
                createLocalTracks({
                    devices: [ 'audio', 'video' ],
                    cameraDeviceId,
                    micDeviceId
                })

                // If we fail to do this, try to create them separately.
                .catch(() => Promise.all([
                    createAudioTrack(false).then(([ stream ]) => stream),
                    createVideoTrack(false).then(([ stream ]) => stream)
                ]))
                .then(tracks => {
                    if (audioTrackError) {
                        APP.store.dispatch(notifyMicError(audioTrackError));
                    }

                    if (videoTrackError) {
                        APP.store.dispatch(notifyCameraError(videoTrackError));
                    }

                    return tracks.filter(t => typeof t !== 'undefined');
                }));
        } else if (videoRequested && !audioRequested) {
            return createVideoTrack();
        } else if (audioRequested && !videoRequested) {
            return createAudioTrack();
        }

        return Promise.resolve([]);

        /**
         *
         */
        function createAudioTrack(showError = true) {
            return (
                createLocalTracks({
                    devices: [ 'audio' ],
                    cameraDeviceId: null,
                    micDeviceId
                })
                .catch(err => {
                    audioTrackError = err;
                    showError && APP.store.dispatch(notifyMicError(err));

                    return [];
                }));
        }

        /**
         *
         */
        function createVideoTrack(showError = true) {
            return (
                createLocalTracks({
                    devices: [ 'video' ],
                    cameraDeviceId,
                    micDeviceId: null
                })
                .catch(err => {
                    videoTrackError = err;
                    showError && APP.store.dispatch(notifyCameraError(err));

                    return [];
                }));
        }
    }
};


################################################################################

## File: .\jitsi-meet\modules\recorder\Recorder.js

/* global APP, config */

/**
 * The (name of the) command which transports the recorder info.
 */
const _USER_INFO_COMMAND = 'userinfo';

/**
 * The Recorder class is meant to take care of recorder related presence
 * commands.
 */
class Recorder {
    /**
     * Creates new recorder instance.
     */
    constructor() {
        if (config.iAmRecorder) {
            this._sendRecorderInfo();
        }
    }

    /**
     * Sends the information that this is a recorder through the presence.
     * @private
     */
    _sendRecorderInfo() {
        const commands = APP.conference.commands;

        // XXX The "Follow Me" command represents a snapshot of all states
        // which are to be followed so don't forget to removeCommand before
        // sendCommand!
        commands.removeCommand(_USER_INFO_COMMAND);
        commands.sendCommand(
            _USER_INFO_COMMAND,
            {
                attributes: {
                    xmlns: 'http://jitsi.org/jitmeet/userinfo',
                    robot: true
                }
            });
    }
}

export default Recorder;


################################################################################

## File: .\jitsi-meet\modules\translation\translation.js

import $ from 'jquery';
import jqueryI18next from 'jquery-i18next';

import i18next from '../../react/features/base/i18n/i18next';

/**
 * Notifies that the {@link i18next} instance has finished its initialization.
 *
 * @returns {void}
 * @private
 */
function _onI18nInitialized() {

    const documentElement
        = document.documentElement || {};

    $('[data-i18n]').localize();
    documentElement.lang = i18next.language;
}

/**
 *
 */
class Translation {
    /**
     *
     */
    constructor() {
        jqueryI18next.init(i18next, $, { useOptionsAttr: true });

        if (i18next.isInitialized) {
            _onI18nInitialized();
        } else {
            i18next.on('initialized', _onI18nInitialized);
        }

        i18next.on('languageChanged', _onI18nInitialized);
    }

    /**
     *
     */
    generateTranslationHTML(key, options) {
        const optAttr
            = options ? ` data-i18n-options='${JSON.stringify(options)}'` : '';

        // XXX i18next expects undefined if options are missing.
        const text = i18next.t(key, options ? options : undefined);

        return `<span data-i18n="${key}"${optAttr}>${text}</span>`;
    }

    /**
     *
     */
    translateElement(selector, options) {
        // XXX i18next expects undefined if options are missing.
        selector.localize(options ? options : undefined);
    }
}

export default new Translation();


################################################################################

## File: .\jitsi-meet\modules\transport\.eslintrc.js

module.exports = {
    'extends': '../../react/.eslintrc.js'
};


################################################################################

## File: .\jitsi-meet\modules\transport\index.js

// FIXME: change to '../API' when we update to webpack2. If we do this now all
// files from API modules will be included in external_api.js.
import { PostMessageTransportBackend, Transport } from '@jitsi/js-utils/transport';

import { getJitsiMeetGlobalNS } from '../../react/features/base/util/helpers';
import { API_ID } from '../API/constants';


export {
    PostMessageTransportBackend,
    Transport
};

/**
 * Option for the default low level transport.
 *
 * @type {Object}
 */
const postisOptions = {};

if (typeof API_ID === 'number') {
    postisOptions.scope = `jitsi_meet_external_api_${API_ID}`;
}

/**
 * The instance of Transport class that will be used by Jitsi Meet.
 *
 * @type {Transport}
 */
let transport;

/**
 * Returns the instance of Transport class that will be used by Jitsi Meet.
 *
 * @returns {Transport}
 */
export function getJitsiMeetTransport() {
    if (!transport) {
        transport = new Transport({ backend: new PostMessageTransportBackend({ postisOptions }) });
    }

    return transport;
}

/**
 * Sets the transport to passed transport.
 *
 * @param {Object} externalTransportBackend - The new transport.
 * @returns {void}
 */
getJitsiMeetGlobalNS().setExternalTransportBackend = externalTransportBackend =>
    transport.setBackend(externalTransportBackend);


################################################################################

## File: .\jitsi-meet\modules\UI\UI.js

/* global APP, config */


const UI = {};

import Logger from '@jitsi/logger';

import {
    conferenceWillInit
} from '../../react/features/base/conference/actions';
import { isMobileBrowser } from '../../react/features/base/environment/utils';
import { setColorAlpha } from '../../react/features/base/util/helpers';
import { sanitizeUrl } from '../../react/features/base/util/uri';
import { setDocumentUrl } from '../../react/features/etherpad/actions';
import {
    setNotificationsEnabled,
    showNotification
} from '../../react/features/notifications/actions';
import { NOTIFICATION_TIMEOUT_TYPE } from '../../react/features/notifications/constants';
import { joinLeaveNotificationsDisabled } from '../../react/features/notifications/functions';
import {
    dockToolbox,
    setToolboxEnabled,
    showToolbox
} from '../../react/features/toolbox/actions.web';

import EtherpadManager from './etherpad/Etherpad';
import UIUtil from './util/UIUtil';
import VideoLayout from './videolayout/VideoLayout';

const logger = Logger.getLogger(__filename);

let etherpadManager;

/**
 * Indicates if we're currently in full screen mode.
 *
 * @return {boolean} {true} to indicate that we're currently in full screen
 * mode, {false} otherwise
 */
UI.isFullScreen = function() {
    return UIUtil.isFullScreen();
};

/**
 * Initialize conference UI.
 */
UI.initConference = function() {
    UI.showToolbar();
};

/**
 * Starts the UI module and initializes all related components.
 */
UI.start = function() {
    APP.store.dispatch(conferenceWillInit());

    if (isMobileBrowser()) {
        document.body.classList.add('mobile-browser');
    } else {
        document.body.classList.add('desktop-browser');
    }

    if (config.backgroundAlpha !== undefined) {
        const backgroundColor = getComputedStyle(document.body).getPropertyValue('background-color');
        const alphaColor = setColorAlpha(backgroundColor, config.backgroundAlpha);

        document.body.style.backgroundColor = alphaColor;
    }

    if (config.iAmRecorder) {
        // in case of iAmSipGateway keep local video visible
        if (!config.iAmSipGateway) {
            APP.store.dispatch(setNotificationsEnabled(false));
        }

        APP.store.dispatch(setToolboxEnabled(false));
    }
};

/**
 * Handles etherpad click.
 */
UI.onEtherpadClicked = function() {
    etherpadManager && etherpadManager.toggleEtherpad();
};

/**
 *
 */
function onResize() {
    VideoLayout.onResize();
}

/**
 * Setup some DOM event listeners.
 */
UI.bindEvents = () => {
    // Resize and reposition videos in full screen mode.
    document.addEventListener('webkitfullscreenchange', onResize);
    document.addEventListener('mozfullscreenchange', onResize);
    document.addEventListener('fullscreenchange', onResize);

    window.addEventListener('resize', onResize);
};

/**
 * Unbind some DOM event listeners.
 */
UI.unbindEvents = () => {
    document.removeEventListener('webkitfullscreenchange', onResize);
    document.removeEventListener('mozfullscreenchange', onResize);
    document.removeEventListener('fullscreenchange', onResize);

    window.removeEventListener('resize', onResize);
};

/**
 * Setup and show Etherpad.
 * @param {string} name etherpad id
 */
UI.initEtherpad = name => {
    const etherpadBaseUrl = sanitizeUrl(config.etherpad_base);

    if (etherpadManager || !etherpadBaseUrl || !name) {
        return;
    }
    logger.log('Etherpad is enabled');

    etherpadManager = new EtherpadManager();

    const url = new URL(name, etherpadBaseUrl);

    APP.store.dispatch(setDocumentUrl(url.toString()));

    if (config.openSharedDocumentOnJoin) {
        etherpadManager.toggleEtherpad();
    }
};

/**
 * Returns the shared document manager object.
 * @return {EtherpadManager} the shared document manager object
 */
UI.getSharedDocumentManager = () => etherpadManager;

/**
 * Show user on UI.
 * @param {JitsiParticipant} user
 */
UI.addUser = function(user) {
    const status = user.getStatus();

    if (status) {
        // FIXME: move updateUserStatus in participantPresenceChanged action
        UI.updateUserStatus(user, status);
    }
};

/**
 * Updates the user status.
 *
 * @param {JitsiParticipant} user - The user which status we need to update.
 * @param {string} status - The new status.
 */
UI.updateUserStatus = (user, status) => {
    const reduxState = APP.store.getState() || {};
    const { calleeInfoVisible } = reduxState['features/invite'] || {};

    // We hide status updates when join/leave notifications are disabled,
    // as jigasi is the component with statuses and they are seen as join/leave notifications.
    if (!status || calleeInfoVisible || joinLeaveNotificationsDisabled()) {
        return;
    }

    const displayName = user.getDisplayName();

    APP.store.dispatch(showNotification({
        titleKey: `${displayName} connected`,
        descriptionKey: 'dialOut.statusMessage'
    }, NOTIFICATION_TIMEOUT_TYPE.SHORT));
};

/**
 * Sets muted video state for participant
 */
UI.setVideoMuted = function(id) {
    VideoLayout._updateLargeVideoIfDisplayed(id, true);

    if (APP.conference.isLocalId(id)) {
        APP.conference.updateVideoIconEnabled();
    }
};

UI.updateLargeVideo = (id, forceUpdate) => VideoLayout.updateLargeVideo(id, forceUpdate);

// Used by torture.
UI.showToolbar = timeout => APP.store.dispatch(showToolbox(timeout));

// Used by torture.
UI.dockToolbar = dock => APP.store.dispatch(dockToolbox(dock));

UI.handleLastNEndpoints = function(leavingIds, enteringIds) {
    VideoLayout.onLastNEndpointsChanged(leavingIds, enteringIds);
};

/**
 * Update audio level visualization for specified user.
 * @param {string} id user id
 * @param {number} lvl audio level
 */
UI.setAudioLevel = (id, lvl) => VideoLayout.setAudioLevel(id, lvl);

/**
 * Update list of available physical devices.
 */
UI.onAvailableDevicesChanged = function() {
    APP.conference.updateAudioIconEnabled();
    APP.conference.updateVideoIconEnabled();
};

/**
 * Returns the id of the current video shown on large.
 * Currently used by tests (torture).
 */
UI.getLargeVideoID = function() {
    return VideoLayout.getLargeVideoID();
};

/**
 * Returns the current video shown on large.
 * Currently used by tests (torture).
 */
UI.getLargeVideo = function() {
    return VideoLayout.getLargeVideo();
};

// TODO: Export every function separately. For now there is no point of doing
// this because we are importing everything.
export default UI;


################################################################################

## File: .\jitsi-meet\modules\UI\UIErrors.js

/**
 * A list of all UI errors.
 */

/**
 * Indicates that a Feedback request is currently in progress.
 *
 * @type {{FEEDBACK_REQUEST_IN_PROGRESS: string}}
 */
export const FEEDBACK_REQUEST_IN_PROGRESS = 'FeedbackRequestInProgress';

/**
 * Indicated an attempted audio only screen share session with no audio track present
 *
 * @type {{AUDIO_ONLY_SCREEN_SHARE_NO_TRACK: string}}
 */
export const AUDIO_ONLY_SCREEN_SHARE_NO_TRACK = 'AudioOnlyScreenShareNoTrack';


################################################################################

## File: .\jitsi-meet\modules\UI\audio_levels\AudioLevels.js

/* global interfaceConfig */

import UIUtil from '../util/UIUtil';

/**
 * Responsible for drawing audio levels.
 */
const AudioLevels = {
    /**
     * Updates the audio level of the large video.
     *
     * @param audioLevel the new audio level to set.
     */
    updateLargeVideoAudioLevel(elementId, audioLevel) {
        const element = document.getElementById(elementId);

        if (!UIUtil.isVisible(element)) {
            return;
        }

        let level = parseFloat(audioLevel);

        level = isNaN(level) ? 0 : level;

        let shadowElement = element.getElementsByClassName('dynamic-shadow');

        if (shadowElement && shadowElement.length > 0) {
            shadowElement = shadowElement[0];
        }

        shadowElement.style.boxShadow = this._updateLargeVideoShadow(level);
    },

    /**
     * Updates the large video shadow effect.
     */
    _updateLargeVideoShadow(level) {
        const scale = 2;

        // Internal circle audio level.
        const int = {
            level: level > 0.15 ? 20 : 0,
            color: interfaceConfig.AUDIO_LEVEL_PRIMARY_COLOR
        };

        // External circle audio level.
        const ext = {
            level: parseFloat(
                ((int.level * scale * level) + int.level).toFixed(0)),
            color: interfaceConfig.AUDIO_LEVEL_SECONDARY_COLOR
        };

        // Internal blur.
        int.blur = int.level ? 2 : 0;

        // External blur.
        ext.blur = ext.level ? 6 : 0;

        return [
            `0 0 ${int.blur}px ${int.level}px ${int.color}`,
            `0 0 ${ext.blur}px ${ext.level}px ${ext.color}`
        ].join(', ');
    }
};

export default AudioLevels;


################################################################################

## File: .\jitsi-meet\modules\UI\etherpad\Etherpad.js

/* global APP, interfaceConfig */

import $ from 'jquery';

import { setDocumentEditingState } from '../../../react/features/etherpad/actions';
import { getSharedDocumentUrl } from '../../../react/features/etherpad/functions';
import { getToolboxHeight } from '../../../react/features/toolbox/functions.web';
import Filmstrip from '../videolayout/Filmstrip';
import LargeContainer from '../videolayout/LargeContainer';
import VideoLayout from '../videolayout/VideoLayout';


/**
 * Default Etherpad frame width.
 */
const DEFAULT_WIDTH = 640;

/**
 * Default Etherpad frame height.
 */
const DEFAULT_HEIGHT = 480;

const ETHERPAD_CONTAINER_TYPE = 'etherpad';

/**
 * Container for Etherpad iframe.
 */
class Etherpad extends LargeContainer {
    /**
     * Creates new Etherpad object
     */
    constructor(url) {
        super();

        const iframe = document.createElement('iframe');

        iframe.id = 'etherpadIFrame';
        iframe.src = url;
        iframe.style.border = 0;
        iframe.scrolling = 'no';
        iframe.width = DEFAULT_WIDTH;
        iframe.height = DEFAULT_HEIGHT;
        iframe.setAttribute('style', 'visibility: hidden;');

        this.container.appendChild(iframe);

        this.iframe = iframe;
    }

    /**
     *
     */
    get isOpen() {
        return Boolean(this.iframe);
    }

    /**
     *
     */
    get container() {
        return document.getElementById('etherpad');
    }

    /**
     *
     */
    resize(containerWidth, containerHeight) {
        let height, width;

        if (interfaceConfig.VERTICAL_FILMSTRIP) {
            height = containerHeight - getToolboxHeight();
            width = containerWidth - Filmstrip.getVerticalFilmstripWidth();
        } else {
            height = containerHeight - Filmstrip.getFilmstripHeight();
            width = containerWidth;
        }

        $(this.iframe)
            .width(width)
            .height(height);
    }

    /**
     *
     */
    show() {
        const $iframe = $(this.iframe);
        const $container = $(this.container);
        const self = this;

        return new Promise(resolve => {
            $iframe.fadeIn(300, () => {
                self.bodyBackground = document.body.style.background;
                document.body.style.background = '#eeeeee';
                $iframe.css({ visibility: 'visible' });
                $container.css({ zIndex: 2 });

                APP.store.dispatch(setDocumentEditingState(true));

                resolve();
            });
        });
    }

    /**
     *
     */
    hide() {
        const $iframe = $(this.iframe);
        const $container = $(this.container);

        document.body.style.background = this.bodyBackground;

        return new Promise(resolve => {
            $iframe.fadeOut(300, () => {
                $iframe.css({ visibility: 'hidden' });
                $container.css({ zIndex: 0 });

                APP.store.dispatch(setDocumentEditingState(false));

                resolve();
            });
        });
    }

    /**
     * @return {boolean} do not switch on dominant speaker event if on stage.
     */
    stayOnStage() {
        return true;
    }
}

/**
 * Manager of the Etherpad frame.
 */
export default class EtherpadManager {
    /**
     *
     */
    constructor() {
        this.etherpad = null;
    }

    /**
     *
     */
    get isOpen() {
        return Boolean(this.etherpad);
    }

    /**
     *
     */
    isVisible() {
        return VideoLayout.isLargeContainerTypeVisible(ETHERPAD_CONTAINER_TYPE);
    }

    /**
     * Create new Etherpad frame.
     */
    openEtherpad() {
        this.etherpad = new Etherpad(getSharedDocumentUrl(APP.store.getState));
        VideoLayout.addLargeVideoContainer(
            ETHERPAD_CONTAINER_TYPE,
            this.etherpad
        );
    }

    /**
     * Toggle Etherpad frame visibility.
     * Open new Etherpad frame if there is no Etherpad frame yet.
     */
    toggleEtherpad() {
        if (!this.isOpen) {
            this.openEtherpad();
        }

        const isVisible = this.isVisible();

        VideoLayout.showLargeVideoContainer(
            ETHERPAD_CONTAINER_TYPE, !isVisible);

        APP.store.dispatch(setDocumentEditingState(!isVisible));
    }
}


################################################################################

## File: .\jitsi-meet\modules\UI\util\UIUtil.js

import $ from 'jquery';

/**
 * Created by hristo on 12/22/14.
 */
const UIUtil = {

    /**
     * Escapes the given text.
     */
    escapeHtml(unsafeText) {
        return $('<div/>').text(unsafeText)
            .html();
    },

    /**
     * Inserts given child element as the first one into the container.
     * @param container the container to which new child element will be added
     * @param newChild the new element that will be inserted into the container
     */
    prependChild(container, newChild) {
        const firstChild = container.childNodes[0];
        let result;

        if (firstChild) {
            result = container.insertBefore(newChild, firstChild);
        } else {
            result = container.appendChild(newChild);
        }

        return result;
    },

    /**
     * Indicates if we're currently in full screen mode.
     *
     * @return {boolean} {true} to indicate that we're currently in full screen
     * mode, {false} otherwise
     */
    isFullScreen() {
        return Boolean(document.fullscreenElement
            || document.mozFullScreenElement
            || document.webkitFullscreenElement
            || document.msFullscreenElement);
    },

    /**
     * Checks if the given DOM element is currently visible. The offsetParent
     * will be null if the "display" property of the element or any of its
     * parent containers is set to "none". This method will NOT check the
     * visibility property though.
     * @param {el} The DOM element we'd like to check for visibility
     */
    isVisible(el) {
        return el.offsetParent !== null;
    }
};

export default UIUtil;


################################################################################

## File: .\jitsi-meet\modules\UI\videolayout\Filmstrip.js

/* global APP, interfaceConfig */

import {
    getVerticalFilmstripVisibleAreaWidth,
    isFilmstripVisible
} from '../../../react/features/filmstrip/functions';

const Filmstrip = {
    /**
     * Returns the height of filmstrip
     * @returns {number} height
     */
    getFilmstripHeight() {
        // FIXME Make it more clear the getFilmstripHeight check is used in
        // horizontal film strip mode for calculating how tall large video
        // display should be.
        if (isFilmstripVisible(APP.store) && !interfaceConfig.VERTICAL_FILMSTRIP) {
            return document.querySelector('.filmstrip')?.offsetHeight ?? 0;
        }

        return 0;
    },

    /**
     * Returns the width of the vertical filmstrip if the filmstrip is visible and 0 otherwise.
     *
     * @returns {number} - The width of the vertical filmstrip if the filmstrip is visible and 0 otherwise.
     */
    getVerticalFilmstripWidth() {
        return isFilmstripVisible(APP.store) ? getVerticalFilmstripVisibleAreaWidth() : 0;
    }
};

export default Filmstrip;


################################################################################

## File: .\jitsi-meet\modules\UI\videolayout\LargeContainer.js


/**
 * Base class for all Large containers which we can show.
 */
export default class LargeContainer {
    /* eslint-disable no-unused-vars, no-empty-function */
    /**
     * Show this container.
     * @returns Promise
     */
    show() {
    }

    /**
     * Hide this container.
     * @returns Promise
     */
    hide() {
    }

    /**
     * Resize this container.
     * @param {number} containerWidth available width
     * @param {number} containerHeight available height
     * @param {boolean} animate if container should animate it's resize process
     */
    resize(containerWidth, containerHeight, animate) {
    }

    /**
     * Handler for "hover in" events.
     */
    onHoverIn(e) {
    }

    /**
     * Handler for "hover out" events.
     */
    onHoverOut(e) {
    }

    /**
     * Update video stream.
     * @param {string} userID
     * @param {JitsiTrack?} stream new stream
     * @param {string} videoType video type
     */
    setStream(userID, stream, videoType) {
    }

    /**
     * Show or hide user avatar.
     * @param {boolean} show
     */
    showAvatar(show) {
    }

    /**
     * Whether current container needs to be switched on dominant speaker event
     * when the container is on stage.
     * @return {boolean}
     */
    stayOnStage() {
    }

    /* eslint-enable no-unused-vars, no-empty-function */
}


################################################################################

## File: .\jitsi-meet\modules\UI\videolayout\LargeVideoManager.js

/* global APP */
/* eslint-disable no-unused-vars */
import Logger from '@jitsi/logger';
import $ from 'jquery';
import React from 'react';
import ReactDOM from 'react-dom';
import { I18nextProvider } from 'react-i18next';
import { Provider } from 'react-redux';

import { createScreenSharingIssueEvent } from '../../../react/features/analytics/AnalyticsEvents';
import { sendAnalytics } from '../../../react/features/analytics/functions';
import Avatar from '../../../react/features/base/avatar/components/Avatar';
import theme from '../../../react/features/base/components/themes/participantsPaneTheme.json';
import { getSsrcRewritingFeatureFlag } from '../../../react/features/base/config/functions.any';
import i18next from '../../../react/features/base/i18n/i18next';
import { JitsiTrackEvents } from '../../../react/features/base/lib-jitsi-meet';
import { VIDEO_TYPE } from '../../../react/features/base/media/constants';
import {
    getLocalParticipant,
    getParticipantById,
    getParticipantDisplayName,
    isLocalScreenshareParticipant,
    isScreenShareParticipant
} from '../../../react/features/base/participants/functions';
import { getHideSelfView } from '../../../react/features/base/settings/functions.any';
import { trackStreamingStatusChanged } from '../../../react/features/base/tracks/actions.any';
import { getVideoTrackByParticipant } from '../../../react/features/base/tracks/functions.any';
import { CHAT_SIZE } from '../../../react/features/chat/constants';
import {
    isTrackStreamingStatusActive,
    isTrackStreamingStatusInactive,
    isTrackStreamingStatusInterrupted
} from '../../../react/features/connection-indicator/functions';
import { FILMSTRIP_BREAKPOINT } from '../../../react/features/filmstrip/constants';
import { getVerticalViewMaxWidth, isFilmstripResizable } from '../../../react/features/filmstrip/functions';
import {
    updateKnownLargeVideoResolution
} from '../../../react/features/large-video/actions';
import { getParticipantsPaneOpen } from '../../../react/features/participants-pane/functions';
import PresenceLabel from '../../../react/features/presence-status/components/PresenceLabel';
import { shouldDisplayTileView } from '../../../react/features/video-layout/functions.any';
/* eslint-enable no-unused-vars */
import { createDeferred } from '../../util/helpers';
import AudioLevels from '../audio_levels/AudioLevels';

import { VIDEO_CONTAINER_TYPE, VideoContainer } from './VideoContainer';

const logger = Logger.getLogger(__filename);

const DESKTOP_CONTAINER_TYPE = 'desktop';

/**
 * Manager for all Large containers.
 */
export default class LargeVideoManager {
    /**
     * Checks whether given container is a {@link VIDEO_CONTAINER_TYPE}.
     * FIXME currently this is a workaround for the problem where video type is
     * mixed up with container type.
     * @param {string} containerType
     * @return {boolean}
     */
    static isVideoContainer(containerType) {
        return containerType === VIDEO_CONTAINER_TYPE
            || containerType === DESKTOP_CONTAINER_TYPE;
    }

    /**
     *
     */
    constructor() {
        /**
         * The map of <tt>LargeContainer</tt>s where the key is the video
         * container type.
         * @type {Object.<string, LargeContainer>}
         */
        this.containers = {};

        this.state = VIDEO_CONTAINER_TYPE;

        // FIXME: We are passing resizeContainer as parameter which is calling
        // Container.resize. Probably there's better way to implement this.
        this.videoContainer = new VideoContainer(() => this.resizeContainer(VIDEO_CONTAINER_TYPE));
        this.addContainer(VIDEO_CONTAINER_TYPE, this.videoContainer);

        // use the same video container to handle desktop tracks
        this.addContainer(DESKTOP_CONTAINER_TYPE, this.videoContainer);

        /**
         * The preferred width passed as an argument to {@link updateContainerSize}.
         *
         * @type {number|undefined}
         */
        this.preferredWidth = undefined;

        /**
         * The preferred height passed as an argument to {@link updateContainerSize}.
         *
         * @type {number|undefined}
         */
        this.preferredHeight = undefined;

        /**
         * The calculated width that will be used for the large video.
         * @type {number}
         */
        this.width = 0;

        /**
         * The calculated height that will be used for the large video.
         * @type {number}
         */
        this.height = 0;

        /**
         * Cache the aspect ratio of the video displayed to detect changes to
         * the aspect ratio on video resize events.
         *
         * @type {number}
         */
        this._videoAspectRatio = 0;

        /**
         * The video track in effect.
         * This is used to add and remove listeners on track streaming status change.
         *
         * @type {Object}
         */
        this.videoTrack = undefined;

        this.container = document.getElementById('largeVideoContainer');

        this.container.style.display = 'inline-block';

        this.container.addEventListener('mouseenter', e => this.onHoverIn(e));
        this.container.addEventListener('mouseleave', e => this.onHoverOut(e));

        // Bind event handler so it is only bound once for every instance.
        this._onVideoResolutionUpdate
            = this._onVideoResolutionUpdate.bind(this);

        this.videoContainer.addResizeListener(this._onVideoResolutionUpdate);

        this._dominantSpeakerAvatarContainer
            = document.getElementById('dominantSpeakerAvatarContainer');
    }

    /**
     * Removes any listeners registered on child components, including
     * React Components.
     *
     * @returns {void}
     */
    destroy() {
        this.videoContainer.removeResizeListener(this._onVideoResolutionUpdate);

        // Remove track streaming status listener.
        // TODO: when this class is converted to a function react component,
        // use a custom hook to update a local track streaming status.
        if (this.videoTrack && !this.videoTrack.local) {
            this.videoTrack.jitsiTrack.off(JitsiTrackEvents.TRACK_STREAMING_STATUS_CHANGED,
                this.handleTrackStreamingStatusChanged);
            APP.store.dispatch(trackStreamingStatusChanged(this.videoTrack.jitsiTrack,
                this.videoTrack.jitsiTrack.getTrackStreamingStatus()));
        }

        this.removePresenceLabel();

        ReactDOM.unmountComponentAtNode(this._dominantSpeakerAvatarContainer);

        this.container.style.display = 'none';
    }

    /**
     *
     */
    onHoverIn(e) {
        if (!this.state) {
            return;
        }
        const container = this.getCurrentContainer();

        container.onHoverIn(e);
    }

    /**
     *
     */
    onHoverOut(e) {
        if (!this.state) {
            return;
        }
        const container = this.getCurrentContainer();

        container.onHoverOut(e);
    }

    /**
     *
     */
    get id() {
        const container = this.getCurrentContainer();

        // If a user switch for large video is in progress then provide what
        // will be the end result of the update.
        if (this.updateInProcess
            && this.newStreamData
            && this.newStreamData.id !== container.id) {
            return this.newStreamData.id;
        }

        return container.id;
    }

    /**
     *
     */
    scheduleLargeVideoUpdate() {
        if (this.updateInProcess || !this.newStreamData) {
            return;
        }

        this.updateInProcess = true;

        // Include hide()/fadeOut if we're switching between users or between different sources of the same user.
        const container = this.getCurrentContainer();
        const isUserSwitch = container.id !== this.newStreamData.id
            || container.stream?.getSourceName() !== this.newStreamData.stream?.getSourceName();
        const preUpdate = isUserSwitch ? container.hide() : Promise.resolve();

        preUpdate.then(() => {
            const { id, stream, videoType, resolve } = this.newStreamData;

            this.newStreamData = null;

            const state = APP.store.getState();
            const shouldHideSelfView = getHideSelfView(state);
            const localId = getLocalParticipant(state)?.id;


            // FIXME this does not really make sense, because the videoType
            // (camera or desktop) is a completely different thing than
            // the video container type (Etherpad, SharedVideo, VideoContainer).
            const isVideoContainer = LargeVideoManager.isVideoContainer(videoType);

            logger.debug(`Scheduled large video update for ${id}`);
            this.state = videoType;
            // eslint-disable-next-line no-shadow
            const container = this.getCurrentContainer();

            if (shouldHideSelfView && localId === id) {
                return container.hide();
            }

            container.setStream(id, stream, videoType);

            // change the avatar url on large
            this.updateAvatar();

            const isVideoMuted = !stream || stream.isMuted();
            const participant = getParticipantById(state, id);
            const videoTrack = getVideoTrackByParticipant(state, participant);

            // Remove track streaming status listener from the old track and add it to the new track,
            // in order to stop updating track streaming status for the old track and start it for the new track.
            // TODO: when this class is converted to a function react component,
            // use a custom hook to update a local track streaming status.
            if (this.videoTrack?.jitsiTrack?.getSourceName() !== videoTrack?.jitsiTrack?.getSourceName()
                || this.videoTrack?.jitsiTrack?.isP2P !== videoTrack?.jitsiTrack?.isP2P) {
            // In the case where we switch from jvb to p2p when we need to switch the p2p and jvb track, they will be
            // with the same source name. In order to add the streaming status listener we need to check if the isP2P
            // flag is different. Without this check we won't have the correct stream status listener for the track.
            // Normally the Thumbnail and ConnectionIndicator components will update the streaming status the same way
            // and this may mask the problem. But if for some reason the update from the Thumbnail and
            // ConnectionIndicator components don't happen this may lead to showing the avatar instead of
            // the video because of the old track inactive streaming status.
                if (this.videoTrack && !this.videoTrack.local) {
                    this.videoTrack.jitsiTrack.off(JitsiTrackEvents.TRACK_STREAMING_STATUS_CHANGED,
                        this.handleTrackStreamingStatusChanged);
                    APP.store.dispatch(trackStreamingStatusChanged(this.videoTrack.jitsiTrack,
                        this.videoTrack.jitsiTrack.getTrackStreamingStatus()));
                }

                this.videoTrack = videoTrack;

                if (this.videoTrack && !this.videoTrack.local) {
                    this.videoTrack.jitsiTrack.on(JitsiTrackEvents.TRACK_STREAMING_STATUS_CHANGED,
                        this.handleTrackStreamingStatusChanged);
                    APP.store.dispatch(trackStreamingStatusChanged(this.videoTrack.jitsiTrack,
                        this.videoTrack.jitsiTrack.getTrackStreamingStatus()));
                }
            }
            const streamingStatusActive = isTrackStreamingStatusActive(videoTrack);
            const isVideoRenderable = !isVideoMuted
                && (APP.conference.isLocalId(id)
                    || isLocalScreenshareParticipant(participant)
                    || streamingStatusActive
                );

            const isAudioOnly = APP.conference.isAudioOnly();

            // Multi-stream is not supported on plan-b endpoints even if its is enabled via config.js. A virtual
            // screenshare tile is still created when a remote endpoint starts screenshare to keep the behavior
            // consistent and an avatar is displayed on the original participant thumbnail as long as screenshare is in
            // progress.
            const legacyScreenshare = videoType === VIDEO_TYPE.DESKTOP && !isScreenShareParticipant(participant);

            const showAvatar
                = isVideoContainer
                    && ((isAudioOnly && videoType !== VIDEO_TYPE.DESKTOP) || !isVideoRenderable || legacyScreenshare);

            logger.debug(`scheduleLargeVideoUpdate: Remote track ${videoTrack?.jitsiTrack}, isVideoMuted=${
                isVideoMuted}, streamingStatusActive=${streamingStatusActive}, isVideoRenderable=${
                isVideoRenderable}, showAvatar=${showAvatar}`);

            let promise;

            // do not show stream if video is muted
            // but we still should show watermark
            if (showAvatar) {
                this.showWatermark(true);

                // If the intention of this switch is to show the avatar
                // we need to make sure that the video is hidden
                promise = container.hide();

                if ((!shouldDisplayTileView(state) || participant?.pinned) // In theory the tile view may not be
                // enabled yet when we auto pin the participant.

                        && participant && !participant.local && !participant.fakeParticipant) {
                    // remote participant only

                    const track = getVideoTrackByParticipant(state, participant);

                    const isScreenSharing = track?.videoType === 'desktop';

                    if (isScreenSharing) {
                        // send the event
                        sendAnalytics(createScreenSharingIssueEvent({
                            source: 'large-video',
                            isVideoMuted,
                            isAudioOnly,
                            isVideoContainer,
                            videoType
                        }));
                    }
                }

            } else {
                promise = container.show();
            }

            // show the avatar on large if needed
            container.showAvatar(showAvatar);

            // Clean up audio level after previous speaker.
            if (showAvatar) {
                this.updateLargeVideoAudioLevel(0);
            }

            const messageKey = isTrackStreamingStatusInactive(videoTrack) ? 'connection.LOW_BANDWIDTH' : null;

            // Do not show connection status message in the audio only mode,
            // because it's based on the video playback status.
            const overrideAndHide = APP.conference.isAudioOnly();

            this.updateParticipantConnStatusIndication(
                    id,
                    !overrideAndHide && messageKey);

            // Change the participant id the presence label is listening to.
            this.updatePresenceLabel(id);

            this.videoContainer.positionRemoteStatusMessages();

            // resolve updateLargeVideo promise after everything is done
            promise.then(resolve);

            return promise;
        }).then(() => {
            // after everything is done check again if there are any pending
            // new streams.
            this.updateInProcess = false;
            this.scheduleLargeVideoUpdate();
        });
    }

    /**
     * Handle track streaming status change event by
     * by dispatching an action to update track streaming status for the given track in app state.
     *
     * @param {JitsiTrack} jitsiTrack the track with streaming status updated
     * @param {JitsiTrackStreamingStatus} streamingStatus the updated track streaming status
     *
     * @private
     */
    handleTrackStreamingStatusChanged(jitsiTrack, streamingStatus) {
        APP.store.dispatch(trackStreamingStatusChanged(jitsiTrack, streamingStatus));
    }

    /**
     * Shows/hides notification about participant's connectivity issues to be
     * shown on the large video area.
     *
     * @param {string} id the id of remote participant(MUC nickname)
     * @param {string|null} messageKey the i18n key of the message which will be
     * displayed on the large video or <tt>null</tt> to hide it.
     *
     * @private
     */
    updateParticipantConnStatusIndication(id, messageKey) {
        const state = APP.store.getState();

        if (messageKey) {
            // Get user's display name
            const displayName
                = getParticipantDisplayName(state, id);

            this._setRemoteConnectionMessage(
                messageKey,
                { displayName });

            // Show it now only if the VideoContainer is on top
            this.showRemoteConnectionMessage(
                LargeVideoManager.isVideoContainer(this.state));
        } else {
            // Hide the message
            this.showRemoteConnectionMessage(false);
        }

    }

    /**
     * Update large video.
     * Switches to large video even if previously other container was visible.
     * @param userID the userID of the participant associated with the stream
     * @param {JitsiTrack?} stream new stream
     * @param {string?} videoType new video type
     * @returns {Promise}
     */
    updateLargeVideo(userID, stream, videoType) {
        if (this.newStreamData) {
            this.newStreamData.reject();
        }

        this.newStreamData = createDeferred();
        this.newStreamData.id = userID;
        this.newStreamData.stream = stream;
        this.newStreamData.videoType = videoType;

        this.scheduleLargeVideoUpdate();

        return this.newStreamData.promise;
    }

    /**
     * Update container size.
     */
    updateContainerSize(width, height) {
        if (typeof width === 'number') {
            this.preferredWidth = width;
        }
        if (typeof height === 'number') {
            this.preferredHeight = height;
        }

        let widthToUse = this.preferredWidth || window.innerWidth;
        const state = APP.store.getState();
        const { isOpen } = state['features/chat'];
        const { width: filmstripWidth, visible } = state['features/filmstrip'];
        const isParticipantsPaneOpen = getParticipantsPaneOpen(state);
        const resizableFilmstrip = isFilmstripResizable(state);

        if (isParticipantsPaneOpen) {
            widthToUse -= theme.participantsPaneWidth;
        }

        if (isOpen && window.innerWidth > 580) {
            /**
             * If chat state is open, we re-compute the container width
             * by subtracting the default width of the chat.
             */
            widthToUse -= CHAT_SIZE;
        }

        if (resizableFilmstrip && visible && filmstripWidth.current >= FILMSTRIP_BREAKPOINT) {
            widthToUse -= getVerticalViewMaxWidth(state);
        }

        this.width = widthToUse;
        this.height = this.preferredHeight || window.innerHeight;
    }

    /**
     * Resize Large container of specified type.
     * @param {string} type type of container which should be resized.
     * @param {boolean} [animate=false] if resize process should be animated.
     */
    resizeContainer(type, animate = false) {
        const container = this.getContainer(type);

        container.resize(this.width, this.height, animate);
    }

    /**
     * Resize all Large containers.
     * @param {boolean} animate if resize process should be animated.
     */
    resize(animate) {
        // resize all containers
        Object.keys(this.containers)
            .forEach(type => this.resizeContainer(type, animate));
    }

    /**
     * Updates the src of the dominant speaker avatar
     */
    updateAvatar() {
        ReactDOM.render(
            <Provider store = { APP.store }>
                <Avatar
                    id = "dominantSpeakerAvatar"
                    participantId = { this.id }
                    size = { 200 } />
            </Provider>,
            this._dominantSpeakerAvatarContainer
        );
    }

    /**
     * Updates the audio level indicator of the large video.
     *
     * @param lvl the new audio level to set
     */
    updateLargeVideoAudioLevel(lvl) {
        AudioLevels.updateLargeVideoAudioLevel('dominantSpeaker', lvl);
    }

    /**
     * Displays a message of the passed in participant id's presence status. The
     * message will not display if the remote connection message is displayed.
     *
     * @param {string} id - The participant ID whose associated user's presence
     * status should be displayed.
     * @returns {void}
     */
    updatePresenceLabel(id) {
        const isConnectionMessageVisible = getComputedStyle(
            document.getElementById('remoteConnectionMessage')).display !== 'none';

        if (isConnectionMessageVisible) {
            this.removePresenceLabel();

            return;
        }

        const presenceLabelContainer = document.getElementById('remotePresenceMessage');

        if (presenceLabelContainer) {
            ReactDOM.render(
                <Provider store = { APP.store }>
                    <I18nextProvider i18n = { i18next }>
                        <PresenceLabel
                            participantID = { id }
                            className = 'presence-label' />
                    </I18nextProvider>
                </Provider>,
                presenceLabelContainer);
        }
    }

    /**
     * Removes the messages about the displayed participant's presence status.
     *
     * @returns {void}
     */
    removePresenceLabel() {
        const presenceLabelContainer = document.getElementById('remotePresenceMessage');

        if (presenceLabelContainer) {
            ReactDOM.unmountComponentAtNode(presenceLabelContainer);
        }
    }

    /**
     * Show or hide watermark.
     * @param {boolean} show
     */
    showWatermark(show) {
        const watermark = document.querySelectorAll('.watermark');

        watermark.forEach(el => {
            el.style.visibility = show ? 'visible' : 'hidden';
        });
    }

    /**
     * Shows hides the "avatar" message which is to be displayed either in
     * the middle of the screen or below the avatar image.
     *
     * @param {boolean|undefined} [show=undefined] <tt>true</tt> to show
     * the avatar message or <tt>false</tt> to hide it. If not provided then
     * the connection status of the user currently on the large video will be
     * obtained form "APP.conference" and the message will be displayed if
     * the user's connection is either interrupted or inactive.
     */
    showRemoteConnectionMessage(show) {
        if (typeof show !== 'boolean') {
            const participant = getParticipantById(APP.store.getState(), this.id);
            const state = APP.store.getState();
            const videoTrack = getVideoTrackByParticipant(state, participant);

            // eslint-disable-next-line no-param-reassign
            show = !APP.conference.isLocalId(this.id)
                && (isTrackStreamingStatusInterrupted(videoTrack) || isTrackStreamingStatusInactive(videoTrack));
        }

        if (show) {
            document.getElementById('remoteConnectionMessage').style.display = 'block';
        } else {
            document.getElementById('remoteConnectionMessage').style.display = 'none';
        }
    }

    /**
     * Updates the text which describes that the remote user is having
     * connectivity issues.
     *
     * @param {string} msgKey the translation key which will be used to get
     * the message text.
     * @param {object} msgOptions translation options object.
     *
     * @private
     */
    _setRemoteConnectionMessage(msgKey, msgOptions) {
        if (msgKey) {
            $('#remoteConnectionMessage')
                .attr('data-i18n', msgKey)
                .attr('data-i18n-options', JSON.stringify(msgOptions));
            APP.translation.translateElement(
                $('#remoteConnectionMessage'), msgOptions);
        }
    }

    /**
     * Add container of specified type.
     * @param {string} type container type
     * @param {LargeContainer} container container to add.
     */
    addContainer(type, container) {
        if (this.containers[type]) {
            throw new Error(`container of type ${type} already exist`);
        }

        this.containers[type] = container;
        this.resizeContainer(type);
    }

    /**
     * Get Large container of specified type.
     * @param {string} type container type.
     * @returns {LargeContainer}
     */
    getContainer(type) {
        const container = this.containers[type];

        if (!container) {
            throw new Error(`container of type ${type} doesn't exist`);
        }

        return container;
    }

    /**
     * Returns {@link LargeContainer} for the current {@link state}
     *
     * @return {LargeContainer}
     *
     * @throws an <tt>Error</tt> if there is no container for the current
     * {@link state}.
     */
    getCurrentContainer() {
        return this.getContainer(this.state);
    }

    /**
     * Returns type of the current {@link LargeContainer}
     * @return {string}
     */
    getCurrentContainerType() {
        return this.state;
    }

    /**
     * Remove Large container of specified type.
     * @param {string} type container type.
     */
    removeContainer(type) {
        if (!this.containers[type]) {
            throw new Error(`container of type ${type} doesn't exist`);
        }

        delete this.containers[type];
    }

    /**
     * Show Large container of specified type.
     * Does nothing if such container is already visible.
     * @param {string} type container type.
     * @returns {Promise}
     */
    showContainer(type) {
        if (this.state === type) {
            return Promise.resolve();
        }

        const oldContainer = this.containers[this.state];

        // FIXME when video is being replaced with other content we need to hide
        // companion icons/messages. It would be best if the container would
        // be taking care of it by itself, but that is a bigger refactoring

        if (LargeVideoManager.isVideoContainer(this.state)) {
            this.showWatermark(false);
            this.showRemoteConnectionMessage(false);
        }
        oldContainer.hide();

        this.state = type;
        const container = this.getContainer(type);

        return container.show().then(() => {
            if (LargeVideoManager.isVideoContainer(type)) {
                // FIXME when video appears on top of other content we need to
                // show companion icons/messages. It would be best if
                // the container would be taking care of it by itself, but that
                // is a bigger refactoring
                this.showWatermark(true);

                // "avatar" and "video connection" can not be displayed both
                // at the same time, but the latter is of higher priority and it
                // will hide the avatar one if will be displayed.
                this.showRemoteConnectionMessage(/* fetch the current state */);
            }
        });
    }

    /**
     * Changes the flipX state of the local video.
     * @param val {boolean} true if flipped.
     */
    onLocalFlipXChange(val) {
        this.videoContainer.setLocalFlipX(val);
    }

    /**
     * Dispatches an action to update the known resolution state of the large video and adjusts container sizes when the
     * resolution changes.
     *
     * @private
     * @returns {void}
     */
    _onVideoResolutionUpdate() {
        const { height, width } = this.videoContainer.getStreamSize();
        const { resolution } = APP.store.getState()['features/large-video'];

        if (height !== resolution) {
            APP.store.dispatch(updateKnownLargeVideoResolution(height));
        }

        const currentAspectRatio = height === 0 ? 0 : width / height;

        if (this._videoAspectRatio !== currentAspectRatio) {
            this._videoAspectRatio = currentAspectRatio;
            this.resize();
        }
    }
}


################################################################################

## File: .\jitsi-meet\modules\UI\videolayout\VideoContainer.js

/* global APP, interfaceConfig */

/* eslint-disable no-unused-vars */
import Logger from '@jitsi/logger';
import $ from 'jquery';
import React from 'react';
import ReactDOM from 'react-dom';

import { browser } from '../../../react/features/base/lib-jitsi-meet';
import { FILMSTRIP_BREAKPOINT } from '../../../react/features/filmstrip/constants';
import { setLargeVideoDimensions } from '../../../react/features/large-video/actions.any';
import { LargeVideoBackground, ORIENTATION } from '../../../react/features/large-video/components/LargeVideoBackground';
import { LAYOUTS } from '../../../react/features/video-layout/constants';
import { getCurrentLayout } from '../../../react/features/video-layout/functions.any';
/* eslint-enable no-unused-vars */
import UIUtil from '../util/UIUtil';

import Filmstrip from './Filmstrip';
import LargeContainer from './LargeContainer';

// FIXME should be 'video'
export const VIDEO_CONTAINER_TYPE = 'camera';

// Corresponds to animation duration from the animatedFadeIn and animatedFadeOut CSS classes.
const FADE_DURATION_MS = 300;

const logger = Logger.getLogger(__filename);

/**
 * List of container events that we are going to process for the large video.
 *
 * NOTE: Currently used only for logging for debug purposes.
 */
const containerEvents = [ 'abort', 'canplaythrough', 'ended', 'error', 'stalled', 'suspend', 'waiting' ];

/**
 * Returns an array of the video dimensions, so that it keeps it's aspect
 * ratio and fits available area with it's larger dimension. This method
 * ensures that whole video will be visible and can leave empty areas.
 *
 * @param videoWidth the width of the video to position
 * @param videoHeight the height of the video to position
 * @param videoSpaceWidth the width of the available space
 * @param videoSpaceHeight the height of the available space
 * @param subtractFilmstrip whether to subtract the filmstrip or not
 * @return an array with 2 elements, the video width and the video height
 */
function computeDesktopVideoSize( // eslint-disable-line max-params
        videoWidth,
        videoHeight,
        videoSpaceWidth,
        videoSpaceHeight,
        subtractFilmstrip) {
    if (videoWidth === 0 || videoHeight === 0 || videoSpaceWidth === 0 || videoSpaceHeight === 0) {
        // Avoid NaN values caused by division by 0.
        return [ 0, 0 ];
    }

    const aspectRatio = videoWidth / videoHeight;
    let availableWidth = Math.max(videoWidth, videoSpaceWidth);
    let availableHeight = Math.max(videoHeight, videoSpaceHeight);

    if (interfaceConfig.VERTICAL_FILMSTRIP) {
        if (subtractFilmstrip) {
            // eslint-disable-next-line no-param-reassign
            videoSpaceWidth -= Filmstrip.getVerticalFilmstripWidth();
        }
    } else {
        // eslint-disable-next-line no-param-reassign
        videoSpaceHeight -= Filmstrip.getFilmstripHeight();
    }

    if (availableWidth / aspectRatio >= videoSpaceHeight) {
        availableHeight = videoSpaceHeight;
        availableWidth = availableHeight * aspectRatio;
    }

    if (availableHeight * aspectRatio >= videoSpaceWidth) {
        availableWidth = videoSpaceWidth;
        availableHeight = availableWidth / aspectRatio;
    }

    return [ availableWidth, availableHeight ];
}


/**
 * Returns an array of the video dimensions. It respects the
 * VIDEO_LAYOUT_FIT config, to fit the video to the screen, by hiding some parts
 * of it, or to fit it to the height or width.
 *
 * @param videoWidth the original video width
 * @param videoHeight the original video height
 * @param videoSpaceWidth the width of the video space
 * @param videoSpaceHeight the height of the video space
 * @return an array with 2 elements, the video width and the video height
 */
function computeCameraVideoSize( // eslint-disable-line max-params
        videoWidth,
        videoHeight,
        videoSpaceWidth,
        videoSpaceHeight,
        videoLayoutFit) {
    if (videoWidth === 0 || videoHeight === 0 || videoSpaceWidth === 0 || videoSpaceHeight === 0) {
        // Avoid NaN values caused by division by 0.
        return [ 0, 0 ];
    }

    const aspectRatio = videoWidth / videoHeight;
    const videoSpaceRatio = videoSpaceWidth / videoSpaceHeight;

    switch (videoLayoutFit) {
    case 'height':
        return [ videoSpaceHeight * aspectRatio, videoSpaceHeight ];
    case 'width':
        return [ videoSpaceWidth, videoSpaceWidth / aspectRatio ];
    case 'nocrop':
        return computeCameraVideoSize(
            videoWidth,
            videoHeight,
            videoSpaceWidth,
            videoSpaceHeight,
            videoSpaceRatio < aspectRatio ? 'width' : 'height');
    case 'both': {
        const maxZoomCoefficient = interfaceConfig.MAXIMUM_ZOOMING_COEFFICIENT
            || Infinity;

        if (videoSpaceRatio === aspectRatio) {
            return [ videoSpaceWidth, videoSpaceHeight ];
        }

        let [ width, height ] = computeCameraVideoSize(
            videoWidth,
            videoHeight,
            videoSpaceWidth,
            videoSpaceHeight,
            videoSpaceRatio < aspectRatio ? 'height' : 'width');
        const maxWidth = videoSpaceWidth * maxZoomCoefficient;
        const maxHeight = videoSpaceHeight * maxZoomCoefficient;

        if (width > maxWidth) {
            width = maxWidth;
            height = width / aspectRatio;
        } else if (height > maxHeight) {
            height = maxHeight;
            width = height * aspectRatio;
        }

        return [ width, height ];
    }
    default:
        return [ videoWidth, videoHeight ];
    }
}

/**
 * Returns an array of the video horizontal and vertical indents,
 * so that if fits its parent.
 *
 * @return an array with 2 elements, the horizontal indent and the vertical
 * indent
 */
function getCameraVideoPosition( // eslint-disable-line max-params
        videoWidth,
        videoHeight,
        videoSpaceWidth,
        videoSpaceHeight) {
    // Parent height isn't completely calculated when we position the video in
    // full screen mode and this is why we use the screen height in this case.
    // Need to think it further at some point and implement it properly.
    if (UIUtil.isFullScreen()) {
        // eslint-disable-next-line no-param-reassign
        videoSpaceHeight = window.innerHeight;
    }

    const horizontalIndent = (videoSpaceWidth - videoWidth) / 2;
    const verticalIndent = (videoSpaceHeight - videoHeight) / 2;

    return { horizontalIndent,
        verticalIndent };
}

/**
 * Container for user video.
 */
export class VideoContainer extends LargeContainer {
    /**
     *
     */
    get video() {
        return document.getElementById('largeVideo');
    }

    /**
     *
     */
    get id() {
        return this.userId;
    }

    /**
     * Creates new VideoContainer instance.
     * @param resizeContainer {Function} function that takes care of the size
     * of the video container.
     */
    constructor(resizeContainer) {
        super();
        this.stream = null;
        this.userId = null;
        this.videoType = null;
        this.localFlipX = true;
        this.resizeContainer = resizeContainer;

        /**
         * Whether the background should fit the height of the container
         * (portrait) or fit the width of the container (landscape).
         *
         * @private
         * @type {string|null}
         */
        this._backgroundOrientation = null;

        /**
         * Flag indicates whether or not the background should be rendered.
         * If the background will not be visible then it is hidden to save
         * on performance.
         * @type {boolean}
         */
        this._hideBackground = true;

        this._isHidden = false;

        /**
         * Flag indicates whether or not the avatar is currently displayed.
         * @type {boolean}
         */
        this.avatarDisplayed = false;
        this.avatar = document.getElementById('dominantSpeaker');

        /**
         * The HTMLElements of the remote connection message.
         * @type {HTMLElement}
         */
        this.remoteConnectionMessage = document.getElementById('remoteConnectionMessage');
        this.remotePresenceMessage = document.getElementById('remotePresenceMessage');

        this.$wrapper = $('#largeVideoWrapper');

        this.wrapperParent = document.getElementById('largeVideoElementsContainer');
        this.avatarHeight = document.getElementById('dominantSpeakerAvatarContainer').getBoundingClientRect().height;
        this.video.onplaying = function(event) {
            logger.debug('Large video is playing!');
            if (typeof resizeContainer === 'function') {
                resizeContainer(event);
            }
        };

        containerEvents.forEach(event => {
            this.video.addEventListener(event, () => {
                logger.debug(`${event} handler was called for the large video.`);
            });
        });

        /**
         * A Set of functions to invoke when the video element resizes.
         *
         * @private
         */
        this._resizeListeners = new Set();

        this.video.onresize = this._onResize.bind(this);
        this._play = this._play.bind(this);
    }

    /**
     * Adds a function to the known subscribers of video element resize
     * events.
     *
     * @param {Function} callback - The subscriber to notify when the video
     * element resizes.
     * @returns {void}
     */
    addResizeListener(callback) {
        this._resizeListeners.add(callback);
    }

    /**
     * Obtains media stream ID of the underlying {@link JitsiTrack}.
     * @return {string|null}
     */
    getStreamID() {
        return this.stream ? this.stream.getId() : null;
    }

    /**
     * Get size of video element.
     * @returns {{width, height}}
     */
    getStreamSize() {
        const video = this.video;


        return {
            width: video.videoWidth,
            height: video.videoHeight
        };
    }

    /**
     * Calculate optimal video size for specified container size.
     * @param {number} containerWidth container width
     * @param {number} containerHeight container height
     * @param {number} verticalFilmstripWidth current width of the vertical filmstrip
     * @returns {{availableWidth, availableHeight}}
     */
    _getVideoSize(containerWidth, containerHeight, verticalFilmstripWidth) {
        const { width, height } = this.getStreamSize();

        if (this.stream && this.isScreenSharing()) {
            return computeDesktopVideoSize(width,
                height,
                containerWidth,
                containerHeight,
                verticalFilmstripWidth < FILMSTRIP_BREAKPOINT);
        }

        return computeCameraVideoSize(width,
            height,
            containerWidth,
            containerHeight,
            interfaceConfig.VIDEO_LAYOUT_FIT);
    }

    /* eslint-disable max-params */
    /**
     * Calculate optimal video position (offset for top left corner)
     * for specified video size and container size.
     * @param {number} width video width
     * @param {number} height video height
     * @param {number} containerWidth container width
     * @param {number} containerHeight container height
     * @param {number} verticalFilmstripWidth current width of the vertical filmstrip
     * @returns {{horizontalIndent, verticalIndent}}
     */
    getVideoPosition(width, height, containerWidth, containerHeight, verticalFilmstripWidth) {
        let containerWidthToUse = containerWidth;

        /* eslint-enable max-params */
        if (this.stream && this.isScreenSharing()) {
            if (interfaceConfig.VERTICAL_FILMSTRIP && verticalFilmstripWidth < FILMSTRIP_BREAKPOINT) {
                containerWidthToUse -= Filmstrip.getVerticalFilmstripWidth();
            }

            return getCameraVideoPosition(width,
                height,
                containerWidthToUse,
                containerHeight);
        }

        return getCameraVideoPosition(width,
                height,
                containerWidthToUse,
                containerHeight);

    }

    /**
     * Updates the positioning of the remote connection presence message and the
     * connection status message which escribes that the remote user is having
     * connectivity issues.
     *
     * @returns {void}
     */
    positionRemoteStatusMessages() {
        this._positionParticipantStatus(this.remoteConnectionMessage);
        this._positionParticipantStatus(this.remotePresenceMessage);
    }

    /**
     * Modifies the position of the passed in jQuery object so it displays
     * in the middle of the video container or below the avatar.
     *
     * @private
     * @returns {void}
     */
    _positionParticipantStatus(element) {
        if (this.avatarDisplayed) {
            const avatarImage = document.getElementById('dominantSpeakerAvatarContainer').getBoundingClientRect();

            element.style.top = avatarImage.top + avatarImage.height + 10;
        } else {
            const height = element.getBoundingClientRect().height;
            const parentHeight = element.parentElement.getBoundingClientRect().height;

            element.style.top = (parentHeight / 2) - (height / 2);
        }
    }

    /**
     *
     */
    resize(containerWidth, containerHeight, animate = false) {
        // XXX Prevent TypeError: undefined is not an object when the Web
        // browser does not support WebRTC (yet).
        if (!this.video) {
            return;
        }
        const state = APP.store.getState();
        const currentLayout = getCurrentLayout(state);

        const verticalFilmstripWidth = state['features/filmstrip'].width?.current;

        if (currentLayout === LAYOUTS.TILE_VIEW || currentLayout === LAYOUTS.STAGE_FILMSTRIP_VIEW) {
            // We don't need to resize the large video since it won't be displayed and we'll resize when returning back
            // to stage view.
            return;
        }

        this.positionRemoteStatusMessages();

        const [ width, height ] = this._getVideoSize(containerWidth, containerHeight, verticalFilmstripWidth);

        if (width === 0 || height === 0) {
            // We don't need to set 0 for width or height since the visibility is controlled by the visibility css prop
            // on the largeVideoElementsContainer. Also if the width/height of the video element is 0 the attached
            // stream won't be played. Normally if we attach a new stream we won't resize the video element until the
            // stream has been played. But setting width/height to 0 will prevent the video from playing.

            return;
        }

        if ((containerWidth > width) || (containerHeight > height)) {
            this._backgroundOrientation = containerWidth > width ? ORIENTATION.LANDSCAPE : ORIENTATION.PORTRAIT;
            this._hideBackground = false;
        } else {
            this._hideBackground = true;
        }

        this._updateBackground();

        const { horizontalIndent, verticalIndent }
            = this.getVideoPosition(width, height, containerWidth, containerHeight, verticalFilmstripWidth);

        APP.store.dispatch(setLargeVideoDimensions(height, width));

        this.$wrapper.animate({
            width,
            height,

            top: verticalIndent,
            bottom: verticalIndent,

            left: horizontalIndent,
            right: horizontalIndent
        }, {
            queue: false,
            duration: animate ? 500 : 0
        });
    }

    /**
     * Removes a function from the known subscribers of video element resize
     * events.
     *
     * @param {Function} callback - The callback to remove from known
     * subscribers of video resize events.
     * @returns {void}
     */
    removeResizeListener(callback) {
        this._resizeListeners.delete(callback);
    }

    /**
     * Plays the large video element.
     *
     * @param {number} retries - Number of retries to play the large video if play fails.
     * @returns {void}
     */
    _play(retries = 0) {
        this.video.play()
            .then(() => {
                logger.debug(`Successfully played large video after ${retries + 1} retries!`);
            })
            .catch(e => {
                if (retries < 3) {
                    logger.debug(`Error while trying to playing the large video. Will retry after 1s. Retries: ${
                        retries}. Error: ${e}`);
                    window.setTimeout(() => {
                        this._play(retries + 1);
                    }, 1000);
                } else {
                    logger.error(`Error while trying to playing the large video after 3 retries: ${e}`);
                }
            });
    }

    /**
     * Update video stream.
     * @param {string} userID
     * @param {JitsiTrack?} stream new stream
     * @param {string} videoType video type
     */
    setStream(userID, stream, videoType) {
        if (this.userId === userID && this.stream === stream && !stream?.forceStreamToReattach) {
            logger.debug(`SetStream on the large video for user ${userID} ignored: the stream is not changed!`);

            // Handles the use case for the remote participants when the
            // videoType is received with delay after turning on/off the
            // desktop sharing.
            if (this.videoType !== videoType) {
                this.videoType = videoType;
                this.resizeContainer();
            }

            return;
        }

        this.userId = userID;

        if (stream?.forceStreamToReattach) {
            delete stream.forceStreamToReattach;
        }

        // detach old stream
        if (this.stream && this.video) {
            this.stream.detach(this.video);
        }

        this.stream = stream;
        this.videoType = videoType;

        if (!stream) {
            logger.debug('SetStream on the large video is called without a stream argument!');

            return;
        }

        if (this.video) {
            logger.debug(`Attaching a remote track to the large video for user ${userID}`);
            stream.attach(this.video).catch(error => {
                logger.error(`Attaching the remote track ${stream} to large video has failed with `, error);
            });

            // Ensure large video gets play() called on it when a new stream is attached to it.
            this._play();

            const flipX = stream.isLocal() && this.localFlipX && !this.isScreenSharing();

            this.video.style.transform = flipX ? 'scaleX(-1)' : 'none';
            this._updateBackground();
        } else {
            logger.debug(`SetStream on the large video won't attach a track for ${
                userID} because no large video element was found!`);
        }
    }

    /**
     * Changes the flipX state of the local video.
     * @param val {boolean} true if flipped.
     */
    setLocalFlipX(val) {
        this.localFlipX = val;
        if (!this.video || !this.stream || !this.stream.isLocal() || this.isScreenSharing()) {
            return;
        }
        this.video.style.transform = this.localFlipX ? 'scaleX(-1)' : 'none';

        this._updateBackground();
    }


    /**
     * Check if current video stream is screen sharing.
     * @returns {boolean}
     */
    isScreenSharing() {
        return this.videoType === 'desktop';
    }

    /**
     * Show or hide user avatar.
     * @param {boolean} show
     */
    showAvatar(show) {
        this.avatar.style.visibility = show ? 'visible' : 'hidden';
        this.avatarDisplayed = show;

        APP.API.notifyLargeVideoVisibilityChanged(show);
    }

    /**
     * Show video container.
     */
    show() {
        return new Promise(resolve => {
            this.wrapperParent.style.visibility = 'visible';
            this.wrapperParent.classList.remove('animatedFadeOut');
            this.wrapperParent.classList.add('animatedFadeIn');
            setTimeout(() => {
                this._isHidden = false;
                this._updateBackground();
                resolve();
            }, FADE_DURATION_MS);
        });
    }

    /**
     * Hide video container.
     */
    hide() {
        // as the container is hidden/replaced by another container
        // hide its avatar
        this.showAvatar(false);

        return new Promise(resolve => {
            this.wrapperParent.classList.remove('animatedFadeIn');
            this.wrapperParent.classList.add('animatedFadeOut');
            setTimeout(() => {
                this.wrapperParent.style.visibility = 'hidden';
                this._isHidden = true;
                this._updateBackground();
                resolve();
            }, FADE_DURATION_MS);
        });
    }

    /**
     * @return {boolean} switch on dominant speaker event if on stage.
     */
    stayOnStage() {
        return false;
    }

    /**
     * Callback invoked when the video element changes dimensions.
     *
     * @private
     * @returns {void}
     */
    _onResize() {
        this._resizeListeners.forEach(callback => callback());
    }

    /**
     * Attaches and/or updates a React Component to be used as a background for
     * the large video, to display blurred video and fill up empty space not
     * taken up by the large video.
     *
     * @private
     * @returns {void}
     */
    _updateBackground() {
        // Do not the background display on browsers that might experience
        // performance issues from the presence of the background or if
        // explicitly disabled.
        if (interfaceConfig.DISABLE_VIDEO_BACKGROUND
                || browser.isFirefox()
                || browser.isWebKitBased()) {
            return;
        }

        ReactDOM.render(
            <LargeVideoBackground
                hidden = { this._hideBackground || this._isHidden }
                mirror = {
                    this.stream
                    && this.stream.isLocal()
                    && this.localFlipX
                }
                orientationFit = { this._backgroundOrientation }
                videoElement = { this.video }
                videoTrack = { this.stream } />,
            document.getElementById('largeVideoBackgroundContainer')
        );
    }
}


################################################################################

## File: .\jitsi-meet\modules\UI\videolayout\VideoLayout.js

/* global APP  */

import Logger from '@jitsi/logger';

import { MEDIA_TYPE, VIDEO_TYPE } from '../../../react/features/base/media/constants';
import {
    getParticipantById,
    getPinnedParticipant,
    isScreenShareParticipantById
} from '../../../react/features/base/participants/functions';
import {
    getTrackByMediaTypeAndParticipant,
    getVideoTrackByParticipant
} from '../../../react/features/base/tracks/functions.any';

import LargeVideoManager from './LargeVideoManager';
import { VIDEO_CONTAINER_TYPE } from './VideoContainer';

const logger = Logger.getLogger(__filename);
let largeVideo;

const VideoLayout = {
    /**
     * Handler for local flip X changed event.
     */
    onLocalFlipXChanged(localFlipX) {
        if (largeVideo) {
            largeVideo.onLocalFlipXChange(localFlipX);
        }
    },

    /**
     * Cleans up state of this singleton {@code VideoLayout}.
     *
     * @returns {void}
     */
    reset() {
        this._resetLargeVideo();
    },

    initLargeVideo() {
        this._resetLargeVideo();

        largeVideo = new LargeVideoManager();

        const { store } = APP;
        const { localFlipX } = store.getState()['features/base/settings'];

        if (typeof localFlipX === 'boolean') {
            largeVideo.onLocalFlipXChange(localFlipX);
        }
        largeVideo.updateContainerSize();
    },

    /**
     * Sets the audio level of the video elements associated to the given id.
     *
     * @param id the video identifier in the form it comes from the library
     * @param lvl the new audio level to update to
     */
    setAudioLevel(id, lvl) {
        if (largeVideo && id === largeVideo.id) {
            largeVideo.updateLargeVideoAudioLevel(lvl);
        }
    },

    /**
     * FIXME get rid of this method once muted indicator are reactified (by
     * making sure that user with no tracks is displayed as muted )
     *
     * If participant has no tracks will make the UI display muted status.
     * @param {string} participantId
     */
    updateVideoMutedForNoTracks(participantId) {
        const participant = APP.conference.getParticipantById(participantId);

        if (participant && !participant.getTracksByMediaType('video').length) {
            VideoLayout._updateLargeVideoIfDisplayed(participantId, true);
        }
    },

    /**
     * Return the type of the remote video.
     * @param id the id for the remote video
     * @returns {String} the video type video or screen.
     */
    getRemoteVideoType(id) {
        const state = APP.store.getState();
        const participant = getParticipantById(state, id);
        const isScreenShare = isScreenShareParticipantById(state, id);

        if (participant?.fakeParticipant && !isScreenShare) {
            return VIDEO_TYPE.CAMERA;
        }

        if (isScreenShare) {
            return VIDEO_TYPE.DESKTOP;
        }

        const videoTrack = getTrackByMediaTypeAndParticipant(state['features/base/tracks'], MEDIA_TYPE.VIDEO, id);

        return videoTrack?.videoType;
    },

    getPinnedId() {
        const { id } = getPinnedParticipant(APP.store.getState()) || {};

        return id || null;
    },

    /**
     * On last N change event.
     *
     * @param endpointsLeavingLastN the list currently leaving last N
     * endpoints
     * @param endpointsEnteringLastN the list currently entering last N
     * endpoints
     */
    onLastNEndpointsChanged(endpointsLeavingLastN, endpointsEnteringLastN) {
        if (endpointsLeavingLastN) {
            endpointsLeavingLastN.forEach(this._updateLargeVideoIfDisplayed, this);
        }

        if (endpointsEnteringLastN) {
            endpointsEnteringLastN.forEach(this._updateLargeVideoIfDisplayed, this);
        }
    },

    /**
     * Resizes the video area.
     */
    resizeVideoArea() {
        if (largeVideo) {
            largeVideo.updateContainerSize();
            largeVideo.resize(false);
        }
    },

    isLargeVideoVisible() {
        return this.isLargeContainerTypeVisible(VIDEO_CONTAINER_TYPE);
    },

    /**
     * @return {LargeContainer} the currently displayed container on large
     * video.
     */
    getCurrentlyOnLargeContainer() {
        return largeVideo.getCurrentContainer();
    },

    isCurrentlyOnLarge(id) {
        return largeVideo && largeVideo.id === id;
    },

    updateLargeVideo(id, forceUpdate, forceStreamToReattach = false) {
        if (!largeVideo) {
            logger.debug(`Ignoring large video update with user id ${id}: large video not initialized yet!`);

            return;
        }
        const currentContainer = largeVideo.getCurrentContainer();
        const currentContainerType = largeVideo.getCurrentContainerType();
        const isOnLarge = this.isCurrentlyOnLarge(id);
        const state = APP.store.getState();
        const participant = getParticipantById(state, id);
        const videoTrack = getVideoTrackByParticipant(state, participant);
        const videoStream = videoTrack?.jitsiTrack;

        if (videoStream && forceStreamToReattach) {
            videoStream.forceStreamToReattach = forceStreamToReattach;
        }

        if (isOnLarge && !forceUpdate
                && LargeVideoManager.isVideoContainer(currentContainerType)
                && videoStream) {
            const currentStreamId = currentContainer.getStreamID();
            const newStreamId = videoStream?.getId() || null;

            // FIXME it might be possible to get rid of 'forceUpdate' argument
            if (currentStreamId !== newStreamId) {
                logger.debug('Enforcing large video update for stream change');
                forceUpdate = true; // eslint-disable-line no-param-reassign
            }
        }

        if (!isOnLarge || forceUpdate) {
            const videoType = this.getRemoteVideoType(id);

            largeVideo.updateLargeVideo(
                id,
                videoStream,
                videoType || VIDEO_TYPE.CAMERA
            ).catch(() => {
                // do nothing
            });
        }
    },

    addLargeVideoContainer(type, container) {
        largeVideo && largeVideo.addContainer(type, container);
    },

    removeLargeVideoContainer(type) {
        largeVideo && largeVideo.removeContainer(type);
    },

    /**
     * @returns Promise
     */
    showLargeVideoContainer(type, show) {
        if (!largeVideo) {
            return Promise.reject();
        }

        const isVisible = this.isLargeContainerTypeVisible(type);

        if (isVisible === show) {
            return Promise.resolve();
        }

        let containerTypeToShow = type;

        // if we are hiding a container and there is focusedVideo
        // (pinned remote video) use its video type,
        // if not then use default type - large video

        if (!show) {
            const pinnedId = this.getPinnedId();

            if (pinnedId) {
                containerTypeToShow = this.getRemoteVideoType(pinnedId);
            } else {
                containerTypeToShow = VIDEO_CONTAINER_TYPE;
            }
        }

        return largeVideo.showContainer(containerTypeToShow);
    },

    isLargeContainerTypeVisible(type) {
        return largeVideo && largeVideo.state === type;
    },

    /**
     * Returns the id of the current video shown on large.
     * Currently used by tests (torture).
     */
    getLargeVideoID() {
        return largeVideo && largeVideo.id;
    },

    /**
     * Returns the the current video shown on large.
     * Currently used by tests (torture).
     */
    getLargeVideo() {
        return largeVideo;
    },

    /**
     * Returns the wrapper jquery selector for the largeVideo
     * @returns {JQuerySelector} the wrapper jquery selector for the largeVideo
     */
    getLargeVideoWrapper() {
        return this.getCurrentlyOnLargeContainer().$wrapper;
    },

    /**
     * Helper method to invoke when the video layout has changed and elements
     * have to be re-arranged and resized.
     *
     * @returns {void}
     */
    refreshLayout() {
        VideoLayout.resizeVideoArea();
    },

    /**
     * Cleans up any existing largeVideo instance.
     *
     * @private
     * @returns {void}
     */
    _resetLargeVideo() {
        if (largeVideo) {
            largeVideo.destroy();
        }

        largeVideo = null;
    },

    /**
     * Triggers an update of large video if the passed in participant is
     * currently displayed on large video.
     *
     * @param {string} participantId - The participant ID that should trigger an
     * update of large video if displayed.
     * @param {boolean} force - Whether or not the large video update should
     * happen no matter what.
     * @returns {void}
     */
    _updateLargeVideoIfDisplayed(participantId, force = false) {
        if (this.isCurrentlyOnLarge(participantId)) {
            this.updateLargeVideo(participantId, force, false);
        }
    },

    /**
     * Handles window resizes.
     */
    onResize() {
        VideoLayout.resizeVideoArea();
    }
};

export default VideoLayout;


################################################################################

## File: .\jitsi-meet\modules\util\helpers.js

import { TaskQueue } from './TaskQueue';

/**
 * Create deferred object.
 *
 * @returns {{promise, resolve, reject}}
 */
export function createDeferred() {
    const deferred = {};

    deferred.promise = new Promise((resolve, reject) => {
        deferred.resolve = resolve;
        deferred.reject = reject;
    });

    return deferred;
}

/**
 * Returns an instance of {@link TaskQueue}.
 *
 * @returns {Object}
 */
export function createTaskQueue() {
    return new TaskQueue();
}


################################################################################

## File: .\jitsi-meet\modules\util\TaskQueue.js

const logger = require('@jitsi/logger').getLogger(__filename);

/**
 * Manages a queue of functions where the current function in progress will
 * automatically execute the next queued function.
 */
export class TaskQueue {
    /**
     * Creates a new instance of {@link TaskQueue} and sets initial instance
     * variable values.
     */
    constructor() {
        this._queue = [];
        this._currentTask = null;

        this._onTaskComplete = this._onTaskComplete.bind(this);
    }

    /**
     * Adds a new function to the queue. It will be immediately invoked if no
     * other functions are queued.
     *
     * @param {Function} taskFunction - The function to be queued for execution.
     * @private
     * @returns {void}
     */
    enqueue(taskFunction) {
        this._queue.push(taskFunction);
        this._executeNext();
    }

    /**
     * If no queued task is currently executing, invokes the first task in the
     * queue if any.
     *
     * @private
     * @returns {void}
     */
    _executeNext() {
        if (this._currentTask) {
            logger.warn('Task queued while a task is in progress.');

            return;
        }

        this._currentTask = this._queue.shift() || null;

        if (this._currentTask) {
            logger.debug('Executing a task.');

            try {
                this._currentTask(this._onTaskComplete);
            } catch (error) {
                logger.error(`Task execution failed: ${error}`);
                this._onTaskComplete();
            }
        }
    }

    /**
     * Prepares to invoke the next function in the queue.
     *
     * @private
     * @returns {void}
     */
    _onTaskComplete() {
        this._currentTask = null;
        logger.debug('Task completed.');
        this._executeNext();
    }
}


################################################################################

## File: .\jitsi-meet\react\.eslintrc-react-native.js

module.exports = {
    'plugins': [
        'react-native'
    ],
    'rules': {
        'react-native/no-color-literals': 2,
        'react-native/no-inline-styles': 2,
        'react-native/no-unused-styles': 2,
        'react-native/split-platform-components': 2
    }
};



################################################################################

## File: .\jitsi-meet\react\.eslintrc.js

module.exports = {
    'extends': [
        '../.eslintrc.js',
        '@jitsi/eslint-config/jsdoc',
        '@jitsi/eslint-config/react',
        '.eslintrc-react-native.js'
    ],
    'overrides': [
        {
            'files': [ '*.ts', '*.tsx' ],
            extends: [ '@jitsi/eslint-config/typescript' ],
            parserOptions: {
                sourceType: 'module',
                project: [ './tsconfig.web.json', './tsconfig.native.json' ]
            },
            rules: {
                '@typescript-eslint/naming-convention': [
                    'error',
                    {
                        'selector': 'interface',
                        'format': [ 'PascalCase' ],
                        'custom': {
                            'regex': '^I[A-Z]',
                            'match': true
                        }
                    }
                ]
            }
        }
    ],
    'rules': {
        // XXX remove this eventually.
        'react/jsx-indent-props': 0
    },
    'settings': {
        'react': {
            'version': 'detect'
        }
    }
};


################################################################################

## File: .\jitsi-meet\react\bootstrap.native.js

// https://github.com/software-mansion/react-native-gesture-handler/issues/320#issuecomment-443815828
import 'react-native-gesture-handler';

// Apply all necessary polyfills as early as possible to make sure anything imported henceforth
// sees them.
import 'react-native-get-random-values';
import './features/mobile/polyfills';


################################################################################

## File: .\jitsi-meet\react\index.native.js

// NB: This import must always come first.
import './bootstrap.native';

import React, { PureComponent } from 'react';
import { AppRegistry } from 'react-native';

import { App } from './features/app/components/App.native';
import { _initLogging } from './features/base/logging/functions';

/**
 * React Native doesn't support specifying props to the main/root component (in
 * the JS/JSX source code). So create a wrapper React Component (class) around
 * features/app's App instead.
 *
 * @augments Component
 */
class Root extends PureComponent {
    /**
     * Implements React's {@link Component#render()}.
     *
     * @inheritdoc
     * @returns {ReactElement}
     */
    render() {
        return (
            <App { ...this.props } />
        );
    }
}

// Initialize logging.
_initLogging();

// Register the main/root Component of JitsiMeetView.
AppRegistry.registerComponent('App', () => Root);


################################################################################

## File: .\jitsi-meet\react\index.web.js

import React from 'react';
import ReactDOM from 'react-dom';

import { App } from './features/app/components/App.web';
import { getLogger } from './features/base/logging/functions';
import Platform from './features/base/react/Platform.web';
import { getJitsiMeetGlobalNS } from './features/base/util/helpers';
import DialInSummaryApp from './features/invite/components/dial-in-summary/web/DialInSummaryApp';
import PrejoinApp from './features/prejoin/components/web/PrejoinApp';
import WhiteboardApp from './features/whiteboard/components/web/WhiteboardApp';

const logger = getLogger('index.web');

// Add global loggers.
window.addEventListener('error', ev => {
    logger.error(
        `UnhandledError: ${ev.message}`,
        `Script: ${ev.filename}`,
        `Line: ${ev.lineno}`,
        `Column: ${ev.colno}`,
        'StackTrace: ', ev.error?.stack);
});

window.addEventListener('unhandledrejection', ev => {
    logger.error(
        `UnhandledPromiseRejection: ${ev.reason}`,
        'StackTrace: ', ev.reason?.stack);
});

// Workaround for the issue when returning to a page with the back button and
// the page is loaded from the 'back-forward' cache on iOS which causes nothing
// to be rendered.
if (Platform.OS === 'ios') {
    window.addEventListener('pageshow', event => {
        // Detect pages loaded from the 'back-forward' cache
        // (https://webkit.org/blog/516/webkit-page-cache-ii-the-unload-event/)
        if (event.persisted) {
            // Maybe there is a more graceful approach but in the moment of
            // writing nothing else resolves the issue. I tried to execute our
            // DOMContentLoaded handler but it seems that the 'onpageshow' event
            // is triggered only when 'window.location.reload()' code exists.
            window.location.reload();
        }
    });
}

const globalNS = getJitsiMeetGlobalNS();

// Used for automated performance tests.
globalNS.connectionTimes = {
    'index.loaded': window.indexLoadedTime
};

window.addEventListener('load', () => {
    globalNS.connectionTimes['window.loaded'] = window.loadedEventTime;
});

document.addEventListener('DOMContentLoaded', () => {
    const now = window.performance.now();

    globalNS.connectionTimes['document.ready'] = now;
    logger.log('(TIME) document ready:\t', now);
});

globalNS.entryPoints = {
    APP: App,
    PREJOIN: PrejoinApp,
    DIALIN: DialInSummaryApp,
    WHITEBOARD: WhiteboardApp
};

globalNS.renderEntryPoint = ({
    Component,
    props = {},
    elementId = 'react'
}) => {
    ReactDOM.render(
        <Component { ...props } />,
        document.getElementById(elementId)
    );
};


################################################################################

## File: .\jitsi-meet\react\features\analytics\actions.ts

import { IStore } from '../app/types';
import { analytics } from '../base/lib-jitsi-meet';

import { SET_INITIAL_PERMANENT_PROPERTIES } from './actionTypes';

/**
 * Updates a permanentProperty.
 *
 * @param {Object} properties - An object with properties to be updated.
 * @returns {Function}
 */
export function setPermanentProperty(properties: Object) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const { isInitialized = false } = getState()['features/analytics'];

        if (isInitialized) {
            analytics.addPermanentProperties(properties);
        } else {
            dispatch({
                type: SET_INITIAL_PERMANENT_PROPERTIES,
                properties
            });
        }
    };
}


################################################################################

## File: .\jitsi-meet\react\features\analytics\actionTypes.ts

/**
 * The type of (redux) action which signals that local media duration has changed.
 *
 * {
 *     type: UPDATE_LOCAL_TRACKS_DURATION,
 *     localTracksDuration: Object
 * }
 */
export const UPDATE_LOCAL_TRACKS_DURATION = 'UPDATE_LOCAL_TRACKS_DURATION';

/**
 * The type of (redux) action which sets the isInitialized redux prop.
 *
 * {
 *     type: SET_INITIALIZED,
 *     value: boolean
 * }
 */
export const SET_INITIALIZED = 'SET_INITIALIZED';

/**
 * The type of (redux) action which updates the initial permanent properties.
 *
 * {
 *     type: SET_INITIAL_PERMANENT_PROPERTIES,
 *     properties: Object
 * }
 */
export const SET_INITIAL_PERMANENT_PROPERTIES = 'SET_INITIAL_PERMANENT_PROPERTIES';


################################################################################

## File: .\jitsi-meet\react\features\analytics\AnalyticsEvents.ts

/**
 * The constant for the event type 'track'.
 * TODO: keep these constants in a single place. Can we import them from
 * lib-jitsi-meet's AnalyticsEvents somehow?
 *
 * @type {string}
 */
const TYPE_TRACK = 'track';

/**
 * The constant for the event type 'UI' (User Interaction).
 * TODO: keep these constants in a single place. Can we import them from
 * lib-jitsi-meet's AnalyticsEvents somehow?
 *
 * @type {string}
 */
const TYPE_UI = 'ui';

/**
 * The identifier for the "pinned" action. The local participant has pinned a
 * participant to remain on large video.
 *
 * @type {String}
 */
export const ACTION_PINNED = 'pinned';

/**
 * The identifier for the "unpinned" action. The local participant has unpinned
 * a participant so the participant doesn't remain permanently on local large
 * video.
 *
 * @type {String}
 */
export const ACTION_UNPINNED = 'unpinned';

/**
 * The identifier for the "pressed" action for shortcut events. This action
 * means that a button was pressed (and not yet released).
 *
 * @type {String}
 */
export const ACTION_SHORTCUT_PRESSED = 'pressed';

/**
 * The identifier for the "released" action for shortcut events. This action
 * means that a button which was previously pressed was released.
 *
 * @type {String}
 */
export const ACTION_SHORTCUT_RELEASED = 'released';

/**
 * The identifier for the "triggered" action for shortcut events. This action
 * means that a button was pressed, and we don't care about whether it was
 * released or will be released in the future.
 *
 * @type {String}
 */
export const ACTION_SHORTCUT_TRIGGERED = 'triggered';

/**
 * The name of the keyboard shortcut or toolbar button for muting audio.
 */
export const AUDIO_MUTE = 'audio.mute';

/**
 * The name of the keyboard shortcut or toolbar button for muting video.
 */
export const VIDEO_MUTE = 'video.mute';

/**
 * Creates an event which indicates that a certain action was requested through
 * the jitsi-meet API.
 *
 * @param {string} action - The action which was requested through the
 * jitsi-meet API.
 * @param {Object} attributes - Attributes to attach to the event.
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createApiEvent(action: string, attributes = {}) {
    return {
        action,
        attributes,
        source: 'jitsi-meet-api'
    };
}

/**
 * Creates an event which indicates that the audio-only mode has been changed.
 *
 * @param {boolean} enabled - True if audio-only is enabled, false otherwise.
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createAudioOnlyChangedEvent(enabled: boolean) {
    return {
        action: `audio.only.${enabled ? 'enabled' : 'disabled'}`
    };
}

/**
 * Creates an event for about the JitsiConnection.
 *
 * @param {string} action - The action that the event represents.
 * @param {boolean} attributes - Additional attributes to attach to the event.
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createConnectionEvent(action: string, attributes = {}) {
    return {
        action,
        actionSubject: 'connection',
        attributes
    };
}

/**
 * Creates an event which indicates an action occurred in the calendar
 * integration UI.
 *
 * @param {string} eventName - The name of the calendar UI event.
 * @param {Object} attributes - Attributes to attach to the event.
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createCalendarClickedEvent(eventName: string, attributes = {}) {
    return {
        action: 'clicked',
        actionSubject: eventName,
        attributes,
        source: 'calendar',
        type: TYPE_UI
    };
}

/**
 * Creates an event which indicates that the calendar container is shown and
 * selected.
 *
 * @param {Object} attributes - Attributes to attach to the event.
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createCalendarSelectedEvent(attributes = {}) {
    return {
        action: 'selected',
        attributes,
        source: 'calendar',
        type: TYPE_UI
    };
}

/**
 * Creates an event indicating that a calendar has been connected.
 *
 * @param {boolean} attributes - Additional attributes to attach to the event.
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createCalendarConnectedEvent(attributes = {}) {
    return {
        action: 'connected',
        actionSubject: 'calendar',
        attributes
    };
}

/**
 * Creates an event which indicates an action occurred in the recent list
 * integration UI.
 *
 * @param {string} eventName - The name of the recent list UI event.
 * @param {Object} attributes - Attributes to attach to the event.
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createRecentClickedEvent(eventName: string, attributes = {}) {
    return {
        action: 'clicked',
        actionSubject: eventName,
        attributes,
        source: 'recent.list',
        type: TYPE_UI
    };
}

/**
 * Creates an event which indicate an action occurred in the chrome extension banner.
 *
 * @param {boolean} installPressed - Whether the user pressed install or `x` - cancel.
 * @param {Object} attributes - Attributes to attach to the event.
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createChromeExtensionBannerEvent(installPressed: boolean, attributes = {}) {
    return {
        action: installPressed ? 'install' : 'cancel',
        attributes,
        source: 'chrome.extension.banner',
        type: TYPE_UI
    };
}

/**
 * Creates an event which indicates that the recent list container is shown and
 * selected.
 *
 * @param {Object} attributes - Attributes to attach to the event.
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createRecentSelectedEvent(attributes = {}) {
    return {
        action: 'selected',
        attributes,
        source: 'recent.list',
        type: TYPE_UI
    };
}

/**
 * Creates an event for an action on the deep linking page.
 *
 * @param {string} action - The action that the event represents.
 * @param {string} actionSubject - The subject that was acted upon.
 * @param {boolean} attributes - Additional attributes to attach to the event.
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createDeepLinkingPageEvent(
        action: string, actionSubject: string, attributes = {}) {
    return {
        action,
        actionSubject,
        source: 'deepLinkingPage',
        attributes
    };
}

/**
 * Creates an event which indicates that a device was changed.
 *
 * @param {string} mediaType - The media type of the device ('audio' or
 * 'video').
 * @param {string} deviceType - The type of the device ('input' or 'output').
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createDeviceChangedEvent(mediaType: string, deviceType: string) {
    return {
        action: 'device.changed',
        attributes: {
            'device_type': deviceType,
            'media_type': mediaType
        }
    };
}

/**
 * Creates an event indicating that an action related to E2EE occurred.
 *
 * @param {string} action - The action which occurred.
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createE2EEEvent(action: string) {
    return {
        action,
        actionSubject: 'e2ee'
    };
}

/**
 * Creates an event which specifies that the feedback dialog has been opened.
 *
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createFeedbackOpenEvent() {
    return {
        action: 'feedback.opened'
    };
}

/**
 * Creates an event for an action regarding the AddPeopleDialog (invites).
 *
 * @param {string} action - The action that the event represents.
 * @param {string} actionSubject - The subject that was acted upon.
 * @param {boolean} attributes - Additional attributes to attach to the event.
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createInviteDialogEvent(
        action: string, actionSubject: string, attributes = {}) {
    return {
        action,
        actionSubject,
        attributes,
        source: 'inviteDialog'
    };
}

/**
 * Creates an event which reports about the current network information reported by the operating system.
 *
 * @param {boolean} isOnline - Tells whether or not the internet is reachable.
 * @param {string} [networkType] - Network type, see {@code NetworkInfo} type defined by the 'base/net-info' feature.
 * @param {Object} [details] - Extra info, see {@code NetworkInfo} type defined by the 'base/net-info' feature.
 * @returns {Object}
 */
export function createNetworkInfoEvent({ isOnline, networkType, details }:
    { details?: Object; isOnline: boolean; networkType?: string; }) {
    const attributes: {
        details?: Object;
        isOnline: boolean;
        networkType?: string;
    } = { isOnline };

    // Do no include optional stuff or Amplitude handler will log warnings.
    networkType && (attributes.networkType = networkType);
    details && (attributes.details = details);

    return {
        action: 'network.info',
        attributes
    };
}

/**
 * Creates a "not allowed error" event.
 *
 * @param {string} type - The type of the error.
 * @param {string} reason - The reason for the error.
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createNotAllowedErrorEvent(type: string, reason: string) {
    return {
        action: 'not.allowed.error',
        attributes: {
            reason,
            type
        }
    };
}

/**
 * Creates an "offer/answer failure" event.
 *
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createOfferAnswerFailedEvent() {
    return {
        action: 'offer.answer.failure'
    };
}

/**
 * Creates a "page reload" event.
 *
 * @param {string} reason - The reason for the reload.
 * @param {number} timeout - The timeout in seconds after which the page is
 * scheduled to reload.
 * @param {Object} details - The details for the error.
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createPageReloadScheduledEvent(reason: string, timeout: number, details: Object = {}) {
    return {
        action: 'page.reload.scheduled',
        attributes: {
            reason,
            timeout,
            ...details
        }
    };
}

/**
 * Creates a "pinned" or "unpinned" event.
 *
 * @param {string} action - The action ("pinned" or "unpinned").
 * @param {string} participantId - The ID of the participant which was pinned.
 * @param {Object} attributes - Attributes to attach to the event.
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createPinnedEvent(action: string, participantId: string, attributes = {}) {
    return {
        type: TYPE_TRACK,
        action,
        actionSubject: 'participant',
        objectType: 'participant',
        objectId: participantId,
        attributes
    };
}

/**
 * Creates a poll event.
 * The following events will be created:
 * - poll.created
 * - poll.vote.checked
 * - poll.vote.sent
 * - poll.vote.skipped
 * - poll.vote.detailsViewed
 * - poll.vote.changed
 * - poll.option.added
 * - poll.option.moved
 * - poll.option.removed.
 *
 * @param {string} action - The action.
 * @returns {Object}
 */
export function createPollEvent(action: string) {
    return {
        action: `poll.${action}`
    };
}

/**
 * Creates an event which indicates that a button in the profile panel was
 * clicked.
 *
 * @param {string} buttonName - The name of the button.
 * @param {Object} attributes - Attributes to attach to the event.
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createProfilePanelButtonEvent(buttonName: string, attributes = {}) {
    return {
        action: 'clicked',
        actionSubject: buttonName,
        attributes,
        source: 'profile.panel',
        type: TYPE_UI
    };
}

/**
 * Creates an event which indicates that a specific button on one of the
 * recording-related dialogs was clicked.
 *
 * @param {string} dialogName - The name of the dialog (e.g. 'start' or 'stop').
 * @param {string} buttonName - The name of the button (e.g. 'confirm' or
 * 'cancel').
 * @param {Object} attributes - Attributes to attach to the event.
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createRecordingDialogEvent(
        dialogName: string, buttonName: string, attributes = {}) {
    return {
        action: 'clicked',
        actionSubject: buttonName,
        attributes,
        source: `${dialogName}.recording.dialog`,
        type: TYPE_UI
    };
}

/**
 * Creates an event which indicates that a specific button on one of the
 * liveStreaming-related dialogs was clicked.
 *
 * @param {string} dialogName - The name of the dialog (e.g. 'start' or 'stop').
 * @param {string} buttonName - The name of the button (e.g. 'confirm' or
 * 'cancel').
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createLiveStreamingDialogEvent(dialogName: string, buttonName: string) {
    return {
        action: 'clicked',
        actionSubject: buttonName,
        source: `${dialogName}.liveStreaming.dialog`,
        type: TYPE_UI
    };
}

/**
 * Creates an event with the local tracks duration.
 *
 * @param {Object} duration - The object with the duration of the local tracks.
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createLocalTracksDurationEvent(duration: {
    audio: { value: number; };
    conference: { value: number; };
    video: {
        camera: { value: number; };
        desktop: { value: number; };
    };
}) {
    const { audio, video, conference } = duration;
    const { camera, desktop } = video;

    return {
        action: 'local.tracks.durations',
        attributes: {
            audio: audio.value,
            camera: camera.value,
            conference: conference.value,
            desktop: desktop.value
        }
    };
}

/**
 * Creates an event which indicates that an action related to recording has
 * occurred.
 *
 * @param {string} action - The action (e.g. 'start' or 'stop').
 * @param {string} type - The recording type (e.g. 'file' or 'live').
 * @param {number} value - The duration of the recording in seconds (for stop
 * action).
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createRecordingEvent(action: string, type: string, value?: number) {
    return {
        action,
        actionSubject: `recording.${type}`,
        attributes: {
            value
        }
    };
}

/**
 * Creates an event which indicates that the same conference has been rejoined.
 *
 * @param {string} url - The full conference URL.
 * @param {number} lastConferenceDuration - How many seconds user stayed in the previous conference.
 * @param {number} timeSinceLeft - How many seconds since the last conference was left.
 * @returns {Object} The event in a format suitable for sending via sendAnalytics.
 */
export function createRejoinedEvent({ url, lastConferenceDuration, timeSinceLeft }: {
    lastConferenceDuration: number;
    timeSinceLeft: number;
    url: string;
}) {
    return {
        action: 'rejoined',
        attributes: {
            lastConferenceDuration,
            timeSinceLeft,
            url
        }
    };
}

/**
 * Creates an event which specifies that the "confirm" button on the remote
 * mute dialog has been clicked.
 *
 * @param {string} participantId - The ID of the participant that was remotely
 * muted.
 * @param {string} mediaType - The media type of the channel to mute.
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createRemoteMuteConfirmedEvent(participantId: string, mediaType: string) {
    return {
        action: 'clicked',
        attributes: {
            'participant_id': participantId,
            'media_type': mediaType
        },
        source: 'remote.mute.button',
        type: TYPE_UI
    };
}

/**
 * Creates an event which indicates that one of the buttons in the "remote
 * video menu" was clicked.
 *
 * @param {string} buttonName - The name of the button.
 * @param {Object} attributes - Attributes to attach to the event.
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createRemoteVideoMenuButtonEvent(buttonName: string, attributes = {}) {
    return {
        action: 'clicked',
        actionSubject: buttonName,
        attributes,
        source: 'remote.video.menu',
        type: TYPE_UI
    };
}

/**
 * The rtcstats websocket onclose event. We send this to amplitude in order
 * to detect trace ws prematurely closing.
 *
 * @param {Object} closeEvent - The event with which the websocket closed.
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createRTCStatsTraceCloseEvent(closeEvent: { code: string; reason: string; }) {
    const event: {
        action: string;
        code?: string;
        reason?: string;
        source: string;
    } = {
        action: 'trace.onclose',
        source: 'rtcstats'
    };

    event.code = closeEvent.code;
    event.reason = closeEvent.reason;

    return event;
}

/**
 * Creates an event indicating that an action related to screen sharing
 * occurred (e.g. It was started or stopped).
 *
 * @param {string} action - The action which occurred.
 * @param {number?} value - The screenshare duration in seconds.
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createScreenSharingEvent(action: string, value = null) {
    return {
        action,
        actionSubject: 'screen.sharing',
        attributes: {
            value
        }
    };
}

/**
 * Creates an event which indicates the screen sharing video is not displayed when it needs to be displayed.
 *
 * @param {Object} attributes - Additional information that describes the issue.
 * @returns {Object} The event in a format suitable for sending via sendAnalytics.
 */
export function createScreenSharingIssueEvent(attributes = {}) {
    return {
        action: 'screen.sharing.issue',
        attributes
    };
}

/**
 * Creates an event associated with the "shared video" feature.
 *
 * @param {string} action - The action that the event represents.
 * @param {Object} attributes - Attributes to attach to the event.
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createSharedVideoEvent(action: string, attributes = {}) {
    return {
        action,
        attributes,
        actionSubject: 'shared.video'
    };
}

/**
 * Creates an event associated with a shortcut being pressed, released or
 * triggered. By convention, where appropriate an attribute named 'enable'
 * should be used to indicate the action which resulted by the shortcut being
 * pressed (e.g. Whether screen sharing was enabled or disabled).
 *
 * @param {string} shortcut - The identifier of the shortcut which produced
 * an action.
 * @param {string} action - The action that the event represents (one
 * of ACTION_SHORTCUT_PRESSED, ACTION_SHORTCUT_RELEASED
 * or ACTION_SHORTCUT_TRIGGERED).
 * @param {Object} attributes - Attributes to attach to the event.
 * @param {string} source - The event's source.
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createShortcutEvent(
        shortcut: string,
        action = ACTION_SHORTCUT_TRIGGERED,
        attributes = {},
        source = 'keyboard.shortcut') {
    return {
        action,
        actionSubjectId: shortcut,
        attributes,
        source,
        type: TYPE_UI
    };
}

/**
 * Creates an event which indicates the "start audio only" configuration.
 *
 * @param {boolean} audioOnly - Whether "start audio only" is enabled or not.
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createStartAudioOnlyEvent(audioOnly: boolean) {
    return {
        action: 'start.audio.only',
        attributes: {
            enabled: audioOnly
        }
    };
}

/**
 * Creates an event which indicates the "start silent" configuration.
 *
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createStartSilentEvent() {
    return {
        action: 'start.silent'
    };
}

/**
 * Creates an event which indicates that HTMLAudioElement.play has failed.
 *
 * @param {string} elementID - The ID of the HTMLAudioElement.
 * @returns {Object} The event in a format suitable for sending via sendAnalytics.
 */
export function createAudioPlayErrorEvent(elementID: string) {
    return {
        action: 'audio.play.error',
        attributes: {
            elementID
        }
    };
}

/**
 * Creates an event which indicates that HTMLAudioElement.play has succeeded after a prior failure.
 *
 * @param {string} elementID - The ID of the HTMLAudioElement.
 * @returns {Object} The event in a format suitable for sending via sendAnalytics.
 */
export function createAudioPlaySuccessEvent(elementID: string) {
    return {
        action: 'audio.play.success',
        attributes: {
            elementID
        }
    };
}

/**
 * Creates an event which indicates the "start muted" configuration.
 *
 * @param {string} source - The source of the configuration, 'local' or
 * 'remote' depending on whether it comes from the static configuration (i.e.
 * {@code config.js}) or comes dynamically from Jicofo.
 * @param {boolean} audioMute - Whether the configuration requests that audio
 * is muted.
 * @param {boolean} videoMute - Whether the configuration requests that video
 * is muted.
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createStartMutedConfigurationEvent(
        source: string,
        audioMute: boolean,
        videoMute: boolean) {
    return {
        action: 'start.muted.configuration',
        attributes: {
            source,
            'audio_mute': audioMute,
            'video_mute': videoMute
        }
    };
}

/**
 * Automatically changing the mute state of a media track in order to match
 * the current stored state in redux.
 *
 * @param {string} mediaType - The track's media type ('audio' or 'video').
 * @param {boolean} muted - Whether the track is being muted or unmuted as
 * as result of the sync operation.
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createSyncTrackStateEvent(mediaType: string, muted: boolean) {
    return {
        action: 'sync.track.state',
        attributes: {
            'media_type': mediaType,
            muted
        }
    };
}

/**
 * Creates an event associated with a toolbar button being clicked/pressed. By
 * convention, where appropriate an attribute named 'enable' should be used to
 * indicate the action which resulted by the shortcut being pressed (e.g.
 * Whether screen sharing was enabled or disabled).
 *
 * @param {string} buttonName - The identifier of the toolbar button which was
 * clicked/pressed.
 * @param {Object} attributes - Attributes to attach to the event.
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createToolbarEvent(buttonName: string, attributes = {}) {
    return {
        action: 'clicked',
        actionSubject: buttonName,
        attributes,
        source: 'toolbar.button',
        type: TYPE_UI
    };
}

/**
 * Creates an event associated with a reaction button being clicked/pressed.
 *
 * @param {string} buttonName - The identifier of the reaction button which was
 * clicked/pressed.
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createReactionMenuEvent(buttonName: string) {
    return {
        action: 'clicked',
        actionSubject: 'button',
        source: 'reaction',
        buttonName,
        type: TYPE_UI
    };
}

/**
 * Creates an event associated with disabling of reaction sounds.
 *
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createReactionSoundsDisabledEvent() {
    return {
        action: 'disabled',
        actionSubject: 'sounds',
        source: 'reaction.settings',
        type: TYPE_UI
    };
}

/**
 * Creates an event which indicates that a local track was muted.
 *
 * @param {string} mediaType - The track's media type ('audio' or 'video').
 * @param {string} reason - The reason the track was muted (e.g. It was
 * triggered by the "initial mute" option, or a previously muted track was
 * replaced (e.g. When a new device was used)).
 * @param {boolean} muted - Whether the track was muted or unmuted.
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createTrackMutedEvent(mediaType: string, reason: string, muted = true) {
    return {
        action: 'track.muted',
        attributes: {
            'media_type': mediaType,
            muted,
            reason
        }
    };
}

/**
 * Creates an event for joining a vpaas conference.
 *
 * @param {string} tenant - The conference tenant.
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createVpaasConferenceJoinedEvent(tenant: string) {
    return {
        action: 'vpaas.conference.joined',
        attributes: {
            tenant
        }
    };
}

/**
 * Creates an event for an action on the welcome page.
 *
 * @param {string} action - The action that the event represents.
 * @param {string} actionSubject - The subject that was acted upon.
 * @param {boolean} attributes - Additional attributes to attach to the event.
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createWelcomePageEvent(action: string, actionSubject?: string, attributes = {}) {
    return {
        action,
        actionSubject,
        attributes,
        source: 'welcomePage'
    };
}

/**
 * Creates an event which indicates a screenshot of the screensharing has been taken.
 *
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createScreensharingCaptureTakenEvent() {
    return {
        action: 'screen.sharing.capture.taken'
    };
}

/**
 * Creates an event for an action on breakout rooms.
 *
 * @param {string} actionSubject - The subject that was acted upon.
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createBreakoutRoomsEvent(actionSubject: string) {
    return {
        action: 'clicked',
        actionSubject: `${actionSubject}.button`,
        source: 'breakout.rooms'
    };
}

/**
 * Creates an event which indicates a GIF was sent.
 *
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createGifSentEvent() {
    return {
        action: 'gif.sent'
    };
}

/**
 * Creates an event which indicates the whiteboard was opened.
 *
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createOpenWhiteboardEvent() {
    return {
        action: 'whiteboard.open'
    };
}

/**
 * Creates an event which indicates the whiteboard limit was enforced.
 *
 * @returns {Object} The event in a format suitable for sending via
 * sendAnalytics.
 */
export function createRestrictWhiteboardEvent() {
    return {
        action: 'whiteboard.restrict'
    };
}


################################################################################

## File: .\jitsi-meet\react\features\analytics\functions.ts

// @ts-expect-error
import { API_ID } from '../../../modules/API/constants';
import { getName as getAppName } from '../app/functions';
import { IStore } from '../app/types';
import { getAnalyticsRoomName } from '../base/conference/functions';
import checkChromeExtensionsInstalled from '../base/environment/checkChromeExtensionsInstalled';
import {
    isMobileBrowser
} from '../base/environment/utils';
import JitsiMeetJS, {
    analytics,
    browser
} from '../base/lib-jitsi-meet';
import { isAnalyticsEnabled } from '../base/lib-jitsi-meet/functions.any';
import { getJitsiMeetGlobalNS } from '../base/util/helpers';
import { inIframe } from '../base/util/iframeUtils';
import { loadScript } from '../base/util/loadScript';
import { parseURIString } from '../base/util/uri';
import { isPrejoinPageVisible } from '../prejoin/functions';

import AmplitudeHandler from './handlers/AmplitudeHandler';
import MatomoHandler from './handlers/MatomoHandler';
import logger from './logger';

/**
 * Sends an event through the lib-jitsi-meet AnalyticsAdapter interface.
 *
 * @param {Object} event - The event to send. It should be formatted as
 * described in AnalyticsAdapter.js in lib-jitsi-meet.
 * @returns {void}
 */
export function sendAnalytics(event: Object) {
    try {
        analytics.sendEvent(event);
    } catch (e) {
        logger.warn(`Error sending analytics event: ${e}`);
    }
}

/**
 * Return saved amplitude identity info such as session id, device id and user id. We assume these do not change for
 * the duration of the conference.
 *
 * @returns {Object}
 */
export function getAmplitudeIdentity() {
    return analytics.amplitudeIdentityProps;
}

/**
 * Resets the analytics adapter to its initial state - removes handlers, cache,
 * disabled state, etc.
 *
 * @returns {void}
 */
export function resetAnalytics() {
    analytics.reset();
}

/**
 * Creates the analytics handlers.
 *
 * @param {Store} store - The redux store in which the specified {@code action} is being dispatched.
 * @returns {Promise} Resolves with the handlers that have been successfully loaded.
 */
export async function createHandlers({ getState }: IStore) {
    getJitsiMeetGlobalNS().analyticsHandlers = [];

    if (!isAnalyticsEnabled(getState)) {
        // Avoid all analytics processing if there are no handlers, since no event would be sent.
        analytics.dispose();

        return [];
    }

    const state = getState();
    const config = state['features/base/config'];
    const { locationURL } = state['features/base/connection'];
    const host = locationURL ? locationURL.host : '';
    const {
        analytics: analyticsConfig = {},
        deploymentInfo
    } = config;
    const {
        amplitudeAPPKey,
        amplitudeIncludeUTM,
        blackListedEvents,
        scriptURLs,
        googleAnalyticsTrackingId,
        matomoEndpoint,
        matomoSiteID,
        whiteListedEvents
    } = analyticsConfig;
    const { group, user } = state['features/base/jwt'];
    const handlerConstructorOptions = {
        amplitudeAPPKey,
        amplitudeIncludeUTM,
        blackListedEvents,
        envType: deploymentInfo?.envType || 'dev',
        googleAnalyticsTrackingId,
        matomoEndpoint,
        matomoSiteID,
        group,
        host,
        product: deploymentInfo?.product,
        subproduct: deploymentInfo?.environment,
        user: user?.id,
        version: JitsiMeetJS.version,
        whiteListedEvents
    };
    const handlers = [];

    if (amplitudeAPPKey) {
        try {
            const amplitude = new AmplitudeHandler(handlerConstructorOptions);

            analytics.amplitudeIdentityProps = amplitude.getIdentityProps();

            handlers.push(amplitude);
        } catch (e) {
            logger.error('Failed to initialize Amplitude handler', e);
        }
    }

    if (matomoEndpoint && matomoSiteID) {
        try {
            const matomo = new MatomoHandler(handlerConstructorOptions);

            handlers.push(matomo);
        } catch (e) {
            logger.error('Failed to initialize Matomo handler', e);
        }
    }

    if (Array.isArray(scriptURLs) && scriptURLs.length > 0) {
        let externalHandlers;

        try {
            externalHandlers = await _loadHandlers(scriptURLs, handlerConstructorOptions);
            handlers.push(...externalHandlers);
        } catch (e) {
            logger.error('Failed to initialize external analytics handlers', e);
        }
    }

    // Avoid all analytics processing if there are no handlers, since no event would be sent.
    if (handlers.length === 0) {
        analytics.dispose();
    }

    logger.info(`Initialized ${handlers.length} analytics handlers`);

    return handlers;
}

/**
 * Inits JitsiMeetJS.analytics by setting permanent properties and setting the handlers from the loaded scripts.
 * NOTE: Has to be used after JitsiMeetJS.init. Otherwise analytics will be null.
 *
 * @param {Store} store - The redux store in which the specified {@code action} is being dispatched.
 * @param {Array<Object>} handlers - The analytics handlers.
 * @returns {boolean} - True if the analytics were successfully initialized and false otherwise.
 */
export function initAnalytics(store: IStore, handlers: Array<Object>): boolean {
    const { getState, dispatch } = store;

    if (!isAnalyticsEnabled(getState) || handlers.length === 0) {
        return false;
    }

    const state = getState();
    const config = state['features/base/config'];
    const {
        deploymentInfo
    } = config;
    const { group, server } = state['features/base/jwt'];
    const { locationURL = { href: '' } } = state['features/base/connection'];
    const { tenant } = parseURIString(locationURL.href) || {};
    const permanentProperties: {
        appName?: string;
        externalApi?: boolean;
        group?: string;
        inIframe?: boolean;
        isPromotedFromVisitor?: boolean;
        isVisitor?: boolean;
        server?: string;
        tenant?: string;
        wasLobbyVisible?: boolean;
        wasPrejoinDisplayed?: boolean;
        websocket?: boolean;
    } & typeof deploymentInfo = {};

    if (server) {
        permanentProperties.server = server;
    }
    if (group) {
        permanentProperties.group = group;
    }

    // Report the application name
    permanentProperties.appName = getAppName();

    // Report if user is using websocket
    permanentProperties.websocket = typeof config.websocket === 'string';

    // Report if user is using the external API
    permanentProperties.externalApi = typeof API_ID === 'number';

    // Report if we are loaded in iframe
    permanentProperties.inIframe = inIframe();

    // Report the tenant from the URL.
    permanentProperties.tenant = tenant || '/';

    permanentProperties.wasPrejoinDisplayed = isPrejoinPageVisible(state);

    // Currently we don't know if there will be lobby. We will update it to true if we go through lobby.
    permanentProperties.wasLobbyVisible = false;

    // Setting visitor properties to false by default. We will update them later if it turns out we are visitor.
    permanentProperties.isVisitor = false;
    permanentProperties.isPromotedFromVisitor = false;

    // Optionally, include local deployment information based on the
    // contents of window.config.deploymentInfo.
    if (deploymentInfo) {
        for (const key in deploymentInfo) {
            if (deploymentInfo.hasOwnProperty(key)) {
                permanentProperties[key as keyof typeof deploymentInfo] = deploymentInfo[
                    key as keyof typeof deploymentInfo];
            }
        }
    }

    analytics.addPermanentProperties({
        ...permanentProperties,
        ...getState()['features/analytics'].initialPermanentProperties
    });

    analytics.setConferenceName(getAnalyticsRoomName(state, dispatch));

    // Set the handlers last, since this triggers emptying of the cache
    analytics.setAnalyticsHandlers(handlers);

    if (!isMobileBrowser() && browser.isChromiumBased()) {
        const bannerCfg = state['features/base/config'].chromeExtensionBanner;

        checkChromeExtensionsInstalled(bannerCfg).then(extensionsInstalled => {
            if (extensionsInstalled?.length) {
                analytics.addPermanentProperties({
                    hasChromeExtension: extensionsInstalled.some(ext => ext)
                });
            }
        });
    }

    return true;
}

/**
 * Tries to load the scripts for the external analytics handlers and creates them.
 *
 * @param {Array} scriptURLs - The array of script urls to load.
 * @param {Object} handlerConstructorOptions - The default options to pass when creating handlers.
 * @private
 * @returns {Promise} Resolves with the handlers that have been successfully loaded and rejects if there are no handlers
 * loaded or the analytics is disabled.
 */
function _loadHandlers(scriptURLs: string[] = [], handlerConstructorOptions: Object) {
    const promises: Promise<{ error?: Error; type: string; url?: string; }>[] = [];

    for (const url of scriptURLs) {
        promises.push(
            loadScript(url).then(
                () => {
                    return { type: 'success' };
                },
                (error: Error) => {
                    return {
                        type: 'error',
                        error,
                        url
                    };
                }));
    }

    return Promise.all(promises).then(values => {
        for (const el of values) {
            if (el.type === 'error') {
                logger.warn(`Failed to load ${el.url}: ${el.error}`);
            }
        }

        const handlers = [];

        for (const Handler of getJitsiMeetGlobalNS().analyticsHandlers) {
            // Catch any error while loading to avoid skipping analytics in case
            // of multiple scripts.
            try {
                handlers.push(new Handler(handlerConstructorOptions));
            } catch (error) {
                logger.warn(`Error creating analytics handler: ${error}`);
            }
        }
        logger.debug(`Loaded ${handlers.length} external analytics handlers`);

        return handlers;
    });
}


################################################################################

## File: .\jitsi-meet\react\features\analytics\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/analytics');


################################################################################

## File: .\jitsi-meet\react\features\analytics\middleware.ts

import { IReduxState } from '../app/types';
import {
    CONFERENCE_JOINED,
    CONFERENCE_WILL_LEAVE,
    SET_ROOM
} from '../base/conference/actionTypes';
import { SET_CONFIG } from '../base/config/actionTypes';
import { SET_NETWORK_INFO } from '../base/net-info/actionTypes';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import {
    TRACK_ADDED,
    TRACK_REMOVED,
    TRACK_UPDATED
} from '../base/tracks/actionTypes';
import {
    getLocalAudioTrack,
    getLocalVideoTrack
} from '../base/tracks/functions';
import { SET_LOBBY_VISIBILITY } from '../lobby/actionTypes';
import { getIsLobbyVisible } from '../lobby/functions';
import { I_AM_VISITOR_MODE } from '../visitors/actionTypes';
import { iAmVisitor } from '../visitors/functions';

import { createLocalTracksDurationEvent, createNetworkInfoEvent } from './AnalyticsEvents';
import { SET_INITIALIZED, UPDATE_LOCAL_TRACKS_DURATION } from './actionTypes';
import { setPermanentProperty } from './actions';
import { createHandlers, initAnalytics, resetAnalytics, sendAnalytics } from './functions';

/**
 * Calculates the duration of the local tracks.
 *
 * @param {Object} state - The redux state.
 * @returns {Object} - The local tracks duration.
 */
function calculateLocalTrackDuration(state: IReduxState) {
    const now = Date.now();
    const { localTracksDuration } = state['features/analytics'];
    const { conference } = state['features/base/conference'];
    const { audio, video } = localTracksDuration;
    const { camera, desktop } = video;
    const tracks = state['features/base/tracks'];
    const audioTrack = getLocalAudioTrack(tracks);
    const videoTrack = getLocalVideoTrack(tracks);
    const newDuration = { ...localTracksDuration };

    if (!audioTrack || audioTrack.muted || !conference) {
        newDuration.audio = {
            startedTime: -1,
            value: audio.value + (audio.startedTime === -1 ? 0 : now - audio.startedTime)
        };
    } else if (audio.startedTime === -1) {
        newDuration.audio.startedTime = now;
    }

    if (!videoTrack || videoTrack.muted || !conference) {
        newDuration.video = {
            camera: {
                startedTime: -1,
                value: camera.value + (camera.startedTime === -1 ? 0 : now - camera.startedTime)
            },
            desktop: {
                startedTime: -1,
                value: desktop.value + (desktop.startedTime === -1 ? 0 : now - desktop.startedTime)
            }
        };
    } else {
        const { videoType } = videoTrack;

        if (video[videoType as keyof typeof video].startedTime === -1) {
            newDuration.video[videoType as keyof typeof video].startedTime = now;
        }
    }

    return {
        ...localTracksDuration,
        ...newDuration
    };
}

/**
 * Middleware which intercepts config actions to handle evaluating analytics
 * config based on the config stored in the store.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {
    switch (action.type) {
    case I_AM_VISITOR_MODE: {
        const oldIAmVisitor = iAmVisitor(store.getState());
        const result = next(action);
        const newIAmVisitor = iAmVisitor(store.getState());

        store.dispatch(setPermanentProperty({
            isVisitor: newIAmVisitor,
            isPromotedFromVisitor: oldIAmVisitor && !newIAmVisitor
        }));

        return result;
    }
    case SET_CONFIG:
        if (navigator.product === 'ReactNative') {
            // Resetting the analytics is currently not needed for web because
            // the user will be redirected to another page and new instance of
            // Analytics will be created and initialized.
            resetAnalytics();

            const { dispatch } = store;

            dispatch({
                type: SET_INITIALIZED,
                value: false
            });
        }
        break;
    case SET_ROOM: {
        // createHandlers is called before the SET_ROOM action is executed in order for Amplitude to initialize before
        // the deeplinking logic is executed (after the SET_ROOM action) so that the Amplitude device id is available
        // if needed.
        const createHandlersPromise = createHandlers(store);
        const result = next(action);

        createHandlersPromise.then(handlers => {
            if (initAnalytics(store, handlers)) {
                store.dispatch({
                    type: SET_INITIALIZED,
                    value: true
                });
            }
        });

        return result;
    }
    }

    const result = next(action);

    switch (action.type) {
    case CONFERENCE_JOINED: {
        const { dispatch, getState } = store;
        const state = getState();

        dispatch({
            type: UPDATE_LOCAL_TRACKS_DURATION,
            localTracksDuration: {
                ...calculateLocalTrackDuration(state),
                conference: {
                    startedTime: Date.now(),
                    value: 0
                }
            }
        });
        break;
    }

    case CONFERENCE_WILL_LEAVE: {
        const { dispatch, getState } = store;
        const state = getState();
        const { localTracksDuration } = state['features/analytics'];
        const newLocalTracksDuration = {
            ...calculateLocalTrackDuration(state),
            conference: {
                startedTime: -1,
                value: Date.now() - localTracksDuration.conference.startedTime
            }
        };

        sendAnalytics(createLocalTracksDurationEvent(newLocalTracksDuration));

        dispatch({
            type: UPDATE_LOCAL_TRACKS_DURATION,
            localTracksDuration: newLocalTracksDuration
        });
        break;
    }
    case SET_LOBBY_VISIBILITY:
        if (getIsLobbyVisible(store.getState())) {
            store.dispatch(setPermanentProperty({
                wasLobbyVisible: true
            }));
        }

        break;
    case SET_NETWORK_INFO:
        sendAnalytics(
            createNetworkInfoEvent({
                isOnline: action.isOnline,
                details: action.details,
                networkType: action.networkType
            }));
        break;
    case TRACK_ADDED:
    case TRACK_REMOVED:
    case TRACK_UPDATED: {
        const { dispatch, getState } = store;
        const state = getState();
        const { localTracksDuration } = state['features/analytics'];

        if (localTracksDuration.conference.startedTime === -1) {
            // We don't want to track the media duration if the conference is not joined yet because otherwise we won't
            // be able to compare them with the conference duration (from conference join to conference will leave).
            break;
        }
        dispatch({
            type: UPDATE_LOCAL_TRACKS_DURATION,
            localTracksDuration: {
                ...localTracksDuration,
                ...calculateLocalTrackDuration(state)
            }
        });
        break;
    }
    }

    return result;
});


################################################################################

## File: .\jitsi-meet\react\features\analytics\reducer.ts

import ReducerRegistry from '../base/redux/ReducerRegistry';

import {
    SET_INITIALIZED,
    SET_INITIAL_PERMANENT_PROPERTIES,
    UPDATE_LOCAL_TRACKS_DURATION
} from './actionTypes';

/**
 * Initial state.
 */
const DEFAULT_STATE = {
    isInitialized: false,
    initialPermanentProperties: {},
    localTracksDuration: {
        audio: {
            startedTime: -1,
            value: 0
        },
        video: {
            camera: {
                startedTime: -1,
                value: 0
            },
            desktop: {
                startedTime: -1,
                value: 0
            }
        },
        conference: {
            startedTime: -1,
            value: 0
        }
    }
};

interface IValue {
    startedTime: number;
    value: number;
}

export interface IAnalyticsState {
    initialPermanentProperties: Object;
    isInitialized: boolean;
    localTracksDuration: {
        audio: IValue;
        conference: IValue;
        video: {
            camera: IValue;
            desktop: IValue;
        };
    };
}

/**
 * Listen for actions which changes the state of the analytics feature.
 *
 * @param {Object} state - The Redux state of the feature features/analytics.
 * @param {Object} action - Action object.
 * @param {string} action.type - Type of action.
 * @returns {Object}
 */
ReducerRegistry.register<IAnalyticsState>('features/analytics',
(state = DEFAULT_STATE, action): IAnalyticsState => {
    switch (action.type) {
    case SET_INITIALIZED:
        return {
            ...state,
            initialPermanentProperties: action.value ? state.initialPermanentProperties : {},
            isInitialized: action.value
        };
    case SET_INITIAL_PERMANENT_PROPERTIES:
        return {
            ...state,
            initialPermanentProperties: {
                ...state.initialPermanentProperties,
                ...action.properties
            }
        };
    case UPDATE_LOCAL_TRACKS_DURATION:
        return {
            ...state,
            localTracksDuration: action.localTracksDuration
        };
    default:
        return state;
    }
});


################################################################################

## File: .\jitsi-meet\react\features\analytics\handlers\AbstractHandler.ts

export interface IEvent {
    action?: string;
    actionSubject?: string;
    attributes?: {
        [key: string]: string | undefined;
    };
    name?: string;
    source?: string;
    type?: string;
}

interface IOptions {
    amplitudeAPPKey?: string;
    amplitudeIncludeUTM?: boolean;
    blackListedEvents?: string[];
    envType?: string;
    googleAnalyticsTrackingId?: string;
    group?: string;
    host?: string;
    matomoEndpoint?: string;
    matomoSiteID?: string;
    product?: string;
    subproduct?: string;
    user?: string;
    version?: string;
    whiteListedEvents?: string[];
}

/**
 * Abstract implementation of analytics handler.
 */
export default class AbstractHandler {
    _enabled: boolean;
    _whiteListedEvents: Array<string> | undefined;
    _blackListedEvents: Array<string> | undefined;

    /**
     * Creates new instance.
     *
     * @param {Object} options - Optional parameters.
     */
    constructor(options: IOptions = {}) {
        this._enabled = false;
        this._whiteListedEvents = options.whiteListedEvents;

        // FIXME:
        // Keeping the list with the very noisy events so that we don't flood with events whoever hasn't configured
        // white/black lists yet. We need to solve this issue properly by either making these events not so noisy or
        // by removing them completely from the code.
        this._blackListedEvents = [
            ...(options.blackListedEvents || []), // eslint-disable-line no-extra-parens
            'e2e_rtt', 'rtp.stats', 'rtt.by.region', 'available.device', 'stream.switch.delay', 'ice.state.changed',
            'ice.duration', 'peer.conn.status.duration'
        ];
    }

    /**
     * Extracts a name for the event from the event properties.
     *
     * @param {Object} event - The analytics event.
     * @returns {string} - The extracted name.
     */
    _extractName(event: IEvent) {
        // Page events have a single 'name' field.
        if (event.type === 'page') {
            return event.name;
        }

        const {
            action,
            actionSubject,
            source
        } = event;

        // All events have action, actionSubject, and source fields. All
        // three fields are required, and often jitsi-meet and
        // lib-jitsi-meet use the same value when separate values are not
        // necessary (i.e. event.action == event.actionSubject).
        // Here we concatenate these three fields, but avoid adding the same
        // value twice, because it would only make the event's name harder
        // to read.
        let name = action;

        if (actionSubject && actionSubject !== action) {
            name = `${actionSubject}.${action}`;
        }
        if (source && source !== action) {
            name = `${source}.${name}`;
        }

        return name;
    }

    /**
     * Checks if an event should be ignored or not.
     *
     * @param {Object} event - The event.
     * @returns {boolean}
     */
    _shouldIgnore(event: IEvent) {
        if (!event || !this._enabled) {
            return true;
        }

        const name = this._extractName(event) ?? '';

        if (Array.isArray(this._whiteListedEvents)) {
            return this._whiteListedEvents.indexOf(name) === -1;
        }

        if (Array.isArray(this._blackListedEvents)) {
            return this._blackListedEvents.indexOf(name) !== -1;
        }

        return false;
    }
}


################################################################################

## File: .\jitsi-meet\react\features\analytics\handlers\AmplitudeHandler.ts

import logger from '../logger';

import AbstractHandler, { IEvent } from './AbstractHandler';
import { fixDeviceID } from './amplitude/fixDeviceID';
import amplitude from './amplitude/lib';

/**
 * Analytics handler for Amplitude.
 */
export default class AmplitudeHandler extends AbstractHandler {
    _deviceId: string;
    _userId: Object;

    /**
     * Creates new instance of the Amplitude analytics handler.
     *
     * @param {Object} options - The amplitude options.
     * @param {string} options.amplitudeAPPKey - The Amplitude app key required by the Amplitude API.
     * @param {boolean} options.amplitudeIncludeUTM - Whether to include UTM parameters
     * in the Amplitude events.
     */
    constructor(options: any) {
        super(options);

        const {
            amplitudeAPPKey,
            amplitudeIncludeUTM: includeUtm = true,
            user
        } = options;

        this._enabled = true;

        const onError = (e: Error) => {
            logger.error('Error initializing Amplitude', e);
            this._enabled = false;
        };

        // Forces sending all events on exit (flushing) via sendBeacon
        const onExitPage = () => {
            // @ts-ignore
            amplitude.getInstance().sendEvents();
        };

        if (navigator.product === 'ReactNative') {
            amplitude.getInstance().init(amplitudeAPPKey);
            fixDeviceID(amplitude.getInstance()).then(() => {
                amplitude.getInstance().getDeviceId()

                // @ts-ignore
                    .then((deviceId: string) => {
                        this._deviceId = deviceId;
                    });
            });
        } else {
            const amplitudeOptions: any = {
                includeReferrer: true,
                includeUtm,
                saveParamsReferrerOncePerSession: false,
                onError,
                onExitPage
            };

            // @ts-ignore
            amplitude.getInstance().init(amplitudeAPPKey, undefined, amplitudeOptions);
            fixDeviceID(amplitude.getInstance());
        }

        if (user) {
            this._userId = user;
            amplitude.getInstance().setUserId(user);
        }
    }

    /**
     * Sets the Amplitude user properties.
     *
     * @param {Object} userProps - The user portperties.
     * @returns {void}
     */
    setUserProperties(userProps: any) {
        if (this._enabled) {
            amplitude.getInstance().setUserProperties(userProps);
        }
    }

    /**
     * Sends an event to Amplitude. The format of the event is described
     * in AnalyticsAdapter in lib-jitsi-meet.
     *
     * @param {Object} event - The event in the format specified by
     * lib-jitsi-meet.
     * @returns {void}
     */
    sendEvent(event: IEvent) {
        if (this._shouldIgnore(event)) {
            return;
        }

        // @ts-ignore
        amplitude.getInstance().logEvent(this._extractName(event) ?? '', event);
    }

    /**
     * Return amplitude identity information.
     *
     * @returns {Object}
     */
    getIdentityProps() {
        if (navigator.product === 'ReactNative') {
            return {
                deviceId: this._deviceId,
                userId: this._userId
            };
        }

        return {
            sessionId: amplitude.getInstance().getSessionId(),

            // @ts-ignore
            deviceId: amplitude.getInstance().options.deviceId,

            // @ts-ignore
            userId: amplitude.getInstance().options.userId
        };
    }
}


################################################################################

## File: .\jitsi-meet\react\features\analytics\handlers\GoogleAnalyticsHandler.ts

/* global ga */

import { getJitsiMeetGlobalNS } from '../../base/util/helpers';

import AbstractHandler, { IEvent } from './AbstractHandler';

/**
 * Analytics handler for Google Analytics.
 */
class GoogleAnalyticsHandler extends AbstractHandler {
    _userProperties: Object;
    _userPropertiesString: string;

    /**
     * Creates new instance of the GA analytics handler.
     *
     * @param {Object} options - The Google Analytics options.
     * @param {string} options.googleAnalyticsTrackingId - The GA track id
     * required by the GA API.
     */
    constructor(options: any) {
        super(options);

        this._userProperties = {};

        if (!options.googleAnalyticsTrackingId) {
            throw new Error('Failed to initialize Google Analytics handler, no tracking ID');
        }

        this._enabled = true;
        this._initGoogleAnalytics(options);
    }

    /**
     * Initializes the ga object.
     *
     * @param {Object} options - The Google Analytics options.
     * @param {string} options.googleAnalyticsTrackingId - The GA track id
     * required by the GA API.
     * @returns {void}
     */
    _initGoogleAnalytics(options: any) {
        /**
         * TODO: Keep this local, there's no need to add it to window.
         */
        /* eslint-disable */ // @ts-ignore
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            // @ts-ignore
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        /* eslint-enable */
        // @ts-ignore
        ga('create', options.googleAnalyticsTrackingId, 'auto');

        // @ts-ignore
        ga('send', 'pageview');
    }

    /**
     * Extracts the integer to use for a Google Analytics event's value field
     * from a lib-jitsi-meet analytics event.
     *
     * @param {Object} event - The lib-jitsi-meet analytics event.
     * @returns {number} - The integer to use for the 'value' of a Google
     * analytics event, or NaN if the lib-jitsi-meet event doesn't contain a
     * suitable value.
     * @private
     */
    _extractValue(event: IEvent) {
        let value: string | number | undefined = event?.attributes?.value;

        // Try to extract an integer from the "value" attribute.
        value = Math.round(parseFloat(value ?? ''));

        return value;
    }

    /**
     * Extracts the string to use for a Google Analytics event's label field
     * from a lib-jitsi-meet analytics event.
     *
     * @param {Object} event - The lib-jitsi-meet analytics event.
     * @returns {string} - The string to use for the 'label' of a Google
     * analytics event.
     * @private
     */
    _extractLabel(event: IEvent) {
        const { attributes = {} } = event;
        const labelsArray
            = Object.keys(attributes).map(key => `${key}=${attributes[key]}`);

        labelsArray.push(this._userPropertiesString);

        return labelsArray.join('&');
    }

    /**
     * Sets the permanent properties for the current session.
     *
     * @param {Object} userProps - The permanent portperties.
     * @returns {void}
     */
    setUserProperties(userProps: any = {}) {
        if (!this._enabled) {
            return;
        }

        // The label field is limited to 500B. We will concatenate all
        // attributes of the event, except the user agent because it may be
        // lengthy and is probably included from elsewhere.
        const filter = [ 'user_agent', 'callstats_name' ];

        this._userPropertiesString
            = Object.keys(userProps)
                .filter(key => filter.indexOf(key) === -1)
                .map(key => `permanent_${key}=${userProps[key]}`)
                .join('&');
    }

    /**
     * This is the entry point of the API. The function sends an event to
     * google analytics. The format of the event is described in
     * analyticsAdapter in lib-jitsi-meet.
     *
     * @param {Object} event - The event in the format specified by
     * lib-jitsi-meet.
     * @returns {void}
     */
    sendEvent(event: IEvent) {
        if (this._shouldIgnore(event)) {
            return;
        }

        const gaEvent: {
            eventAction?: string;
            eventCategory: string;
            eventLabel: string;
            eventValue?: number;
        } = {
            'eventCategory': 'jitsi-meet',
            'eventAction': this._extractName(event),
            'eventLabel': this._extractLabel(event)
        };
        const value = this._extractValue(event);

        if (!isNaN(value)) {
            gaEvent.eventValue = value;
        }

        // @ts-ignore
        ga('send', 'event', gaEvent);
    }

}

const globalNS = getJitsiMeetGlobalNS();

globalNS.analyticsHandlers = globalNS.analyticsHandlers || [];
globalNS.analyticsHandlers.push(GoogleAnalyticsHandler);


################################################################################

## File: .\jitsi-meet\react\features\analytics\handlers\MatomoHandler.ts

/* global _paq */

import { getJitsiMeetGlobalNS } from '../../base/util/helpers';

import AbstractHandler, { IEvent } from './AbstractHandler';

/**
 * Analytics handler for Matomo.
 */
export default class MatomoHandler extends AbstractHandler {
    _userProperties: Object;

    /**
     * Creates new instance of the Matomo handler.
     *
     * @param {Object} options - The matomo options.
     * @param {string} options.matomoEndpoint - The Matomo endpoint.
     * @param {string} options.matomoSiteID   - The site ID.
     */
    constructor(options: any) {
        super(options);
        this._userProperties = {};

        if (!options.matomoEndpoint) {
            throw new Error(
                'Failed to initialize Matomo handler: no endpoint defined.'
            );
        }
        if (!options.matomoSiteID) {
            throw new Error(
                'Failed to initialize Matomo handler: no site ID defined.'
            );
        }

        this._enabled = true;
        this._initMatomo(options);
    }

    /**
     * Initializes the _paq object.
     *
     * @param {Object} options - The matomo options.
     * @param {string} options.matomoEndpoint - The Matomo endpoint.
     * @param {string} options.matomoSiteID   - The site ID.
     * @returns {void}
     */
    _initMatomo(options: any) {
        // @ts-ignore
        const _paq = window._paq || [];

        // @ts-ignore
        window._paq = _paq;

        _paq.push([ 'trackPageView' ]);
        _paq.push([ 'enableLinkTracking' ]);

        (function() {
            // add trailing slash if needed
            const u = options.matomoEndpoint.endsWith('/')
                ? options.matomoEndpoint
                : `${options.matomoEndpoint}/`;

            // configure the tracker
            _paq.push([ 'setTrackerUrl', `${u}matomo.php` ]);
            _paq.push([ 'setSiteId', options.matomoSiteID ]);

            // insert the matomo script
            const d = document,
                g = d.createElement('script'),
                s = d.getElementsByTagName('script')[0];

            g.type = 'text/javascript';
            g.async = true;
            g.defer = true;
            g.src = `${u}matomo.js`;
            s.parentNode?.insertBefore(g, s);
        })();
    }

    /**
     * Extracts the integer to use for a Matomo event's value field
     * from a lib-jitsi-meet analytics event.
     *
     * @param {Object} event - The lib-jitsi-meet analytics event.
     * @returns {number} - The integer to use for the 'value' of a Matomo
     * event, or NaN if the lib-jitsi-meet event doesn't contain a
     * suitable value.
     * @private
     */
    _extractValue(event: IEvent) {
        const value = event?.attributes?.value;

        // Try to extract an integer from the 'value' attribute.
        return Math.round(parseFloat(value ?? ''));
    }

    /**
     * Sets the permanent properties for the current session.
     *
     * @param {Object} userProps - The permanent properties.
     * @returns {void}
     */
    setUserProperties(userProps: any = {}) {
        if (!this._enabled) {
            return;
        }

        const visitScope = [ 'user_agent', 'callstats_name', 'browser_name' ];

        // add variables in the 'page' scope
        Object.keys(userProps)
            .filter(key => visitScope.indexOf(key) === -1)
            .forEach((key, index) => {
                // @ts-ignore
                _paq.push([
                    'setCustomVariable',
                    1 + index,
                    key,
                    userProps[key],
                    'page'
                ]);
            });


        // add variables in the 'visit' scope
        Object.keys(userProps)
            .filter(key => visitScope.indexOf(key) !== -1)
            .forEach((key, index) => {
                // @ts-ignore
                _paq.push([
                    'setCustomVariable',
                    1 + index,
                    key,
                    userProps[key],
                    'visit'
                ]);
            });
    }

    /**
     * This is the entry point of the API. The function sends an event to
     * the Matomo endpoint. The format of the event is described in
     * analyticsAdapter in lib-jitsi-meet.
     *
     * @param {Object} event - The event in the format specified by
     * lib-jitsi-meet.
     * @returns {void}
     */
    sendEvent(event: IEvent) {
        if (this._shouldIgnore(event)) {
            return;
        }

        const value = this._extractValue(event);
        const matomoEvent: Array<string | number | undefined> = [
            'trackEvent', 'jitsi-meet', this._extractName(event) ];

        if (!isNaN(value)) {
            matomoEvent.push(value);
        }

        // @ts-ignore
        _paq.push(matomoEvent);
    }
}

const globalNS = getJitsiMeetGlobalNS();

globalNS.analyticsHandlers = globalNS.analyticsHandlers || [];
globalNS.analyticsHandlers.push(MatomoHandler);


################################################################################

## File: .\jitsi-meet\react\features\analytics\handlers\amplitude\fixDeviceID.native.ts

import { Amplitude } from '@amplitude/react-native';
import DefaultPreference from 'react-native-default-preference';
import { getUniqueId } from 'react-native-device-info';

import logger from '../../logger';


/**
 * Custom logic for setting the correct device id.
 *
 * @param {AmplitudeClient} amplitude - The amplitude instance.
 * @returns {void}
 */
export async function fixDeviceID(amplitude: Amplitude) {
    await DefaultPreference.setName('jitsi-preferences');

    const current = await DefaultPreference.get('amplitudeDeviceId');

    if (current) {
        await amplitude.setDeviceId(current);
    } else {
        const uid = await getUniqueId();

        if (!uid) {
            logger.warn('Device ID is not set!');

            return;
        }

        await amplitude.setDeviceId(uid as string);
        await DefaultPreference.set('amplitudeDeviceId', uid as string);
    }
}


################################################################################

## File: .\jitsi-meet\react\features\analytics\handlers\amplitude\fixDeviceID.web.ts

import { AmplitudeClient } from 'amplitude-js';

/**
 * Custom logic for setting the correct device id.
 *
 * @param {AmplitudeClient} _amplitude - The amplitude instance.
 * @returns {void}
 */
export function fixDeviceID(_amplitude: AmplitudeClient): Promise<any> {
    return new Promise(resolve => resolve(true));
}


################################################################################

## File: .\jitsi-meet\react\features\analytics\handlers\amplitude\lib.native.ts

import { Amplitude } from '@amplitude/react-native';

export default Amplitude;


################################################################################

## File: .\jitsi-meet\react\features\analytics\handlers\amplitude\lib.web.ts

import amplitude from 'amplitude-js';

export default amplitude;


################################################################################

## File: .\jitsi-meet\react\features\app\actions.any.ts

// @ts-ignore
// eslint-disable-next-line
import { openTokenAuthUrl } from '../authentication/actions';

// @ts-ignore
import { getTokenAuthUrl, isTokenAuthEnabled } from '../authentication/functions';
import { getJwtExpirationDate } from '../base/jwt/functions';
import { MEDIA_TYPE } from '../base/media/constants';
import { isLocalTrackMuted } from '../base/tracks/functions.any';
import { getLocationContextRoot, parseURIString } from '../base/util/uri';

import { addTrackStateToURL } from './functions.any';
import logger from './logger';
import { IStore } from './types';


/**
 * Redirects to another page generated by replacing the path in the original URL
 * with the given path.
 *
 * @param {(string)} pathname - The path to navigate to.
 * @returns {Function}
 */
export function redirectWithStoredParams(pathname: string) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const { locationURL } = getState()['features/base/connection'];
        const newLocationURL = new URL(locationURL?.href ?? '');

        newLocationURL.pathname = pathname;
        window.location.assign(newLocationURL.toString());
    };
}

/**
 * Assigns a specific pathname to window.location.pathname taking into account
 * the context root of the Web app.
 *
 * @param {string} pathname - The pathname to assign to
 * window.location.pathname. If the specified pathname is relative, the context
 * root of the Web app will be prepended to the specified pathname before
 * assigning it to window.location.pathname.
 * @param {string} hashParam - Optional hash param to assign to
 * window.location.hash.
 * @returns {Function}
 */
export function redirectToStaticPage(pathname: string, hashParam?: string) {
    return () => {
        const windowLocation = window.location;
        let newPathname = pathname;

        if (!newPathname.startsWith('/')) {
            // A pathname equal to ./ specifies the current directory. It will be
            // fine but pointless to include it because contextRoot is the current
            // directory.
            newPathname.startsWith('./')
                && (newPathname = newPathname.substring(2));
            newPathname = getLocationContextRoot(windowLocation) + newPathname;
        }

        if (hashParam) {
            windowLocation.hash = hashParam;
        }

        windowLocation.pathname = newPathname;
    };
}

/**
 * Reloads the page by restoring the original URL.
 *
 * @returns {Function}
 */
export function reloadWithStoredParams() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const { locationURL } = state['features/base/connection'];

        // Preserve the local tracks muted states.
        // @ts-ignore
        const newURL = addTrackStateToURL(locationURL, state);
        const windowLocation = window.location;
        const oldSearchString = windowLocation.search;

        windowLocation.replace(newURL.toString());

        if (newURL.search === oldSearchString) {
            // NOTE: Assuming that only the hash or search part of the URL will
            // be changed!
            // location.replace will not trigger redirect/reload when
            // only the hash params are changed. That's why we need to call
            // reload in addition to replace.
            windowLocation.reload();
        }
    };
}

/**
 * Checks whether tokenAuthUrl is set, we have a jwt token that will expire soon
 * and redirect to the auth url to obtain new token if this is the case.
 *
 * @param {Dispatch} dispatch - The Redux dispatch function.
 * @param {Function} getState - The Redux state.
 * @param {Function} failureCallback - The callback on failure to obtain auth url.
 * @returns {boolean} Whether we will redirect or not.
 */
export function maybeRedirectToTokenAuthUrl(
        dispatch: IStore['dispatch'], getState: IStore['getState'], failureCallback: Function) {
    const state = getState();
    const config = state['features/base/config'];
    const { enabled: audioOnlyEnabled } = state['features/base/audio-only'];
    const { startAudioOnly } = config;
    const { locationURL = { href: '' } as URL } = state['features/base/connection'];
    const audioMuted = isLocalTrackMuted(state['features/base/tracks'], MEDIA_TYPE.AUDIO);
    const videoMuted = isLocalTrackMuted(state['features/base/tracks'], MEDIA_TYPE.VIDEO);

    if (!isTokenAuthEnabled(config)) {
        return false;
    }

    // if tokenAuthUrl check jwt if is about to expire go through the url to get new token
    const jwt = state['features/base/jwt'].jwt;
    const expirationDate = getJwtExpirationDate(jwt);

    // if there is jwt and its expiration time is less than 3 minutes away
    // let's obtain new token
    if (expirationDate && expirationDate.getTime() - Date.now() < 3 * 60 * 1000) {
        const room = state['features/base/conference'].room;
        const { tenant } = parseURIString(locationURL.href) || {};

        getTokenAuthUrl(
            config,
            locationURL,
            {
                audioMuted,
                audioOnlyEnabled: audioOnlyEnabled || startAudioOnly,
                skipPrejoin: true,
                videoMuted
            },
            room,
            tenant
        )
            .then((tokenAuthServiceUrl: string | undefined) => {
                if (!tokenAuthServiceUrl) {
                    logger.warn('Cannot handle login, token service URL is not set');

                    return Promise.reject();
                }

                return dispatch(openTokenAuthUrl(tokenAuthServiceUrl));
            })
            .catch(() => {
                failureCallback();
            });

        return true;
    }

    return false;
}




################################################################################

## File: .\jitsi-meet\react\features\app\actions.native.ts

import { setRoom } from '../base/conference/actions';
import { getConferenceState } from '../base/conference/functions';
import {
    configWillLoad,
    loadConfigError,
    setConfig,
    storeConfig
} from '../base/config/actions';
import {
    createFakeConfig,
    restoreConfig
} from '../base/config/functions.native';
import { connect, disconnect, setLocationURL } from '../base/connection/actions.native';
import { JITSI_CONNECTION_URL_KEY } from '../base/connection/constants';
import { loadConfig } from '../base/lib-jitsi-meet/functions.native';
import { createDesiredLocalTracks } from '../base/tracks/actions.native';
import isInsecureRoomName from '../base/util/isInsecureRoomName';
import { parseURLParams } from '../base/util/parseURLParams';
import {
    appendURLParam,
    getBackendSafeRoomName,
    parseURIString,
    toURLString
} from '../base/util/uri';
import { isPrejoinPageEnabled } from '../mobile/navigation/functions';
import {
    goBackToRoot,
    navigateRoot
} from '../mobile/navigation/rootNavigationContainerRef';
import { screen } from '../mobile/navigation/routes';
import { clearNotifications } from '../notifications/actions';
import { isUnsafeRoomWarningEnabled } from '../prejoin/functions';

import { maybeRedirectToTokenAuthUrl } from './actions.any';
import { addTrackStateToURL, getDefaultURL } from './functions.native';
import logger from './logger';
import { IReloadNowOptions, IStore } from './types';

export * from './actions.any';

/**
 * Triggers an in-app navigation to a specific route. Allows navigation to be
 * abstracted between the mobile/React Native and Web/React applications.
 *
 * @param {string|undefined} uri - The URI to which to navigate. It may be a
 * full URL with an HTTP(S) scheme, a full or partial URI with the app-specific
 * scheme, or a mere room name.
 * @param {Object} [options] - Options.
 * @returns {Function}
 */
export function appNavigate(uri?: string, options: IReloadNowOptions = {}) {
    logger.info(`appNavigate to ${uri}`);

    return async (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        let location = parseURIString(uri);

        // If the specified location (URI) does not identify a host, use the app's
        // default.
        if (!location?.host) {
            const defaultLocation = parseURIString(getDefaultURL(getState));

            if (location) {
                location.host = defaultLocation.host;

                // FIXME Turn location's host, hostname, and port properties into
                // setters in order to reduce the risks of inconsistent state.
                location.hostname = defaultLocation.hostname;
                location.pathname
                    = defaultLocation.pathname + location.pathname.substr(1);
                location.port = defaultLocation.port;
                location.protocol = defaultLocation.protocol;
            } else {
                location = defaultLocation;
            }
        }

        location.protocol || (location.protocol = 'https:');
        const { contextRoot, host, hostname, pathname, room } = location;
        const locationURL = new URL(location.toString());
        const { conference } = getConferenceState(getState());

        if (room) {
            if (conference) {

                // We need to check if the location is the same with the previous one.
                const currentLocationURL = conference?.getConnection()[JITSI_CONNECTION_URL_KEY];
                const { hostname: currentHostName, pathname: currentPathName } = currentLocationURL;

                if (currentHostName === hostname && currentPathName === pathname) {
                    logger.warn(`Joining same conference using URL: ${currentLocationURL}`);

                    return;
                }
            } else {
                navigateRoot(screen.connecting);
            }
        }

        dispatch(disconnect());

        dispatch(configWillLoad(locationURL, room));

        let protocol = location.protocol.toLowerCase();

        // The React Native app supports an app-specific scheme which is sure to not
        // be supported by fetch.
        protocol !== 'http:' && protocol !== 'https:' && (protocol = 'https:');

        const baseURL = `${protocol}//${host}${contextRoot || '/'}`;
        let url = `${baseURL}config.js`;

        // XXX In order to support multiple shards, tell the room to the deployment.
        room && (url = appendURLParam(url, 'room', getBackendSafeRoomName(room) ?? ''));

        const { release } = parseURLParams(location, true, 'search');

        release && (url = appendURLParam(url, 'release', release));

        let config;

        // Avoid (re)loading the config when there is no room.
        if (!room) {
            config = restoreConfig(baseURL);
        }

        if (!config) {
            try {
                config = await loadConfig(url);
                dispatch(storeConfig(baseURL, config));
            } catch (error: any) {
                config = restoreConfig(baseURL);

                if (!config) {
                    if (room) {
                        dispatch(loadConfigError(error, locationURL));

                        return;
                    }

                    // If there is no room (we are on the welcome page), don't fail, just create a fake one.
                    logger.warn('Failed to load config but there is no room, applying a fake one');
                    config = createFakeConfig(baseURL);
                }
            }
        }

        if (getState()['features/base/config'].locationURL !== locationURL) {
            dispatch(loadConfigError(new Error('Config no longer needed!'), locationURL));

            return;
        }

        dispatch(setLocationURL(locationURL));
        dispatch(setConfig(config));
        dispatch(setRoom(room));

        if (!room) {
            goBackToRoot(getState(), dispatch);

            return;
        }

        dispatch(createDesiredLocalTracks());
        dispatch(clearNotifications());

        if (!options.hidePrejoin && isPrejoinPageEnabled(getState())) {
            if (isUnsafeRoomWarningEnabled(getState()) && isInsecureRoomName(room)) {
                navigateRoot(screen.unsafeRoomWarning);
            } else {
                navigateRoot(screen.preJoin);
            }
        } else {
            dispatch(connect());
            navigateRoot(screen.conference.root);
        }
    };
}

/**
 * Check if the welcome page is enabled and redirects to it.
 * If requested show a thank you dialog before that.
 * If we have a close page enabled, redirect to it without
 * showing any other dialog.
 *
 * @param {Object} _options - Ignored.
 * @returns {Function}
 */
export function maybeRedirectToWelcomePage(_options?: any): any {
    // Dummy.
}

/**
 * Reloads the page.
 *
 * @protected
 * @returns {Function}
 */
export function reloadNow() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {

        const state = getState();
        const { locationURL } = state['features/base/connection'];

        // Preserve the local tracks muted state after the reload.
        // @ts-ignore
        const newURL = addTrackStateToURL(locationURL, state);

        const reloadAction = () => {
            logger.info(`Reloading the conference using URL: ${locationURL}`);

            dispatch(appNavigate(toURLString(newURL), {
                hidePrejoin: true
            }));
        };

        if (maybeRedirectToTokenAuthUrl(dispatch, getState, reloadAction)) {
            return;
        }

        reloadAction();
    };
}


################################################################################

## File: .\jitsi-meet\react\features\app\actions.web.ts

// @ts-expect-error
import { API_ID } from '../../../modules/API';
import { setRoom } from '../base/conference/actions';
import {
    configWillLoad,
    setConfig
} from '../base/config/actions';
import { setLocationURL } from '../base/connection/actions.web';
import { loadConfig } from '../base/lib-jitsi-meet/functions.web';
import { inIframe } from '../base/util/iframeUtils';
import { parseURIString } from '../base/util/uri';
import { isVpaasMeeting } from '../jaas/functions';
import { clearNotifications, showNotification } from '../notifications/actions';
import { NOTIFICATION_TIMEOUT_TYPE } from '../notifications/constants';
import { isWelcomePageEnabled } from '../welcome/functions';

import {
    maybeRedirectToTokenAuthUrl,
    redirectToStaticPage,
    redirectWithStoredParams,
    reloadWithStoredParams
} from './actions.any';
import { getDefaultURL, getName } from './functions.web';
import logger from './logger';
import { IStore } from './types';

export * from './actions.any';


/**
 * Triggers an in-app navigation to a specific route. Allows navigation to be
 * abstracted between the mobile/React Native and Web/React applications.
 *
 * @param {string|undefined} uri - The URI to which to navigate. It may be a
 * full URL with an HTTP(S) scheme, a full or partial URI with the app-specific
 * scheme, or a mere room name.
 * @returns {Function}
 */
export function appNavigate(uri?: string) {
    return async (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        let location = parseURIString(uri);

        // If the specified location (URI) does not identify a host, use the app's
        // default.
        if (!location?.host) {
            const defaultLocation = parseURIString(getDefaultURL(getState));

            if (location) {
                location.host = defaultLocation.host;

                // FIXME Turn location's host, hostname, and port properties into
                // setters in order to reduce the risks of inconsistent state.
                location.hostname = defaultLocation.hostname;
                location.pathname
                    = defaultLocation.pathname + location.pathname.substr(1);
                location.port = defaultLocation.port;
                location.protocol = defaultLocation.protocol;
            } else {
                location = defaultLocation;
            }
        }

        location.protocol || (location.protocol = 'https:');

        const { room } = location;
        const locationURL = new URL(location.toString());

        // There are notifications now that gets displayed after we technically left
        // the conference, but we're still on the conference screen.
        dispatch(clearNotifications());

        dispatch(configWillLoad(locationURL, room));

        const config = await loadConfig();

        dispatch(setLocationURL(locationURL));
        dispatch(setConfig(config));
        dispatch(setRoom(room));
    };
}

/**
 * Check if the welcome page is enabled and redirects to it.
 * If requested show a thank you dialog before that.
 * If we have a close page enabled, redirect to it without
 * showing any other dialog.
 *
 * @param {Object} options - Used to decide which particular close page to show
 * or if close page is disabled, whether we should show the thankyou dialog.
 * @param {boolean} options.showThankYou - Whether we should
 * show thank you dialog.
 * @param {boolean} options.feedbackSubmitted - Whether feedback was submitted.
 * @returns {Function}
 */
export function maybeRedirectToWelcomePage(options: { feedbackSubmitted?: boolean; showThankYou?: boolean; } = {}) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {

        const {
            enableClosePage
        } = getState()['features/base/config'];

        // if close page is enabled redirect to it, without further action
        if (enableClosePage) {
            if (isVpaasMeeting(getState())) {
                const isOpenedInIframe = inIframe();

                if (isOpenedInIframe) {
                    // @ts-ignore
                    window.location = 'about:blank';
                } else {
                    dispatch(redirectToStaticPage('/'));
                }

                return;
            }

            const { jwt } = getState()['features/base/jwt'];

            let hashParam;

            // save whether current user is guest or not, and pass auth token,
            // before navigating to close page
            window.sessionStorage.setItem('guest', (!jwt).toString());
            window.sessionStorage.setItem('jwt', jwt ?? '');

            let path = 'close.html';

            if (interfaceConfig.SHOW_PROMOTIONAL_CLOSE_PAGE) {
                if (Number(API_ID) === API_ID) {
                    hashParam = `#jitsi_meet_external_api_id=${API_ID}`;
                }
                path = 'close3.html';
            } else if (!options.feedbackSubmitted) {
                path = 'close2.html';
            }

            dispatch(redirectToStaticPage(`static/${path}`, hashParam));

            return;
        }

        // else: show thankYou dialog only if there is no feedback
        if (options.showThankYou) {
            dispatch(showNotification({
                titleArguments: { appName: getName() },
                titleKey: 'dialog.thankYou'
            }, NOTIFICATION_TIMEOUT_TYPE.STICKY));
        }

        // if Welcome page is enabled redirect to welcome page after 3 sec, if
        // there is a thank you message to be shown, 0.5s otherwise.
        if (isWelcomePageEnabled(getState())) {
            setTimeout(
                () => {
                    dispatch(redirectWithStoredParams('/'));
                },
                options.showThankYou ? 3000 : 500);
        }
    };
}

/**
 * Reloads the page.
 *
 * @protected
 * @returns {Function}
 */
export function reloadNow() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {

        const state = getState();
        const { locationURL } = state['features/base/connection'];

        const reloadAction = () => {
            logger.info(`Reloading the conference using URL: ${locationURL}`);

            dispatch(reloadWithStoredParams());
        };

        if (maybeRedirectToTokenAuthUrl(dispatch, getState, reloadAction)) {
            return;
        }

        reloadAction();
    };
}


################################################################################

## File: .\jitsi-meet\react\features\app\functions.any.ts

import { IStateful } from '../base/app/types';
import { MEDIA_TYPE } from '../base/media/constants';
import { toState } from '../base/redux/functions';
import { isLocalTrackMuted } from '../base/tracks/functions';
import { addHashParamsToURL } from '../base/util/uri';

/**
 * Adds the current track state to the passed URL.
 *
 * @param {URL} url - The URL that will be modified.
 * @param {Function|Object} stateful - The redux store or {@code getState} function.
 * @returns {URL} - Returns the modified URL.
 */
export function addTrackStateToURL(url: string, stateful: IStateful) {
    const state = toState(stateful);
    const tracks = state['features/base/tracks'];
    const isVideoMuted = isLocalTrackMuted(tracks, MEDIA_TYPE.VIDEO);
    const isAudioMuted = isLocalTrackMuted(tracks, MEDIA_TYPE.AUDIO);

    return addHashParamsToURL(new URL(url), { // use new URL object in order to not pollute the passed parameter.
        'config.startWithAudioMuted': isAudioMuted,
        'config.startWithVideoMuted': isVideoMuted
    });

}


################################################################################

## File: .\jitsi-meet\react\features\app\functions.native.ts

import { NativeModules } from 'react-native';

import { IStateful } from '../base/app/types';
import { toState } from '../base/redux/functions';
import { getServerURL } from '../base/settings/functions.native';

export * from './functions.any';

/**
 * Retrieves the default URL for the app. This can either come from a prop to
 * the root App component or be configured in the settings.
 *
 * @param {Function|Object} stateful - The redux store or {@code getState}
 * function.
 * @returns {string} - Default URL for the app.
 */
export function getDefaultURL(stateful: IStateful) {
    const state = toState(stateful);

    return getServerURL(state);
}

/**
 * Returns application name.
 *
 * @returns {string} The application name.
 */
export function getName() {
    return NativeModules.AppInfo.name;
}

/**
 * Returns the path to the Jitsi Meet SDK bundle on iOS. On Android it will be
 * undefined.
 *
 * @returns {string|undefined}
 */
export function getSdkBundlePath() {
    return NativeModules.AppInfo.sdkBundlePath;
}


################################################################################

## File: .\jitsi-meet\react\features\app\functions.web.ts

import { IStateful } from '../base/app/types';
import { toState } from '../base/redux/functions';
import { getServerURL } from '../base/settings/functions.web';

export * from './functions.any';

/**
 * Retrieves the default URL for the app. This can either come from a prop to
 * the root App component or be configured in the settings.
 *
 * @param {Function|Object} stateful - The redux store or {@code getState}
 * function.
 * @returns {string} - Default URL for the app.
 */
export function getDefaultURL(stateful: IStateful) {
    const state = toState(stateful);
    const { href } = window.location;

    if (href) {
        return href;
    }

    return getServerURL(state);
}

/**
 * Returns application name.
 *
 * @returns {string} The application name.
 */
export function getName() {
    return interfaceConfig.APP_NAME;
}


################################################################################

## File: .\jitsi-meet\react\features\app\getRouteToRender.native.ts


import RootNavigationContainer from '../mobile/navigation/components/RootNavigationContainer';

const route = {
    component: RootNavigationContainer,
    href: undefined
};

/**
 * Determines which route is to be rendered in order to depict a specific Redux
 * store.
 *
 * @param {any} _stateful - Used on web.
 * @returns {Promise<Object>}
 */
export function _getRouteToRender(_stateful?: any) {
    return Promise.resolve(route);
}


################################################################################

## File: .\jitsi-meet\react\features\app\getRouteToRender.web.ts

// @ts-expect-error
import { generateRoomWithoutSeparator } from '@jitsi/js-utils/random';

import { getTokenAuthUrl } from '../authentication/functions.web';
import { IStateful } from '../base/app/types';
import { isRoomValid } from '../base/conference/functions';
import { isSupportedBrowser } from '../base/environment/environment';
import { browser } from '../base/lib-jitsi-meet';
import { toState } from '../base/redux/functions';
import { parseURIString } from '../base/util/uri';
import Conference from '../conference/components/web/Conference';
import { getDeepLinkingPage } from '../deep-linking/functions';
import UnsupportedDesktopBrowser from '../unsupported-browser/components/UnsupportedDesktopBrowser';
import BlankPage from '../welcome/components/BlankPage.web';
import WelcomePage from '../welcome/components/WelcomePage.web';
import { getCustomLandingPageURL, isWelcomePageEnabled } from '../welcome/functions';

import { IReduxState } from './types';

/**
 * Determines which route is to be rendered in order to depict a specific Redux
 * store.
 *
 * @param {(Function|Object)} stateful - THe redux store, state, or
 * {@code getState} function.
 * @returns {Promise<Object>}
 */
export function _getRouteToRender(stateful: IStateful) {
    const state = toState(stateful);

    return _getWebConferenceRoute(state) || _getWebWelcomePageRoute(state);
}

/**
 * Returns the {@code Route} to display when trying to access a conference if
 * a valid conference is being joined.
 *
 * @param {Object} state - The redux state.
 * @returns {Promise|undefined}
 */
function _getWebConferenceRoute(state: IReduxState) {
    const room = state['features/base/conference'].room;

    if (!isRoomValid(room)) {
        return;
    }

    const route = _getEmptyRoute();
    const config = state['features/base/config'];

    // if we have auto redirect enabled, and we have previously logged in successfully
    // let's redirect to the auth url to get the token and login again
    if (!browser.isElectron() && config.tokenAuthUrl && config.tokenAuthUrlAutoRedirect
            && state['features/authentication'].tokenAuthUrlSuccessful
            && !state['features/base/jwt'].jwt && room) {
        const { locationURL = { href: '' } as URL } = state['features/base/connection'];
        const { tenant } = parseURIString(locationURL.href) || {};
        const { startAudioOnly } = config;

        return getTokenAuthUrl(
            config,
            locationURL,
            {
                audioMuted: false,
                audioOnlyEnabled: startAudioOnly,
                skipPrejoin: false,
                videoMuted: false
            },
            room,
            tenant
        )
            .then((url: string | undefined) => {
                route.href = url;

                return route;
            })
            .catch(() => Promise.resolve(route));
    }

    // Update the location if it doesn't match. This happens when a room is
    // joined from the welcome page. The reason for doing this instead of using
    // the history API is that we want to load the config.js which takes the
    // room into account.
    const { locationURL } = state['features/base/connection'];

    if (window.location.href !== locationURL?.href) {
        route.href = locationURL?.href;

        return Promise.resolve(route);
    }

    return getDeepLinkingPage(state)
        .then(deepLinkComponent => {
            if (deepLinkComponent) {
                route.component = deepLinkComponent;
            } else if (isSupportedBrowser()) {
                route.component = Conference;
            } else {
                route.component = UnsupportedDesktopBrowser;
            }

            return route;
        });
}

/**
 * Returns the {@code Route} to display when trying to access the welcome page.
 *
 * @param {Object} state - The redux state.
 * @returns {Promise<Object>}
 */
function _getWebWelcomePageRoute(state: IReduxState) {
    const route = _getEmptyRoute();

    if (isWelcomePageEnabled(state)) {
        if (isSupportedBrowser()) {
            const customLandingPage = getCustomLandingPageURL(state);

            if (customLandingPage) {
                route.href = customLandingPage;
            } else {
                route.component = WelcomePage;
            }
        } else {
            route.component = UnsupportedDesktopBrowser;
        }
    } else {
        // Web: if the welcome page is disabled, go directly to a random room.
        const url = new URL(window.location.href);

        url.pathname += generateRoomWithoutSeparator();
        route.href = url.href;
    }

    return Promise.resolve(route);
}

/**
 * Returns the default {@code Route}.
 *
 * @returns {Object}
 */
function _getEmptyRoute(): {
    component: React.ReactNode;
    href?: string;
    } {
    return {
        component: BlankPage,
        href: undefined
    };
}


################################################################################

## File: .\jitsi-meet\react\features\app\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/app');


################################################################################

## File: .\jitsi-meet\react\features\app\middleware.ts

import { AnyAction } from 'redux';

import { createConnectionEvent } from '../analytics/AnalyticsEvents';
import { sendAnalytics } from '../analytics/functions';
import { appWillNavigate } from '../base/app/actions';
import { SET_ROOM } from '../base/conference/actionTypes';
import { CONNECTION_ESTABLISHED, CONNECTION_FAILED } from '../base/connection/actionTypes';
import { getURLWithoutParams } from '../base/connection/utils';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import { inIframe } from '../base/util/iframeUtils';

import { reloadNow } from './actions';
import { _getRouteToRender } from './getRouteToRender';
import { IStore } from './types';

MiddlewareRegistry.register(store => next => action => {
    switch (action.type) {
    case CONNECTION_ESTABLISHED:
        return _connectionEstablished(store, next, action);
    case CONNECTION_FAILED:
        return _connectionFailed(store, next, action);

    case SET_ROOM:
        return _setRoom(store, next, action);
    }

    return next(action);
});

/**
 * Notifies the feature app that the action {@link CONNECTION_ESTABLISHED} is
 * being dispatched within a specific redux {@code store}.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @param {Dispatch} next - The redux {@code dispatch} function to dispatch the
 * specified {@code action} to the specified {@code store}.
 * @param {Action} action - The redux action {@code CONNECTION_ESTABLISHED}
 * which is being dispatched in the specified {@code store}.
 * @private
 * @returns {Object} The new state that is the result of the reduction of the
 * specified {@code action}.
 */
function _connectionEstablished(store: IStore, next: Function, action: AnyAction) {
    const result = next(action);

    // In the Web app we explicitly do not want to display the hash and
    // query/search URL params. Unfortunately, window.location and, more
    // importantly, its params are used not only in jitsi-meet but also in
    // lib-jitsi-meet. Consequently, the time to remove the params is
    // determined by when no one needs them anymore.
    // @ts-ignore
    const { history, location } = window;

    if (inIframe()) {
        return;
    }

    if (history
            && location
            && history.length
            && typeof history.replaceState === 'function') {
        // @ts-ignore
        const replacement = getURLWithoutParams(location);

        // @ts-ignore
        if (location !== replacement) {
            history.replaceState(
                history.state,
                document?.title || '',
                replacement);
        }
    }

    return result;
}

/**
 * CONNECTION_FAILED action side effects.
 *
 * @param {Object} store - The Redux store.
 * @param {Dispatch} next - The redux {@code dispatch} function to dispatch the specified {@code action} to
 * the specified {@code store}.
 * @param {Action} action - The redux action {@code CONNECTION_FAILED} which is being dispatched in the specified
 * {@code store}.
 * @returns {Object}
 * @private
 */
function _connectionFailed({ dispatch, getState }: IStore, next: Function, action: AnyAction) {
    // In the case of a split-brain error, reload early and prevent further
    // handling of the action.
    if (_isMaybeSplitBrainError(getState, action)) {
        dispatch(reloadNow());

        return;
    }

    return next(action);
}

/**
 * Returns whether or not a CONNECTION_FAILED action is for a possible split brain error. A split brain error occurs
 * when at least two users join a conference on different bridges. It is assumed the split brain scenario occurs very
 * early on in the call.
 *
 * @param {Function} getState - The redux function for fetching the current state.
 * @param {Action} action - The redux action {@code CONNECTION_FAILED} which is being dispatched in the specified
 * {@code store}.
 * @private
 * @returns {boolean}
 */
function _isMaybeSplitBrainError(getState: IStore['getState'], action: AnyAction) {
    const { error } = action;
    const isShardChangedError = error
        && error.message === 'item-not-found'
        && error.details
        && error.details.shard_changed;

    if (isShardChangedError) {
        const state = getState();
        const { timeEstablished } = state['features/base/connection'];
        const { _immediateReloadThreshold } = state['features/base/config'];

        const timeSinceConnectionEstablished = Number(timeEstablished && Date.now() - timeEstablished);
        const reloadThreshold = typeof _immediateReloadThreshold === 'number' ? _immediateReloadThreshold : 1500;

        const isWithinSplitBrainThreshold = !timeEstablished || timeSinceConnectionEstablished <= reloadThreshold;

        sendAnalytics(createConnectionEvent('failed', {
            ...error,
            connectionEstablished: timeEstablished,
            splitBrain: isWithinSplitBrainThreshold,
            timeSinceConnectionEstablished
        }));

        return isWithinSplitBrainThreshold;
    }

    return false;
}

/**
 * Navigates to a route in accord with a specific redux state.
 *
 * @param {Store} store - The redux store which determines/identifies the route
 * to navigate to.
 * @private
 * @returns {void}
 */
function _navigate({ dispatch, getState }: IStore) {
    const state = getState();
    const { app } = state['features/base/app'];

    _getRouteToRender(state).then((route: Object) => {
        dispatch(appWillNavigate(app, route));

        return app._navigate(route);
    });
}

/**
 * Notifies the feature app that the action {@link SET_ROOM} is being dispatched
 * within a specific redux {@code store}.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @param {Dispatch} next - The redux {@code dispatch} function to dispatch the
 * specified {@code action} to the specified {@code store}.
 * @param {Action} action - The redux action, {@code SET_ROOM}, which is being
 * dispatched in the specified {@code store}.
 * @private
 * @returns {Object} The new state that is the result of the reduction of the
 * specified {@code action}.
 */
function _setRoom(store: IStore, next: Function, action: AnyAction) {
    const result = next(action);

    _navigate(store);

    return result;
}


################################################################################

## File: .\jitsi-meet\react\features\app\middlewares.any.ts

import '../analytics/middleware';
import '../authentication/middleware';
import '../av-moderation/middleware';
import '../base/conference/middleware';
import '../base/config/middleware';
import '../base/i18n/middleware';
import '../base/jwt/middleware';
import '../base/known-domains/middleware';
import '../base/lastn/middleware';
import '../base/lib-jitsi-meet/middleware';
import '../base/logging/middleware';
import '../base/media/middleware';
import '../base/net-info/middleware';
import '../base/participants/middleware';
import '../base/responsive-ui/middleware';
import '../base/redux/middleware';
import '../base/settings/middleware';
import '../base/sounds/middleware';
import '../base/testing/middleware';
import '../base/tracks/middleware';
import '../base/user-interaction/middleware';
import '../breakout-rooms/middleware';
import '../calendar-sync/middleware';
import '../chat/middleware';
import '../conference/middleware';
import '../connection-indicator/middleware';
import '../deep-linking/middleware';
import '../device-selection/middleware';
import '../display-name/middleware';
import '../dynamic-branding/middleware';
import '../etherpad/middleware';
import '../filmstrip/middleware';
import '../follow-me/middleware';
import '../invite/middleware';
import '../jaas/middleware';
import '../large-video/middleware';
import '../lobby/middleware';
import '../notifications/middleware';
import '../overlay/middleware';
import '../participants-pane/middleware';
import '../polls/middleware';
import '../polls-history/middleware';
import '../reactions/middleware';
import '../recent-list/middleware';
import '../recording/middleware';
import '../rejoin/middleware';
import '../room-lock/middleware';
import '../rtcstats/middleware';
import '../speaker-stats/middleware';
import '../subtitles/middleware';
import '../transcribing/middleware';
import '../video-layout/middleware';
import '../video-quality/middleware';
import '../videosipgw/middleware';
import '../visitors/middleware';
import '../whiteboard/middleware.any';

import './middleware';


################################################################################

## File: .\jitsi-meet\react\features\app\middlewares.native.ts

import '../dynamic-branding/middleware';
import '../gifs/middleware';
import '../mobile/audio-mode/middleware';
import '../mobile/background/middleware';
import '../mobile/call-integration/middleware';
import '../mobile/external-api/middleware';
import '../mobile/full-screen/middleware';
import '../mobile/navigation/middleware';
import '../mobile/permissions/middleware';
import '../mobile/proximity/middleware';
import '../mobile/wake-lock/middleware';
import '../mobile/react-native-sdk/middleware';
import '../mobile/watchos/middleware';
import '../share-room/middleware';
import '../shared-video/middleware';
import '../whiteboard/middleware.native';

import './middlewares.any';


################################################################################

## File: .\jitsi-meet\react\features\app\middlewares.web.ts

import '../base/app/middleware';
import '../base/connection/middleware';
import '../base/devices/middleware';
import '../base/media/middleware';
import '../dynamic-branding/middleware';
import '../e2ee/middleware';
import '../external-api/middleware';
import '../keyboard-shortcuts/middleware';
import '../no-audio-signal/middleware';
import '../notifications/middleware';
import '../noise-detection/middleware';
import '../old-client-notification/middleware';
import '../power-monitor/middleware';
import '../prejoin/middleware';
import '../remote-control/middleware';
import '../screen-share/middleware';
import '../shared-video/middleware';
import '../web-hid/middleware';
import '../settings/middleware';
import '../talk-while-muted/middleware';
import '../toolbox/middleware';
import '../face-landmarks/middleware';
import '../gifs/middleware';
import '../whiteboard/middleware.web';

import './middlewares.any';


################################################################################

## File: .\jitsi-meet\react\features\app\reducer.native.ts

import ReducerRegistry from '../base/redux/ReducerRegistry';
import { _ROOT_NAVIGATION_READY } from '../mobile/navigation/actionTypes';

/**
 * Listen for actions which changes the state of the app feature.
 *
 * @param {Object} state - The Redux state of the feature features/app.
 * @param {Object} action - Action object.
 * @param {string} action.type - Type of action.
 * @returns {Object}
 */
ReducerRegistry.register('features/app', (state: Object = {}, action) => {
    switch (action.type) {
    case _ROOT_NAVIGATION_READY:
        return {
            ...state,
            ready: action.ready
        };
    default:
        return state;
    }
});


################################################################################

## File: .\jitsi-meet\react\features\app\reducers.any.ts

import '../analytics/reducer';
import '../authentication/reducer';
import '../av-moderation/reducer';
import '../base/app/reducer';
import '../base/audio-only/reducer';
import '../base/conference/reducer';
import '../base/config/reducer';
import '../base/connection/reducer';
import '../base/dialog/reducer';
import '../base/flags/reducer';
import '../base/jwt/reducer';
import '../base/known-domains/reducer';
import '../base/lastn/reducer';
import '../base/lib-jitsi-meet/reducer';
import '../base/logging/reducer';
import '../base/media/reducer';
import '../base/net-info/reducer';
import '../base/participants/reducer';
import '../base/responsive-ui/reducer';
import '../base/settings/reducer';
import '../base/sounds/reducer';
import '../base/testing/reducer';
import '../base/tracks/reducer';
import '../base/user-interaction/reducer';
import '../breakout-rooms/reducer';
import '../calendar-sync/reducer';
import '../chat/reducer';
import '../deep-linking/reducer';
import '../dropbox/reducer';
import '../dynamic-branding/reducer';
import '../etherpad/reducer';
import '../filmstrip/reducer';
import '../follow-me/reducer';
import '../gifs/reducer';
import '../google-api/reducer';
import '../invite/reducer';
import '../jaas/reducer';
import '../large-video/reducer';
import '../lobby/reducer';
import '../notifications/reducer';
import '../overlay/reducer';
import '../participants-pane/reducer';
import '../polls/reducer';
import '../polls-history/reducer';
import '../reactions/reducer';
import '../recent-list/reducer';
import '../recording/reducer';
import '../settings/reducer';
import '../speaker-stats/reducer';
import '../shared-video/reducer';
import '../subtitles/reducer';
import '../screen-share/reducer';
import '../toolbox/reducer';
import '../transcribing/reducer';
import '../video-layout/reducer';
import '../video-quality/reducer';
import '../videosipgw/reducer';
import '../visitors/reducer';
import '../whiteboard/reducer';


################################################################################

## File: .\jitsi-meet\react\features\app\reducers.native.ts

import '../mobile/audio-mode/reducer';
import '../mobile/background/reducer';
import '../mobile/call-integration/reducer';
import '../mobile/external-api/reducer';
import '../mobile/full-screen/reducer';
import '../mobile/watchos/reducer';
import '../share-room/reducer';

import './reducer.native';

import './reducers.any';


################################################################################

## File: .\jitsi-meet\react\features\app\reducers.web.ts

import '../base/devices/reducer';
import '../base/premeeting/reducer';
import '../base/tooltip/reducer';
import '../e2ee/reducer';
import '../face-landmarks/reducer';
import '../feedback/reducer';
import '../keyboard-shortcuts/reducer';
import '../no-audio-signal/reducer';
import '../noise-detection/reducer';
import '../participants-pane/reducer';
import '../power-monitor/reducer';
import '../prejoin/reducer';
import '../remote-control/reducer';
import '../screen-share/reducer';
import '../noise-suppression/reducer';
import '../screenshot-capture/reducer';
import '../talk-while-muted/reducer';
import '../virtual-background/reducer';
import '../web-hid/reducer';

import './reducers.any';


################################################################################

## File: .\jitsi-meet\react\features\app\types.ts

import { AnyAction } from 'redux';
import { ThunkDispatch } from 'redux-thunk';

import { IAnalyticsState } from '../analytics/reducer';
import { IAuthenticationState } from '../authentication/reducer';
import { IAVModerationState } from '../av-moderation/reducer';
import { IAppState } from '../base/app/reducer';
import { IAudioOnlyState } from '../base/audio-only/reducer';
import { IConferenceState } from '../base/conference/reducer';
import { IConfigState } from '../base/config/reducer';
import { IConnectionState } from '../base/connection/reducer';
import { IDevicesState } from '../base/devices/types';
import { IDialogState } from '../base/dialog/reducer';
import { IFlagsState } from '../base/flags/reducer';
import { IJwtState } from '../base/jwt/reducer';
import { IKnownDomainsState } from '../base/known-domains/reducer';
import { ILastNState } from '../base/lastn/reducer';
import { ILibJitsiMeetState } from '../base/lib-jitsi-meet/reducer';
import { ILoggingState } from '../base/logging/reducer';
import { IMediaState } from '../base/media/reducer';
import { INetInfoState } from '../base/net-info/reducer';
import { IParticipantsState } from '../base/participants/reducer';
import { IPreMeetingState } from '../base/premeeting/types';
import { IResponsiveUIState } from '../base/responsive-ui/reducer';
import { ISettingsState } from '../base/settings/reducer';
import { ISoundsState } from '../base/sounds/reducer';
import { ITestingState } from '../base/testing/reducer';
import { ITooltipState } from '../base/tooltip/reducer';
import { INoSrcDataState, ITracksState } from '../base/tracks/reducer';
import { IUserInteractionState } from '../base/user-interaction/reducer';
import { IBreakoutRoomsState } from '../breakout-rooms/reducer';
import { ICalendarSyncState } from '../calendar-sync/reducer';
import { IChatState } from '../chat/reducer';
import { IDeepLinkingState } from '../deep-linking/reducer';
import { IDropboxState } from '../dropbox/reducer';
import { IDynamicBrandingState } from '../dynamic-branding/reducer';
import { IE2EEState } from '../e2ee/reducer';
import { IEtherpadState } from '../etherpad/reducer';
import { IFaceLandmarksState } from '../face-landmarks/reducer';
import { IFeedbackState } from '../feedback/reducer';
import { IFilmstripState } from '../filmstrip/reducer';
import { IFollowMeState } from '../follow-me/reducer';
import { IGifsState } from '../gifs/reducer';
import { IGoogleApiState } from '../google-api/reducer';
import { IInviteState } from '../invite/reducer';
import { IJaaSState } from '../jaas/reducer';
import { IKeyboardShortcutsState } from '../keyboard-shortcuts/types';
import { ILargeVideoState } from '../large-video/reducer';
import { ILobbyState } from '../lobby/reducer';
import { IMobileAudioModeState } from '../mobile/audio-mode/reducer';
import { IBackgroundState } from '../mobile/background/reducer';
import { ICallIntegrationState } from '../mobile/call-integration/reducer';
import { IMobileExternalApiState } from '../mobile/external-api/reducer';
import { IFullScreenState } from '../mobile/full-screen/reducer';
import { IMobileWatchOSState } from '../mobile/watchos/reducer';
import { INoAudioSignalState } from '../no-audio-signal/reducer';
import { INoiseDetectionState } from '../noise-detection/reducer';
import { INoiseSuppressionState } from '../noise-suppression/reducer';
import { INotificationsState } from '../notifications/reducer';
import { IOverlayState } from '../overlay/reducer';
import { IParticipantsPaneState } from '../participants-pane/reducer';
import { IPollsState } from '../polls/reducer';
import { IPollsHistoryState } from '../polls-history/reducer';
import { IPowerMonitorState } from '../power-monitor/reducer';
import { IPrejoinState } from '../prejoin/reducer';
import { IReactionsState } from '../reactions/reducer';
import { IRecentListState } from '../recent-list/reducer';
import { IRecordingState } from '../recording/reducer';
import { IRemoteControlState } from '../remote-control/reducer';
import { IScreenShareState } from '../screen-share/reducer';
import { IScreenshotCaptureState } from '../screenshot-capture/reducer';
import { IShareRoomState } from '../share-room/reducer';
import { ISharedVideoState } from '../shared-video/reducer';
import { ISpeakerStatsState } from '../speaker-stats/reducer';
import { ISubtitlesState } from '../subtitles/reducer';
import { ITalkWhileMutedState } from '../talk-while-muted/reducer';
import { IToolboxState } from '../toolbox/reducer';
import { ITranscribingState } from '../transcribing/reducer';
import { IVideoLayoutState } from '../video-layout/reducer';
import { IVideoQualityPersistedState, IVideoQualityState } from '../video-quality/reducer';
import { IVideoSipGW } from '../videosipgw/reducer';
import { IVirtualBackground } from '../virtual-background/reducer';
import { IVisitorsState } from '../visitors/reducer';
import { IWebHid } from '../web-hid/reducer';
import { IWhiteboardState } from '../whiteboard/reducer';

export interface IStore {
    dispatch: ThunkDispatch<IReduxState, void, AnyAction>;
    getState: () => IReduxState;
}

export interface IReduxState {
    'features/analytics': IAnalyticsState;
    'features/authentication': IAuthenticationState;
    'features/av-moderation': IAVModerationState;
    'features/background': IBackgroundState;
    'features/base/app': IAppState;
    'features/base/audio-only': IAudioOnlyState;
    'features/base/color-scheme': any;
    'features/base/conference': IConferenceState;
    'features/base/config': IConfigState;
    'features/base/connection': IConnectionState;
    'features/base/devices': IDevicesState;
    'features/base/dialog': IDialogState;
    'features/base/flags': IFlagsState;
    'features/base/jwt': IJwtState;
    'features/base/known-domains': IKnownDomainsState;
    'features/base/lastn': ILastNState;
    'features/base/lib-jitsi-meet': ILibJitsiMeetState;
    'features/base/logging': ILoggingState;
    'features/base/media': IMediaState;
    'features/base/net-info': INetInfoState;
    'features/base/no-src-data': INoSrcDataState;
    'features/base/participants': IParticipantsState;
    'features/base/premeeting': IPreMeetingState;
    'features/base/responsive-ui': IResponsiveUIState;
    'features/base/settings': ISettingsState;
    'features/base/sounds': ISoundsState;
    'features/base/tooltip': ITooltipState;
    'features/base/tracks': ITracksState;
    'features/base/user-interaction': IUserInteractionState;
    'features/breakout-rooms': IBreakoutRoomsState;
    'features/calendar-sync': ICalendarSyncState;
    'features/call-integration': ICallIntegrationState;
    'features/chat': IChatState;
    'features/deep-linking': IDeepLinkingState;
    'features/dropbox': IDropboxState;
    'features/dynamic-branding': IDynamicBrandingState;
    'features/e2ee': IE2EEState;
    'features/etherpad': IEtherpadState;
    'features/face-landmarks': IFaceLandmarksState;
    'features/feedback': IFeedbackState;
    'features/filmstrip': IFilmstripState;
    'features/follow-me': IFollowMeState;
    'features/full-screen': IFullScreenState;
    'features/gifs': IGifsState;
    'features/google-api': IGoogleApiState;
    'features/invite': IInviteState;
    'features/jaas': IJaaSState;
    'features/keyboard-shortcuts': IKeyboardShortcutsState;
    'features/large-video': ILargeVideoState;
    'features/lobby': ILobbyState;
    'features/mobile/audio-mode': IMobileAudioModeState;
    'features/mobile/external-api': IMobileExternalApiState;
    'features/mobile/watchos': IMobileWatchOSState;
    'features/no-audio-signal': INoAudioSignalState;
    'features/noise-detection': INoiseDetectionState;
    'features/noise-suppression': INoiseSuppressionState;
    'features/notifications': INotificationsState;
    'features/overlay': IOverlayState;
    'features/participants-pane': IParticipantsPaneState;
    'features/polls': IPollsState;
    'features/polls-history': IPollsHistoryState;
    'features/power-monitor': IPowerMonitorState;
    'features/prejoin': IPrejoinState;
    'features/reactions': IReactionsState;
    'features/recent-list': IRecentListState;
    'features/recording': IRecordingState;
    'features/remote-control': IRemoteControlState;
    'features/screen-share': IScreenShareState;
    'features/screenshot-capture': IScreenshotCaptureState;
    'features/settings': ISettingsState;
    'features/share-room': IShareRoomState;
    'features/shared-video': ISharedVideoState;
    'features/speaker-stats': ISpeakerStatsState;
    'features/subtitles': ISubtitlesState;
    'features/talk-while-muted': ITalkWhileMutedState;
    'features/testing': ITestingState;
    'features/toolbox': IToolboxState;
    'features/transcribing': ITranscribingState;
    'features/video-layout': IVideoLayoutState;
    'features/video-quality': IVideoQualityState;
    'features/video-quality-persistent-storage': IVideoQualityPersistedState;
    'features/videosipgw': IVideoSipGW;
    'features/virtual-background': IVirtualBackground;
    'features/visitors': IVisitorsState;
    'features/web-hid': IWebHid;
    'features/whiteboard': IWhiteboardState;
}

export interface IReloadNowOptions {
    hidePrejoin?: boolean;
}


################################################################################

## File: .\jitsi-meet\react\features\app\components\AbstractApp.ts

import BaseApp from '../../base/app/components/BaseApp';
import { toURLString } from '../../base/util/uri';
import { appNavigate } from '../actions';
import { getDefaultURL } from '../functions';

/**
 * The type of React {@code Component} props of {@link AbstractApp}.
 */
export interface IProps {

    /**
     * XXX Refer to the implementation of loadURLObject: in
     * ios/sdk/src/JitsiMeetView.m for further information.
     */
    timestamp: number;

    /**
     * The URL, if any, with which the app was launched.
     */
    url: Object | string;
}

/**
 * Base (abstract) class for main App component.
 *
 * @abstract
 */
export class AbstractApp<P extends IProps = IProps> extends BaseApp<P> {
    /**
     * The deferred for the initialisation {{promise, resolve, reject}}.
     */
    _init: {
        promise: Promise<any>;
    };

    /**
     * Initializes the app.
     *
     * @inheritdoc
     */
    async componentDidMount() {
        await super.componentDidMount();

        // If a URL was explicitly specified to this React Component, then
        // open it; otherwise, use a default.
        this._openURL(toURLString(this.props.url) || this._getDefaultURL());
    }

    /**
     * Implements React Component's componentDidUpdate.
     *
     * @inheritdoc
     */
    async componentDidUpdate(prevProps: IProps) {
        const previousUrl = toURLString(prevProps.url);
        const currentUrl = toURLString(this.props.url);
        const previousTimestamp = prevProps.timestamp;
        const currentTimestamp = this.props.timestamp;

        await this._init.promise;

        // Deal with URL changes.

        if (previousUrl !== currentUrl

            // XXX Refer to the implementation of loadURLObject: in
            // ios/sdk/src/JitsiMeetView.m for further information.
            || previousTimestamp !== currentTimestamp) {
            this._openURL(currentUrl || this._getDefaultURL());
        }
    }

    /**
     * Gets the default URL to be opened when this {@code App} mounts.
     *
     * @protected
     * @returns {string} The default URL to be opened when this {@code App}
     * mounts.
     */
    _getDefaultURL() {
        // @ts-ignore
        return getDefaultURL(this.state.store);
    }

    /**
     * Navigates this {@code AbstractApp} to (i.e. Opens) a specific URL.
     *
     * @param {Object|string} url - The URL to navigate this {@code AbstractApp}
     * to (i.e. The URL to open).
     * @protected
     * @returns {void}
     */
    _openURL(url: string | Object) {
        this.state.store?.dispatch(appNavigate(toURLString(url)));
    }
}


################################################################################

## File: .\jitsi-meet\react\features\authentication\actions.any.ts

import { IStore } from '../app/types';
import { checkIfCanJoin } from '../base/conference/actions';
import { IJitsiConference } from '../base/conference/reducer';
import { hideDialog, openDialog } from '../base/dialog/actions';

import {
    LOGIN,
    LOGOUT,
    SET_TOKEN_AUTH_URL_SUCCESS,
    STOP_WAIT_FOR_OWNER,
    UPGRADE_ROLE_FINISHED,
    UPGRADE_ROLE_STARTED, WAIT_FOR_OWNER
} from './actionTypes';
import { LoginDialog, WaitForOwnerDialog } from './components';
import logger from './logger';

/**
 * Initiates authenticating and upgrading the role of the local participant to
 * moderator which will allow to create and join a new conference on an XMPP
 * password + guest access configuration. Refer to {@link LoginDialog} for more
 * info.
 *
 * @param {string} id - The XMPP user's ID (e.g. {@code user@domain.com}).
 * @param {string} password - The XMPP user's password.
 * @param {JitsiConference} conference - The conference for which the local
 * participant's role will be upgraded.
 * @returns {Function}
 */
export function authenticateAndUpgradeRole(
        id: string,
        password: string,
        conference: IJitsiConference) {
    return (dispatch: IStore['dispatch']) => {
        const process
            = conference.authenticateAndUpgradeRole({
                id,
                password,

                onLoginSuccessful() {
                // When the login succeeds, the process has completed half
                // of its job (i.e. 0.5).
                    return dispatch(_upgradeRoleFinished(process, 0.5));
                }
            });

        dispatch(_upgradeRoleStarted(process));
        process.then(
            /* onFulfilled */ () => dispatch(_upgradeRoleFinished(process, 1)),
            /* onRejected */ (error: any) => {
                // The lack of an error signals a cancellation.
                if (error.authenticationError || error.connectionError) {
                    logger.error('authenticateAndUpgradeRole failed', error);
                }

                dispatch(_upgradeRoleFinished(process, error));
            });

        return process;
    };
}


/**
 * Signals that the process of authenticating and upgrading the local
 * participant's role has finished either with success or with a specific error.
 *
 * @param {Object} thenableWithCancel - The process of authenticating and
 * upgrading the local participant's role.
 * @param {Object} progressOrError - If the value is a {@code number}, then the
 * process of authenticating and upgrading the local participant's role has
 * succeeded in one of its two/multiple steps; otherwise, it has failed with the
 * specified error. Refer to {@link JitsiConference#authenticateAndUpgradeRole}
 * in lib-jitsi-meet for the error details.
 * @private
 * @returns {{
 *     type: UPGRADE_ROLE_FINISHED,
 *     error: ?Object,
 *     progress: number
 * }}
 */
function _upgradeRoleFinished(
        thenableWithCancel: Object,
        progressOrError: number | any) {
    let error;
    let progress;

    if (typeof progressOrError === 'number') {
        progress = progressOrError;
    } else {
        // Make the specified error object resemble an Error instance (to the
        // extent that jitsi-meet needs it).
        const {
            authenticationError,
            connectionError,
            ...other
        } = progressOrError;

        error = {
            name: authenticationError || connectionError,
            ...other
        };
        progress = 0;
    }

    return {
        type: UPGRADE_ROLE_FINISHED,
        error,
        progress,
        thenableWithCancel
    };
}

/**
 * Signals that a process of authenticating and upgrading the local
 * participant's role has started.
 *
 * @param {Object} thenableWithCancel - The process of authenticating and
 * upgrading the local participant's role.
 * @private
 * @returns {{
 *     type: UPGRADE_ROLE_STARTED,
 *     thenableWithCancel: Object
 * }}
 */
function _upgradeRoleStarted(thenableWithCancel: Object) {
    return {
        type: UPGRADE_ROLE_STARTED,
        thenableWithCancel
    };
}

/**
 * Hides an authentication dialog where the local participant
 * should authenticate.
 *
 * @returns {Function}
 */
export function hideLoginDialog() {
    return hideDialog(LoginDialog);
}

/**
 * Login.
 *
 * @returns {{
*     type: LOGIN
* }}
*/
export function login() {
    return {
        type: LOGIN
    };
}

/**
* Logout.
*
* @returns {{
*     type: LOGOUT
* }}
*/
export function logout() {
    return {
        type: LOGOUT
    };
}

/**
 * Opens {@link WaitForOnwerDialog}.
 *
 * @protected
 * @returns {Action}
 */
export function openWaitForOwnerDialog() {
    return openDialog(WaitForOwnerDialog);
}

/**
 * Stops waiting for the conference owner.
 *
 * @returns {{
 *     type: STOP_WAIT_FOR_OWNER
 * }}
 */
export function stopWaitForOwner() {
    return {
        type: STOP_WAIT_FOR_OWNER
    };
}

/**
 * Called when Jicofo rejects to create the room for anonymous user. Will
 * start the process of "waiting for the owner" by periodically trying to join
 * the room every five seconds.
 *
 * @returns {Function}
 */
export function waitForOwner() {
    return (dispatch: IStore['dispatch']) =>
        dispatch({
            type: WAIT_FOR_OWNER,
            handler: () => dispatch(checkIfCanJoin()),
            timeoutMs: 5000
        });
}

/**
 * Opens {@link LoginDialog} which will ask to enter username and password
 * for the current conference.
 *
 * @protected
 * @returns {Action}
 */
export function openLoginDialog() {
    return openDialog(LoginDialog);
}

/**
 * Updates the config with new options.
 *
 * @param {boolean} value - The new value.
 * @returns {Function}
 */
export function setTokenAuthUrlSuccess(value: boolean) {
    return {
        type: SET_TOKEN_AUTH_URL_SUCCESS,
        value
    };
}


################################################################################

## File: .\jitsi-meet\react\features\authentication\actions.native.ts

import { Linking } from 'react-native';

import { appNavigate } from '../app/actions.native';
import { IStore } from '../app/types';
import { conferenceLeft } from '../base/conference/actions';
import { connectionFailed } from '../base/connection/actions.native';
import { set } from '../base/redux/functions';

import { CANCEL_LOGIN } from './actionTypes';
import { stopWaitForOwner } from './actions.any';

export * from './actions.any';

/**
 * Cancels {@ink LoginDialog}.
 *
 * @returns {{
 *     type: CANCEL_LOGIN
 * }}
 */
export function cancelLogin() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        dispatch({ type: CANCEL_LOGIN });

        // XXX The error associated with CONNECTION_FAILED was marked as
        // recoverable by the authentication feature  and, consequently,
        // recoverable-aware features such as mobile's external-api did not
        // deliver the CONFERENCE_FAILED to the SDK clients/consumers (as
        // a reaction to CONNECTION_FAILED). Since the
        // app/user is going to navigate to WelcomePage, the SDK
        // clients/consumers need an event.
        const { error = { recoverable: undefined }, passwordRequired }
            = getState()['features/base/connection'];

        passwordRequired
            && dispatch(
                connectionFailed(
                    passwordRequired,
                    set(error, 'recoverable', false) as any));
    };
}

/**
 * Cancels {@link WaitForOwnerDialog}. Will navigate back to the welcome page.
 *
 * @returns {Function}
 */
export function cancelWaitForOwner() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        dispatch(stopWaitForOwner());

        // XXX The error associated with CONFERENCE_FAILED was marked as
        // recoverable by the feature room-lock and, consequently,
        // recoverable-aware features such as mobile's external-api did not
        // deliver the CONFERENCE_FAILED to the SDK clients/consumers. Since the
        // app/user is going to navigate to WelcomePage, the SDK
        // clients/consumers need an event.
        const { authRequired } = getState()['features/base/conference'];

        if (authRequired) {
            dispatch(conferenceLeft(authRequired));

            // in case we are showing lobby and on top of it wait for owner
            // we do not want to navigate away from the conference
            dispatch(appNavigate(undefined));
        }
    };
}

/**
 * Redirect to the default location (e.g. Welcome page).
 *
 * @returns {Function}
 */
export function redirectToDefaultLocation() {
    return (dispatch: IStore['dispatch']) => dispatch(appNavigate(undefined));
}

/**
 * Opens token auth URL page.
 *
 * @param {string} tokenAuthServiceUrl - Authentication service URL.
 *
 * @returns {Function}
 */
export function openTokenAuthUrl(tokenAuthServiceUrl: string) {
    return () => {
        Linking.openURL(tokenAuthServiceUrl);
    };
}


################################################################################

## File: .\jitsi-meet\react\features\authentication\actions.web.ts

import { maybeRedirectToWelcomePage } from '../app/actions.web';
import { IStore } from '../app/types';
import { openDialog } from '../base/dialog/actions';
import { browser } from '../base/lib-jitsi-meet';

import { CANCEL_LOGIN } from './actionTypes';
import LoginQuestionDialog from './components/web/LoginQuestionDialog';

export * from './actions.any';

/**
 * Cancels {@ink LoginDialog}.
 *
 * @returns {{
 *     type: CANCEL_LOGIN
 * }}
 */
export function cancelLogin() {
    return {
        type: CANCEL_LOGIN
    };
}

/**
 * Cancels authentication, closes {@link WaitForOwnerDialog}
 * and navigates back to the welcome page only in the case of authentication required error.
 * We can be showing the dialog while lobby is enabled and participant is still waiting there and hiding this dialog
 * should do nothing.
 *
 * @returns {Function}
 */
export function cancelWaitForOwner() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const { authRequired } = getState()['features/base/conference'];

        authRequired && dispatch(maybeRedirectToWelcomePage());
    };
}

/**
 * Redirect to the default location (e.g. Welcome page).
 *
 * @returns {Function}
 */
export function redirectToDefaultLocation() {
    return (dispatch: IStore['dispatch']) => dispatch(maybeRedirectToWelcomePage());
}

/**
 * Opens token auth URL page.
 *
 * @param {string} tokenAuthServiceUrl - Authentication service URL.
 *
 * @returns {Function}
 */
export function openTokenAuthUrl(tokenAuthServiceUrl: string): any {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const redirect = () => {
            if (browser.isElectron()) {
                window.open(tokenAuthServiceUrl, '_blank');
            } else {
                window.location.href = tokenAuthServiceUrl;
            }
        };

        // Show warning for leaving conference only when in a conference.
        if (!browser.isElectron() && getState()['features/base/conference'].conference) {
            dispatch(openDialog(LoginQuestionDialog, {
                handler: () => {
                    // Give time for the dialog to close.
                    setTimeout(() => redirect(), 500);
                }
            }));
        } else {
            redirect();
        }
    };
}


################################################################################

## File: .\jitsi-meet\react\features\authentication\actionTypes.ts

/**
 * The type of (redux) action which signals that {@link LoginDialog} has been
 * canceled.
 *
 * {
 *     type: CANCEL_LOGIN
 * }
 */
export const CANCEL_LOGIN = 'CANCEL_LOGIN';

/**
 * The type of (redux) action which signals to login.
 *
 * {
 *     type: LOGOUT
 * }
 */
export const LOGIN = 'LOGIN';

/**
 * The type of (redux) action which signals to logout.
 *
 * {
 *     type: LOGOUT
 * }
 */
export const LOGOUT = 'LOGOUT';

/**
 * The type of (redux) action which signals that we have authenticated successful when
 * tokenAuthUrl is set.
 *
 * {
 *     type: SET_TOKEN_AUTH_URL_SUCCESS
 * }
 */
export const SET_TOKEN_AUTH_URL_SUCCESS = 'SET_TOKEN_AUTH_URL_SUCCESS';

/**
 * The type of (redux) action which signals that the cyclic operation of waiting
 * for conference owner has been aborted.
 *
 * {
 *     type: STOP_WAIT_FOR_OWNER
 * }
 */
export const STOP_WAIT_FOR_OWNER = 'STOP_WAIT_FOR_OWNER';

/**
 * The type of (redux) action which informs that the authentication and role
 * upgrade process has finished either with success or with a specific error.
 * If {@code error} is {@code undefined}, then the process succeeded;
 * otherwise, it failed. Refer to
 * {@link JitsiConference#authenticateAndUpgradeRole} in lib-jitsi-meet for the
 * error details.
 *
 * {
 *     type: UPGRADE_ROLE_FINISHED,
 *     error: Object,
 *     progress: number,
 *     thenableWithCancel: Object
 * }
 */
export const UPGRADE_ROLE_FINISHED = 'UPGRADE_ROLE_FINISHED';

/**
 * The type of (redux) action which signals that the process of authenticating
 * and upgrading the local participant's role has been started.
 *
 * {
 *     type: UPGRADE_ROLE_STARTED,
 *     thenableWithCancel: Object
 * }
 */
export const UPGRADE_ROLE_STARTED = 'UPGRADE_ROLE_STARTED';

/**
 * The type of (redux) action that sets delayed handler which will check if
 * the conference has been created and it's now possible to join from anonymous
 * connection.
 *
 * {
 *     type: WAIT_FOR_OWNER,
 *     handler: Function,
 *     timeoutMs: number
 * }
 */
export const WAIT_FOR_OWNER = 'WAIT_FOR_OWNER';


################################################################################

## File: .\jitsi-meet\react\features\authentication\functions.any.ts

import { IConfig } from '../base/config/configType';
import { parseURLParams } from '../base/util/parseURLParams';
import { getBackendSafeRoomName } from '../base/util/uri';

/**
 * Checks if the token for authentication is available.
 *
 * @param {Object} config - Configuration state object from store.
 * @returns {boolean}
 */
export const isTokenAuthEnabled = (config: IConfig): boolean =>
    typeof config.tokenAuthUrl === 'string' && config.tokenAuthUrl.length > 0;

/**
 * Returns the state that we can add as a parameter to the tokenAuthUrl.
 *
 * @param {URL} locationURL - The location URL.
 * @param {Object} options: - Config options {
 *     audioMuted: boolean | undefined
 *     audioOnlyEnabled: boolean | undefined,
 *     skipPrejoin: boolean | undefined,
 *     videoMuted: boolean | undefined
 * }.
 * @param {string?} roomName - The room name.
 * @param {string?} tenant - The tenant name if any.
 *
 * @returns {Object} The state object.
 */
export const _getTokenAuthState = (
        locationURL: URL,
        options: {
            audioMuted: boolean | undefined;
            audioOnlyEnabled: boolean | undefined;
            skipPrejoin: boolean | undefined;
            videoMuted: boolean | undefined;
        },
        roomName: string | undefined,
        tenant: string | undefined): object => {
    const state = {
        room: roomName,
        roomSafe: getBackendSafeRoomName(roomName),
        tenant
    };

    const {
        audioMuted = false,
        audioOnlyEnabled = false,
        skipPrejoin = false,
        videoMuted = false
    } = options;

    if (audioMuted) {

        // @ts-ignore
        state['config.startWithAudioMuted'] = true;
    }

    if (audioOnlyEnabled) {

        // @ts-ignore
        state['config.startAudioOnly'] = true;
    }

    if (skipPrejoin) {
        // We have already shown the prejoin screen, no need to show it again after obtaining the token.
        // @ts-ignore
        state['config.prejoinConfig.enabled'] = false;
    }

    if (videoMuted) {

        // @ts-ignore
        state['config.startWithVideoMuted'] = true;
    }
    const params = parseURLParams(locationURL);

    for (const key of Object.keys(params)) {
        // we allow only config and interfaceConfig overrides in the state
        if (key.startsWith('config.') || key.startsWith('interfaceConfig.') || key.startsWith('iceServers.')) {
            // @ts-ignore
            state[key] = params[key];
        }
    }

    return state;
};


################################################################################

## File: .\jitsi-meet\react\features\authentication\functions.native.ts

import { Platform } from 'react-native';

import { IConfig } from '../base/config/configType';

import { _getTokenAuthState } from './functions.any';

export * from './functions.any';

/**
 * Creates the URL pointing to JWT token authentication service. It is
 * formatted from the 'urlPattern' argument which can contain the following
 * constants:
 * '{room}' - name of the conference room passed as <tt>roomName</tt>
 * argument to this method.
 *
 * @param {Object} config - Configuration state object from store. A URL pattern pointing to the login service.
 * @param {URL} locationURL - The location URL.
 * @param {Object} options:  - Config options {
 *     audioMuted: boolean | undefined
 *     audioOnlyEnabled: boolean | undefined,
 *     skipPrejoin: boolean | undefined,
 *     videoMuted: boolean | undefined
 * }.
 * @param {string?} roomName - The room name.
 * @param {string?} tenant - The tenant name if any.
 *
 * @returns {Promise<string|undefined>} - The URL pointing to JWT login service or
 * <tt>undefined</tt> if the pattern stored in config is not a string and the URL can not be
 * constructed.
 */
export const getTokenAuthUrl = (
        config: IConfig,
        locationURL: URL,
        options: {
            audioMuted: boolean | undefined;
            audioOnlyEnabled: boolean | undefined;
            skipPrejoin: boolean | undefined;
            videoMuted: boolean | undefined;
        },
        roomName: string | undefined,
        // eslint-disable-next-line max-params
        tenant: string | undefined): Promise<string | undefined> => {

    const {
        audioMuted = false,
        audioOnlyEnabled = false,
        skipPrejoin = false,
        videoMuted = false
    } = options;

    let url = config.tokenAuthUrl;

    if (!url || !roomName) {
        return Promise.resolve(undefined);
    }

    if (url.indexOf('{state}')) {
        const state = _getTokenAuthState(
            locationURL,
            {
                audioMuted,
                audioOnlyEnabled,
                skipPrejoin,
                videoMuted
            },
            roomName,
            tenant
        );

        // Append ios=true or android=true to the token URL.
        // @ts-ignore
        state[Platform.OS] = true;

        url = url.replace('{state}', encodeURIComponent(JSON.stringify(state)));
    }

    return Promise.resolve(url.replace('{room}', roomName));
};


################################################################################

## File: .\jitsi-meet\react\features\authentication\functions.web.ts

import base64js from 'base64-js';

import { IConfig } from '../base/config/configType';
import { browser } from '../base/lib-jitsi-meet';

import { _getTokenAuthState } from './functions.any';

export * from './functions.any';

/**
 * Based on rfc7636 we need a random string for a code verifier.
 */
const POSSIBLE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';

/**
 * Crypto random, alternative of Math.random.
 *
 * @returns {float} A random value.
 */
function _cryptoRandom() {
    const typedArray = new Uint8Array(1);
    const randomValue = crypto.getRandomValues(typedArray)[0];

    return randomValue / Math.pow(2, 8);
}

/**
 * Creates the URL pointing to JWT token authentication service. It is
 * formatted from the 'urlPattern' argument which can contain the following
 * constants:
 * '{room}' - name of the conference room passed as <tt>roomName</tt>
 * argument to this method.
 *
 * @param {Object} config - Configuration state object from store. A URL pattern pointing to the login service.
 * @param {URL} locationURL - The location URL.
 * @param {Object} options:  - Config options {
 *     audioMuted: boolean | undefined
 *     audioOnlyEnabled: boolean | undefined,
 *     skipPrejoin: boolean | undefined,
 *     videoMuted: boolean | undefined
 * }.
 * @param {string?} roomName - The room name.
 * @param {string?} tenant - The tenant name if any.
 *
 * @returns {Promise<string|undefined>} - The URL pointing to JWT login service or
 * <tt>undefined</tt> if the pattern stored in config is not a string and the URL can not be
 * constructed.
 */
export const getTokenAuthUrl = (
        config: IConfig,
        locationURL: URL,
        options: {
            audioMuted: boolean | undefined;
            audioOnlyEnabled: boolean | undefined;
            skipPrejoin: boolean | undefined;
            videoMuted: boolean | undefined;
        },
        roomName: string | undefined,
        // eslint-disable-next-line max-params
        tenant: string | undefined): Promise<string | undefined> => {

    const {
        audioMuted = false,
        audioOnlyEnabled = false,
        skipPrejoin = false,
        videoMuted = false
    } = options;

    let url = config.tokenAuthUrl;

    if (!url || !roomName) {
        return Promise.resolve(undefined);
    }

    if (url.indexOf('{state}')) {
        const state = _getTokenAuthState(
            locationURL,
            {
                audioMuted,
                audioOnlyEnabled,
                skipPrejoin,
                videoMuted
            },
            roomName,
            tenant
        );

        if (browser.isElectron()) {
            // @ts-ignore
            state.electron = true;
        }

        url = url.replace('{state}', encodeURIComponent(JSON.stringify(state)));
    }

    url = url.replace('{room}', roomName);

    if (url.indexOf('{code_challenge}')) {
        let codeVerifier = '';

        // random string
        for (let i = 0; i < 64; i++) {
            codeVerifier += POSSIBLE_CHARS.charAt(Math.floor(_cryptoRandom() * POSSIBLE_CHARS.length));
        }

        window.sessionStorage.setItem('code_verifier', codeVerifier);

        return window.crypto.subtle.digest('SHA-256', new TextEncoder().encode(codeVerifier))
            .then(digest => {
                // prepare code challenge - base64 encoding without padding as described in:
                // https://datatracker.ietf.org/doc/html/rfc7636#appendix-A
                const codeChallenge = base64js.fromByteArray(new Uint8Array(digest))
                    .replace(/=/g, '')
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_');

                return url ? url.replace('{code_challenge}', codeChallenge) : undefined;
            });
    }

    return Promise.resolve(url);
};


################################################################################

## File: .\jitsi-meet\react\features\authentication\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/authentication');


################################################################################

## File: .\jitsi-meet\react\features\authentication\middleware.ts

import { IStore } from '../app/types';
import { APP_WILL_NAVIGATE } from '../base/app/actionTypes';
import {
    CONFERENCE_FAILED,
    CONFERENCE_JOINED,
    CONFERENCE_LEFT
} from '../base/conference/actionTypes';
import { isRoomValid } from '../base/conference/functions';
import { CONNECTION_ESTABLISHED, CONNECTION_FAILED } from '../base/connection/actionTypes';
import { hideDialog } from '../base/dialog/actions';
import { isDialogOpen } from '../base/dialog/functions';
import {
    JitsiConferenceErrors,
    JitsiConnectionErrors
} from '../base/lib-jitsi-meet';
import { MEDIA_TYPE } from '../base/media/constants';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import { isLocalTrackMuted } from '../base/tracks/functions.any';
import { parseURIString } from '../base/util/uri';
import { openLogoutDialog } from '../settings/actions';

import {
    CANCEL_LOGIN,
    LOGIN,
    LOGOUT,
    STOP_WAIT_FOR_OWNER,
    UPGRADE_ROLE_FINISHED,
    WAIT_FOR_OWNER
} from './actionTypes';
import {
    hideLoginDialog,
    openLoginDialog,
    openTokenAuthUrl,
    openWaitForOwnerDialog,
    redirectToDefaultLocation,
    setTokenAuthUrlSuccess,
    stopWaitForOwner,
    waitForOwner
} from './actions';
import { LoginDialog, WaitForOwnerDialog } from './components';
import { getTokenAuthUrl, isTokenAuthEnabled } from './functions';
import logger from './logger';


/**
 * Middleware that captures connection or conference failed errors and controls
 * {@link WaitForOwnerDialog} and {@link LoginDialog}.
 *
 * FIXME Some of the complexity was introduced by the lack of dialog stacking.
 *
 * @param {Store} store - Redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {
    switch (action.type) {
    case CANCEL_LOGIN: {
        const { dispatch, getState } = store;
        const state = getState();
        const { thenableWithCancel } = state['features/authentication'];

        thenableWithCancel?.cancel();

        // The LoginDialog can be opened on top of "wait for owner". The app
        // should navigate only if LoginDialog was open without the
        // WaitForOwnerDialog.
        if (!isDialogOpen(store, WaitForOwnerDialog)) {
            if (_isWaitingForOwner(store)) {
                // Instead of hiding show the new one.
                const result = next(action);

                dispatch(openWaitForOwnerDialog());

                return result;
            }

            dispatch(hideLoginDialog());

            const { authRequired, conference } = state['features/base/conference'];
            const { passwordRequired } = state['features/base/connection'];

            // Only end the meeting if we are not already inside and trying to upgrade.
            // NOTE: Despite it's confusing name, `passwordRequired` implies an XMPP
            // connection auth error.
            if ((passwordRequired || authRequired) && !conference) {
                dispatch(redirectToDefaultLocation());
            }
        }
        break;
    }

    case CONFERENCE_FAILED: {
        const { error } = action;

        // XXX The feature authentication affords recovery from
        // CONFERENCE_FAILED caused by
        // JitsiConferenceErrors.AUTHENTICATION_REQUIRED.
        let recoverable;
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const [ _lobbyJid, lobbyWaitingForHost ] = error.params;

        if (error.name === JitsiConferenceErrors.AUTHENTICATION_REQUIRED
            || (error.name === JitsiConferenceErrors.MEMBERS_ONLY_ERROR && lobbyWaitingForHost)) {
            if (typeof error.recoverable === 'undefined') {
                error.recoverable = true;
            }
            recoverable = error.recoverable;
        }
        if (recoverable) {
            store.dispatch(waitForOwner());
        } else {
            store.dispatch(stopWaitForOwner());
        }
        break;
    }

    case CONFERENCE_JOINED: {
        const { dispatch, getState } = store;
        const state = getState();
        const config = state['features/base/config'];

        if (isTokenAuthEnabled(config)
            && config.tokenAuthUrlAutoRedirect
            && state['features/base/jwt'].jwt) {
            // auto redirect is turned on and we have succesfully logged in
            // let's mark that
            dispatch(setTokenAuthUrlSuccess(true));
        }

        if (_isWaitingForOwner(store)) {
            store.dispatch(stopWaitForOwner());
        }
        store.dispatch(hideLoginDialog());
        break;
    }

    case CONFERENCE_LEFT:
        store.dispatch(stopWaitForOwner());
        break;

    case CONNECTION_ESTABLISHED:
        store.dispatch(hideLoginDialog());
        break;

    case CONNECTION_FAILED: {
        const { error } = action;
        const { getState } = store;
        const state = getState();
        const { jwt } = state['features/base/jwt'];

        if (error
                && error.name === JitsiConnectionErrors.PASSWORD_REQUIRED
                && typeof error.recoverable === 'undefined'
                && !jwt) {
            error.recoverable = true;

            _handleLogin(store);
        }

        break;
    }

    case LOGIN: {
        _handleLogin(store);

        break;
    }

    case LOGOUT: {
        _handleLogout(store);

        break;
    }

    case APP_WILL_NAVIGATE: {
        const { dispatch, getState } = store;
        const state = getState();
        const config = state['features/base/config'];
        const room = state['features/base/conference'].room;

        if (isRoomValid(room)
            && config.tokenAuthUrl && config.tokenAuthUrlAutoRedirect
            && state['features/authentication'].tokenAuthUrlSuccessful
            && !state['features/base/jwt'].jwt) {
            // if we have auto redirect enabled, and we have previously logged in successfully
            // we will redirect to the auth url to get the token and login again
            // we want to mark token auth success to false as if login is unsuccessful
            // the participant can join anonymously and not go in login loop
            dispatch(setTokenAuthUrlSuccess(false));
        }

        break;
    }

    case STOP_WAIT_FOR_OWNER:
        _clearExistingWaitForOwnerTimeout(store);
        store.dispatch(hideDialog(WaitForOwnerDialog));
        break;

    case UPGRADE_ROLE_FINISHED: {
        const { error, progress } = action;

        if (!error && progress === 1) {
            store.dispatch(hideLoginDialog());
        }
        break;
    }

    case WAIT_FOR_OWNER: {
        _clearExistingWaitForOwnerTimeout(store);

        const { handler, timeoutMs }: { handler: () => void; timeoutMs: number; } = action;

        action.waitForOwnerTimeoutID = setTimeout(handler, timeoutMs);

        // The WAIT_FOR_OWNER action is cyclic, and we don't want to hide the
        // login dialog every few seconds.
        isDialogOpen(store, LoginDialog)
            || store.dispatch(openWaitForOwnerDialog());
        break;
    }
    }

    return next(action);
});

/**
 * Will clear the wait for conference owner timeout handler if any is currently
 * set.
 *
 * @param {Object} store - The redux store.
 * @returns {void}
 */
function _clearExistingWaitForOwnerTimeout({ getState }: IStore) {
    const { waitForOwnerTimeoutID } = getState()['features/authentication'];

    waitForOwnerTimeoutID && clearTimeout(waitForOwnerTimeoutID);
}


/**
 * Checks if the cyclic "wait for conference owner" task is currently scheduled.
 *
 * @param {Object} store - The redux store.
 * @returns {boolean}
 */
function _isWaitingForOwner({ getState }: IStore) {
    return Boolean(getState()['features/authentication'].waitForOwnerTimeoutID);
}

/**
 * Handles login challenge. Opens login dialog or redirects to token auth URL.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @returns {void}
 */
function _handleLogin({ dispatch, getState }: IStore) {
    const state = getState();
    const config = state['features/base/config'];
    const room = state['features/base/conference'].room;
    const { locationURL = { href: '' } as URL } = state['features/base/connection'];
    const { tenant } = parseURIString(locationURL.href) || {};
    const { enabled: audioOnlyEnabled } = state['features/base/audio-only'];
    const audioMuted = isLocalTrackMuted(state['features/base/tracks'], MEDIA_TYPE.AUDIO);
    const videoMuted = isLocalTrackMuted(state['features/base/tracks'], MEDIA_TYPE.VIDEO);

    if (!room) {
        logger.warn('Cannot handle login, room is undefined!');

        return;
    }

    if (!isTokenAuthEnabled(config)) {
        dispatch(openLoginDialog());

        return;
    }

    getTokenAuthUrl(
        config,
        locationURL,
        {
            audioMuted,
            audioOnlyEnabled,
            skipPrejoin: true,
            videoMuted
        },
        room,
        tenant
    )
        .then((tokenAuthServiceUrl: string | undefined) => {
            if (!tokenAuthServiceUrl) {
                logger.warn('Cannot handle login, token service URL is not set');

                return;
            }

            return dispatch(openTokenAuthUrl(tokenAuthServiceUrl));
        });
}

/**
 * Handles logout challenge. Opens logout dialog and hangs up the conference.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @param {string} logoutUrl - The url for logging out.
 * @returns {void}
 */
function _handleLogout({ dispatch, getState }: IStore) {
    const state = getState();
    const { conference } = state['features/base/conference'];

    if (!conference) {
        return;
    }

    dispatch(openLogoutDialog());
}


################################################################################

## File: .\jitsi-meet\react\features\authentication\reducer.ts

import PersistenceRegistry from '../base/redux/PersistenceRegistry';
import ReducerRegistry from '../base/redux/ReducerRegistry';
import { assign } from '../base/redux/functions';

import {
    CANCEL_LOGIN,
    SET_TOKEN_AUTH_URL_SUCCESS,
    STOP_WAIT_FOR_OWNER,
    UPGRADE_ROLE_FINISHED,
    UPGRADE_ROLE_STARTED,
    WAIT_FOR_OWNER
} from './actionTypes';

export interface IAuthenticationState {
    error?: Object | undefined;
    progress?: number | undefined;
    thenableWithCancel?: {
        cancel: Function;
    };
    tokenAuthUrlSuccessful?: boolean;
    waitForOwnerTimeoutID?: number;
}

/**
 * Sets up the persistence of the feature {@code authentication}.
 */
PersistenceRegistry.register('features/authentication', {
    tokenAuthUrlSuccessful: true
});

/**
 * Listens for actions which change the state of the authentication feature.
 *
 * @param {Object} state - The Redux state of the authentication feature.
 * @param {Object} action - Action object.
 * @param {string} action.type - Type of action.
 * @returns {Object}
 */
ReducerRegistry.register<IAuthenticationState>('features/authentication',
(state = {}, action): IAuthenticationState => {
    switch (action.type) {
    case CANCEL_LOGIN:
        return assign(state, {
            error: undefined,
            progress: undefined,
            thenableWithCancel: undefined
        });
    case SET_TOKEN_AUTH_URL_SUCCESS:
        return assign(state, {
            tokenAuthUrlSuccessful: action.value
        });

    case STOP_WAIT_FOR_OWNER:
        return assign(state, {
            error: undefined,
            waitForOwnerTimeoutID: undefined
        });

    case UPGRADE_ROLE_FINISHED: {
        let { thenableWithCancel } = action;

        if (state.thenableWithCancel === thenableWithCancel) {
            const { error, progress } = action;

            // An error interrupts the process of authenticating and upgrading
            // the role of the local participant/user i.e. the process is no
            // more. Obviously, the process seizes to exist also when it does
            // its whole job.
            if (error || progress === 1) {
                thenableWithCancel = undefined;
            }

            return assign(state, {
                error,
                progress: progress || undefined,
                thenableWithCancel
            });
        }
        break;
    }

    case UPGRADE_ROLE_STARTED:
        return assign(state, {
            error: undefined,
            progress: undefined,
            thenableWithCancel: action.thenableWithCancel
        });

    case WAIT_FOR_OWNER:
        return assign(state, {
            waitForOwnerTimeoutID: action.waitForOwnerTimeoutID
        });
    }

    return state;
});


################################################################################

## File: .\jitsi-meet\react\features\authentication\components\index.native.ts

export { default as LoginDialog } from './native/LoginDialog';
export { default as WaitForOwnerDialog } from './native/WaitForOwnerDialog';


################################################################################

## File: .\jitsi-meet\react\features\authentication\components\index.web.ts

export { default as LoginDialog } from './web/LoginDialog';
export { default as WaitForOwnerDialog } from './web/WaitForOwnerDialog';


################################################################################

## File: .\jitsi-meet\react\features\av-moderation\actions.ts

import { IStore } from '../app/types';
import { getConferenceState } from '../base/conference/functions';
import { MEDIA_TYPE, type MediaType } from '../base/media/constants';
import { getParticipantById, isParticipantModerator } from '../base/participants/functions';
import { IParticipant } from '../base/participants/types';
import { isForceMuted } from '../participants-pane/functions';

import {
    DISABLE_MODERATION,
    DISMISS_PENDING_PARTICIPANT,
    ENABLE_MODERATION,
    LOCAL_PARTICIPANT_APPROVED,
    LOCAL_PARTICIPANT_MODERATION_NOTIFICATION,
    LOCAL_PARTICIPANT_REJECTED,
    PARTICIPANT_APPROVED,
    PARTICIPANT_PENDING_AUDIO,
    PARTICIPANT_REJECTED,
    REQUEST_DISABLE_AUDIO_MODERATION,
    REQUEST_DISABLE_VIDEO_MODERATION,
    REQUEST_ENABLE_AUDIO_MODERATION,
    REQUEST_ENABLE_VIDEO_MODERATION
} from './actionTypes';
import { isEnabledFromState } from './functions';

/**
 * Action used by moderator to approve audio for a participant.
 *
 * @param {staring} id - The id of the participant to be approved.
 * @returns {void}
 */
export const approveParticipantAudio = (id: string) => (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
    const state = getState();
    const { conference } = getConferenceState(state);
    const participant = getParticipantById(state, id);

    const isAudioModerationOn = isEnabledFromState(MEDIA_TYPE.AUDIO, state);
    const isVideoModerationOn = isEnabledFromState(MEDIA_TYPE.VIDEO, state);
    const isVideoForceMuted = isForceMuted(participant, MEDIA_TYPE.VIDEO, state);

    if (isAudioModerationOn || !isVideoModerationOn || !isVideoForceMuted) {
        conference?.avModerationApprove(MEDIA_TYPE.AUDIO, id);
    }
};

/**
 * Action used by moderator to approve video for a participant.
 *
 * @param {staring} id - The id of the participant to be approved.
 * @returns {void}
 */
export const approveParticipantVideo = (id: string) => (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
    const state = getState();
    const { conference } = getConferenceState(state);
    const participant = getParticipantById(state, id);

    const isVideoForceMuted = isForceMuted(participant, MEDIA_TYPE.VIDEO, state);
    const isVideoModerationOn = isEnabledFromState(MEDIA_TYPE.VIDEO, state);

    if (isVideoModerationOn && isVideoForceMuted) {
        conference?.avModerationApprove(MEDIA_TYPE.VIDEO, id);
    }
};

/**
 * Action used by moderator to approve audio and video for a participant.
 *
 * @param {staring} id - The id of the participant to be approved.
 * @returns {void}
 */
export const approveParticipant = (id: string) => (dispatch: IStore['dispatch']) => {
    dispatch(approveParticipantAudio(id));
    dispatch(approveParticipantVideo(id));
};

/**
 * Action used by moderator to reject audio for a participant.
 *
 * @param {staring} id - The id of the participant to be rejected.
 * @returns {void}
 */
export const rejectParticipantAudio = (id: string) => (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
    const state = getState();
    const { conference } = getConferenceState(state);
    const audioModeration = isEnabledFromState(MEDIA_TYPE.AUDIO, state);

    const participant = getParticipantById(state, id);
    const isAudioForceMuted = isForceMuted(participant, MEDIA_TYPE.AUDIO, state);
    const isModerator = isParticipantModerator(participant);

    if (audioModeration && !isAudioForceMuted && !isModerator) {
        conference?.avModerationReject(MEDIA_TYPE.AUDIO, id);
    }
};

/**
 * Action used by moderator to reject video for a participant.
 *
 * @param {staring} id - The id of the participant to be rejected.
 * @returns {void}
 */
export const rejectParticipantVideo = (id: string) => (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
    const state = getState();
    const { conference } = getConferenceState(state);
    const videoModeration = isEnabledFromState(MEDIA_TYPE.VIDEO, state);

    const participant = getParticipantById(state, id);
    const isVideoForceMuted = isForceMuted(participant, MEDIA_TYPE.VIDEO, state);
    const isModerator = isParticipantModerator(participant);

    if (videoModeration && !isVideoForceMuted && !isModerator) {
        conference?.avModerationReject(MEDIA_TYPE.VIDEO, id);
    }
};

/**
 * Audio or video moderation is disabled.
 *
 * @param {MediaType} mediaType - The media type that was disabled.
 * @param {JitsiParticipant} actor - The actor disabling.
 * @returns {{
 *     type: REQUEST_DISABLE_MODERATED_AUDIO
 * }}
 */
export const disableModeration = (mediaType: MediaType, actor: Object) => {
    return {
        type: DISABLE_MODERATION,
        mediaType,
        actor
    };
};


/**
 * Hides the notification with the participant that asked to unmute audio.
 *
 * @param {IParticipant} participant - The participant for which the notification to be hidden.
 * @returns {Object}
 */
export function dismissPendingAudioParticipant(participant: IParticipant) {
    return dismissPendingParticipant(participant.id, MEDIA_TYPE.AUDIO);
}

/**
 * Hides the notification with the participant that asked to unmute.
 *
 * @param {string} id - The participant id for which the notification to be hidden.
 * @param {MediaType} mediaType - The media type.
 * @returns {Object}
 */
export function dismissPendingParticipant(id: string, mediaType: MediaType) {
    return {
        type: DISMISS_PENDING_PARTICIPANT,
        id,
        mediaType
    };
}

/**
 * Audio or video moderation is enabled.
 *
 * @param {MediaType} mediaType - The media type that was enabled.
 * @param {JitsiParticipant} actor - The actor enabling.
 * @returns {{
 *     type: REQUEST_ENABLE_MODERATED_AUDIO
 * }}
 */
export const enableModeration = (mediaType: MediaType, actor: Object) => {
    return {
        type: ENABLE_MODERATION,
        mediaType,
        actor
    };
};

/**
 * Requests disable of audio moderation.
 *
 * @returns {{
 *     type: REQUEST_DISABLE_AUDIO_MODERATION
 * }}
 */
export const requestDisableAudioModeration = () => {
    return {
        type: REQUEST_DISABLE_AUDIO_MODERATION
    };
};

/**
 * Requests disable of video moderation.
 *
 * @returns {{
 *     type: REQUEST_DISABLE_VIDEO_MODERATION
 * }}
 */
export const requestDisableVideoModeration = () => {
    return {
        type: REQUEST_DISABLE_VIDEO_MODERATION
    };
};

/**
 * Requests enable of audio moderation.
 *
 * @returns {{
 *     type: REQUEST_ENABLE_AUDIO_MODERATION
 * }}
 */
export const requestEnableAudioModeration = () => {
    return {
        type: REQUEST_ENABLE_AUDIO_MODERATION
    };
};

/**
 * Requests enable of video moderation.
 *
 * @returns {{
 *     type: REQUEST_ENABLE_VIDEO_MODERATION
 * }}
 */
export const requestEnableVideoModeration = () => {
    return {
        type: REQUEST_ENABLE_VIDEO_MODERATION
    };
};

/**
 * Local participant was approved to be able to unmute audio and video.
 *
 * @param {MediaType} mediaType - The media type to disable.
 * @returns {{
 *     type: LOCAL_PARTICIPANT_APPROVED
 * }}
 */
export const localParticipantApproved = (mediaType: MediaType) => {
    return {
        type: LOCAL_PARTICIPANT_APPROVED,
        mediaType
    };
};

/**
 * Local participant was blocked to be able to unmute audio and video.
 *
 * @param {MediaType} mediaType - The media type to disable.
 * @returns {{
 *     type: LOCAL_PARTICIPANT_REJECTED
 * }}
 */
export const localParticipantRejected = (mediaType: MediaType) => {
    return {
        type: LOCAL_PARTICIPANT_REJECTED,
        mediaType
    };
};

/**
 * Shows notification when A/V moderation is enabled and local participant is still not approved.
 *
 * @param {MediaType} mediaType - Audio or video media type.
 * @returns {Object}
 */
export function showModeratedNotification(mediaType: MediaType) {
    return {
        type: LOCAL_PARTICIPANT_MODERATION_NOTIFICATION,
        mediaType
    };
}

/**
 * Shows a notification with the participant that asked to audio unmute.
 *
 * @param {IParticipant} participant - The participant for which is the notification.
 * @returns {Object}
 */
export function participantPendingAudio(participant: IParticipant) {
    return {
        type: PARTICIPANT_PENDING_AUDIO,
        participant
    };
}

/**
 * A participant was approved to unmute for a mediaType.
 *
 * @param {string} id - The id of the approved participant.
 * @param {MediaType} mediaType - The media type which was approved.
 * @returns {{
 *     type: PARTICIPANT_APPROVED,
 * }}
 */
export function participantApproved(id: string, mediaType: MediaType) {
    return {
        type: PARTICIPANT_APPROVED,
        id,
        mediaType
    };
}

/**
 * A participant was blocked to unmute for a mediaType.
 *
 * @param {string} id - The id of the approved participant.
 * @param {MediaType} mediaType - The media type which was approved.
 * @returns {{
 *     type: PARTICIPANT_REJECTED,
 * }}
 */
export function participantRejected(id: string, mediaType: MediaType) {
    return {
        type: PARTICIPANT_REJECTED,
        id,
        mediaType
    };
}



################################################################################

## File: .\jitsi-meet\react\features\av-moderation\actionTypes.ts

/**
 * The type of (redux) action which signals that A/V Moderation had been disabled.
 *
 * {
 *     type: DISABLE_MODERATION
 * }
 */
export const DISABLE_MODERATION = 'DISABLE_MODERATION';

/**
 * The type of (redux) action which signals that the notification for audio/video unmute should
 * be dismissed.
 *
 * {
 *     type: DISMISS_PARTICIPANT_PENDING_AUDIO
 * }
 */
export const DISMISS_PENDING_PARTICIPANT = 'DISMISS_PENDING_PARTICIPANT';


/**
 * The type of (redux) action which signals that A/V Moderation had been enabled.
 *
 * {
 *     type: ENABLE_MODERATION
 * }
 */
export const ENABLE_MODERATION = 'ENABLE_MODERATION';


/**
 * The type of (redux) action which signals that Audio Moderation disable has been requested.
 *
 * {
 *     type: REQUEST_DISABLE_AUDIO_MODERATION
 * }
 */
export const REQUEST_DISABLE_AUDIO_MODERATION = 'REQUEST_DISABLE_AUDIO_MODERATION';

/**
 * The type of (redux) action which signals that Video Moderation disable has been requested.
 *
 * {
 *     type: REQUEST_DISABLE_VIDEO_MODERATION
 * }
 */
export const REQUEST_DISABLE_VIDEO_MODERATION = 'REQUEST_DISABLE_VIDEO_MODERATION';

/**
 * The type of (redux) action which signals that Audio Moderation enable has been requested.
 *
 * {
 *     type: REQUEST_ENABLE_AUDIO_MODERATION
 * }
 */
export const REQUEST_ENABLE_AUDIO_MODERATION = 'REQUEST_ENABLE_AUDIO_MODERATION';

/**
 * The type of (redux) action which signals that Video Moderation enable has been requested.
 *
 * {
 *     type: REQUEST_ENABLE_VIDEO_MODERATION
 * }
 */
export const REQUEST_ENABLE_VIDEO_MODERATION = 'REQUEST_ENABLE_VIDEO_MODERATION';

/**
 * The type of (redux) action which signals that the local participant had been approved.
 *
 * {
 *     type: LOCAL_PARTICIPANT_APPROVED,
 *     mediaType: MediaType
 * }
 */
export const LOCAL_PARTICIPANT_APPROVED = 'LOCAL_PARTICIPANT_APPROVED';

/**
 * The type of (redux) action which signals that the local participant had been blocked.
 *
 * {
 *     type: LOCAL_PARTICIPANT_REJECTED,
 *     mediaType: MediaType
 * }
 */
export const LOCAL_PARTICIPANT_REJECTED = 'LOCAL_PARTICIPANT_REJECTED';

/**
 * The type of (redux) action which signals to show notification to the local participant.
 *
 * {
 *     type: LOCAL_PARTICIPANT_MODERATION_NOTIFICATION
 * }
 */
export const LOCAL_PARTICIPANT_MODERATION_NOTIFICATION = 'LOCAL_PARTICIPANT_MODERATION_NOTIFICATION';

/**
 * The type of (redux) action which signals that a participant was approved for a media type.
 *
 * {
 *     type: PARTICIPANT_APPROVED,
 *     mediaType: MediaType
 *     participantId: String
 * }
 */
export const PARTICIPANT_APPROVED = 'PARTICIPANT_APPROVED';

/**
 * The type of (redux) action which signals that a participant was blocked for a media type.
 *
 * {
 *     type: PARTICIPANT_REJECTED,
 *     mediaType: MediaType
 *     participantId: String
 * }
 */
export const PARTICIPANT_REJECTED = 'PARTICIPANT_REJECTED';


/**
 * The type of (redux) action which signals that a participant asked to have its audio umuted.
 *
 * {
 *     type: PARTICIPANT_PENDING_AUDIO
 * }
 */
export const PARTICIPANT_PENDING_AUDIO = 'PARTICIPANT_PENDING_AUDIO';


################################################################################

## File: .\jitsi-meet\react\features\av-moderation\constants.ts

import { MEDIA_TYPE } from '../base/media/constants';

/**
 * Mapping between a media type and the witelist reducer key.
 */
export const MEDIA_TYPE_TO_WHITELIST_STORE_KEY: { [key: string]: string; } = {
    [MEDIA_TYPE.AUDIO]: 'audioWhitelist',
    [MEDIA_TYPE.VIDEO]: 'videoWhitelist'
};

/**
 * Mapping between a media type and the pending reducer key.
 */
export const MEDIA_TYPE_TO_PENDING_STORE_KEY: { [key: string]: 'pendingAudio' | 'pendingVideo'; } = {
    [MEDIA_TYPE.AUDIO]: 'pendingAudio',
    [MEDIA_TYPE.VIDEO]: 'pendingVideo'
};

export const ASKED_TO_UNMUTE_NOTIFICATION_ID = 'asked-to-unmute';
export const ASKED_TO_UNMUTE_SOUND_ID = 'ASKED_TO_UNMUTE_SOUND';

export const AUDIO_MODERATION_NOTIFICATION_ID = 'audio-moderation';
export const VIDEO_MODERATION_NOTIFICATION_ID = 'video-moderation';
export const CS_MODERATION_NOTIFICATION_ID = 'screensharing-moderation';

export const MODERATION_NOTIFICATIONS = {
    [MEDIA_TYPE.AUDIO]: AUDIO_MODERATION_NOTIFICATION_ID,
    [MEDIA_TYPE.SCREENSHARE]: CS_MODERATION_NOTIFICATION_ID,
    [MEDIA_TYPE.VIDEO]: VIDEO_MODERATION_NOTIFICATION_ID
};


################################################################################

## File: .\jitsi-meet\react\features\av-moderation\functions.ts

import { IReduxState } from '../app/types';
import { MEDIA_TYPE, type MediaType } from '../base/media/constants';
import { isLocalParticipantModerator } from '../base/participants/functions';
import { IParticipant } from '../base/participants/types';
import { isInBreakoutRoom } from '../breakout-rooms/functions';

import { MEDIA_TYPE_TO_PENDING_STORE_KEY, MEDIA_TYPE_TO_WHITELIST_STORE_KEY } from './constants';

/**
 * Returns this feature's root state.
 *
 * @param {IReduxState} state - Global state.
 * @returns {Object} Feature state.
 */
const getState = (state: IReduxState) => state['features/av-moderation'];

/**
 * We use to construct once the empty array so we can keep the same instance between calls
 * of getParticipantsAskingToAudioUnmute.
 *
 * @type {any[]}
 */
const EMPTY_ARRAY: any[] = [];

/**
 * Returns whether moderation is enabled per media type.
 *
 * @param {MEDIA_TYPE} mediaType - The media type to check.
 * @param {IReduxState} state - Global state.
 * @returns {boolean}
 */
export const isEnabledFromState = (mediaType: MediaType, state: IReduxState) =>
    (mediaType === MEDIA_TYPE.AUDIO
        ? getState(state)?.audioModerationEnabled
        : getState(state)?.videoModerationEnabled) === true;

/**
 * Returns whether moderation is enabled per media type.
 *
 * @param {MEDIA_TYPE} mediaType - The media type to check.
 * @returns {boolean}
 */
export const isEnabled = (mediaType: MediaType) => (state: IReduxState) => isEnabledFromState(mediaType, state);

/**
 * Returns whether moderation is supported by the backend.
 *
 * @returns {boolean}
 */
export const isSupported = () => (state: IReduxState) => {
    const { conference } = state['features/base/conference'];

    return Boolean(!isInBreakoutRoom(state) && conference?.isAVModerationSupported());
};

/**
 * Returns whether local participant is approved to unmute a media type.
 *
 * @param {MEDIA_TYPE} mediaType - The media type to check.
 * @param {IReduxState} state - Global state.
 * @returns {boolean}
 */
export const isLocalParticipantApprovedFromState = (mediaType: MediaType, state: IReduxState) => {
    const approved = (mediaType === MEDIA_TYPE.AUDIO
        ? getState(state).audioUnmuteApproved
        : getState(state).videoUnmuteApproved) === true;

    return approved || isLocalParticipantModerator(state);
};

/**
 * Returns whether local participant is approved to unmute a media type.
 *
 * @param {MEDIA_TYPE} mediaType - The media type to check.
 * @returns {boolean}
 */
export const isLocalParticipantApproved = (mediaType: MediaType) =>
    (state: IReduxState) =>
        isLocalParticipantApprovedFromState(mediaType, state);

/**
 * Returns a selector creator which determines if the participant is approved or not for a media type.
 *
 * @param {string} id - The participant id.
 * @param {MEDIA_TYPE} mediaType - The media type to check.
 * @returns {boolean}
 */
export const isParticipantApproved = (id: string, mediaType: MediaType) => (state: IReduxState) => {
    const storeKey = MEDIA_TYPE_TO_WHITELIST_STORE_KEY[mediaType];

    const avModerationState = getState(state);
    const stateForMediaType = avModerationState[storeKey as keyof typeof avModerationState];

    return Boolean(stateForMediaType && stateForMediaType[id as keyof typeof stateForMediaType]);
};

/**
 * Returns a selector creator which determines if the participant is pending or not for a media type.
 *
 * @param {IParticipant} participant - The participant.
 * @param {MEDIA_TYPE} mediaType - The media type to check.
 * @returns {boolean}
 */
export const isParticipantPending = (participant: IParticipant, mediaType: MediaType) => (state: IReduxState) => {
    const storeKey = MEDIA_TYPE_TO_PENDING_STORE_KEY[mediaType];
    const arr = getState(state)[storeKey];

    return Boolean(arr.find(pending => pending.id === participant.id));
};

/**
 * Selector which returns a list with all the participants asking to audio unmute.
 * This is visible only for the moderator.
 *
 * @param {Object} state - The global state.
 * @returns {Array<Object>}
 */
export const getParticipantsAskingToAudioUnmute = (state: IReduxState) => {
    if (isLocalParticipantModerator(state)) {
        return getState(state).pendingAudio;
    }

    return EMPTY_ARRAY;
};

/**
 * Returns true if a special notification can be displayed when a participant
 * tries to unmute.
 *
 * @param {MediaType} mediaType - 'audio' or 'video' media type.
 * @param {Object} state - The global state.
 * @returns {boolean}
 */
export const shouldShowModeratedNotification = (mediaType: MediaType, state: IReduxState) =>
    isEnabledFromState(mediaType, state)
    && !isLocalParticipantApprovedFromState(mediaType, state);


################################################################################

## File: .\jitsi-meet\react\features\av-moderation\middleware.ts

import { batch } from 'react-redux';

import { APP_WILL_MOUNT, APP_WILL_UNMOUNT } from '../base/app/actionTypes';
import { getConferenceState } from '../base/conference/functions';
import { JitsiConferenceEvents } from '../base/lib-jitsi-meet';
import { MEDIA_TYPE, MediaType } from '../base/media/constants';
import { PARTICIPANT_UPDATED } from '../base/participants/actionTypes';
import { raiseHand } from '../base/participants/actions';
import {
    getLocalParticipant,
    getRemoteParticipants,
    hasRaisedHand,
    isLocalParticipantModerator,
    isParticipantModerator
} from '../base/participants/functions';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import StateListenerRegistry from '../base/redux/StateListenerRegistry';
import { playSound, registerSound, unregisterSound } from '../base/sounds/actions';
import { hideNotification, showNotification } from '../notifications/actions';
import { NOTIFICATION_TIMEOUT_TYPE } from '../notifications/constants';
import { muteLocal } from '../video-menu/actions.any';

import {
    DISABLE_MODERATION,
    ENABLE_MODERATION,
    LOCAL_PARTICIPANT_APPROVED,
    LOCAL_PARTICIPANT_MODERATION_NOTIFICATION,
    LOCAL_PARTICIPANT_REJECTED,
    PARTICIPANT_APPROVED,
    PARTICIPANT_REJECTED,
    REQUEST_DISABLE_AUDIO_MODERATION,
    REQUEST_DISABLE_VIDEO_MODERATION,
    REQUEST_ENABLE_AUDIO_MODERATION,
    REQUEST_ENABLE_VIDEO_MODERATION
} from './actionTypes';
import {
    disableModeration,
    dismissPendingAudioParticipant,
    dismissPendingParticipant,
    enableModeration,
    localParticipantApproved,
    localParticipantRejected,
    participantApproved,
    participantPendingAudio,
    participantRejected
} from './actions';
import {
    ASKED_TO_UNMUTE_NOTIFICATION_ID,
    ASKED_TO_UNMUTE_SOUND_ID,
    AUDIO_MODERATION_NOTIFICATION_ID,
    CS_MODERATION_NOTIFICATION_ID,
    VIDEO_MODERATION_NOTIFICATION_ID
} from './constants';
import {
    isEnabledFromState,
    isParticipantApproved,
    isParticipantPending
} from './functions';
import { ASKED_TO_UNMUTE_FILE } from './sounds';

MiddlewareRegistry.register(({ dispatch, getState }) => next => action => {
    const { type } = action;
    const { conference } = getConferenceState(getState());

    switch (type) {
    case APP_WILL_MOUNT: {
        dispatch(registerSound(ASKED_TO_UNMUTE_SOUND_ID, ASKED_TO_UNMUTE_FILE));
        break;
    }
    case APP_WILL_UNMOUNT: {
        dispatch(unregisterSound(ASKED_TO_UNMUTE_SOUND_ID));
        break;
    }
    case LOCAL_PARTICIPANT_MODERATION_NOTIFICATION: {
        let descriptionKey;
        let titleKey;
        let uid = '';
        const localParticipant = getLocalParticipant(getState);
        const raisedHand = hasRaisedHand(localParticipant);

        switch (action.mediaType) {
        case MEDIA_TYPE.AUDIO: {
            titleKey = 'notify.moderationInEffectTitle';
            uid = AUDIO_MODERATION_NOTIFICATION_ID;
            break;
        }
        case MEDIA_TYPE.VIDEO: {
            titleKey = 'notify.moderationInEffectVideoTitle';
            uid = VIDEO_MODERATION_NOTIFICATION_ID;
            break;
        }
        case MEDIA_TYPE.SCREENSHARE: {
            titleKey = 'notify.moderationInEffectCSTitle';
            uid = CS_MODERATION_NOTIFICATION_ID;
            break;
        }
        }

        dispatch(showNotification({
            customActionNameKey: [ 'notify.raiseHandAction' ],
            customActionHandler: [ () => batch(() => {
                !raisedHand && dispatch(raiseHand(true));
                dispatch(hideNotification(uid));
            }) ],
            descriptionKey,
            sticky: true,
            titleKey,
            uid
        }, NOTIFICATION_TIMEOUT_TYPE.MEDIUM));

        break;
    }
    case REQUEST_DISABLE_AUDIO_MODERATION: {
        conference?.disableAVModeration(MEDIA_TYPE.AUDIO);
        break;
    }
    case REQUEST_DISABLE_VIDEO_MODERATION: {
        conference?.disableAVModeration(MEDIA_TYPE.VIDEO);
        break;
    }
    case REQUEST_ENABLE_AUDIO_MODERATION: {
        conference?.enableAVModeration(MEDIA_TYPE.AUDIO);
        break;
    }
    case REQUEST_ENABLE_VIDEO_MODERATION: {
        conference?.enableAVModeration(MEDIA_TYPE.VIDEO);
        break;
    }
    case PARTICIPANT_UPDATED: {
        const state = getState();
        const audioModerationEnabled = isEnabledFromState(MEDIA_TYPE.AUDIO, state);
        const participant = action.participant;

        if (participant && audioModerationEnabled) {
            if (isLocalParticipantModerator(state)) {

                // this is handled only by moderators
                if (hasRaisedHand(participant)) {
                    // if participant raises hand show notification
                    !isParticipantApproved(participant.id, MEDIA_TYPE.AUDIO)(state)
                    && dispatch(participantPendingAudio(participant));
                } else {
                    // if participant lowers hand hide notification
                    isParticipantPending(participant, MEDIA_TYPE.AUDIO)(state)
                    && dispatch(dismissPendingAudioParticipant(participant));
                }
            } else if (participant.id === getLocalParticipant(state)?.id
                && /* the new role */ isParticipantModerator(participant)) {

                // this is the granted moderator case
                getRemoteParticipants(state).forEach(p => {
                    hasRaisedHand(p) && !isParticipantApproved(p.id, MEDIA_TYPE.AUDIO)(state)
                        && dispatch(participantPendingAudio(p));
                });
            }
        }

        break;
    }
    case ENABLE_MODERATION: {
        if (typeof APP !== 'undefined') {
            APP.API.notifyModerationChanged(action.mediaType, true);
        }
        break;
    }
    case DISABLE_MODERATION: {
        if (typeof APP !== 'undefined') {
            APP.API.notifyModerationChanged(action.mediaType, false);
        }
        break;
    }
    case LOCAL_PARTICIPANT_APPROVED: {
        if (typeof APP !== 'undefined') {
            const local = getLocalParticipant(getState());

            APP.API.notifyParticipantApproved(local?.id, action.mediaType);
        }
        break;
    }
    case PARTICIPANT_APPROVED: {
        if (typeof APP !== 'undefined') {
            APP.API.notifyParticipantApproved(action.id, action.mediaType);
        }
        break;
    }
    case LOCAL_PARTICIPANT_REJECTED: {
        if (typeof APP !== 'undefined') {
            const local = getLocalParticipant(getState());

            APP.API.notifyParticipantRejected(local?.id, action.mediaType);
        }
        break;
    }
    case PARTICIPANT_REJECTED: {
        if (typeof APP !== 'undefined') {
            APP.API.notifyParticipantRejected(action.id, action.mediaType);
        }
        break;
    }
    }

    return next(action);
});

/**
 * Registers a change handler for state['features/base/conference'].conference to
 * set the event listeners needed for the A/V moderation feature to operate.
 */
StateListenerRegistry.register(
    state => state['features/base/conference'].conference,
    (conference, { dispatch }, previousConference) => {
        if (conference && !previousConference) {
            // local participant is allowed to unmute
            conference.on(JitsiConferenceEvents.AV_MODERATION_APPROVED, ({ mediaType }: { mediaType: MediaType; }) => {
                dispatch(localParticipantApproved(mediaType));

                // Audio & video moderation are both enabled at the same time.
                // Avoid displaying 2 different notifications.
                if (mediaType === MEDIA_TYPE.AUDIO) {
                    dispatch(showNotification({
                        titleKey: 'notify.hostAskedUnmute',
                        sticky: true,
                        customActionNameKey: [ 'notify.unmute' ],
                        customActionHandler: [ () => dispatch(muteLocal(false, MEDIA_TYPE.AUDIO)) ],
                        uid: ASKED_TO_UNMUTE_NOTIFICATION_ID
                    }, NOTIFICATION_TIMEOUT_TYPE.MEDIUM));
                    dispatch(playSound(ASKED_TO_UNMUTE_SOUND_ID));
                }
            });

            conference.on(JitsiConferenceEvents.AV_MODERATION_REJECTED, ({ mediaType }: { mediaType: MediaType; }) => {
                dispatch(localParticipantRejected(mediaType));
            });

            conference.on(JitsiConferenceEvents.AV_MODERATION_CHANGED, ({ enabled, mediaType, actor }: {
                actor: Object; enabled: boolean; mediaType: MediaType;
            }) => {
                enabled ? dispatch(enableModeration(mediaType, actor)) : dispatch(disableModeration(mediaType, actor));
            });

            // this is received by moderators
            conference.on(
                JitsiConferenceEvents.AV_MODERATION_PARTICIPANT_APPROVED,
                ({ participant, mediaType }: { mediaType: MediaType; participant: { _id: string; }; }) => {
                    const { _id: id } = participant;

                    batch(() => {
                        // store in the whitelist
                        dispatch(participantApproved(id, mediaType));

                        // remove from pending list
                        dispatch(dismissPendingParticipant(id, mediaType));
                    });
                });

            // this is received by moderators
            conference.on(
                JitsiConferenceEvents.AV_MODERATION_PARTICIPANT_REJECTED,
                ({ participant, mediaType }: { mediaType: MediaType; participant: { _id: string; }; }) => {
                    const { _id: id } = participant;

                    dispatch(participantRejected(id, mediaType));
                });
        }
    });


################################################################################

## File: .\jitsi-meet\react\features\av-moderation\reducer.ts

import { MEDIA_TYPE } from '../base/media/constants';
import type { MediaType } from '../base/media/constants';
import {
    PARTICIPANT_LEFT,
    PARTICIPANT_UPDATED
} from '../base/participants/actionTypes';
import { IParticipant } from '../base/participants/types';
import ReducerRegistry from '../base/redux/ReducerRegistry';

import {
    DISABLE_MODERATION,
    DISMISS_PENDING_PARTICIPANT,
    ENABLE_MODERATION,
    LOCAL_PARTICIPANT_APPROVED,
    LOCAL_PARTICIPANT_REJECTED,
    PARTICIPANT_APPROVED,
    PARTICIPANT_PENDING_AUDIO,
    PARTICIPANT_REJECTED
} from './actionTypes';
import { MEDIA_TYPE_TO_PENDING_STORE_KEY } from './constants';

const initialState = {
    audioModerationEnabled: false,
    videoModerationEnabled: false,
    audioWhitelist: {},
    videoWhitelist: {},
    pendingAudio: [],
    pendingVideo: []
};

export interface IAVModerationState {
    audioModerationEnabled: boolean;
    audioUnmuteApproved?: boolean | undefined;
    audioWhitelist: { [id: string]: boolean; };
    pendingAudio: Array<{ id: string; }>;
    pendingVideo: Array<{ id: string; }>;
    videoModerationEnabled: boolean;
    videoUnmuteApproved?: boolean | undefined;
    videoWhitelist: { [id: string]: boolean; };
}

/**
 * Updates a participant in the state for the specified media type.
 *
 * @param {MediaType} mediaType - The media type.
 * @param {Object} participant - Information about participant to be modified.
 * @param {Object} state - The current state.
 * @private
 * @returns {boolean} - Whether state instance was modified.
 */
function _updatePendingParticipant(mediaType: MediaType, participant: IParticipant, state: IAVModerationState) {
    let arrayItemChanged = false;
    const storeKey = MEDIA_TYPE_TO_PENDING_STORE_KEY[mediaType];
    const arr = state[storeKey];
    const newArr = arr.map((pending: { id: string; }) => {
        if (pending.id === participant.id) {
            arrayItemChanged = true;

            return {
                ...pending,
                ...participant
            };
        }

        return pending;
    });

    if (arrayItemChanged) {
        state[storeKey] = newArr;

        return true;
    }

    return false;
}

ReducerRegistry.register<IAVModerationState>('features/av-moderation',
(state = initialState, action): IAVModerationState => {
    switch (action.type) {
    case DISABLE_MODERATION: {
        const newState = action.mediaType === MEDIA_TYPE.AUDIO
            ? {
                audioModerationEnabled: false,
                audioUnmuteApproved: undefined
            } : {
                videoModerationEnabled: false,
                videoUnmuteApproved: undefined
            };

        return {
            ...state,
            ...newState,
            audioWhitelist: {},
            videoWhitelist: {},
            pendingAudio: [],
            pendingVideo: []
        };
    }

    case ENABLE_MODERATION: {
        const newState = action.mediaType === MEDIA_TYPE.AUDIO
            ? { audioModerationEnabled: true } : { videoModerationEnabled: true };

        return {
            ...state,
            ...newState
        };
    }

    case LOCAL_PARTICIPANT_APPROVED: {
        const newState = action.mediaType === MEDIA_TYPE.AUDIO
            ? { audioUnmuteApproved: true } : { videoUnmuteApproved: true };

        return {
            ...state,
            ...newState
        };
    }

    case LOCAL_PARTICIPANT_REJECTED: {
        const newState = action.mediaType === MEDIA_TYPE.AUDIO
            ? { audioUnmuteApproved: false } : { videoUnmuteApproved: false };

        return {
            ...state,
            ...newState
        };
    }

    case PARTICIPANT_PENDING_AUDIO: {
        const { participant } = action;

        // Add participant to pendingAudio array only if it's not already added
        if (!state.pendingAudio.find(pending => pending.id === participant.id)) {
            const updated = [ ...state.pendingAudio ];

            updated.push(participant);

            return {
                ...state,
                pendingAudio: updated
            };
        }

        return state;
    }

    case PARTICIPANT_UPDATED: {
        const participant = action.participant;
        const { audioModerationEnabled, videoModerationEnabled } = state;
        let hasStateChanged = false;

        // skips changing the reference of pendingAudio or pendingVideo,
        // if there is no change in the elements
        if (audioModerationEnabled) {
            hasStateChanged = _updatePendingParticipant(MEDIA_TYPE.AUDIO, participant, state);
        }

        if (videoModerationEnabled) {
            hasStateChanged = hasStateChanged || _updatePendingParticipant(MEDIA_TYPE.VIDEO, participant, state);
        }

        // If the state has changed we need to return a new object reference in order to trigger subscriber updates.
        if (hasStateChanged) {
            return {
                ...state
            };
        }

        return state;
    }
    case PARTICIPANT_LEFT: {
        const participant = action.participant;
        const { audioModerationEnabled, videoModerationEnabled } = state;
        let hasStateChanged = false;

        // skips changing the reference of pendingAudio or pendingVideo,
        // if there is no change in the elements
        if (audioModerationEnabled) {
            const newPendingAudio = state.pendingAudio.filter(pending => pending.id !== participant.id);

            if (state.pendingAudio.length !== newPendingAudio.length) {
                state.pendingAudio = newPendingAudio;
                hasStateChanged = true;
            }
        }

        if (videoModerationEnabled) {
            const newPendingVideo = state.pendingVideo.filter(pending => pending.id !== participant.id);

            if (state.pendingVideo.length !== newPendingVideo.length) {
                state.pendingVideo = newPendingVideo;
                hasStateChanged = true;
            }
        }

        // If the state has changed we need to return a new object reference in order to trigger subscriber updates.
        if (hasStateChanged) {
            return {
                ...state
            };
        }

        return state;
    }

    case DISMISS_PENDING_PARTICIPANT: {
        const { id, mediaType } = action;

        if (mediaType === MEDIA_TYPE.AUDIO) {
            return {
                ...state,
                pendingAudio: state.pendingAudio.filter(pending => pending.id !== id)
            };
        }

        if (mediaType === MEDIA_TYPE.VIDEO) {
            return {
                ...state,
                pendingVideo: state.pendingVideo.filter(pending => pending.id !== id)
            };
        }

        return state;
    }

    case PARTICIPANT_APPROVED: {
        const { mediaType, id } = action;

        if (mediaType === MEDIA_TYPE.AUDIO) {
            return {
                ...state,
                audioWhitelist: {
                    ...state.audioWhitelist,
                    [id]: true
                }
            };
        }

        if (mediaType === MEDIA_TYPE.VIDEO) {
            return {
                ...state,
                videoWhitelist: {
                    ...state.videoWhitelist,
                    [id]: true
                }
            };
        }

        return state;
    }

    case PARTICIPANT_REJECTED: {
        const { mediaType, id } = action;

        if (mediaType === MEDIA_TYPE.AUDIO) {
            return {
                ...state,
                audioWhitelist: {
                    ...state.audioWhitelist,
                    [id]: false
                }
            };
        }

        if (mediaType === MEDIA_TYPE.VIDEO) {
            return {
                ...state,
                videoWhitelist: {
                    ...state.videoWhitelist,
                    [id]: false
                }
            };
        }

        return state;
    }

    }

    return state;
});


################################################################################

## File: .\jitsi-meet\react\features\av-moderation\sounds.ts

/**
 * The name of the bundled audio file which will be played for the raise hand sound.
 *
 * @type {string}
 */
export const ASKED_TO_UNMUTE_FILE = 'asked-unmute.mp3';


################################################################################

## File: .\jitsi-meet\react\features\base\app\actions.ts

import { IStore } from '../../app/types';

import {
    APP_WILL_MOUNT,
    APP_WILL_NAVIGATE,
    APP_WILL_UNMOUNT
} from './actionTypes';

/**
 * Signals that a specific App will mount (in the terms of React).
 *
 * @param {App} app - The App which will mount.
 * @returns {{
 *     type: APP_WILL_MOUNT,
 *     app: App
 * }}
 */
export function appWillMount(app: Object) {
    return (dispatch: IStore['dispatch']) => {
        // TODO There was a redux action creator appInit which I did not like
        // because we already had the redux action creator appWillMount and,
        // respectively, the redux action APP_WILL_MOUNT. So I set out to remove
        // appInit and managed to move everything it was doing but the
        // following. Which is not extremely bad because we haven't moved the
        // API module into its own feature yet so we're bound to work on that in
        // the future.
        typeof APP === 'object' && APP.API.init();

        dispatch({
            type: APP_WILL_MOUNT,
            app
        });
    };
}

/**
 * Signals that a specific App will unmount (in the terms of React).
 *
 * @param {App} app - The App which will unmount.
 * @returns {{
 *     type: APP_WILL_UNMOUNT,
 *     app: App
 * }}
 */
export function appWillUnmount(app: Object) {
    return {
        type: APP_WILL_UNMOUNT,
        app
    };
}

/**
 * Signals that a specific App will navigate (in the terms of React).
 *
 * @param {App} app - The App which will navigate.
 * @param {Object} route - The route which will be used.
 * @returns {{
 *     type: APP_WILL_NAVIGATE,
 *     app: App,
 *     route: Object
 * }}
 */
export function appWillNavigate(app: Object, route: Object) {
    return {
        type: APP_WILL_NAVIGATE,
        app,
        route
    };
}


################################################################################

## File: .\jitsi-meet\react\features\base\app\actionTypes.ts

/**
 * The type of (redux) action which signals that a specific App will mount (in
 * React terms).
 *
 * {
 *     type: APP_WILL_MOUNT,
 *     app: App
 * }
 */
export const APP_WILL_MOUNT = 'APP_WILL_MOUNT';

/**
 * The type of (redux) action which signals that a specific App will unmount (in
 * React terms).
 *
 * {
 *     type: APP_WILL_UNMOUNT,
 *     app: App
 * }
 */
export const APP_WILL_UNMOUNT = 'APP_WILL_UNMOUNT';

/**
 * The type of (redux) action which signals that a specific App will navigate using a route (in
 * React terms).
 *
 * {
 *     type: APP_WILL_NAVIGATE,
 *     app: App,
 *     route: Route
 * }
 */
export const APP_WILL_NAVIGATE = 'APP_WILL_NAVIGATE';


################################################################################

## File: .\jitsi-meet\react\features\base\app\functions.ts

import { toState } from '../redux/functions';

import { IStateful } from './types';

/**
 * Gets the value of a specific React {@code Component} prop of the currently
 * mounted {@link App}.
 *
 * @param {IStateful} stateful - The redux store or {@code getState}
 * function.
 * @param {string} propName - The name of the React {@code Component} prop of
 * the currently mounted {@code App} to get.
 * @returns {*} The value of the specified React {@code Component} prop of the
 * currently mounted {@code App}.
 */
export function getAppProp(stateful: IStateful, propName: string) {
    const state = toState(stateful)['features/base/app'];

    if (state) {
        const { app } = state;

        if (app) {
            return app.props[propName];
        }
    }

    return undefined;
}


################################################################################

## File: .\jitsi-meet\react\features\base\app\logger.ts

import { getLogger } from '../logging/functions';

export default getLogger('features/base/app');


################################################################################

## File: .\jitsi-meet\react\features\base\app\middleware.web.ts

import { AnyAction } from 'redux';

import MiddlewareRegistry from '../redux/MiddlewareRegistry';
import { inIframe } from '../util/iframeUtils';

import { APP_WILL_MOUNT, APP_WILL_UNMOUNT } from './actionTypes';
import logger from './logger';


/**
 * Experimental feature to monitor CPU pressure.
 */
let pressureObserver: typeof window.PressureObserver;

/**
 * Middleware which intercepts app actions to handle changes to the related state.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(() => (next: Function) => (action: AnyAction) => {

    switch (action.type) {
    case APP_WILL_MOUNT: {
        // Disable it inside an iframe until Google fixes the origin trial for 3rd party sources:
        // https://bugs.chromium.org/p/chromium/issues/detail?id=1504167
        if (!inIframe() && 'PressureObserver' in globalThis) {
            pressureObserver = new window.PressureObserver(
                    (records: typeof window.PressureRecord) => {
                        logger.info('Compute pressure state changed:', JSON.stringify(records));
                        if (typeof APP !== 'undefined') {
                            APP.API.notifyComputePressureChanged(records);
                        }
                    },
                    { sampleRate: 1 }
            );

            try {
                pressureObserver
                    .observe('cpu')
                    .catch((e: any) => logger.error('CPU pressure observer failed to start', e));
            } catch (e: any) {
                logger.error('CPU pressure observer failed to start', e);
            }
        }
        break;
    }
    case APP_WILL_UNMOUNT: {
        if (pressureObserver) {
            pressureObserver.unobserve('cpu');
        }
        break;
    }
    }

    return next(action);
});


################################################################################

## File: .\jitsi-meet\react\features\base\app\reducer.ts

import ReducerRegistry from '../redux/ReducerRegistry';

import { APP_WILL_MOUNT, APP_WILL_UNMOUNT } from './actionTypes';

export interface IAppState {
    app?: any;
}

ReducerRegistry.register<IAppState>('features/base/app', (state = {}, action): IAppState => {
    switch (action.type) {
    case APP_WILL_MOUNT: {
        const { app } = action;

        if (state.app !== app) {
            return {
                ...state,
                app
            };
        }
        break;
    }

    case APP_WILL_UNMOUNT:
        if (state.app === action.app) {
            return {
                ...state,
                app: undefined
            };
        }
        break;
    }

    return state;
});


################################################################################

## File: .\jitsi-meet\react\features\base\app\types.ts

import { IReduxState, IStore } from '../../app/types';

export type IStateful = (() => IReduxState) | IStore | IReduxState;


################################################################################

## File: .\jitsi-meet\react\features\base\audio-only\actions.ts

import { createAudioOnlyChangedEvent } from '../../analytics/AnalyticsEvents';
import { sendAnalytics } from '../../analytics/functions';
import { IStore } from '../../app/types';

import { SET_AUDIO_ONLY } from './actionTypes';
import logger from './logger';


/**
 * Sets the audio-only flag for the current JitsiConference.
 *
 * @param {boolean} audioOnly - True if the conference should be audio only; false, otherwise.
 * @returns {{
 *     type: SET_AUDIO_ONLY,
 *     audioOnly: boolean
 * }}
 */
export function setAudioOnly(audioOnly: boolean) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const { enabled: oldValue } = getState()['features/base/audio-only'];

        if (oldValue !== audioOnly) {
            sendAnalytics(createAudioOnlyChangedEvent(audioOnly));
            logger.log(`Audio-only ${audioOnly ? 'enabled' : 'disabled'}`);

            dispatch({
                type: SET_AUDIO_ONLY,
                audioOnly
            });

            if (typeof APP !== 'undefined') {
                // TODO This should be a temporary solution that lasts only until video
                // tracks and all ui is moved into react/redux on the web.
                APP.conference.onToggleAudioOnly();
            }
        }
    };
}

/**
 * Toggles the audio-only flag for the current JitsiConference.
 *
 * @returns {Function}
 */
export function toggleAudioOnly() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const { enabled } = getState()['features/base/audio-only'];

        dispatch(setAudioOnly(!enabled));
    };
}


################################################################################

## File: .\jitsi-meet\react\features\base\audio-only\actionTypes.ts

/**
 * The type of (redux) action which sets the audio-only flag for the current
 * conference.
 *
 * {
 *     type: SET_AUDIO_ONLY,
 *     audioOnly: boolean
 * }
 */
export const SET_AUDIO_ONLY = 'SET_AUDIO_ONLY';


################################################################################

## File: .\jitsi-meet\react\features\base\audio-only\logger.ts

import { getLogger } from '../logging/functions';

export default getLogger('features/base/audio-only');


################################################################################

## File: .\jitsi-meet\react\features\base\audio-only\reducer.ts

import ReducerRegistry from '../redux/ReducerRegistry';

import { SET_AUDIO_ONLY } from './actionTypes';

export interface IAudioOnlyState {
    enabled: boolean;
}

const DEFAULT_STATE = {
    enabled: false
};


ReducerRegistry.register<IAudioOnlyState>('features/base/audio-only',
(state = DEFAULT_STATE, action): IAudioOnlyState => {
    switch (action.type) {
    case SET_AUDIO_ONLY:
        return {
            ...state,
            enabled: action.audioOnly
        };
    default:
        return state;
    }
});


################################################################################

## File: .\jitsi-meet\react\features\base\avatar\constants.ts

/**
 * The base URL for gravatar images.
 */
export const GRAVATAR_BASE_URL = 'https://www.gravatar.com/avatar/';


################################################################################

## File: .\jitsi-meet\react\features\base\avatar\functions.ts

import GraphemeSplitter from 'grapheme-splitter';
import { split } from 'lodash-es';

const AVATAR_COLORS = [
    '#6A50D3',
    '#FF9B42',
    '#DF486F',
    '#73348C',
    '#B23683',
    '#F96E57',
    '#4380E2',
    '#238561',
    '#00A8B3'
];
const wordSplitRegex = (/\s+|\.+|_+|;+|-+|,+|\|+|\/+|\\+|"+|'+|\(+|\)+|#+|&+/);
const splitter = new GraphemeSplitter();

/**
 * Generates the background color of an initials based avatar.
 *
 * @param {string?} initials - The initials of the avatar.
 * @param {Array<string>} customAvatarBackgrounds - Custom avatar background values.
 * @returns {string}
 */
export function getAvatarColor(initials: string | undefined, customAvatarBackgrounds: Array<string>) {
    const hasCustomAvatarBackgronds = customAvatarBackgrounds?.length;
    const colorsBase = hasCustomAvatarBackgronds ? customAvatarBackgrounds : AVATAR_COLORS;

    let colorIndex = 0;

    if (initials) {
        let nameHash = 0;

        for (const s of initials) {
            nameHash += Number(s.codePointAt(0));
        }

        colorIndex = nameHash % colorsBase.length;
    }

    return colorsBase[colorIndex];
}

/**
 * Returns the first grapheme from a word, uppercased.
 *
 * @param {string} word - The string to get grapheme from.
 * @returns {string}
 */
function getFirstGraphemeUpper(word: string) {
    if (!word?.length) {
        return '';
    }

    return splitter.splitGraphemes(word)[0].toUpperCase();
}

/**
 * Generates initials for a simple string.
 *
 * @param {string?} s - The string to generate initials for.
 * @returns {string?}
 */
export function getInitials(s?: string) {
    // We don't want to use the domain part of an email address, if it is one
    const initialsBasis = split(s, '@')[0];
    const [ firstWord, secondWord ] = initialsBasis.split(wordSplitRegex).filter(Boolean);

    return getFirstGraphemeUpper(firstWord) + getFirstGraphemeUpper(secondWord);
}

/**
 * Checks if the passed URL should be loaded with CORS.
 *
 * @param {string} url - The URL.
 * @param {Array<string>} corsURLs - The URL pattern that matches a URL that needs to be handled with CORS.
 * @returns {void}
 */
export function isCORSAvatarURL(url: string, corsURLs: Array<string> = []): boolean {
    return corsURLs.some(pattern => url.startsWith(pattern));
}

/**
 * Checks if the passed prop is a loaded icon or not.
 *
 * @param {string? | Object?} iconProp - The prop to check.
 * @returns {boolean}
 */
export function isIcon(iconProp?: string | Function): iconProp is Function {
    return Boolean(iconProp) && (typeof iconProp === 'object' || typeof iconProp === 'function');
}


################################################################################

## File: .\jitsi-meet\react\features\base\avatar\types.ts

export interface IAvatarProps {

    /**
     * Color of the (initials based) avatar, if needed.
     */
    color?: string;

    /**
     * The user icon(browser only).
     */
    iconUser?: any;

    /**
     * Initials to be used to render the initials based avatars.
     */
    initials?: string;

    /**
     * Callback to signal the failure of the loading of the URL.
     */
    onAvatarLoadError?: Function;

    /**
     * Additional parameters to be passed to onAvatarLoadError function.
     */
    onAvatarLoadErrorParams?: Object;

    /**
     * Expected size of the avatar.
     */
    size?: number;
}


################################################################################

## File: .\jitsi-meet\react\features\base\avatar\components\index.native.ts

export { default as StatelessAvatar } from './native/StatelessAvatar';


################################################################################

## File: .\jitsi-meet\react\features\base\avatar\components\index.web.ts

export { default as StatelessAvatar } from './web/StatelessAvatar';


################################################################################

## File: .\jitsi-meet\react\features\base\avatar\components\styles.ts

// Colors for avatar status badge
export const PRESENCE_AVAILABLE_COLOR = 'rgb(110, 176, 5)';
export const PRESENCE_AWAY_COLOR = 'rgb(250, 201, 20)';
export const PRESENCE_BUSY_COLOR = 'rgb(233, 0, 27)';
export const PRESENCE_IDLE_COLOR = 'rgb(172, 172, 172)';


################################################################################

## File: .\jitsi-meet\react\features\base\avatar\components\native\styles.ts

import { StyleSheet } from 'react-native';

import { ColorPalette } from '../../../styles/components/styles/ColorPalette';
import { PRESENCE_AVAILABLE_COLOR, PRESENCE_AWAY_COLOR, PRESENCE_BUSY_COLOR, PRESENCE_IDLE_COLOR } from '../styles';

const DEFAULT_SIZE = 65;

/**
 * The styles of the feature base/participants.
 */
export default {

    avatarContainer: (size: number = DEFAULT_SIZE) => {
        return {
            alignItems: 'center',
            borderRadius: size / 2,
            height: size,
            justifyContent: 'center',
            overflow: 'hidden',
            width: size
        };
    },

    avatarContent: (size: number = DEFAULT_SIZE) => {
        return {
            height: size,
            width: size
        };
    },

    badge: (size: number = DEFAULT_SIZE, status: string) => {
        let color;

        switch (status) {
        case 'available':
            color = PRESENCE_AVAILABLE_COLOR;
            break;
        case 'away':
            color = PRESENCE_AWAY_COLOR;
            break;
        case 'busy':
            color = PRESENCE_BUSY_COLOR;
            break;
        case 'idle':
            color = PRESENCE_IDLE_COLOR;
            break;
        }

        return {
            backgroundColor: color,
            borderRadius: size / 2,
            bottom: 0,
            height: size * 0.3,
            position: 'absolute',
            width: size * 0.3
        };
    },

    badgeContainer: {
        ...StyleSheet.absoluteFillObject
    },

    initialsContainer: {
        alignItems: 'center',
        alignSelf: 'stretch',
        flex: 1,
        justifyContent: 'center'
    },

    initialsText: (size: number = DEFAULT_SIZE) => {
        return {
            color: 'white',
            fontSize: size * 0.45,
            fontWeight: '100'
        };
    },

    staticAvatar: {
        backgroundColor: ColorPalette.lightGrey,
        opacity: 0.4
    }
};


################################################################################

## File: .\jitsi-meet\react\features\base\color-scheme\ColorSchemeRegistry.ts

import { IStateful } from '../app/types';
import { toState } from '../redux/functions';
import { StyleType } from '../styles/functions.any';

import defaultScheme from './defaultScheme';

/**
 * A registry class to register styles that need to be color-schemed.
 *
 * This class uses lazy initialization for scheme-ified style definitions on
 * request.
 */
class ColorSchemeRegistry {
    /**
     * A map of already scheme-ified style definitions.
     */
    _schemedStyles = new Map();

    /**
     * A map of registered style templates.
     */
    _styleTemplates = new Map();

    /**
     * Clears the already scheme-ified style definitions.
     *
     * @returns {void}
     */
    clear() {
        this._schemedStyles.clear();
    }

    /**
     * Retrieves the color-scheme applied style definition of a component.
     *
     * @param {Object | Function} stateful - An object or function that can be
     * resolved to Redux state using the {@code toState} function.
     * @param {string} componentName - The name of the component whose style we
     * want to retrieve.
     * @returns {StyleType}
     */
    get(stateful: IStateful, componentName: string): StyleType {
        let schemedStyle = this._schemedStyles.get(componentName);

        if (!schemedStyle) {
            schemedStyle
                = this._applyColorScheme(
                    stateful,
                    componentName,
                    this._styleTemplates.get(componentName));
            this._schemedStyles.set(componentName, schemedStyle);
        }

        return schemedStyle;
    }

    /**
     * Registers a style definition to the registry for color-scheming.
     *
     * NOTE: It's suggested to only use this registry on styles where color
     * scheming is needed, otherwise just use a static style object as before.
     *
     * @param {string} componentName - The name of the component to register the
     * style to (e.g. {@code 'Toolbox'}).
     * @param {StyleType} style - The style definition to register.
     * @returns {void}
     */
    register(componentName: string, style: any): void {
        this._styleTemplates.set(componentName, style);

        // If this is a style overwrite, we need to delete the processed version
        // of the style from the other map
        this._schemedStyles.delete(componentName);
    }

    /**
     * Creates a color schemed style object applying the color scheme to every
     * colors in the style object prepared in a special way.
     *
     * @param {Object | Function} stateful - An object or function that can be
     * resolved to Redux state using the {@code toState} function.
     * @param {string} componentName - The name of the component to apply the
     * color scheme to.
     * @param {StyleType} style - The style definition to apply the color scheme
     * to.
     * @returns {StyleType}
     */
    _applyColorScheme(
            stateful: IStateful,
            componentName: string,
            style: StyleType | null): StyleType {
        let schemedStyle: any;

        if (Array.isArray(style)) {
            // The style is an array of styles, we apply the same transformation
            // to each, recursively.
            schemedStyle = [];

            for (const entry of style) {
                schemedStyle.push(this._applyColorScheme(
                    stateful, componentName, entry));
            }
        } else {
            // The style is an object, we create a copy of it to avoid in-place
            // modification.
            schemedStyle = {
                ...style
            };

            for (const [
                styleName,
                styleValue
            ] of Object.entries(schemedStyle)) {
                if (typeof styleValue === 'object') {
                    // The value is another style object, we apply the same
                    // transformation recursively.
                    schemedStyle[styleName]
                        = this._applyColorScheme(
                            stateful, componentName, styleValue as StyleType);
                } else if (typeof styleValue === 'function') {
                    // The value is a function, which indicates that it's a
                    // dynamic, schemed color we need to resolve.
                    const value = styleValue();

                    schemedStyle[styleName]
                        = this._getColor(stateful, componentName, value);
                }

            }
        }

        return schemedStyle;
    }

    /**
     * Function to get the color value for the provided identifier.
     *
     * @param {Object | Function} stateful - An object or function that can be
     * resolved to Redux state using the {@code toState} function.
     * @param {string} componentName - The name of the component to get the
     * color value for.
     * @param {string} colorDefinition - The string identifier of the color,
     * e.g. {@code appBackground}.
     * @returns {string}
     */
    _getColor(
            stateful: IStateful,
            componentName: string,
            colorDefinition: string): string {
        const colorScheme = toState(stateful)['features/base/color-scheme'] || {};

        return {
            ...defaultScheme._defaultTheme,
            ...colorScheme._defaultTheme,
            ...defaultScheme[componentName as keyof typeof defaultScheme],
            ...colorScheme[componentName]
        }[colorDefinition];
    }

}

export default new ColorSchemeRegistry();


################################################################################

## File: .\jitsi-meet\react\features\base\color-scheme\defaultScheme.ts

import { ColorPalette } from '../styles/components/styles/ColorPalette';
import { getRGBAFormat } from '../styles/functions.any';

/**
 * The default color scheme of the application.
 */
export default {
    '_defaultTheme': {
        // Generic app theme colors that are used across the entire app.
        // All scheme definitions below inherit these values.
        background: 'rgb(255, 255, 255)',
        errorText: ColorPalette.red,
        icon: 'rgb(28, 32, 37)',
        text: 'rgb(28, 32, 37)'
    },
    'Dialog': {},
    'Header': {
        background: ColorPalette.blue,
        icon: ColorPalette.white,
        statusBar: ColorPalette.blueHighlight,
        statusBarContent: ColorPalette.white,
        text: ColorPalette.white
    },
    'Toolbox': {
        button: 'rgb(255, 255, 255)',
        buttonToggled: 'rgb(38, 58, 76)',
        buttonToggledBorder: getRGBAFormat('#a4b8d1', 0.6),
        hangup: 'rgb(227,79,86)'
    }
};


################################################################################

## File: .\jitsi-meet\react\features\base\color-scheme\functions.ts

/**
 * A special function to be used in the {@code createColorSchemedStyle} call,
 * that denotes that the color is a dynamic color.
 *
 * @param {string} colorDefinition - The definition of the color to mark to be
 * resolved.
 * @returns {Function}
 */
export function schemeColor(colorDefinition: string): Function {
    return () => colorDefinition;
}


################################################################################

## File: .\jitsi-meet\react\features\base\conference\actions.any.ts

import { createStartMutedConfigurationEvent } from '../../analytics/AnalyticsEvents';
import { sendAnalytics } from '../../analytics/functions';
import { IReduxState, IStore } from '../../app/types';
import { transcriberJoined, transcriberLeft } from '../../transcribing/actions';
import { setIAmVisitor } from '../../visitors/actions';
import { iAmVisitor } from '../../visitors/functions';
import { overwriteConfig } from '../config/actions';
import { getReplaceParticipant } from '../config/functions';
import { connect, disconnect, hangup } from '../connection/actions';
import { JITSI_CONNECTION_CONFERENCE_KEY } from '../connection/constants';
import { hasAvailableDevices } from '../devices/functions.any';
import JitsiMeetJS, { JitsiConferenceEvents, JitsiE2ePingEvents } from '../lib-jitsi-meet';
import {
    setAudioMuted,
    setAudioUnmutePermissions,
    setVideoMuted,
    setVideoUnmutePermissions
} from '../media/actions';
import { MEDIA_TYPE, MediaType } from '../media/constants';
import {
    dominantSpeakerChanged,
    participantKicked,
    participantMutedUs,
    participantPresenceChanged,
    participantRoleChanged,
    participantSourcesUpdated,
    participantUpdated
} from '../participants/actions';
import { getNormalizedDisplayName, getParticipantByIdOrUndefined } from '../participants/functions';
import { IJitsiParticipant } from '../participants/types';
import { toState } from '../redux/functions';
import {
    destroyLocalTracks,
    replaceLocalTrack,
    trackAdded,
    trackRemoved
} from '../tracks/actions.any';
import { getLocalTracks } from '../tracks/functions';
import { getBackendSafeRoomName } from '../util/uri';

import {
    AUTH_STATUS_CHANGED,
    CONFERENCE_FAILED,
    CONFERENCE_JOINED,
    CONFERENCE_JOIN_IN_PROGRESS,
    CONFERENCE_LEFT,
    CONFERENCE_LOCAL_SUBJECT_CHANGED,
    CONFERENCE_SUBJECT_CHANGED,
    CONFERENCE_TIMESTAMP_CHANGED,
    CONFERENCE_UNIQUE_ID_SET,
    CONFERENCE_WILL_INIT,
    CONFERENCE_WILL_JOIN,
    CONFERENCE_WILL_LEAVE,
    DATA_CHANNEL_CLOSED,
    DATA_CHANNEL_OPENED,
    E2E_RTT_CHANGED,
    ENDPOINT_MESSAGE_RECEIVED,
    KICKED_OUT,
    LOCK_STATE_CHANGED,
    NON_PARTICIPANT_MESSAGE_RECEIVED,
    P2P_STATUS_CHANGED,
    SEND_TONES,
    SET_ASSUMED_BANDWIDTH_BPS,
    SET_FOLLOW_ME,
    SET_FOLLOW_ME_RECORDER,
    SET_OBFUSCATED_ROOM,
    SET_PASSWORD,
    SET_PASSWORD_FAILED,
    SET_PENDING_SUBJECT_CHANGE,
    SET_ROOM,
    SET_START_MUTED_POLICY,
    SET_START_REACTIONS_MUTED,
    UPDATE_CONFERENCE_METADATA
} from './actionTypes';
import { setupVisitorStartupMedia } from './actions';
import {
    AVATAR_URL_COMMAND,
    EMAIL_COMMAND,
    JITSI_CONFERENCE_URL_KEY
} from './constants';
import {
    _addLocalTracksToConference,
    commonUserJoinedHandling,
    commonUserLeftHandling,
    getConferenceOptions,
    getConferenceState,
    getCurrentConference,
    getVisitorOptions,
    sendLocalParticipant
} from './functions';
import logger from './logger';
import { IConferenceMetadata, IJitsiConference } from './reducer';

/**
 * Adds conference (event) listeners.
 *
 * @param {JitsiConference} conference - The JitsiConference instance.
 * @param {Dispatch} dispatch - The Redux dispatch function.
 * @param {Object} state - The Redux state.
 * @private
 * @returns {void}
 */
function _addConferenceListeners(conference: IJitsiConference, dispatch: IStore['dispatch'], state: IReduxState) {
    // A simple logger for conference errors received through
    // the listener. These errors are not handled now, but logged.
    conference.on(JitsiConferenceEvents.CONFERENCE_ERROR,
        (error: Error) => logger.error('Conference error.', error));

    // Dispatches into features/base/conference follow:

    // we want to ignore this event in case of tokenAuthUrl config
    // we are deprecating this and at some point will get rid of it
    if (!state['features/base/config'].tokenAuthUrl) {
        conference.on(
            JitsiConferenceEvents.AUTH_STATUS_CHANGED,
            (authEnabled: boolean, authLogin: string) => dispatch(authStatusChanged(authEnabled, authLogin)));
    }

    conference.on(
        JitsiConferenceEvents.CONFERENCE_FAILED,
        (err: string, ...args: any[]) => dispatch(conferenceFailed(conference, err, ...args)));
    conference.on(
        JitsiConferenceEvents.CONFERENCE_JOINED,
        (..._args: any[]) => dispatch(conferenceJoined(conference)));
    conference.on(
        JitsiConferenceEvents.CONFERENCE_UNIQUE_ID_SET,
        (..._args: any[]) => dispatch(conferenceUniqueIdSet(conference)));
    conference.on(
        JitsiConferenceEvents.CONFERENCE_JOIN_IN_PROGRESS,
        (..._args: any[]) => dispatch(conferenceJoinInProgress(conference)));
    conference.on(
        JitsiConferenceEvents.CONFERENCE_LEFT,
        (..._args: any[]) => {
            dispatch(conferenceTimestampChanged(0));
            dispatch(conferenceLeft(conference));
        });
    conference.on(JitsiConferenceEvents.SUBJECT_CHANGED,
        (subject: string) => dispatch(conferenceSubjectChanged(subject)));

    conference.on(JitsiConferenceEvents.CONFERENCE_CREATED_TIMESTAMP,
        (timestamp: number) => dispatch(conferenceTimestampChanged(timestamp)));

    conference.on(
        JitsiConferenceEvents.KICKED,
        (participant: any) => dispatch(kickedOut(conference, participant)));

    conference.on(
        JitsiConferenceEvents.PARTICIPANT_KICKED,
        (kicker: any, kicked: any) => dispatch(participantKicked(kicker, kicked)));

    conference.on(
        JitsiConferenceEvents.PARTICIPANT_SOURCE_UPDATED,
        (jitsiParticipant: IJitsiParticipant) => dispatch(participantSourcesUpdated(jitsiParticipant)));

    conference.on(
        JitsiConferenceEvents.LOCK_STATE_CHANGED,
        (locked: boolean) => dispatch(lockStateChanged(conference, locked)));

    // Dispatches into features/base/media follow:

    conference.on(
        JitsiConferenceEvents.STARTED_MUTED,
        () => {
            const audioMuted = Boolean(conference.isStartAudioMuted());
            const videoMuted = Boolean(conference.isStartVideoMuted());
            const localTracks = getLocalTracks(state['features/base/tracks']);

            sendAnalytics(createStartMutedConfigurationEvent('remote', audioMuted, videoMuted));
            logger.log(`Start muted: ${audioMuted ? 'audio, ' : ''}${videoMuted ? 'video' : ''}`);

            // XXX Jicofo tells lib-jitsi-meet to start with audio and/or video
            // muted i.e. Jicofo expresses an intent. Lib-jitsi-meet has turned
            // Jicofo's intent into reality by actually muting the respective
            // tracks. The reality is expressed in base/tracks already so what
            // is left is to express Jicofo's intent in base/media.
            // TODO Maybe the app needs to learn about Jicofo's intent and
            // transfer that intent to lib-jitsi-meet instead of lib-jitsi-meet
            // acting on Jicofo's intent without the app's knowledge.
            dispatch(setAudioMuted(audioMuted));
            dispatch(setVideoMuted(videoMuted));

            // Remove the tracks from peerconnection as well.
            for (const track of localTracks) {
                const trackType = track.jitsiTrack.getType();

                // Do not remove the audio track on RN. Starting with iOS 15 it will fail to unmute otherwise.
                if ((audioMuted && trackType === MEDIA_TYPE.AUDIO && navigator.product !== 'ReactNative')
                        || (videoMuted && trackType === MEDIA_TYPE.VIDEO)) {
                    dispatch(replaceLocalTrack(track.jitsiTrack, null, conference));
                }
            }
        });

    conference.on(
        JitsiConferenceEvents.AUDIO_UNMUTE_PERMISSIONS_CHANGED,
        (disableAudioMuteChange: boolean) => {
            dispatch(setAudioUnmutePermissions(disableAudioMuteChange));
        });
    conference.on(
        JitsiConferenceEvents.VIDEO_UNMUTE_PERMISSIONS_CHANGED,
        (disableVideoMuteChange: boolean) => {
            dispatch(setVideoUnmutePermissions(disableVideoMuteChange));
        });

    // Dispatches into features/base/tracks follow:

    conference.on(
        JitsiConferenceEvents.TRACK_ADDED,
        (t: any) => t && !t.isLocal() && dispatch(trackAdded(t)));
    conference.on(
        JitsiConferenceEvents.TRACK_REMOVED,
        (t: any) => t && !t.isLocal() && dispatch(trackRemoved(t)));

    conference.on(
        JitsiConferenceEvents.TRACK_MUTE_CHANGED,
        (track: any, participantThatMutedUs: any) => {
            if (participantThatMutedUs) {
                dispatch(participantMutedUs(participantThatMutedUs, track));
            }
        });

    conference.on(JitsiConferenceEvents.TRACK_UNMUTE_REJECTED, (track: any) => dispatch(destroyLocalTracks(track)));

    // Dispatches into features/base/participants follow:
    conference.on(
        JitsiConferenceEvents.DISPLAY_NAME_CHANGED,
        (id: string, displayName: string) => dispatch(participantUpdated({
            conference,
            id,
            name: getNormalizedDisplayName(displayName)
        })));

    conference.on(
        JitsiConferenceEvents.SILENT_STATUS_CHANGED,
        (id: string, isSilent: boolean) => dispatch(participantUpdated({
            conference,
            id,
            isSilent
        })));

    conference.on(
        JitsiConferenceEvents.DOMINANT_SPEAKER_CHANGED,
        (dominant: string, previous: string[], silence: boolean | string) => {
            dispatch(dominantSpeakerChanged(dominant, previous, Boolean(silence), conference));
        });

    conference.on(
        JitsiConferenceEvents.ENDPOINT_MESSAGE_RECEIVED,
        (participant: Object, json: Object) => dispatch(endpointMessageReceived(participant, json)));

    conference.on(
        JitsiConferenceEvents.NON_PARTICIPANT_MESSAGE_RECEIVED,
        (id: string, json: Object) => dispatch(nonParticipantMessageReceived(id, json)));

    conference.on(
        JitsiConferenceEvents.USER_JOINED,
        (_id: string, user: any) => commonUserJoinedHandling({ dispatch }, conference, user));
    conference.on(
        JitsiConferenceEvents.USER_LEFT,
        (_id: string, user: any) => commonUserLeftHandling({ dispatch }, conference, user));
    conference.on(
        JitsiConferenceEvents.USER_ROLE_CHANGED,
        (id: string, role: string) => dispatch(participantRoleChanged(id, role)));
    conference.on(
        JitsiConferenceEvents.USER_STATUS_CHANGED,
        (id: string, presence: string) => dispatch(participantPresenceChanged(id, presence)));

    conference.on(
        JitsiE2ePingEvents.E2E_RTT_CHANGED,
        (participant: Object, rtt: number) => dispatch(e2eRttChanged(participant, rtt)));

    conference.on(
        JitsiConferenceEvents.BOT_TYPE_CHANGED,
        (id: string, botType: string) => dispatch(participantUpdated({
            conference,
            id,
            botType
        })));

    conference.on(
        JitsiConferenceEvents.TRANSCRIPTION_STATUS_CHANGED,
        (status: string, id: string, abruptly: boolean) => {
            if (status === JitsiMeetJS.constants.transcriptionStatus.ON) {
                dispatch(transcriberJoined(id));
            } else if (status === JitsiMeetJS.constants.transcriptionStatus.OFF) {
                dispatch(transcriberLeft(id, abruptly));
            }
        });

    conference.addCommandListener(
        AVATAR_URL_COMMAND,
        (data: { value: string; }, id: string) => {
            const participant = getParticipantByIdOrUndefined(state, id);

            // if already set from presence(jwt), skip the command processing
            if (!participant?.avatarURL) {
                return dispatch(participantUpdated({
                    conference,
                    id,
                    avatarURL: data.value
                }));
            }
        });
    conference.addCommandListener(
        EMAIL_COMMAND,
        (data: { value: string; }, id: string) => dispatch(participantUpdated({
            conference,
            id,
            email: data.value
        })));
}

/**
 * Action for updating the conference metadata.
 *
 * @param {IConferenceMetadata} metadata - The metadata object.
 * @returns {{
 *    type: UPDATE_CONFERENCE_METADATA,
 *    metadata: IConferenceMetadata
 * }}
 */
export function updateConferenceMetadata(metadata: IConferenceMetadata | null) {
    return {
        type: UPDATE_CONFERENCE_METADATA,
        metadata
    };
}

/**
 * Create an action for when the end-to-end RTT against a specific remote participant has changed.
 *
 * @param {Object} participant - The participant against which the rtt is measured.
 * @param {number} rtt - The rtt.
 * @returns {{
 *     type: E2E_RTT_CHANGED,
 *     e2eRtt: {
 *         participant: Object,
 *         rtt: number
 *     }
 * }}
 */
export function e2eRttChanged(participant: Object, rtt: number) {
    return {
        type: E2E_RTT_CHANGED,
        e2eRtt: {
            rtt,
            participant
        }
    };
}

/**
 * Updates the current known state of server-side authentication.
 *
 * @param {boolean} authEnabled - Whether or not server authentication is
 * enabled.
 * @param {string} authLogin - The current name of the logged in user, if any.
 * @returns {{
 *     type: AUTH_STATUS_CHANGED,
 *     authEnabled: boolean,
 *     authLogin: string
 * }}
 */
export function authStatusChanged(authEnabled: boolean, authLogin: string) {
    return {
        type: AUTH_STATUS_CHANGED,
        authEnabled,
        authLogin
    };
}

/**
 * Signals that a specific conference has failed.
 *
 * @param {JitsiConference} conference - The JitsiConference that has failed.
 * @param {string} error - The error describing/detailing the cause of the
 * failure.
 * @param {any} params - Rest of the params that we receive together with the event.
 * @returns {{
 *     type: CONFERENCE_FAILED,
 *     conference: JitsiConference,
 *     error: Error
 * }}
 * @public
 */
export function conferenceFailed(conference: IJitsiConference, error: string, ...params: any) {
    return {
        type: CONFERENCE_FAILED,
        conference,

        // Make the error resemble an Error instance (to the extent that
        // jitsi-meet needs it).
        error: {
            name: error,
            params,
            recoverable: undefined
        }
    };
}

/**
 * Signals that a specific conference has been joined.
 *
 * @param {JitsiConference} conference - The JitsiConference instance which was
 * joined by the local participant.
 * @returns {{
 *     type: CONFERENCE_JOINED,
 *     conference: JitsiConference
 * }}
 */
export function conferenceJoined(conference: IJitsiConference) {
    return {
        type: CONFERENCE_JOINED,
        conference
    };
}

/**
 * Signals that a specific conference join is in progress.
 *
 * @param {JitsiConference} conference - The JitsiConference instance for which join by the local participant
 * is in progress.
 * @returns {{
 *     type: CONFERENCE_JOIN_IN_PROGRESS,
 *     conference: JitsiConference
 * }}
 */
export function conferenceJoinInProgress(conference: IJitsiConference) {
    return {
        type: CONFERENCE_JOIN_IN_PROGRESS,
        conference
    };
}

/**
 * Signals that a specific conference has been left.
 *
 * @param {JitsiConference} conference - The JitsiConference instance which was
 * left by the local participant.
 * @returns {{
 *     type: CONFERENCE_LEFT,
 *     conference: JitsiConference
 * }}
 */
export function conferenceLeft(conference?: IJitsiConference) {
    return {
        type: CONFERENCE_LEFT,
        conference
    };
}

/**
 * Signals that the conference subject has been changed.
 *
 * @param {string} subject - The new subject.
 * @returns {{
 *     type: CONFERENCE_SUBJECT_CHANGED,
 *     subject: string
 * }}
 */
export function conferenceSubjectChanged(subject: string) {
    return {
        type: CONFERENCE_SUBJECT_CHANGED,
        subject
    };
}

/**
* Signals that the conference timestamp has been changed.
*
* @param {number} conferenceTimestamp - The UTC timestamp.
* @returns {{
*       type: CONFERENCE_TIMESTAMP_CHANGED,
*       conferenceTimestamp
* }}
*/
export function conferenceTimestampChanged(conferenceTimestamp: number) {
    return {
        type: CONFERENCE_TIMESTAMP_CHANGED,
        conferenceTimestamp
    };
}

/**
* Signals that the unique identifier for conference has been set.
*
* @param {JitsiConference} conference - The JitsiConference instance, where the uuid has been set.
* @returns {{
*   type: CONFERENCE_UNIQUE_ID_SET,
*   conference: JitsiConference,
* }}
*/
export function conferenceUniqueIdSet(conference: IJitsiConference) {
    return {
        type: CONFERENCE_UNIQUE_ID_SET,
        conference
    };
}

/**
 * Adds any existing local tracks to a specific conference before the conference
 * is joined. Then signals the intention of the application to have the local
 * participant join the specified conference.
 *
 * @param {JitsiConference} conference - The {@code JitsiConference} instance
 * the local participant will (try to) join.
 * @returns {Function}
 */
export function _conferenceWillJoin(conference: IJitsiConference) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const localTracks
            = getLocalTracks(state['features/base/tracks'])
                .map(t => t.jitsiTrack);

        if (localTracks.length && !iAmVisitor(state)) {
            _addLocalTracksToConference(conference, localTracks);
        }

        dispatch(conferenceWillJoin(conference));
    };
}

/**
 * Signals the intention of the application to have a conference initialized.
 *
 * @returns {{
 *     type: CONFERENCE_WILL_INIT
 * }}
 */
export function conferenceWillInit() {
    return {
        type: CONFERENCE_WILL_INIT
    };
}

/**
 * Signals the intention of the application to have the local participant
 * join the specified conference.
 *
 * @param {JitsiConference} conference - The {@code JitsiConference} instance
 * the local participant will (try to) join.
 * @returns {{
 *     type: CONFERENCE_WILL_JOIN,
 *     conference: JitsiConference
 * }}
 */
export function conferenceWillJoin(conference?: IJitsiConference) {
    return {
        type: CONFERENCE_WILL_JOIN,
        conference
    };
}

/**
 * Signals the intention of the application to have the local participant leave
 * a specific conference. Similar in fashion to CONFERENCE_LEFT. Contrary to it
 * though, it's not guaranteed because CONFERENCE_LEFT may be triggered by
 * lib-jitsi-meet and not the application.
 *
 * @param {JitsiConference} conference - The JitsiConference instance which will
 * be left by the local participant.
 * @param {boolean} isRedirect - Indicates if the action has been dispatched as part of visitor promotion.
 * @returns {{
 *     type: CONFERENCE_LEFT,
 *     conference: JitsiConference,
 *     isRedirect: boolean
 * }}
 */
export function conferenceWillLeave(conference?: IJitsiConference, isRedirect?: boolean) {
    return {
        type: CONFERENCE_WILL_LEAVE,
        conference,
        isRedirect
    };
}

/**
 * Initializes a new conference.
 *
 * @param {string} overrideRoom - Override the room to join, instead of taking it
 * from Redux.
 * @returns {Function}
 */
export function createConference(overrideRoom?: string | String) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const { connection, locationURL } = state['features/base/connection'];

        if (!connection) {
            throw new Error('Cannot create a conference without a connection!');
        }

        const { password, room } = state['features/base/conference'];

        if (!room) {
            throw new Error('Cannot join a conference without a room name!');
        }

        // XXX: revisit this.
        // Hide the custom domain in the room name.
        const tmp: any = overrideRoom || room;
        let _room: any = getBackendSafeRoomName(tmp);

        if (tmp.domain) {
            // eslint-disable-next-line no-new-wrappers
            _room = new String(tmp);
            _room.domain = tmp.domain;
        }

        const conference = connection.initJitsiConference(_room, getConferenceOptions(state));

        // @ts-ignore
        connection[JITSI_CONNECTION_CONFERENCE_KEY] = conference;

        conference[JITSI_CONFERENCE_URL_KEY] = locationURL;

        dispatch(_conferenceWillJoin(conference));

        _addConferenceListeners(conference, dispatch, state);

        sendLocalParticipant(state, conference);

        const replaceParticipant = getReplaceParticipant(state);

        conference.join(password, replaceParticipant);
    };
}

/**
 * Will try to join the conference again in case it failed earlier with
 * {@link JitsiConferenceErrors.AUTHENTICATION_REQUIRED}. It means that Jicofo
 * did not allow to create new room from anonymous domain, but it can be tried
 * again later in case authenticated user created it in the meantime.
 *
 * @returns {Function}
 */
export function checkIfCanJoin() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const { authRequired, password }
            = getState()['features/base/conference'];

        const replaceParticipant = getReplaceParticipant(getState());

        authRequired && dispatch(_conferenceWillJoin(authRequired));
        authRequired?.join(password, replaceParticipant);
    };
}

/**
 * Signals the data channel with the bridge has successfully opened.
 *
 * @returns {{
 *     type: DATA_CHANNEL_OPENED
 * }}
 */
export function dataChannelOpened() {
    return {
        type: DATA_CHANNEL_OPENED
    };
}

/**
 * Signals the data channel with the bridge was abruptly closed.
 *
 * @param {number} code - Close code.
 * @param {string} reason - Close reason.
 *
 * @returns {{
 *     type: DATA_CHANNEL_CLOSED,
 *     code: number,
 *     reason: string
 * }}
 */
export function dataChannelClosed(code: number, reason: string) {
    return {
        type: DATA_CHANNEL_CLOSED,
        code,
        reason
    };
}

/**
 * Signals that a participant sent an endpoint message on the data channel.
 *
 * @param {Object} participant - The participant details sending the message.
 * @param {Object} data - The data carried by the endpoint message.
 * @returns {{
*      type: ENDPOINT_MESSAGE_RECEIVED,
*      participant: Object,
*      data: Object
* }}
*/
export function endpointMessageReceived(participant: Object, data: Object) {
    return {
        type: ENDPOINT_MESSAGE_RECEIVED,
        participant,
        data
    };
}

/**
 * Action to end a conference for all participants.
 *
 * @returns {Function}
 */
export function endConference() {
    return async (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const { conference } = getConferenceState(toState(getState));

        conference?.end();
    };
}

/**
 * Signals that we've been kicked out of the conference.
 *
 * @param {JitsiConference} conference - The {@link JitsiConference} instance
 * for which the event is being signaled.
 * @param {JitsiParticipant} participant - The {@link JitsiParticipant}
 * instance which initiated the kick event.
 * @returns {{
 *     type: KICKED_OUT,
 *     conference: JitsiConference,
 *     participant: JitsiParticipant
 * }}
 */
export function kickedOut(conference: IJitsiConference, participant: Object) {
    return {
        type: KICKED_OUT,
        conference,
        participant
    };
}


/**
 * Action to leave a conference.
 *
 * @returns {Function}
 */
export function leaveConference() {
    return async (dispatch: IStore['dispatch']) => dispatch(hangup(true));
}

/**
 * Signals that the lock state of a specific JitsiConference changed.
 *
 * @param {JitsiConference} conference - The JitsiConference which had its lock
 * state changed.
 * @param {boolean} locked - If the specified conference became locked, true;
 * otherwise, false.
 * @returns {{
 *     type: LOCK_STATE_CHANGED,
 *     conference: JitsiConference,
 *     locked: boolean
 * }}
 */
export function lockStateChanged(conference: IJitsiConference, locked: boolean) {
    return {
        type: LOCK_STATE_CHANGED,
        conference,
        locked
    };
}

/**
 * Signals that a non participant endpoint message has been received.
 *
 * @param {string} id - The resource id of the sender.
 * @param {Object} json - The json carried by the endpoint message.
 * @returns {{
 *      type: NON_PARTICIPANT_MESSAGE_RECEIVED,
 *      id: Object,
 *      json: Object
 * }}
 */
export function nonParticipantMessageReceived(id: string, json: Object) {
    return {
        type: NON_PARTICIPANT_MESSAGE_RECEIVED,
        id,
        json
    };
}

/**
 * Updates the known state of start muted policies.
 *
 * @param {boolean} audioMuted - Whether or not members will join the conference
 * as audio muted.
 * @param {boolean} videoMuted - Whether or not members will join the conference
 * as video muted.
 * @returns {{
 *     type: SET_START_MUTED_POLICY,
 *     startAudioMutedPolicy: boolean,
 *     startVideoMutedPolicy: boolean
 * }}
 */
export function onStartMutedPolicyChanged(
        audioMuted: boolean, videoMuted: boolean) {
    return {
        type: SET_START_MUTED_POLICY,
        startAudioMutedPolicy: audioMuted,
        startVideoMutedPolicy: videoMuted
    };
}

/**
 * Sets whether or not peer2peer is currently enabled.
 *
 * @param {boolean} p2p - Whether or not peer2peer is currently active.
 * @returns {{
 *     type: P2P_STATUS_CHANGED,
 *     p2p: boolean
 * }}
 */
export function p2pStatusChanged(p2p: boolean) {
    return {
        type: P2P_STATUS_CHANGED,
        p2p
    };
}

/**
 * Signals to play touch tones.
 *
 * @param {string} tones - The tones to play.
 * @param {number} [duration] - How long to play each tone.
 * @param {number} [pause] - How long to pause between each tone.
 * @returns {{
 *     type: SEND_TONES,
 *     tones: string,
 *     duration: number,
 *     pause: number
 * }}
 */
export function sendTones(tones: string, duration: number, pause: number) {
    return {
        type: SEND_TONES,
        tones,
        duration,
        pause
    };
}

/**
 * Enables or disables the Follow Me feature.
 *
 * @param {boolean} enabled - Whether or not Follow Me should be enabled.
 * @returns {{
 *     type: SET_FOLLOW_ME,
 *     enabled: boolean
 * }}
 */
export function setFollowMe(enabled: boolean) {
    return {
        type: SET_FOLLOW_ME,
        enabled
    };
}

/**
 * Enables or disables the Follow Me feature used only for the recorder.
 *
 * @param {boolean} enabled - Whether Follow Me should be enabled and used only by the recorder.
 * @returns {{
 *     type: SET_FOLLOW_ME_RECORDER,
 *     enabled: boolean
 * }}
 */
export function setFollowMeRecorder(enabled: boolean) {
    return {
        type: SET_FOLLOW_ME_RECORDER,
        enabled
    };
}

/**
 * Enables or disables the Mute reaction sounds feature.
 *
 * @param {boolean} muted - Whether or not reaction sounds should be muted for all participants.
 * @param {boolean} updateBackend - Whether or not the moderator should notify all participants for the new setting.
 * @returns {{
 *     type: SET_START_REACTIONS_MUTED,
 *     muted: boolean
 * }}
 */
export function setStartReactionsMuted(muted: boolean, updateBackend = false) {
    return {
        type: SET_START_REACTIONS_MUTED,
        muted,
        updateBackend
    };
}

/**
 * Sets the password to join or lock a specific JitsiConference.
 *
 * @param {JitsiConference} conference - The JitsiConference which requires a
 * password to join or is to be locked with the specified password.
 * @param {Function} method - The JitsiConference method of password protection
 * such as join or lock.
 * @param {string} password - The password with which the specified conference
 * is to be joined or locked.
 * @returns {Function}
 */
export function setPassword(
        conference: IJitsiConference | undefined,
        method: Function | undefined,
        password?: string) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        if (!conference) {
            return Promise.reject();
        }
        switch (method) {
        case conference.join: {
            let state = getState()['features/base/conference'];

            dispatch({
                type: SET_PASSWORD,
                conference,
                method,
                password
            });

            // Join the conference with the newly-set password.

            // Make sure that the action did set the password.
            state = getState()['features/base/conference'];
            if (state.password === password

                    // Make sure that the application still wants the
                    // conference joined.
                    && !state.conference) {
                method.call(conference, password);
            }
            break;
        }

        case conference.lock: {
            const state = getState()['features/base/conference'];

            if (state.conference === conference) {
                return (
                    method.call(conference, password)
                        .then(() => dispatch({
                            type: SET_PASSWORD,
                            conference,
                            method,
                            password
                        }))
                        .catch((error: Error) => dispatch({
                            type: SET_PASSWORD_FAILED,
                            error
                        }))
                );
            }

            return Promise.reject();
        }
        }
    };
}

/**
 * Sets the obfuscated room name of the conference to be joined.
 *
 * @param {(string)} obfuscatedRoom - Obfuscated room name.
 * @param {(string)} obfuscatedRoomSource - The room name that was obfuscated.
 * @returns {{
 *     type: SET_OBFUSCATED_ROOM,
 *     room: string
 * }}
 */
export function setObfuscatedRoom(obfuscatedRoom: string, obfuscatedRoomSource: string) {
    return {
        type: SET_OBFUSCATED_ROOM,
        obfuscatedRoom,
        obfuscatedRoomSource
    };
}

/**
 * Sets (the name of) the room of the conference to be joined.
 *
 * @param {(string|undefined)} room - The name of the room of the conference to
 * be joined.
 * @returns {{
 *     type: SET_ROOM,
 *     room: string
 * }}
 */
export function setRoom(room?: string) {
    return {
        type: SET_ROOM,
        room
    };
}

/**
 * Sets whether or not members should join audio and/or video muted.
 *
 * @param {boolean} startAudioMuted - Whether or not members will join the
 * conference as audio muted.
 * @param {boolean} startVideoMuted - Whether or not members will join the
 * conference as video muted.
 * @returns {Function}
 */
export function setStartMutedPolicy(
        startAudioMuted: boolean, startVideoMuted: boolean) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const conference = getCurrentConference(getState());

        conference?.setStartMutedPolicy({
            audio: startAudioMuted,
            video: startVideoMuted
        });

        dispatch(
            onStartMutedPolicyChanged(startAudioMuted, startVideoMuted));
    };
}

/**
 * Sets the conference subject.
 *
 * @param {string} subject - The new subject.
 * @returns {void}
 */
export function setSubject(subject: string) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const { conference } = getState()['features/base/conference'];

        if (conference) {
            conference.setSubject(subject);
        } else {
            dispatch({
                type: SET_PENDING_SUBJECT_CHANGE,
                subject
            });
        }
    };
}

/**
 * Sets the conference local subject.
 *
 * @param {string} localSubject - The new local subject.
 * @returns {{
 *     type: CONFERENCE_LOCAL_SUBJECT_CHANGED,
 *     localSubject: string
 * }}
 */
export function setLocalSubject(localSubject: string) {
    return {
        type: CONFERENCE_LOCAL_SUBJECT_CHANGED,
        localSubject
    };
}


/**
 * Sets the assumed bandwidth bps.
 *
 * @param {number} assumedBandwidthBps - The new assumed bandwidth.
 * @returns {{
*     type: SET_ASSUMED_BANDWIDTH_BPS,
*     assumedBandwidthBps: number
* }}
*/
export function setAssumedBandwidthBps(assumedBandwidthBps: number) {
    return {
        type: SET_ASSUMED_BANDWIDTH_BPS,
        assumedBandwidthBps
    };
}

/**
 * Redirects to a new visitor node.
 *
 * @param {string | undefined} vnode - The vnode to use or undefined if moving back to the main room.
 * @param {string} focusJid - The focus jid to use.
 * @param {string} username - The username to use.
 * @returns {void}
 */
export function redirect(vnode: string, focusJid: string, username: string) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const newConfig = getVisitorOptions(getState, vnode, focusJid, username);

        if (!newConfig) {
            logger.warn('Not redirected missing params');

            return;
        }

        dispatch(overwriteConfig(newConfig));

        dispatch(disconnect(true))
            .then(() => {
                dispatch(setIAmVisitor(Boolean(vnode)));

                // we do not clear local tracks on error, so we need to manually clear them
                return dispatch(destroyLocalTracks());
            })
            .then(() => {
                dispatch(conferenceWillInit());
                logger.info(`Dispatching connect from redirect (visitor = ${Boolean(vnode)}).`);

                return dispatch(connect());
            })
            .then(() => {
                const media: Array<MediaType> = [];

                if (!vnode) {
                    const state = getState();
                    const { enableMediaOnPromote = {} } = state['features/base/config'].visitors ?? {};
                    const { audio = false, video = false } = enableMediaOnPromote;

                    if (audio) {
                        const { available, muted, unmuteBlocked } = state['features/base/media'].audio;
                        const { startSilent } = state['features/base/config'];

                        // do not unmute the user if he was muted before (on the prejoin, the config
                        // or URL param, etc.)
                        if (!unmuteBlocked && !muted && !startSilent && available) {
                            media.push(MEDIA_TYPE.AUDIO);
                        }
                    }

                    if (video) {
                        const { muted, unmuteBlocked } = state['features/base/media'].video;

                        // do not unmute the user if he was muted before (on the prejoin, the config, URL param or
                        // audo only, etc)
                        if (!unmuteBlocked && !muted && hasAvailableDevices(state, 'videoInput')) {
                            media.push(MEDIA_TYPE.VIDEO);
                        }
                    }
                }

                dispatch(setupVisitorStartupMedia(media));
            });
    };
}



################################################################################

## File: .\jitsi-meet\react\features\base\conference\actions.native.ts

import { IStore } from '../../app/types';
import { setAudioMuted, setVideoMuted } from '../media/actions';
import { MEDIA_TYPE, MediaType, VIDEO_MUTISM_AUTHORITY } from '../media/constants';

export * from './actions.any';

/**
 * Starts audio and/or video for the visitor.
 *
 * @param {Array<MediaType>} mediaTypes - The media types that need to be started.
 * @returns {Function}
 */
export function setupVisitorStartupMedia(mediaTypes: Array<MediaType>) {
    return (dispatch: IStore['dispatch']) => {
        if (!mediaTypes || !Array.isArray(mediaTypes)) {
            return;
        }

        mediaTypes.forEach(mediaType => {
            switch (mediaType) {
            case MEDIA_TYPE.AUDIO:
                dispatch(setAudioMuted(false, true));
                break;
            case MEDIA_TYPE.VIDEO:
                dispatch(setVideoMuted(false, VIDEO_MUTISM_AUTHORITY.USER, true));
            }
        });
    };
}


################################################################################

## File: .\jitsi-meet\react\features\base\conference\actions.web.ts

import { IStore } from '../../app/types';
import { gumPending } from '../media/actions';
import { MEDIA_TYPE, MediaType } from '../media/constants';
import { IGUMPendingState } from '../media/types';
import { createAndAddInitialAVTracks } from '../tracks/actions.web';

export * from './actions.any';

/**
 * Starts audio and/or video for the visitor.
 *
 * @param {Array<MediaType>} media - The media types that need to be started.
 * @returns {Function}
 */
export function setupVisitorStartupMedia(media: Array<MediaType>) {
    return (dispatch: IStore['dispatch']) => {
        // Clear the gum pending state in case we have set it to pending since we are starting the
        // conference without tracks.
        dispatch(gumPending([ MEDIA_TYPE.AUDIO, MEDIA_TYPE.VIDEO ], IGUMPendingState.NONE));

        if (media && Array.isArray(media) && media.length > 0) {
            dispatch(createAndAddInitialAVTracks(media));
        }
    };
}


################################################################################

## File: .\jitsi-meet\react\features\base\conference\actionTypes.ts

/**
 * The type of (redux) action which signals that server authentication has
 * becoming available or unavailable or logged in user has changed.
 *
 * {
 *     type: AUTH_STATUS_CHANGED,
 *     authEnabled: boolean,
 *     authLogin: string
 * }
 */
export const AUTH_STATUS_CHANGED = 'AUTH_STATUS_CHANGED';

/**
 * The type of (redux) action which signals that a specific conference failed.
 *
 * {
 *     type: CONFERENCE_FAILED,
 *     conference: JitsiConference,
 *     error: Error
 * }
 */
export const CONFERENCE_FAILED = 'CONFERENCE_FAILED';

/**
 * The type of (redux) action which signals that a specific conference was
 * joined.
 *
 * {
 *     type: CONFERENCE_JOINED,
 *     conference: JitsiConference
 * }
 */
export const CONFERENCE_JOINED = 'CONFERENCE_JOINED';

/**
 * The type of (redux) action which signals that a specific conference joining is in progress.
 * A CONFERENCE_JOINED is guaranteed to follow.
 *
 * {
 *     type: CONFERENCE_JOIN_IN_PROGRESS,
 *     conference: JitsiConference
 * }
 */
export const CONFERENCE_JOIN_IN_PROGRESS = 'CONFERENCE_JOIN_IN_PROGRESS';

/**
 * The type of (redux) action which signals that a specific conference was left.
 *
 * {
 *     type: CONFERENCE_LEFT,
 *     conference: JitsiConference
 * }
 */
export const CONFERENCE_LEFT = 'CONFERENCE_LEFT';

/**
 * The type of (redux) action which signals that the conference is out of focus.
 * For example, if the user navigates to the Chat screen.
 *
 * {
 *      type: CONFERENCE_BLURRED,
 * }
 */
export const CONFERENCE_BLURRED = 'CONFERENCE_BLURRED';

/**
 * The type of (redux) action which signals that the conference is in focus.
 *
 * {
 *      type: CONFERENCE_FOCUSED,
 * }
 */
export const CONFERENCE_FOCUSED = 'CONFERENCE_FOCUSED';

/**
 * The type of (redux) action, which indicates conference local subject changes.
 *
 * {
 *     type: CONFERENCE_LOCAL_SUBJECT_CHANGED
 *     subject: string
 * }
 */
 export const CONFERENCE_LOCAL_SUBJECT_CHANGED = 'CONFERENCE_LOCAL_SUBJECT_CHANGED';

 /**
 * The type of (redux) action, which indicates conference subject changes.
 *
 * {
 *     type: CONFERENCE_SUBJECT_CHANGED
 *     subject: string
 * }
 */
export const CONFERENCE_SUBJECT_CHANGED = 'CONFERENCE_SUBJECT_CHANGED';

/**
* The type of (redux) action, which indicates conference UTC timestamp changes.
*
* {
*      type: CONFERENCE_TIMESTAMP_CHANGED
*      timestamp: number
* }
*/
export const CONFERENCE_TIMESTAMP_CHANGED = 'CONFERENCE_TIMESTAMP_CHANGED';

/**
 * The type of (redux) action which signals that an uuid for a conference has been set.
 *
 * {
 *     type: CONFERENCE_UNIQUE_ID_SET,
 *     conference: JitsiConference
 * }
 */
export const CONFERENCE_UNIQUE_ID_SET = 'CONFERENCE_UNIQUE_ID_SET';

/**
 * The type of (redux) action which signals that the end-to-end RTT against a specific remote participant has changed.
 *
 * {
 *     type: E2E_RTT_CHANGED,
 *     e2eRtt: {
 *         rtt: number,
 *         participant: Object,
 *     }
 * }
 */
export const E2E_RTT_CHANGED = 'E2E_RTT_CHANGED'

/**
 * The type of (redux) action which signals that a conference will be initialized.
 *
 * {
 *     type: CONFERENCE_WILL_INIT
 * }
 */
export const CONFERENCE_WILL_INIT = 'CONFERENCE_WILL_INIT';

/**
 * The type of (redux) action which signals that a specific conference will be
 * joined.
 *
 * {
 *     type: CONFERENCE_WILL_JOIN,
 *     conference: JitsiConference
 * }
 */
export const CONFERENCE_WILL_JOIN = 'CONFERENCE_WILL_JOIN';

/**
 * The type of (redux) action which signals that a specific conference will be
 * left.
 *
 * {
 *     type: CONFERENCE_WILL_LEAVE,
 *     conference: JitsiConference
 * }
 */
export const CONFERENCE_WILL_LEAVE = 'CONFERENCE_WILL_LEAVE';

/**
 * The type of (redux) action which signals that the data channel with the
 * bridge has been established.
 *
 * {
 *     type: DATA_CHANNEL_OPENED
 * }
 */
export const DATA_CHANNEL_OPENED = 'DATA_CHANNEL_OPENED';

/**
 * The type of (redux) action which signals that the data channel with the
 * bridge has been closed.
 *
 * {
 *     type: DATA_CHANNEL_CLOSED,
 *     code: number,
 *     reason: string
 * }
 */
export const DATA_CHANNEL_CLOSED = 'DATA_CHANNEL_CLOSED';

/**
 * The type of (redux) action which indicates that an endpoint message
 * sent by another participant to the data channel is received.
 *
 * {
 *     type: ENDPOINT_MESSAGE_RECEIVED,
 *     participant: Object,
 *     data: Object
 * }
 */
export const ENDPOINT_MESSAGE_RECEIVED = 'ENDPOINT_MESSAGE_RECEIVED';

/**
 * The type of action which signals that the user has been kicked out from
 * the conference.
 *
 * {
 *     type: KICKED_OUT,
 *     conference: JitsiConference
 * }
 */
export const KICKED_OUT = 'KICKED_OUT';

/**
 * The type of (redux) action which signals that the lock state of a specific
 * {@code JitsiConference} changed.
 *
 * {
 *     type: LOCK_STATE_CHANGED,
 *     conference: JitsiConference,
 *     locked: boolean
 * }
 */
export const LOCK_STATE_CHANGED = 'LOCK_STATE_CHANGED';

/**
 * The type of (redux) action which signals that a system (non-participant) message has been received.
 *
 * {
 *     type: NON_PARTICIPANT_MESSAGE_RECEIVED,
 *     id: String,
 *     json: Object
 * }
 */
export const NON_PARTICIPANT_MESSAGE_RECEIVED = 'NON_PARTICIPANT_MESSAGE_RECEIVED';

/**
 * The type of (redux) action which sets the peer2peer flag for the current
 * conference.
 *
 * {
 *     type: P2P_STATUS_CHANGED,
 *     p2p: boolean
 * }
 */
export const P2P_STATUS_CHANGED = 'P2P_STATUS_CHANGED';

/**
 * The type of (redux) action which signals to play specified touch tones.
 *
 * {
 *     type: SEND_TONES,
 *     tones: string,
 *     duration: number,
 *     pause: number
 * }
 */
export const SEND_TONES = 'SEND_TONES';

/**
 * The type of (redux) action which updates the current known status of the
 * Follow Me feature.
 *
 * {
 *     type: SET_FOLLOW_ME,
 *     enabled: boolean
 * }
 */
export const SET_FOLLOW_ME = 'SET_FOLLOW_ME';

/**
 * The type of (redux) action which updates the current known status of the
 * Follow Me feature that is used only by the recorder.
 *
 * {
 *     type: SET_FOLLOW_ME_RECORDER,
 *     enabled: boolean
 * }
 */
export const SET_FOLLOW_ME_RECORDER = 'SET_FOLLOW_ME_RECORDER';

/**
 * The type of (redux) action which sets the obfuscated room name.
 *
 * {
 *     type: SET_OBFUSCATED_ROOM,
 *     obfuscatedRoom: string
 * }
 */
 export const SET_OBFUSCATED_ROOM = 'SET_OBFUSCATED_ROOM';

/**
 * The type of (redux) action which updates the current known status of the
 * Mute Reactions Sound feature.
 *
 * {
 *     type: SET_START_REACTIONS_MUTED,
 *     enabled: boolean
 * }
 */
export const SET_START_REACTIONS_MUTED = 'SET_START_REACTIONS_MUTED';

/**
 * The type of (redux) action which sets the password to join or lock a specific
 * {@code JitsiConference}.
 *
 * {
 *     type: SET_PASSWORD,
 *     conference: JitsiConference,
 *     method: Function
 *     password: string
 * }
 */
export const SET_PASSWORD = 'SET_PASSWORD';

/**
 * The type of (redux) action which signals that setting a password on a
 * {@code JitsiConference} failed (with an error).
 *
 * {
 *     type: SET_PASSWORD_FAILED,
 *     error: string
 * }
 */
export const SET_PASSWORD_FAILED = 'SET_PASSWORD_FAILED';

/**
 * The type of (redux) action which signals for pending subject changes.
 *
 * {
 *     type: SET_PENDING_SUBJECT_CHANGE,
 *     subject: string
 * }
 */
export const SET_PENDING_SUBJECT_CHANGE = 'SET_PENDING_SUBJECT_CHANGE';

/**
 * The type of (redux) action which sets the name of the room of the
 * conference to be joined.
 *
 * {
 *     type: SET_ROOM,
 *     room: string
 * }
 */
export const SET_ROOM = 'SET_ROOM';

/**
 * The type of (redux) action which updates the current known status of the
 * moderator features for starting participants as audio or video muted.
 *
 * {
 *     type: SET_START_MUTED_POLICY,
 *     startAudioMutedPolicy: boolean,
 *     startVideoMutedPolicy: boolean
 * }
 */
export const SET_START_MUTED_POLICY = 'SET_START_MUTED_POLICY';

/**
 * The type of (redux) action which updates the assumed bandwidth bps.
 *
 * {
 *      type: SET_ASSUMED_BANDWIDTH_BPS,
 *      assumedBandwidthBps: number
 * }
 */
export const SET_ASSUMED_BANDWIDTH_BPS = 'SET_ASSUMED_BANDWIDTH_BPS';

/**
 * The type of (redux) action which updated the conference metadata.
 *
 * {
 *     type: UPDATE_CONFERENCE_METADATA,
 *     metadata: Object
 * }
 */
export const UPDATE_CONFERENCE_METADATA = 'UPDATE_CONFERENCE_METADATA';


################################################################################

## File: .\jitsi-meet\react\features\base\conference\constants.ts

/**
 * The command type for updating a participant's avatar URL.
 *
 * @type {string}
 */
export const AVATAR_URL_COMMAND = 'avatar-url';

/**
 * The command type for updating a participant's email address.
 *
 * @type {string}
 */
export const EMAIL_COMMAND = 'email';

/**
 * The name of the {@code JitsiConference} property which identifies the URL of
 * the conference represented by the {@code JitsiConference} instance.
 *
 * TODO It was introduced in a moment of desperation. Jitsi Meet SDK for Android
 * and iOS needs to deliver events from the JavaScript side where they originate
 * to the Java and Objective-C sides, respectively, where they are to be
 * handled. The URL of the {@code JitsiConference} was chosen as the identifier
 * because the Java and Objective-C sides join by URL through their respective
 * loadURL methods. But features/base/connection's {@code locationURL} is not
 * guaranteed at the time of this writing to match the {@code JitsiConference}
 * instance when the events are to be fired. Patching {@code JitsiConference}
 * from the outside is not cool but it should suffice for now.
 */
export const JITSI_CONFERENCE_URL_KEY = Symbol('url');

export const TRIGGER_READY_TO_CLOSE_REASONS = {
    'dialog.sessTerminatedReason': 'The meeting has been terminated',
    'lobby.lobbyClosed': 'Lobby room closed.'
};

/**
 * Conference leave reasons.
 */
export const CONFERENCE_LEAVE_REASONS = {
    SWITCH_ROOM: 'switch_room',
    UNRECOVERABLE_ERROR: 'unrecoverable_error'
};


################################################################################

## File: .\jitsi-meet\react\features\base\conference\functions.ts

import { sha512_256 as sha512 } from 'js-sha512';
import { upperFirst, words } from 'lodash-es';

import { getName } from '../../app/functions';
import { IReduxState, IStore } from '../../app/types';
import { determineTranscriptionLanguage } from '../../transcribing/functions';
import { IStateful } from '../app/types';
import { JitsiTrackErrors } from '../lib-jitsi-meet';
import {
    participantJoined,
    participantLeft
} from '../participants/actions';
import { getLocalParticipant } from '../participants/functions';
import { toState } from '../redux/functions';
import {
    appendURLParam,
    getBackendSafePath,
    safeDecodeURIComponent
} from '../util/uri';

import { setObfuscatedRoom } from './actions';
import {
    AVATAR_URL_COMMAND,
    EMAIL_COMMAND,
    JITSI_CONFERENCE_URL_KEY
} from './constants';
import logger from './logger';
import { IJitsiConference } from './reducer';

/**
 * Returns root conference state.
 *
 * @param {IReduxState} state - Global state.
 * @returns {Object} Conference state.
 */
export const getConferenceState = (state: IReduxState) => state['features/base/conference'];

/**
 * Attach a set of local tracks to a conference.
 *
 * @param {JitsiConference} conference - Conference instance.
 * @param {JitsiLocalTrack[]} localTracks - List of local media tracks.
 * @protected
 * @returns {Promise}
 */
export function _addLocalTracksToConference(
        conference: IJitsiConference,
        localTracks: Array<Object>) {
    const conferenceLocalTracks = conference.getLocalTracks();
    const promises = [];

    for (const track of localTracks) {
        // XXX The library lib-jitsi-meet may be draconian, for example, when
        // adding one and the same video track multiple times.
        if (conferenceLocalTracks.indexOf(track) === -1) {
            promises.push(
                conference.addTrack(track).catch((err: Error) => {
                    _reportError(
                        'Failed to add local track to conference',
                        err);
                }));
        }
    }

    return Promise.all(promises);
}

/**
 * Logic shared between web and RN which processes the {@code USER_JOINED}
 * conference event and dispatches either {@link participantJoined} or
 * {@link hiddenParticipantJoined}.
 *
 * @param {Object} store - The redux store.
 * @param {JitsiMeetConference} conference - The conference for which the
 * {@code USER_JOINED} event is being processed.
 * @param {JitsiParticipant} user - The user who has just joined.
 * @returns {void}
 */
export function commonUserJoinedHandling(
        { dispatch }: { dispatch: IStore['dispatch']; },
        conference: IJitsiConference,
        user: any) {
    const id = user.getId();
    const displayName = user.getDisplayName();

    if (!user.isHidden()) {
        const isReplacing = user?.isReplacing();

        // the identity and avatar come from jwt and never change in the presence
        dispatch(participantJoined({
            avatarURL: user.getIdentity()?.user?.avatar,
            botType: user.getBotType(),
            conference,
            id,
            name: displayName,
            presence: user.getStatus(),
            role: user.getRole(),
            isReplacing,
            sources: user.getSources()
        }));
    }
}

/**
 * Logic shared between web and RN which processes the {@code USER_LEFT}
 * conference event and dispatches either {@link participantLeft} or
 * {@link hiddenParticipantLeft}.
 *
 * @param {Object} store - The redux store.
 * @param {JitsiMeetConference} conference - The conference for which the
 * {@code USER_LEFT} event is being processed.
 * @param {JitsiParticipant} user - The user who has just left.
 * @returns {void}
 */
export function commonUserLeftHandling(
        { dispatch }: { dispatch: IStore['dispatch']; },
        conference: IJitsiConference,
        user: any) {
    const id = user.getId();

    if (!user.isHidden()) {
        const isReplaced = user.isReplaced?.();

        dispatch(participantLeft(id, conference, { isReplaced }));
    }
}

/**
 * Evaluates a specific predicate for each {@link JitsiConference} known to the
 * redux state features/base/conference while it returns {@code true}.
 *
 * @param {IStateful} stateful - The redux store, state, or
 * {@code getState} function.
 * @param {Function} predicate - The predicate to evaluate for each
 * {@code JitsiConference} know to the redux state features/base/conference
 * while it returns {@code true}.
 * @returns {boolean} If the specified {@code predicate} returned {@code true}
 * for all {@code JitsiConference} instances known to the redux state
 * features/base/conference.
 */
export function forEachConference(
        stateful: IStateful,
        predicate: (a: any, b: URL) => boolean) {
    const state = getConferenceState(toState(stateful));

    for (const v of Object.values(state)) {
        // Does the value of the base/conference's property look like a
        // JitsiConference?
        if (v && typeof v === 'object') {
            const url: URL = v[JITSI_CONFERENCE_URL_KEY];

            // XXX The Web version of Jitsi Meet does not utilize
            // JITSI_CONFERENCE_URL_KEY at the time of this writing. An
            // alternative is necessary then to recognize JitsiConference
            // instances and myUserId is as good as any other property.
            if ((url || typeof v.myUserId === 'function')
                    && !predicate(v, url)) {
                return false;
            }
        }
    }

    return true;
}

/**
 * Returns the display name of the conference.
 *
 * @param {IStateful} stateful - Reference that can be resolved to Redux
 * state with the {@code toState} function.
 * @returns {string}
 */
export function getConferenceName(stateful: IStateful): string {
    const state = toState(stateful);
    const { callee } = state['features/base/jwt'];
    const { callDisplayName } = state['features/base/config'];
    const { localSubject, pendingSubjectChange, room, subject } = getConferenceState(state);

    return (localSubject
        || pendingSubjectChange
        || subject
        || callDisplayName
        || callee?.name
        || (room && safeStartCase(safeDecodeURIComponent(room)))) ?? '';
}

/**
 * Returns the name of the conference formatted for the title.
 *
 * @param {IStateful} stateful - Reference that can be resolved to Redux state with the {@code toState}
 * function.
 * @returns {string} - The name of the conference formatted for the title.
 */
export function getConferenceNameForTitle(stateful: IStateful) {
    return safeStartCase(safeDecodeURIComponent(getConferenceState(toState(stateful)).room ?? ''));
}

/**
 * Returns an object aggregating the conference options.
 *
 * @param {IStateful} stateful - The redux store state.
 * @returns {Object} - Options object.
 */
export function getConferenceOptions(stateful: IStateful) {
    const state = toState(stateful);

    const config = state['features/base/config'];
    const { locationURL } = state['features/base/connection'];
    const { tenant } = state['features/base/jwt'];
    const { email, name: nick } = getLocalParticipant(state) ?? {};
    const options: any = { ...config };

    if (tenant) {
        options.siteID = tenant;
    }

    if (options.enableDisplayNameInStats && nick) {
        options.statisticsDisplayName = nick;
    }

    if (options.enableEmailInStats && email) {
        options.statisticsId = email;
    }

    if (locationURL) {
        options.confID = `${locationURL.host}${getBackendSafePath(locationURL.pathname)}`;
    }

    options.applicationName = getName();
    options.transcriptionLanguage = determineTranscriptionLanguage(options);

    // Disable analytics, if requested.
    if (options.disableThirdPartyRequests) {
        delete config.analytics?.scriptURLs;
        delete config.analytics?.amplitudeAPPKey;
        delete config.analytics?.googleAnalyticsTrackingId;
    }

    return options;
}

/**
 * Returns the restored conference options if anything is available to be restored or undefined.
 *
 * @param {IStateful} stateful - The redux store state.
 * @returns {Object?}
 */
export function restoreConferenceOptions(stateful: IStateful) {
    const config = toState(stateful)['features/base/config'];

    if (config.oldConfig) {
        return {
            hosts: {
                domain: config.oldConfig.hosts.domain,
                muc: config.oldConfig.hosts.muc
            },
            focusUserJid: config.oldConfig.focusUserJid,
            disableFocus: false,
            bosh: config.oldConfig.bosh,
            websocket: config.oldConfig.websocket,
            oldConfig: undefined
        };
    }

    // nothing to return
    return;
}

/**
 * Override the global config (that is, window.config) with XMPP configuration required to join as a visitor.
 *
 * @param {IStateful} stateful - The redux store state.
 * @param {string|undefined} vnode - The received parameters.
 * @param {string} focusJid - The received parameters.
 * @param {string|undefined} username - The received parameters.
 * @returns {Object}
 */
export function getVisitorOptions(stateful: IStateful, vnode: string, focusJid: string, username: string) {
    const config = toState(stateful)['features/base/config'];

    if (!config?.hosts) {
        logger.warn('Wrong configuration, missing hosts.');

        return;
    }

    if (!vnode) {
        // this is redirecting back to main, lets restore config
        // not updating disableFocus, as if the room capacity is full the promotion to the main room will fail
        // and the visitor will be redirected back to a vnode from jicofo
        if (config.oldConfig && username) {
            return {
                hosts: config.oldConfig.hosts,
                focusUserJid: focusJid,
                disableLocalStats: false,
                bosh: config.oldConfig.bosh && appendURLParam(config.oldConfig.bosh, 'customusername', username),
                p2p: config.oldConfig.p2p,
                websocket: config.oldConfig.websocket
                    && appendURLParam(config.oldConfig.websocket, 'customusername', username),
                oldConfig: undefined // clears it up
            };
        }

        return;
    }

    const oldConfig = {
        hosts: {
            domain: ''
        },
        focusUserJid: config.focusUserJid,
        bosh: config.bosh,
        p2p: config.p2p,
        websocket: config.websocket
    };

    // copy original hosts, to make sure we do not use a modified one later
    Object.assign(oldConfig.hosts, config.hosts);

    const domain = `${vnode}.meet.jitsi`;

    return {
        oldConfig,
        hosts: {
            domain,
            muc: config.hosts.muc.replace(oldConfig.hosts.domain, domain)
        },
        focusUserJid: focusJid,
        disableFocus: true, // This flag disables sending the initial conference request
        disableLocalStats: true,
        bosh: config.bosh && appendURLParam(config.bosh, 'vnode', vnode),
        p2p: {
            ...config.p2p,
            enabled: false
        },
        websocket: config.websocket && appendURLParam(config.websocket, 'vnode', vnode)
    };
}

/**
* Returns the UTC timestamp when the first participant joined the conference.
*
* @param {IStateful} stateful - Reference that can be resolved to Redux
* state with the {@code toState} function.
* @returns {number}
*/
export function getConferenceTimestamp(stateful: IStateful) {
    const state = toState(stateful);
    const { conferenceTimestamp } = getConferenceState(state);

    return conferenceTimestamp;
}

/**
 * Returns the current {@code JitsiConference} which is joining or joined and is
 * not leaving. Please note the contrast with merely reading the
 * {@code conference} state of the feature base/conference which is not joining
 * but may be leaving already.
 *
 * @param {IStateful} stateful - The redux store, state, or
 * {@code getState} function.
 * @returns {JitsiConference|undefined}
 */
export function getCurrentConference(stateful: IStateful): IJitsiConference | undefined {
    const { conference, joining, leaving, membersOnly, passwordRequired }
        = getConferenceState(toState(stateful));

    // There is a precedence
    if (conference) {
        return conference === leaving ? undefined : conference;
    }

    return joining || passwordRequired || membersOnly;
}

/**
 * Returns whether the current conference is a P2P connection.
 * Will return `false` if it's a JVB one, and `null` if there is no conference.
 *
 * @param {IStateful} stateful - The redux store, state, or
 * {@code getState} function.
 * @returns {boolean|null}
 */
export function isP2pActive(stateful: IStateful): boolean | null {
    const conference = getCurrentConference(toState(stateful));

    if (!conference) {
        return null;
    }

    return conference.isP2PActive();
}

/**
 * Returns the stored room name.
 *
 * @param {IReduxState} state - The current state of the app.
 * @returns {string}
 */
export function getRoomName(state: IReduxState) {
    return getConferenceState(state).room;
}

/**
 * Get an obfuscated room name or create and persist it if it doesn't exists.
 *
 * @param {IReduxState} state - The current state of the app.
 * @param {Function} dispatch - The Redux dispatch function.
 * @returns {string} - Obfuscated room name.
 */
export function getOrCreateObfuscatedRoomName(state: IReduxState, dispatch: IStore['dispatch']) {
    let { obfuscatedRoom } = getConferenceState(state);
    const { obfuscatedRoomSource } = getConferenceState(state);
    const room = getRoomName(state);

    if (!room) {
        return;
    }

    // On native mobile the store doesn't clear when joining a new conference so we might have the obfuscatedRoom
    // stored even though a different room was joined.
    // Check if the obfuscatedRoom was already computed for the current room.
    if (!obfuscatedRoom || (obfuscatedRoomSource !== room)) {
        obfuscatedRoom = sha512(room);
        dispatch(setObfuscatedRoom(obfuscatedRoom, room));
    }

    return obfuscatedRoom;
}

/**
 * Analytics may require an obfuscated room name, this functions decides based on a config if the normal or
 * obfuscated room name should be returned.
 *
 * @param {IReduxState} state - The current state of the app.
 * @param {Function} dispatch - The Redux dispatch function.
 * @returns {string} - Analytics room name.
 */
export function getAnalyticsRoomName(state: IReduxState, dispatch: IStore['dispatch']) {
    const { analysis: { obfuscateRoomName = false } = {} } = state['features/base/config'];

    if (obfuscateRoomName) {
        return getOrCreateObfuscatedRoomName(state, dispatch);
    }

    return getRoomName(state);
}

/**
 * Handle an error thrown by the backend (i.e. {@code lib-jitsi-meet}) while
 * manipulating a conference participant (e.g. Pin or select participant).
 *
 * @param {Error} err - The Error which was thrown by the backend while
 * manipulating a conference participant and which is to be handled.
 * @protected
 * @returns {void}
 */
export function _handleParticipantError(err: Error) {
    // XXX DataChannels are initialized at some later point when the conference
    // has multiple participants, but code that pins or selects a participant
    // might be executed before. So here we're swallowing a particular error.
    // TODO Lib-jitsi-meet should be fixed to not throw such an exception in
    // these scenarios.
    if (err.message !== 'Data channels support is disabled!') {
        throw err;
    }
}

/**
 * Determines whether a specific string is a valid room name.
 *
 * @param {(string|undefined)} room - The name of the conference room to check
 * for validity.
 * @returns {boolean} If the specified room name is valid, then true; otherwise,
 * false.
 */
export function isRoomValid(room?: string) {
    return typeof room === 'string' && room !== '';
}

/**
 * Remove a set of local tracks from a conference.
 *
 * @param {JitsiConference} conference - Conference instance.
 * @param {JitsiLocalTrack[]} localTracks - List of local media tracks.
 * @protected
 * @returns {Promise}
 */
export function _removeLocalTracksFromConference(
        conference: IJitsiConference,
        localTracks: Array<Object>) {
    return Promise.all(localTracks.map(track =>
        conference.removeTrack(track)
            .catch((err: Error) => {
                // Local track might be already disposed by direct
                // JitsiTrack#dispose() call. So we should ignore this error
                // here.
                if (err.name !== JitsiTrackErrors.TRACK_IS_DISPOSED) {
                    _reportError(
                        'Failed to remove local track from conference',
                        err);
                }
            })
    ));
}

/**
 * Reports a specific Error with a specific error message. While the
 * implementation merely logs the specified msg and err via the console at the
 * time of this writing, the intention of the function is to abstract the
 * reporting of errors and facilitate elaborating on it in the future.
 *
 * @param {string} msg - The error message to report.
 * @param {Error} err - The Error to report.
 * @private
 * @returns {void}
 */
function _reportError(msg: string, err: Error) {
    // TODO This is a good point to call some global error handler when we have
    // one.
    logger.error(msg, err);
}

/**
 * Sends a representation of the local participant such as her avatar (URL),
 * email address, and display name to (the remote participants of) a specific
 * conference.
 *
 * @param {Function|Object} stateful - The redux store, state, or
 * {@code getState} function.
 * @param {JitsiConference} conference - The {@code JitsiConference} to which
 * the representation of the local participant is to be sent.
 * @returns {void}
 */
export function sendLocalParticipant(
        stateful: IStateful,
        conference?: IJitsiConference) {
    const {
        avatarURL,
        email,
        features,
        name
    } = getLocalParticipant(stateful) ?? {};

    avatarURL && conference?.sendCommand(AVATAR_URL_COMMAND, {
        value: avatarURL
    });
    email && conference?.sendCommand(EMAIL_COMMAND, {
        value: email
    });

    if (features && features['screen-sharing'] === 'true') {
        conference?.setLocalParticipantProperty('features_screen-sharing', true);
    }

    conference?.setDisplayName(name);
}

/**
 * A safe implementation of lodash#startCase that doesn't deburr the string.
 *
 * NOTE: According to lodash roadmap, lodash v5 will have this function.
 *
 * Code based on https://github.com/lodash/lodash/blob/master/startCase.js.
 *
 * @param {string} s - The string to do start case on.
 * @returns {string}
 */
function safeStartCase(s = '') {
    return words(`${s}`.replace(/['\u2019]/g, '')).reduce(
        (result, word, index) => result + (index ? ' ' : '') + upperFirst(word)
        , '');
}


################################################################################

## File: .\jitsi-meet\react\features\base\conference\logger.ts

import { getLogger } from '../logging/functions';

export default getLogger('features/base/conference');


################################################################################

## File: .\jitsi-meet\react\features\base\conference\middleware.any.ts

import i18n from 'i18next';
import { AnyAction } from 'redux';

// @ts-ignore
import { MIN_ASSUMED_BANDWIDTH_BPS } from '../../../../modules/API/constants';
import {
    ACTION_PINNED,
    ACTION_UNPINNED,
    createNotAllowedErrorEvent,
    createOfferAnswerFailedEvent,
    createPinnedEvent
} from '../../analytics/AnalyticsEvents';
import { sendAnalytics } from '../../analytics/functions';
import { reloadNow } from '../../app/actions';
import { IStore } from '../../app/types';
import { removeLobbyChatParticipant } from '../../chat/actions.any';
import { openDisplayNamePrompt } from '../../display-name/actions';
import { isVpaasMeeting } from '../../jaas/functions';
import { showErrorNotification } from '../../notifications/actions';
import { NOTIFICATION_TIMEOUT_TYPE } from '../../notifications/constants';
import { hasDisplayName } from '../../prejoin/utils';
import { stopLocalVideoRecording } from '../../recording/actions.any';
import LocalRecordingManager from '../../recording/components/Recording/LocalRecordingManager';
import { iAmVisitor } from '../../visitors/functions';
import { overwriteConfig } from '../config/actions';
import { CONNECTION_ESTABLISHED, CONNECTION_FAILED } from '../connection/actionTypes';
import { connectionDisconnected, disconnect } from '../connection/actions';
import { validateJwt } from '../jwt/functions';
import { JitsiConferenceErrors, JitsiConferenceEvents, JitsiConnectionErrors } from '../lib-jitsi-meet';
import { PARTICIPANT_UPDATED, PIN_PARTICIPANT } from '../participants/actionTypes';
import { PARTICIPANT_ROLE } from '../participants/constants';
import {
    getLocalParticipant,
    getParticipantById,
    getPinnedParticipant
} from '../participants/functions';
import MiddlewareRegistry from '../redux/MiddlewareRegistry';
import StateListenerRegistry from '../redux/StateListenerRegistry';
import { TRACK_ADDED, TRACK_REMOVED } from '../tracks/actionTypes';

import {
    CONFERENCE_FAILED,
    CONFERENCE_JOINED,
    CONFERENCE_SUBJECT_CHANGED,
    CONFERENCE_WILL_LEAVE,
    P2P_STATUS_CHANGED,
    SEND_TONES,
    SET_ASSUMED_BANDWIDTH_BPS,
    SET_PENDING_SUBJECT_CHANGE,
    SET_ROOM
} from './actionTypes';
import {
    authStatusChanged,
    conferenceFailed,
    conferenceWillLeave,
    createConference,
    setLocalSubject,
    setSubject,
    updateConferenceMetadata
} from './actions';
import { CONFERENCE_LEAVE_REASONS } from './constants';
import {
    _addLocalTracksToConference,
    _removeLocalTracksFromConference,
    forEachConference,
    getCurrentConference,
    restoreConferenceOptions
} from './functions';
import logger from './logger';
import { IConferenceMetadata } from './reducer';

/**
 * Handler for before unload event.
 */
let beforeUnloadHandler: ((e?: any) => void) | undefined;

/**
 * Implements the middleware of the feature base/conference.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {
    switch (action.type) {
    case CONFERENCE_FAILED:
        return _conferenceFailed(store, next, action);

    case CONFERENCE_JOINED:
        return _conferenceJoined(store, next, action);

    case CONNECTION_ESTABLISHED:
        return _connectionEstablished(store, next, action);

    case CONNECTION_FAILED:
        return _connectionFailed(store, next, action);

    case CONFERENCE_SUBJECT_CHANGED:
        return _conferenceSubjectChanged(store, next, action);

    case CONFERENCE_WILL_LEAVE:
        _conferenceWillLeave(store);
        break;

    case P2P_STATUS_CHANGED:
        return _p2pStatusChanged(next, action);

    case PARTICIPANT_UPDATED:
        return _updateLocalParticipantInConference(store, next, action);

    case PIN_PARTICIPANT:
        return _pinParticipant(store, next, action);

    case SEND_TONES:
        return _sendTones(store, next, action);

    case SET_ROOM:
        return _setRoom(store, next, action);

    case TRACK_ADDED:
    case TRACK_REMOVED:
        return _trackAddedOrRemoved(store, next, action);

    case SET_ASSUMED_BANDWIDTH_BPS:
        return _setAssumedBandwidthBps(store, next, action);
    }

    return next(action);
});

/**
 * Set up state change listener to perform maintenance tasks when the conference
 * is left or failed.
 */
StateListenerRegistry.register(
    state => getCurrentConference(state),
    (conference, { dispatch }, previousConference): void => {
        if (conference && !previousConference) {
            conference.on(JitsiConferenceEvents.METADATA_UPDATED, (metadata: IConferenceMetadata) => {
                dispatch(updateConferenceMetadata(metadata));
            });
        }

        if (conference !== previousConference) {
            dispatch(updateConferenceMetadata(null));
        }
    });

/**
 * Makes sure to leave a failed conference in order to release any allocated
 * resources like peer connections, emit participant left events, etc.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @param {Dispatch} next - The redux {@code dispatch} function to dispatch the
 * specified {@code action} to the specified {@code store}.
 * @param {Action} action - The redux action {@code CONFERENCE_FAILED} which is
 * being dispatched in the specified {@code store}.
 * @private
 * @returns {Object} The value returned by {@code next(action)}.
 */
function _conferenceFailed({ dispatch, getState }: IStore, next: Function, action: AnyAction) {
    const { conference, error } = action;

    const result = next(action);
    const { enableForcedReload } = getState()['features/base/config'];

    if (LocalRecordingManager.isRecordingLocally()) {
        dispatch(stopLocalVideoRecording());
    }

    // Handle specific failure reasons.
    switch (error.name) {
    case JitsiConferenceErrors.CONFERENCE_RESTARTED: {
        if (enableForcedReload) {
            dispatch(showErrorNotification({
                description: 'Restart initiated because of a bridge failure',
                titleKey: 'dialog.sessionRestarted'
            }, NOTIFICATION_TIMEOUT_TYPE.LONG));
        }

        break;
    }
    case JitsiConferenceErrors.CONNECTION_ERROR: {
        const [ msg ] = error.params;

        dispatch(connectionDisconnected(getState()['features/base/connection'].connection));
        dispatch(showErrorNotification({
            descriptionArguments: { msg },
            descriptionKey: msg ? 'dialog.connectErrorWithMsg' : 'dialog.connectError',
            titleKey: 'connection.CONNFAIL'
        }, NOTIFICATION_TIMEOUT_TYPE.LONG));

        break;
    }
    case JitsiConferenceErrors.CONFERENCE_MAX_USERS: {
        dispatch(showErrorNotification({
            hideErrorSupportLink: true,
            descriptionKey: 'dialog.maxUsersLimitReached',
            titleKey: 'dialog.maxUsersLimitReachedTitle'
        }, NOTIFICATION_TIMEOUT_TYPE.LONG));

        // In case of max users(it can be from a visitor node), let's restore
        // oldConfig if any as we will be back to the main prosody.
        const newConfig = restoreConferenceOptions(getState);

        if (newConfig) {
            dispatch(overwriteConfig(newConfig));
            dispatch(conferenceWillLeave(conference));

            conference.leave()
                .then(() => dispatch(disconnect()));
        }

        break;
    }
    case JitsiConferenceErrors.NOT_ALLOWED_ERROR: {
        const [ type, msg ] = error.params;

        let descriptionKey;
        let titleKey = 'dialog.tokenAuthFailed';

        if (type === JitsiConferenceErrors.AUTH_ERROR_TYPES.NO_MAIN_PARTICIPANTS) {
            descriptionKey = 'visitors.notification.noMainParticipantsDescription';
            titleKey = 'visitors.notification.noMainParticipantsTitle';
        } else if (type === JitsiConferenceErrors.AUTH_ERROR_TYPES.NO_VISITORS_LOBBY) {
            descriptionKey = 'visitors.notification.noVisitorLobby';
        } else if (type === JitsiConferenceErrors.AUTH_ERROR_TYPES.PROMOTION_NOT_ALLOWED) {
            descriptionKey = 'visitors.notification.notAllowedPromotion';
        } else if (type === JitsiConferenceErrors.AUTH_ERROR_TYPES.ROOM_CREATION_RESTRICTION) {
            descriptionKey = 'dialog.errorRoomCreationRestriction';
        }

        dispatch(showErrorNotification({
            descriptionKey,
            hideErrorSupportLink: true,
            titleKey
        }, NOTIFICATION_TIMEOUT_TYPE.STICKY));

        sendAnalytics(createNotAllowedErrorEvent(type, msg));

        break;
    }
    case JitsiConferenceErrors.OFFER_ANSWER_FAILED:
        sendAnalytics(createOfferAnswerFailedEvent());
        break;
    }

    !error.recoverable
    && conference
    && conference.leave(CONFERENCE_LEAVE_REASONS.UNRECOVERABLE_ERROR).catch((reason: Error) => {
        // Even though we don't care too much about the failure, it may be
        // good to know that it happen, so log it (on the info level).
        logger.info('JitsiConference.leave() rejected with:', reason);
    });

    // FIXME: Workaround for the web version. Currently, the creation of the
    // conference is handled by /conference.js and appropriate failure handlers
    // are set there.
    if (typeof APP !== 'undefined') {
        _removeUnloadHandler(getState);
    }

    if (enableForcedReload && error?.name === JitsiConferenceErrors.CONFERENCE_RESTARTED) {
        dispatch(conferenceWillLeave(conference));
        dispatch(reloadNow());
    }

    return result;
}

/**
 * Does extra sync up on properties that may need to be updated after the
 * conference was joined.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @param {Dispatch} next - The redux {@code dispatch} function to dispatch the
 * specified {@code action} to the specified {@code store}.
 * @param {Action} action - The redux action {@code CONFERENCE_JOINED} which is
 * being dispatched in the specified {@code store}.
 * @private
 * @returns {Object} The value returned by {@code next(action)}.
 */
function _conferenceJoined({ dispatch, getState }: IStore, next: Function, action: AnyAction) {
    const result = next(action);
    const { conference } = action;
    const { pendingSubjectChange } = getState()['features/base/conference'];
    const {
        disableBeforeUnloadHandlers = false,
        requireDisplayName
    } = getState()['features/base/config'];

    dispatch(removeLobbyChatParticipant(true));

    pendingSubjectChange && dispatch(setSubject(pendingSubjectChange));

    // FIXME: Very dirty solution. This will work on web only.
    // When the user closes the window or quits the browser, lib-jitsi-meet
    // handles the process of leaving the conference. This is temporary solution
    // that should cover the described use case as part of the effort to
    // implement the conferenceWillLeave action for web.
    beforeUnloadHandler = (e?: any) => {
        if (LocalRecordingManager.isRecordingLocally()) {
            dispatch(stopLocalVideoRecording());
            if (e) {
                e.preventDefault();
                e.returnValue = null;
            }
        }
        dispatch(conferenceWillLeave(conference));
    };

    if (!iAmVisitor(getState())) {
        // if a visitor is promoted back to main room and want to join an empty breakout room
        // we need to send iq to jicofo, so it can join/create the breakout room
        dispatch(overwriteConfig({ disableFocus: false }));
    }

    window.addEventListener(disableBeforeUnloadHandlers ? 'unload' : 'beforeunload', beforeUnloadHandler);

    if (requireDisplayName
        && !getLocalParticipant(getState)?.name
        && !conference.isHidden()) {
        dispatch(openDisplayNamePrompt({
            validateInput: hasDisplayName
        }));
    }

    return result;
}

/**
 * Notifies the feature base/conference that the action
 * {@code CONNECTION_ESTABLISHED} is being dispatched within a specific redux
 * store.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @param {Dispatch} next - The redux {@code dispatch} function to dispatch the
 * specified {@code action} to the specified {@code store}.
 * @param {Action} action - The redux action {@code CONNECTION_ESTABLISHED}
 * which is being dispatched in the specified {@code store}.
 * @private
 * @returns {Object} The value returned by {@code next(action)}.
 */
async function _connectionEstablished({ dispatch, getState }: IStore, next: Function, action: AnyAction) {
    const result = next(action);

    const { tokenAuthUrl = false } = getState()['features/base/config'];

    // if there is token auth URL defined and local participant is using jwt
    // this means it is logged in when connection is established, so we can change the state
    if (tokenAuthUrl && !isVpaasMeeting(getState())) {
        let email;

        if (getState()['features/base/jwt'].jwt) {
            email = getLocalParticipant(getState())?.email;
        }

        dispatch(authStatusChanged(true, email || ''));
    }

    // FIXME: Workaround for the web version. Currently, the creation of the
    // conference is handled by /conference.js.
    if (typeof APP === 'undefined') {
        dispatch(createConference());

        return result;
    }

    return result;
}

/**
 * Logs jwt validation errors from xmpp and from the client-side validator.
 *
 * @param {string} message - The error message from xmpp.
 * @param {string} errors - The detailed errors.
 * @returns {void}
 */
function _logJwtErrors(message: string, errors: string) {
    message && logger.error(`JWT error: ${message}`);
    errors && logger.error('JWT parsing errors:', errors);
}

/**
 * Notifies the feature base/conference that the action
 * {@code CONNECTION_FAILED} is being dispatched within a specific redux
 * store.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @param {Dispatch} next - The redux {@code dispatch} function to dispatch the
 * specified {@code action} to the specified {@code store}.
 * @param {Action} action - The redux action {@code CONNECTION_FAILED} which is
 * being dispatched in the specified {@code store}.
 * @private
 * @returns {Object} The value returned by {@code next(action)}.
 */
function _connectionFailed({ dispatch, getState }: IStore, next: Function, action: AnyAction) {
    const { connection, error } = action;
    const { jwt } = getState()['features/base/jwt'];

    if (jwt) {
        const errors: string = validateJwt(jwt).map((err: any) =>
            i18n.t(`dialog.tokenAuthFailedReason.${err.key}`, err.args))
        .join(' ');

        _logJwtErrors(error.message, errors);

        // do not show the notification when we will prompt the user
        // for username and password
        if (error.name === JitsiConnectionErrors.PASSWORD_REQUIRED) {
            dispatch(showErrorNotification({
                descriptionKey: errors ? 'dialog.tokenAuthFailedWithReasons' : 'dialog.tokenAuthFailed',
                descriptionArguments: { reason: errors },
                titleKey: 'dialog.tokenAuthFailedTitle'
            }, NOTIFICATION_TIMEOUT_TYPE.STICKY));
        }
    }

    const result = next(action);

    _removeUnloadHandler(getState);

    forEachConference(getState, conference => {
        // TODO: revisit this
        // It feels that it would make things easier if JitsiConference
        // in lib-jitsi-meet would monitor it's connection and emit
        // CONFERENCE_FAILED when it's dropped. It has more knowledge on
        // whether it can recover or not. But because the reload screen
        // and the retry logic is implemented in the app maybe it can be
        // left this way for now.
        if (conference.getConnection() === connection) {
            // XXX Note that on mobile the error type passed to
            // connectionFailed is always an object with .name property.
            // This fact needs to be checked prior to enabling this logic on
            // web.
            const conferenceAction = conferenceFailed(conference, error.name);

            // Copy the recoverable flag if set on the CONNECTION_FAILED
            // action to not emit recoverable action caused by
            // a non-recoverable one.
            if (typeof error.recoverable !== 'undefined') {
                conferenceAction.error.recoverable = error.recoverable;
            }

            dispatch(conferenceAction);
        }

        return true;
    });

    return result;
}

/**
 * Notifies the feature base/conference that the action
 * {@code CONFERENCE_SUBJECT_CHANGED} is being dispatched within a specific
 *  redux store.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @param {Dispatch} next - The redux {@code dispatch} function to dispatch the
 * specified {@code action} to the specified {@code store}.
 * @param {Action} action - The redux action {@code CONFERENCE_SUBJECT_CHANGED}
 * which is being dispatched in the specified {@code store}.
 * @private
 * @returns {Object} The value returned by {@code next(action)}.
 */
function _conferenceSubjectChanged({ dispatch, getState }: IStore, next: Function, action: AnyAction) {
    const result = next(action);
    const { subject } = getState()['features/base/conference'];

    if (subject) {
        dispatch({
            type: SET_PENDING_SUBJECT_CHANGE,
            subject: undefined
        });
    }

    typeof APP === 'object' && APP.API.notifySubjectChanged(subject);

    return result;
}

/**
 * Notifies the feature base/conference that the action
 * {@code CONFERENCE_WILL_LEAVE} is being dispatched within a specific redux
 * store.
 *
 * @private
 * @param {Object} store - The redux store.
 * @returns {void}
 */
function _conferenceWillLeave({ getState }: IStore) {
    _removeUnloadHandler(getState);
}

/**
 * Notifies the feature base/conference that the action {@code PIN_PARTICIPANT}
 * is being dispatched within a specific redux store. Pins the specified remote
 * participant in the associated conference, ignores the local participant.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @param {Dispatch} next - The redux {@code dispatch} function to dispatch the
 * specified {@code action} to the specified {@code store}.
 * @param {Action} action - The redux action {@code PIN_PARTICIPANT} which is
 * being dispatched in the specified {@code store}.
 * @private
 * @returns {Object} The value returned by {@code next(action)}.
 */
function _pinParticipant({ getState }: IStore, next: Function, action: AnyAction) {
    const state = getState();
    const { conference } = state['features/base/conference'];

    if (!conference) {
        return next(action);
    }

    const id = action.participant.id;
    const participantById = getParticipantById(state, id);
    const pinnedParticipant = getPinnedParticipant(state);
    const actionName = id ? ACTION_PINNED : ACTION_UNPINNED;
    const local
        = participantById?.local
            || (!id && pinnedParticipant && pinnedParticipant.local);
    let participantIdForEvent;

    if (local) {
        participantIdForEvent = local;
    } else {
        participantIdForEvent
            = actionName === ACTION_PINNED ? id : pinnedParticipant?.id;
    }

    sendAnalytics(createPinnedEvent(
        actionName,
        participantIdForEvent,
        {
            local,
            'participant_count': conference.getParticipantCount()
        }));

    return next(action);
}

/**
 * Removes the unload handler.
 *
 * @param {Function} getState - The redux getState function.
 * @returns {void}
 */
function _removeUnloadHandler(getState: IStore['getState']) {
    if (typeof beforeUnloadHandler !== 'undefined') {
        const { disableBeforeUnloadHandlers = false } = getState()['features/base/config'];

        window.removeEventListener(disableBeforeUnloadHandlers ? 'unload' : 'beforeunload', beforeUnloadHandler);
        beforeUnloadHandler = undefined;
    }
}

/**
 * Requests the specified tones to be played.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @param {Dispatch} next - The redux {@code dispatch} function to dispatch the
 * specified {@code action} to the specified {@code store}.
 * @param {Action} action - The redux action {@code SEND_TONES} which is
 * being dispatched in the specified {@code store}.
 * @private
 * @returns {Object} The value returned by {@code next(action)}.
 */
function _sendTones({ getState }: IStore, next: Function, action: AnyAction) {
    const state = getState();
    const { conference } = state['features/base/conference'];

    if (conference) {
        const { duration, tones, pause } = action;

        conference.sendTones(tones, duration, pause);
    }

    return next(action);
}

/**
 * Notifies the feature base/conference that the action
 * {@code SET_ROOM} is being dispatched within a specific
 *  redux store.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @param {Dispatch} next - The redux {@code dispatch} function to dispatch the
 * specified {@code action} to the specified {@code store}.
 * @param {Action} action - The redux action {@code SET_ROOM}
 * which is being dispatched in the specified {@code store}.
 * @private
 * @returns {Object} The value returned by {@code next(action)}.
 */
function _setRoom({ dispatch, getState }: IStore, next: Function, action: AnyAction) {
    const state = getState();
    const { localSubject, subject } = state['features/base/config'];
    const { room } = action;

    if (room) {
        // Set the stored subject.
        localSubject && dispatch(setLocalSubject(localSubject));
        subject && dispatch(setSubject(subject));
    }

    return next(action);
}

/**
 * Synchronizes local tracks from state with local tracks in JitsiConference
 * instance.
 *
 * @param {Store} store - The redux store.
 * @param {Object} action - Action object.
 * @private
 * @returns {Promise}
 */
function _syncConferenceLocalTracksWithState({ getState }: IStore, action: AnyAction) {
    const state = getState();
    const conference = getCurrentConference(state);
    let promise;

    if (conference) {
        const track = action.track.jitsiTrack;

        if (action.type === TRACK_ADDED) {
            // If gUM is slow and tracks are created after the user has already joined the conference, avoid
            // adding the tracks to the conference if the user is a visitor.
            if (!iAmVisitor(state)) {
                promise = _addLocalTracksToConference(conference, [ track ]);
            }
        } else {
            promise = _removeLocalTracksFromConference(conference, [ track ]);
        }
    }

    return promise || Promise.resolve();
}

/**
 * Notifies the feature base/conference that the action {@code TRACK_ADDED}
 * or {@code TRACK_REMOVED} is being dispatched within a specific redux store.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @param {Dispatch} next - The redux {@code dispatch} function to dispatch the
 * specified {@code action} to the specified {@code store}.
 * @param {Action} action - The redux action {@code TRACK_ADDED} or
 * {@code TRACK_REMOVED} which is being dispatched in the specified
 * {@code store}.
 * @private
 * @returns {Object} The value returned by {@code next(action)}.
 */
function _trackAddedOrRemoved(store: IStore, next: Function, action: AnyAction) {
    const track = action.track;

    // TODO All track swapping should happen here instead of conference.js.
    if (track?.local) {
        return (
            _syncConferenceLocalTracksWithState(store, action)
                .then(() => next(action)));
    }

    return next(action);
}

/**
 * Updates the conference object when the local participant is updated.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @param {Dispatch} next - The redux {@code dispatch} function to dispatch the
 * specified {@code action} to the specified {@code store}.
 * @param {Action} action - The redux action which is being dispatched in the
 * specified {@code store}.
 * @private
 * @returns {Object} The value returned by {@code next(action)}.
 */
function _updateLocalParticipantInConference({ dispatch, getState }: IStore, next: Function, action: AnyAction) {
    const { conference } = getState()['features/base/conference'];
    const { participant } = action;
    const result = next(action);

    const localParticipant = getLocalParticipant(getState);

    if (conference && participant.id === localParticipant?.id) {
        if ('name' in participant) {
            conference.setDisplayName(participant.name);
        }

        if ('isSilent' in participant) {
            conference.setIsSilent(participant.isSilent);
        }

        if ('role' in participant && participant.role === PARTICIPANT_ROLE.MODERATOR) {
            const { pendingSubjectChange, subject } = getState()['features/base/conference'];

            // When the local user role is updated to moderator and we have a pending subject change
            // which was not reflected we need to set it (the first time we tried was before becoming moderator).
            if (typeof pendingSubjectChange !== 'undefined' && pendingSubjectChange !== subject) {
                dispatch(setSubject(pendingSubjectChange));
            }
        }
    }

    return result;
}

/**
 * Notifies the external API that the action {@code P2P_STATUS_CHANGED}
 * is being dispatched within a specific redux store.
 *
 * @param {Dispatch} next - The redux {@code dispatch} function to dispatch the
 * specified {@code action} to the specified {@code store}.
 * @param {Action} action - The redux action {@code P2P_STATUS_CHANGED}
 * which is being dispatched in the specified {@code store}.
 * @private
 * @returns {Object} The value returned by {@code next(action)}.
 */
function _p2pStatusChanged(next: Function, action: AnyAction) {
    const result = next(action);

    if (typeof APP !== 'undefined') {
        APP.API.notifyP2pStatusChanged(action.p2p);
    }

    return result;
}

/**
 * Notifies the feature base/conference that the action
 * {@code SET_ASSUMED_BANDWIDTH_BPS} is being dispatched within a specific
 *  redux store.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @param {Dispatch} next - The redux {@code dispatch} function to dispatch the
 * specified {@code action} to the specified {@code store}.
 * @param {Action} action - The redux action {@code SET_ASSUMED_BANDWIDTH_BPS}
 * which is being dispatched in the specified {@code store}.
 * @private
 * @returns {Object} The value returned by {@code next(action)}.
 */
function _setAssumedBandwidthBps({ getState }: IStore, next: Function, action: AnyAction) {
    const state = getState();
    const conference = getCurrentConference(state);
    const payload = Number(action.assumedBandwidthBps);

    const assumedBandwidthBps = isNaN(payload) || payload < MIN_ASSUMED_BANDWIDTH_BPS
        ? MIN_ASSUMED_BANDWIDTH_BPS
        : payload;

    if (conference) {
        conference.setAssumedBandwidthBps(assumedBandwidthBps);
    }

    return next(action);
}


################################################################################

## File: .\jitsi-meet\react\features\base\conference\middleware.native.ts

import { appNavigate } from '../../app/actions.native';
import { notifyConferenceFailed } from '../../conference/actions.native';
import { JitsiConferenceErrors } from '../lib-jitsi-meet';
import MiddlewareRegistry from '../redux/MiddlewareRegistry';

import { CONFERENCE_FAILED } from './actionTypes';
import { conferenceLeft } from './actions';
import { TRIGGER_READY_TO_CLOSE_REASONS } from './constants';

import './middleware.any';

MiddlewareRegistry.register(store => next => action => {
    const { dispatch } = store;
    const { error } = action;

    switch (action.type) {
    case CONFERENCE_FAILED: {
        if (error?.name !== JitsiConferenceErrors.CONFERENCE_DESTROYED) {
            break;
        }

        const [ reason ] = error.params;

        const reasonKey = Object.keys(TRIGGER_READY_TO_CLOSE_REASONS)[
            Object.values(TRIGGER_READY_TO_CLOSE_REASONS).indexOf(reason)
        ];

        dispatch(notifyConferenceFailed(reasonKey, () => {
            dispatch(conferenceLeft(action.conference));
            dispatch(appNavigate(undefined));
        }));
    }
    }

    return next(action);
});


################################################################################

## File: .\jitsi-meet\react\features\base\conference\middleware.web.ts

import i18next from 'i18next';

import {
    setPrejoinPageVisibility,
    setSkipPrejoinOnReload
} from '../../prejoin/actions.web';
import { isPrejoinPageVisible } from '../../prejoin/functions';
import { iAmVisitor } from '../../visitors/functions';
import { CONNECTION_DISCONNECTED, CONNECTION_ESTABLISHED } from '../connection/actionTypes';
import { hangup } from '../connection/actions.web';
import { JitsiConferenceErrors, browser } from '../lib-jitsi-meet';
import { gumPending, setInitialGUMPromise } from '../media/actions';
import { MEDIA_TYPE } from '../media/constants';
import { IGUMPendingState } from '../media/types';
import MiddlewareRegistry from '../redux/MiddlewareRegistry';
import { replaceLocalTrack } from '../tracks/actions.any';
import { getLocalTracks } from '../tracks/functions.any';

import {
    CONFERENCE_FAILED,
    CONFERENCE_JOINED,
    CONFERENCE_JOIN_IN_PROGRESS,
    CONFERENCE_LEFT,
    KICKED_OUT
} from './actionTypes';
import { TRIGGER_READY_TO_CLOSE_REASONS } from './constants';
import logger from './logger';

import './middleware.any';

let screenLock: WakeLockSentinel | undefined;

/**
 * Releases the screen lock.
 *
 * @returns {Promise}
 */
async function releaseScreenLock() {
    if (screenLock) {
        if (!screenLock.released) {
            logger.debug('Releasing wake lock.');

            try {
                await screenLock.release();
            } catch (e) {
                logger.error(`Error while releasing the screen wake lock: ${e}.`);
            }
        }
        screenLock.removeEventListener('release', onWakeLockReleased);
        screenLock = undefined;
        document.removeEventListener('visibilitychange', handleVisibilityChange);
    }
}

/**
 * Requests a new screen wake lock.
 *
 * @returns {void}
 */
function requestWakeLock() {
    if (navigator.wakeLock?.request) {
        navigator.wakeLock.request('screen')
            .then(lock => {
                screenLock = lock;
                screenLock.addEventListener('release', onWakeLockReleased);
                document.addEventListener('visibilitychange', handleVisibilityChange);
                logger.debug('Wake lock created.');
            })
            .catch(e => {
                logger.error(`Error while requesting wake lock for screen: ${e}`);
            });
    }
}

/**
 * Page visibility change handler that re-requests the wake lock if it has been released by the OS.
 *
 * @returns {void}
 */
async function handleVisibilityChange() {
    if (screenLock?.released && document.visibilityState === 'visible') {
        // The screen lock have been released by the OS because of document visibility change. Lets try to request the
        // wake lock again.
        await releaseScreenLock();
        requestWakeLock();
    }
}

/**
 * Wake lock released handler.
 *
 * @returns {void}
 */
function onWakeLockReleased() {
    logger.debug('Wake lock released');
}

MiddlewareRegistry.register(store => next => action => {
    const { dispatch, getState } = store;
    const { enableForcedReload } = getState()['features/base/config'];

    switch (action.type) {
    case CONFERENCE_JOIN_IN_PROGRESS: {
        dispatch(setPrejoinPageVisibility(false));

        break;
    }
    case CONFERENCE_JOINED: {
        if (enableForcedReload) {
            dispatch(setSkipPrejoinOnReload(false));
        }

        requestWakeLock();

        break;
    }
    case CONFERENCE_FAILED: {
        const errorName = action.error?.name;

        if (enableForcedReload && errorName === JitsiConferenceErrors.CONFERENCE_RESTARTED) {
            dispatch(setSkipPrejoinOnReload(true));
        }

        if (errorName === JitsiConferenceErrors.CONFERENCE_DESTROYED) {
            const [ reason ] = action.error.params;
            const titlekey = Object.keys(TRIGGER_READY_TO_CLOSE_REASONS)[
                Object.values(TRIGGER_READY_TO_CLOSE_REASONS).indexOf(reason)
            ];

            dispatch(hangup(true, i18next.t(titlekey) || reason));
        }

        releaseScreenLock();

        break;
    }
    case CONFERENCE_LEFT:
    case KICKED_OUT:
        releaseScreenLock();

        break;
    case CONNECTION_DISCONNECTED: {
        const { initialGUMPromise } = getState()['features/base/media'];

        if (initialGUMPromise) {
            store.dispatch(setInitialGUMPromise());
        }

        break;
    }
    case CONNECTION_ESTABLISHED: {
        if (isPrejoinPageVisible(getState())) {
            let { initialGUMPromise } = getState()['features/base/media'];

            initialGUMPromise = initialGUMPromise || Promise.resolve({ tracks: [] });

            initialGUMPromise.then(() => {
                const state = getState();
                let localTracks = getLocalTracks(state['features/base/tracks']);
                const trackReplacePromises = [];

                // Do not signal audio/video tracks if the user joins muted.
                for (const track of localTracks) {
                    // Always add the audio track on Safari because of a known issue where audio playout doesn't happen
                    // if the user joins audio and video muted.
                    if ((track.muted && !(browser.isWebKitBased() && track.jitsiTrack
                            && track.jitsiTrack.getType() === MEDIA_TYPE.AUDIO)) || iAmVisitor(state)) {
                        trackReplacePromises.push(dispatch(replaceLocalTrack(track.jitsiTrack, null))
                            .catch((error: any) => {
                                logger.error(`Failed to replace local track (${track.jitsiTrack}) with null: ${error}`);
                            }));
                    }
                }

                Promise.allSettled(trackReplacePromises).then(() => {

                    // Re-fetch the local tracks after muted tracks have been removed above.
                    // This is needed, because the tracks are effectively disposed by the replaceLocalTrack and should
                    // not be used anymore.
                    localTracks = getLocalTracks(getState()['features/base/tracks']);

                    const jitsiTracks = localTracks.map((t: any) => t.jitsiTrack);


                    return APP.conference.startConference(jitsiTracks);
                });
            });
        } else {
            let { initialGUMPromise } = getState()['features/base/media'];

            initialGUMPromise = initialGUMPromise || Promise.resolve({ tracks: [] });

            initialGUMPromise.then(({ tracks }) => {
                let tracksToUse = tracks ?? [];

                if (iAmVisitor(getState())) {
                    tracksToUse = [];
                    tracks.forEach(track => track.dispose().catch(logger.error));
                    dispatch(gumPending([ MEDIA_TYPE.AUDIO, MEDIA_TYPE.VIDEO ], IGUMPendingState.NONE));
                }

                dispatch(setInitialGUMPromise());

                return APP.conference.startConference(tracksToUse);
            })
            .catch(logger.error);
        }

        break;
    }
    }

    return next(action);
});


################################################################################

## File: .\jitsi-meet\react\features\base\conference\reducer.ts

import { AnyAction } from 'redux';

import { FaceLandmarks } from '../../face-landmarks/types';
import { LOCKED_LOCALLY, LOCKED_REMOTELY } from '../../room-lock/constants';
import { ISpeakerStats } from '../../speaker-stats/reducer';
import { SET_CONFIG } from '../config/actionTypes';
import { IConfig } from '../config/configType';
import { CONNECTION_WILL_CONNECT, SET_LOCATION_URL } from '../connection/actionTypes';
import { JitsiConferenceErrors } from '../lib-jitsi-meet';
import ReducerRegistry from '../redux/ReducerRegistry';
import { assign, set } from '../redux/functions';

import {
    AUTH_STATUS_CHANGED,
    CONFERENCE_FAILED,
    CONFERENCE_JOINED,
    CONFERENCE_LEFT,
    CONFERENCE_LOCAL_SUBJECT_CHANGED,
    CONFERENCE_SUBJECT_CHANGED,
    CONFERENCE_TIMESTAMP_CHANGED,
    CONFERENCE_WILL_JOIN,
    CONFERENCE_WILL_LEAVE,
    DATA_CHANNEL_CLOSED,
    DATA_CHANNEL_OPENED,
    LOCK_STATE_CHANGED,
    P2P_STATUS_CHANGED,
    SET_ASSUMED_BANDWIDTH_BPS,
    SET_FOLLOW_ME,
    SET_FOLLOW_ME_RECORDER,
    SET_OBFUSCATED_ROOM,
    SET_PASSWORD,
    SET_PENDING_SUBJECT_CHANGE,
    SET_ROOM,
    SET_START_MUTED_POLICY,
    SET_START_REACTIONS_MUTED,
    UPDATE_CONFERENCE_METADATA
} from './actionTypes';
import { isRoomValid } from './functions';

const DEFAULT_STATE = {
    assumedBandwidthBps: undefined,
    conference: undefined,
    dataChannelOpen: undefined,
    e2eeSupported: undefined,
    joining: undefined,
    leaving: undefined,
    locked: undefined,
    membersOnly: undefined,
    metadata: undefined,
    password: undefined,
    passwordRequired: undefined
};

export interface IConferenceMetadata {
    recording?: {
        isTranscribingEnabled: boolean;
    };
    visitors?: {
        live: boolean;
    };
    whiteboard?: {
        collabDetails: {
            roomId: string;
            roomKey: string;
        };
    };
}

export interface IJitsiConference {
    addCommandListener: Function;
    addLobbyMessageListener: Function;
    addTrack: Function;
    authenticateAndUpgradeRole: Function;
    avModerationApprove: Function;
    avModerationReject: Function;
    callUUID?: string;
    createVideoSIPGWSession: Function;
    dial: Function;
    disableAVModeration: Function;
    disableLobby: Function;
    enableAVModeration: Function;
    enableLobby: Function;
    end: Function;
    getBreakoutRooms: Function;
    getConnection: Function;
    getLocalParticipantProperty: Function;
    getLocalTracks: Function;
    getMeetingUniqueId: Function;
    getMetadataHandler: Function;
    getName: Function;
    getParticipantById: Function;
    getParticipantCount: Function;
    getParticipants: Function;
    getRole: Function;
    getSpeakerStats: () => ISpeakerStats;
    getSsrcByTrack: Function;
    getTranscriptionStatus: Function;
    grantOwner: Function;
    isAVModerationSupported: Function;
    isE2EEEnabled: Function;
    isE2EESupported: Function;
    isEndConferenceSupported: Function;
    isLobbySupported: Function;
    isP2PActive: Function;
    isSIPCallingSupported: Function;
    isStartAudioMuted: Function;
    isStartVideoMuted: Function;
    join: Function;
    joinLobby: Function;
    kickParticipant: Function;
    leave: Function;
    lobbyApproveAccess: Function;
    lobbyDenyAccess: Function;
    lock: Function;
    markParticipantVerified: Function;
    muteParticipant: Function;
    myLobbyUserId: Function;
    myUserId: Function;
    off: Function;
    on: Function;
    options: any;
    removeTrack: Function;
    replaceTrack: Function;
    room: IJitsiConferenceRoom;
    sendApplicationLog: Function;
    sendCommand: Function;
    sendCommandOnce: Function;
    sendEndpointMessage: Function;
    sendFaceLandmarks: (faceLandmarks: FaceLandmarks) => void;
    sendFeedback: Function;
    sendLobbyMessage: Function;
    sendMessage: Function;
    sendPrivateTextMessage: Function;
    sendReaction: Function;
    sendTextMessage: Function;
    sendTones: Function;
    sessionId: string;
    setAssumedBandwidthBps: (value: number) => void;
    setDesktopSharingFrameRate: Function;
    setDisplayName: Function;
    setIsSilent: Function;
    setLocalParticipantProperty: Function;
    setMediaEncryptionKey: Function;
    setReceiverConstraints: Function;
    setSenderVideoConstraint: Function;
    setStartMutedPolicy: Function;
    setSubject: Function;
    startRecording: Function;
    startVerification: Function;
    stopRecording: Function;
    toggleE2EE: Function;
}

export interface IConferenceState {
    assumedBandwidthBps?: number;
    authEnabled?: boolean;
    authLogin?: string;
    authRequired?: IJitsiConference;
    conference?: IJitsiConference;
    conferenceTimestamp?: number;
    dataChannelOpen?: boolean;
    e2eeSupported?: boolean;
    error?: Error;
    followMeEnabled?: boolean;
    followMeRecorderEnabled?: boolean;
    joining?: IJitsiConference;
    leaving?: IJitsiConference;
    lobbyWaitingForHost?: boolean;
    localSubject?: string;
    locked?: string;
    membersOnly?: IJitsiConference;
    metadata?: IConferenceMetadata;
    obfuscatedRoom?: string;
    obfuscatedRoomSource?: string;
    p2p?: Object;
    password?: string;
    passwordRequired?: IJitsiConference;
    pendingSubjectChange?: string;
    room?: string;
    startAudioMutedPolicy?: boolean;
    startReactionsMuted?: boolean;
    startVideoMutedPolicy?: boolean;
    subject?: string;
}

export interface IJitsiConferenceRoom {
    locked: boolean;
    myroomjid: string;
    roomjid: string;
    xmpp: {
        moderator: {
            logout: Function;
        };
    };
}

interface IConferenceFailedError extends Error {
    params: Array<any>;
}

/**
 * Listen for actions that contain the conference object, so that it can be
 * stored for use by other action creators.
 */
ReducerRegistry.register<IConferenceState>('features/base/conference',
    (state = DEFAULT_STATE, action): IConferenceState => {
        switch (action.type) {
        case AUTH_STATUS_CHANGED:
            return _authStatusChanged(state, action);

        case CONFERENCE_FAILED:
            return _conferenceFailed(state, action);

        case CONFERENCE_JOINED:
            return _conferenceJoined(state, action);

        case CONFERENCE_SUBJECT_CHANGED:
            return set(state, 'subject', action.subject);

        case CONFERENCE_LOCAL_SUBJECT_CHANGED:
            return set(state, 'localSubject', action.localSubject);

        case CONFERENCE_TIMESTAMP_CHANGED:
            return set(state, 'conferenceTimestamp', action.conferenceTimestamp);

        case CONFERENCE_LEFT:
        case CONFERENCE_WILL_LEAVE:
            return _conferenceLeftOrWillLeave(state, action);

        case CONFERENCE_WILL_JOIN:
            return _conferenceWillJoin(state, action);

        case CONNECTION_WILL_CONNECT:
            return set(state, 'authRequired', undefined);

        case DATA_CHANNEL_CLOSED:
            return set(state, 'dataChannelOpen', false);

        case DATA_CHANNEL_OPENED:
            return set(state, 'dataChannelOpen', true);

        case LOCK_STATE_CHANGED:
            return _lockStateChanged(state, action);

        case P2P_STATUS_CHANGED:
            return _p2pStatusChanged(state, action);

        case SET_ASSUMED_BANDWIDTH_BPS: {
            const assumedBandwidthBps = action.assumedBandwidthBps >= 0
                ? Number(action.assumedBandwidthBps)
                : undefined;

            return set(state, 'assumedBandwidthBps', assumedBandwidthBps);
        }
        case SET_FOLLOW_ME:
            return set(state, 'followMeEnabled', action.enabled);

        case SET_FOLLOW_ME_RECORDER:
            return { ...state,
                followMeRecorderEnabled: action.enabled,
                followMeEnabled: action.enabled
            };

        case SET_START_REACTIONS_MUTED:
            return set(state, 'startReactionsMuted', action.muted);

        case SET_LOCATION_URL:
            return set(state, 'room', undefined);

        case SET_OBFUSCATED_ROOM:
            return { ...state,
                obfuscatedRoom: action.obfuscatedRoom,
                obfuscatedRoomSource: action.obfuscatedRoomSource
            };

        case SET_PASSWORD:
            return _setPassword(state, action);

        case SET_PENDING_SUBJECT_CHANGE:
            return set(state, 'pendingSubjectChange', action.subject);

        case SET_ROOM:
            return _setRoom(state, action);

        case SET_START_MUTED_POLICY:
            return {
                ...state,
                startAudioMutedPolicy: action.startAudioMutedPolicy,
                startVideoMutedPolicy: action.startVideoMutedPolicy
            };

        case UPDATE_CONFERENCE_METADATA:
            return {
                ...state,
                metadata: action.metadata
            };

        case SET_CONFIG:
            return _setConfig(state, action);
        }

        return state;
    });

/**
 * Processes subject and local subject of the conference based on the new config.
 *
 * @param {Object} state - The Redux state of feature base/conference.
 * @param {Action} action - The Redux action SET_CONFIG to reduce.
 * @private
 * @returns {Object} The new state after the reduction of the specified action.
 */
function _setConfig(state: IConferenceState, { config }: { config: IConfig; }) {
    const { localSubject, subject } = config;

    return {
        ...state,
        localSubject,
        pendingSubjectChange: subject,
        subject: undefined
    };
}

/**
 * Reduces a specific Redux action AUTH_STATUS_CHANGED of the feature
 * base/conference.
 *
 * @param {Object} state - The Redux state of the feature base/conference.
 * @param {Action} action - The Redux action AUTH_STATUS_CHANGED to reduce.
 * @private
 * @returns {Object} The new state of the feature base/conference after the
 * reduction of the specified action.
 */
function _authStatusChanged(state: IConferenceState,
        { authEnabled, authLogin }: { authEnabled: boolean; authLogin: string; }) {
    return assign(state, {
        authEnabled,
        authLogin
    });
}

/**
 * Reduces a specific Redux action CONFERENCE_FAILED of the feature
 * base/conference.
 *
 * @param {Object} state - The Redux state of the feature base/conference.
 * @param {Action} action - The Redux action CONFERENCE_FAILED to reduce.
 * @private
 * @returns {Object} The new state of the feature base/conference after the
 * reduction of the specified action.
 */
function _conferenceFailed(state: IConferenceState, { conference, error }: {
    conference: IJitsiConference; error: IConferenceFailedError; }) {
    // The current (similar to getCurrentConference in
    // base/conference/functions.any.js) conference which is joining or joined:
    const conference_ = state.conference || state.joining;

    if (conference_ && conference_ !== conference) {
        return state;
    }

    let authRequired;
    let membersOnly;
    let passwordRequired;
    let lobbyWaitingForHost;

    switch (error.name) {
    case JitsiConferenceErrors.AUTHENTICATION_REQUIRED:
        authRequired = conference;
        break;

    case JitsiConferenceErrors.CONFERENCE_ACCESS_DENIED:
    case JitsiConferenceErrors.MEMBERS_ONLY_ERROR: {
        membersOnly = conference;

        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const [ _lobbyJid, _lobbyWaitingForHost ] = error.params;

        lobbyWaitingForHost = _lobbyWaitingForHost;

        break;
    }

    case JitsiConferenceErrors.PASSWORD_REQUIRED:
        passwordRequired = conference;
        break;
    }

    return assign(state, {
        authRequired,
        conference: undefined,
        e2eeSupported: undefined,
        error,
        joining: undefined,
        leaving: undefined,
        lobbyWaitingForHost,

        /**
         * The indicator of how the conference/room is locked. If falsy, the
         * conference/room is unlocked; otherwise, it's either
         * {@code LOCKED_LOCALLY} or {@code LOCKED_REMOTELY}.
         *
         * @type {string}
         */
        locked: passwordRequired ? LOCKED_REMOTELY : undefined,
        membersOnly,
        password: undefined,

        /**
         * The JitsiConference instance which requires a password to join.
         *
         * @type {JitsiConference}
         */
        passwordRequired
    });
}

/**
 * Reduces a specific Redux action CONFERENCE_JOINED of the feature
 * base/conference.
 *
 * @param {Object} state - The Redux state of the feature base/conference.
 * @param {Action} action - The Redux action CONFERENCE_JOINED to reduce.
 * @private
 * @returns {Object} The new state of the feature base/conference after the
 * reduction of the specified action.
 */
function _conferenceJoined(state: IConferenceState, { conference }: { conference: IJitsiConference; }) {
    // FIXME The indicator which determines whether a JitsiConference is locked
    // i.e. password-protected is private to lib-jitsi-meet. However, the
    // library does not fire LOCK_STATE_CHANGED upon joining a JitsiConference
    // with a password.
    // FIXME Technically JitsiConference.room is a private field.
    const locked = conference.room?.locked ? LOCKED_REMOTELY : undefined;

    return assign(state, {
        authRequired: undefined,

        /**
         * The JitsiConference instance represented by the Redux state of the
         * feature base/conference.
         *
         * @type {JitsiConference}
         */
        conference,

        e2eeSupported: conference.isE2EESupported(),

        joining: undefined,
        membersOnly: undefined,
        leaving: undefined,

        lobbyWaitingForHost: undefined,

        /**
         * The indicator which determines whether the conference is locked.
         *
         * @type {boolean}
         */
        locked,
        passwordRequired: undefined
    });
}

/**
 * Reduces a specific redux action {@link CONFERENCE_LEFT} or
 * {@link CONFERENCE_WILL_LEAVE} for the feature base/conference.
 *
 * @param {Object} state - The redux state of the feature base/conference.
 * @param {Action} action - The redux action {@code CONFERENCE_LEFT} or
 * {@code CONFERENCE_WILL_LEAVE} to reduce.
 * @private
 * @returns {Object} The next/new state of the feature base/conference after the
 * reduction of the specified action.
 */
function _conferenceLeftOrWillLeave(state: IConferenceState, { conference, type }:
    { conference: IJitsiConference; type: string; }) {
    const nextState = { ...state };

    // The redux action CONFERENCE_LEFT is the last time that we should be
    // hearing from a JitsiConference instance.
    //
    // The redux action CONFERENCE_WILL_LEAVE represents the order of the user
    // to leave a JitsiConference instance. From the user's perspective, there's
    // no going back (with respect to the instance itself). The app will perform
    // due clean-up like leaving the associated room, but the instance is no
    // longer the focus of the attention of the user and, consequently, the app.
    for (const p in state) {
        if (state[p as keyof IConferenceState] === conference) {
            nextState[p as keyof IConferenceState] = undefined;

            switch (p) {
            case 'conference':
            case 'passwordRequired':
                // XXX Clear/unset locked & password for a conference which has
                // been LOCKED_LOCALLY or LOCKED_REMOTELY.
                delete nextState.locked;
                delete nextState.password;
                break;
            }
        }
    }

    if (type === CONFERENCE_WILL_LEAVE) {
        // A CONFERENCE_WILL_LEAVE is of further consequence only if it is
        // expected i.e. if the specified conference is joining or joined.
        if (conference === state.joining || conference === state.conference) {
            /**
             * The JitsiConference instance which is currently in the process of
             * being left.
             *
             * @type {JitsiConference}
             */
            nextState.leaving = conference;
        }
    }

    return nextState;
}

/**
 * Reduces a specific Redux action CONFERENCE_WILL_JOIN of the feature
 * base/conference.
 *
 * @param {Object} state - The Redux state of the feature base/conference.
 * @param {Action} action - The Redux action CONFERENCE_WILL_JOIN to reduce.
 * @private
 * @returns {Object} The new state of the feature base/conference after the
 * reduction of the specified action.
 */
function _conferenceWillJoin(state: IConferenceState, { conference }: { conference: IJitsiConference; }) {
    return assign(state, {
        error: undefined,
        joining: conference
    });
}

/**
 * Reduces a specific Redux action LOCK_STATE_CHANGED of the feature
 * base/conference.
 *
 * @param {Object} state - The Redux state of the feature base/conference.
 * @param {Action} action - The Redux action LOCK_STATE_CHANGED to reduce.
 * @private
 * @returns {Object} The new state of the feature base/conference after the
 * reduction of the specified action.
 */
function _lockStateChanged(state: IConferenceState, { conference, locked }: { conference: Object; locked: boolean; }) {
    if (state.conference !== conference) {
        return state;
    }

    return assign(state, {
        locked: locked ? state.locked || LOCKED_REMOTELY : undefined,
        password: locked ? state.password : undefined
    });
}

/**
 * Reduces a specific Redux action P2P_STATUS_CHANGED of the feature
 * base/conference.
 *
 * @param {Object} state - The Redux state of the feature base/conference.
 * @param {Action} action - The Redux action P2P_STATUS_CHANGED to reduce.
 * @private
 * @returns {Object} The new state of the feature base/conference after the
 * reduction of the specified action.
 */
function _p2pStatusChanged(state: IConferenceState, action: AnyAction) {
    return set(state, 'p2p', action.p2p);
}

/**
 * Reduces a specific Redux action SET_PASSWORD of the feature base/conference.
 *
 * @param {Object} state - The Redux state of the feature base/conference.
 * @param {Action} action - The Redux action SET_PASSWORD to reduce.
 * @private
 * @returns {Object} The new state of the feature base/conference after the
 * reduction of the specified action.
 */
function _setPassword(state: IConferenceState, { conference, method, password }: {
    conference: IJitsiConference; method: Object; password: string; }) {
    switch (method) {
    case conference.join:
        return assign(state, {
            // 1. The JitsiConference which transitions away from
            // passwordRequired MUST remain in the redux state
            // features/base/conference until it transitions into
            // conference; otherwise, there is a span of time during which
            // the redux state does not even know that there is a
            // JitsiConference whatsoever.
            //
            // 2. The redux action setPassword will attempt to join the
            // JitsiConference so joining is an appropriate transitional
            // redux state.
            //
            // 3. The redux action setPassword will perform the same check
            // before it proceeds with the re-join.
            joining: state.conference ? state.joining : conference,
            locked: LOCKED_REMOTELY,

            /**
             * The password with which the conference is to be joined.
             *
             * @type {string}
             */
            password
        });

    case conference.lock:
        return assign(state, {
            locked: password ? LOCKED_LOCALLY : undefined,
            password
        });
    }

    return state;
}

/**
 * Reduces a specific Redux action SET_ROOM of the feature base/conference.
 *
 * @param {Object} state - The Redux state of the feature base/conference.
 * @param {Action} action - The Redux action SET_ROOM to reduce.
 * @private
 * @returns {Object} The new state of the feature base/conference after the
 * reduction of the specified action.
 */
function _setRoom(state: IConferenceState, action: AnyAction) {
    let { room } = action;

    if (!isRoomValid(room)) {
        // Technically, there are multiple values which don't represent valid
        // room names. Practically, each of them is as bad as the rest of them
        // because we can't use any of them to join a conference.
        room = undefined;
    }

    /**
     * The name of the room of the conference (to be) joined.
     *
     * @type {string}
     */
    return assign(state, {
        error: undefined,
        room
    });
}



################################################################################

## File: .\jitsi-meet\react\features\base\config\actions.ts

// @ts-expect-error
import { jitsiLocalStorage } from '@jitsi/js-utils';

import { IStore } from '../../app/types';
import { addKnownDomains } from '../known-domains/actions';
import { parseURIString } from '../util/uri';

import {
    CONFIG_WILL_LOAD,
    LOAD_CONFIG_ERROR,
    OVERWRITE_CONFIG,
    SET_CONFIG,
    UPDATE_CONFIG
} from './actionTypes';
import { IConfig } from './configType';
import { _CONFIG_STORE_PREFIX } from './constants';
import { setConfigFromURLParams } from './functions.any';


/**
 * Updates the config with new options.
 *
 * @param {Object} config - The new options (to add).
 * @returns {Function}
 */
export function updateConfig(config: IConfig) {
    return {
        type: UPDATE_CONFIG,
        config
    };
}

/**
 * Signals that the configuration (commonly known in Jitsi Meet as config.js)
 * for a specific locationURL will be loaded now.
 *
 * @param {URL} locationURL - The URL of the location which necessitated the
 * loading of a configuration.
 * @param {string} room - The name of the room (conference) for which we're loading the config for.
 * @returns {{
 *     type: CONFIG_WILL_LOAD,
 *     locationURL: URL,
 *     room: string
 * }}
 */
export function configWillLoad(locationURL: URL, room: string) {
    return {
        type: CONFIG_WILL_LOAD,
        locationURL,
        room
    };
}

/**
 * Signals that a configuration (commonly known in Jitsi Meet as config.js)
 * could not be loaded due to a specific error.
 *
 * @param {Error} error - The {@code Error} which prevented the successful
 * loading of a configuration.
 * @param {URL} locationURL - The URL of the location which necessitated the
 * loading of a configuration.
 * @returns {{
 *     type: LOAD_CONFIG_ERROR,
 *     error: Error,
 *     locationURL: URL
 * }}
 */
export function loadConfigError(error: Error, locationURL: URL) {
    return {
        type: LOAD_CONFIG_ERROR,
        error,
        locationURL
    };
}

/**
 * Overwrites some config values.
 *
 * @param {Object} config - The new options (to overwrite).
 * @returns {{
 *     type: OVERWRITE_CONFIG,
 *     config: Object
 * }}
 */
export function overwriteConfig(config: Object) {
    return {
        type: OVERWRITE_CONFIG,
        config
    };
}

/**
 * Sets the configuration represented by the feature base/config. The
 * configuration is defined and consumed by the library lib-jitsi-meet but some
 * of its properties are consumed by the application jitsi-meet as well.
 *
 * @param {Object} config - The configuration to be represented by the feature
 * base/config.
 * @returns {Function}
 */
export function setConfig(config: IConfig = {}) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const { locationURL } = getState()['features/base/connection'];

        // Now that the loading of the config was successful override the values
        // with the parameters passed in the hash part of the location URI.
        // TODO We're still in the middle ground between old Web with config,
        // and interfaceConfig used via global variables and new
        // Web and mobile reading the respective values from the redux store.
        // Only the config will be overridden on React Native, as the other
        // globals will be undefined here. It's intentional - we do not care to
        // override those configs yet.
        locationURL
            && setConfigFromURLParams(

                // On Web the config also comes from the window.config global,
                // but it is resolved in the loadConfig procedure.
                config,
                window.interfaceConfig,
                locationURL);

        let { bosh } = config;

        if (bosh) {
            // Normalize the BOSH URL.
            if (bosh.startsWith('//')) {
                // By default our config.js doesn't include the protocol.
                bosh = `${locationURL?.protocol}${bosh}`;
            } else if (bosh.startsWith('/')) {
                // Handle relative URLs, which won't work on mobile.
                const {
                    protocol,
                    host,
                    contextRoot
                } = parseURIString(locationURL?.href);

                bosh = `${protocol}//${host}${contextRoot || '/'}${bosh.substr(1)}`;
            }
            config.bosh = bosh;
        }

        dispatch({
            type: SET_CONFIG,
            config
        });
    };
}

/**
 * Stores a specific Jitsi Meet config.js object into {@code localStorage}.
 *
 * @param {string} baseURL - The base URL from which the config.js was
 * downloaded.
 * @param {Object} config - The Jitsi Meet config.js to store.
 * @returns {Function}
 */
export function storeConfig(baseURL: string, config: Object) {
    return (dispatch: IStore['dispatch']) => {
        // Try to store the configuration in localStorage. If the deployment
        // specified 'getroom' as a function, for example, it does not make
        // sense to and it will not be stored.
        let b = false;

        try {
            if (typeof window.config === 'undefined' || window.config !== config) {
                jitsiLocalStorage.setItem(`${_CONFIG_STORE_PREFIX}/${baseURL}`, JSON.stringify(config));
                b = true;
            }
        } catch (e) {
            // Ignore the error because the caching is optional.
        }

        // If base/config knows a domain, then the app knows it.
        if (b) {
            try {
                dispatch(addKnownDomains(parseURIString(baseURL)?.host));
            } catch (e) {
                // Ignore the error because the fiddling with "known domains" is
                // a side effect here.
            }
        }

        return b;
    };
}


################################################################################

## File: .\jitsi-meet\react\features\base\config\actionTypes.ts

/**
 * The redux action which signals that a configuration (commonly known in Jitsi
 * Meet as config.js) will be loaded for a specific locationURL.
 *
 * {
 *     type: CONFIG_WILL_LOAD,
 *     locationURL: URL,
 *     room: string
 * }
 */
export const CONFIG_WILL_LOAD = 'CONFIG_WILL_LOAD';

/**
 * The redux action which signals that a configuration (commonly known in Jitsi
 * Meet as config.js) could not be loaded due to a specific error.
 *
 * {
 *     type: LOAD_CONFIG_ERROR,
 *     error: Error,
 *     locationURL: URL
 * }
 */
export const LOAD_CONFIG_ERROR = 'LOAD_CONFIG_ERROR';

/**
 * The redux action which sets the configuration represented by the feature
 * base/config. The configuration is defined and consumed by the library
 * lib-jitsi-meet but some of its properties are consumed by the application
 * jitsi-meet as well.
 *
 * {
 *     type: SET_CONFIG,
 *     config: Object
 * }
 */
export const SET_CONFIG = 'SET_CONFIG';

/**
 * The redux action which updates the configuration represented by the feature
 * base/config. The configuration is defined and consumed by the library
 * lib-jitsi-meet but some of its properties are consumed by the application
 * jitsi-meet as well. A merge operation is performed between the existing config
 * and the passed object.
 *
 * {
 *     type: UPDATE_CONFIG,
 *     config: Object
 * }
 */
export const UPDATE_CONFIG = 'UPDATE_CONFIG';

/**
 * The redux action which overwrites configurations represented by the feature
 * base/config. The passed on config values overwrite the current values for given props.
 *
 * {
 *     type: OVERWRITE_CONFIG,
 *     config: Object
 * }
 */
export const OVERWRITE_CONFIG = 'OVERWRITE_CONFIG';


################################################################################

## File: .\jitsi-meet\react\features\base\config\configType.ts

import { ToolbarButton } from '../../toolbox/types';

type ButtonsWithNotifyClick = 'camera' |
    'chat' |
    'closedcaptions' |
    'desktop' |
    'download' |
    'embedmeeting' |
    'end-meeting' |
    'etherpad' |
    'feedback' |
    'filmstrip' |
    'fullscreen' |
    'hangup' |
    'hangup-menu' |
    'help' |
    'invite' |
    'livestreaming' |
    'microphone' |
    'mute-everyone' |
    'mute-video-everyone' |
    'participants-pane' |
    'profile' |
    'raisehand' |
    'recording' |
    'security' |
    'select-background' |
    'settings' |
    'shareaudio' |
    'sharedvideo' |
    'shortcuts' |
    'stats' |
    'tileview' |
    'toggle-camera' |
    'videoquality' |
    'add-passcode' |
    '__end';

type ParticipantMenuButtonsWithNotifyClick = 'allow-video' |
    'ask-unmute' |
    'conn-status' |
    'flip-local-video' |
    'grant-moderator' |
    'hide-self-view' |
    'kick' |
    'mute' |
    'mute-others' |
    'mute-others-video' |
    'mute-video' |
    'pinToStage' |
    'privateMessage' |
    'remote-control' |
    'send-participant-to-room' |
    'verify';

type NotifyClickButtonKey = string |
    ButtonsWithNotifyClick |
    ParticipantMenuButtonsWithNotifyClick;

export type NotifyClickButton = NotifyClickButtonKey |
    {
        key: NotifyClickButtonKey;
        preventExecution: boolean;
    };

export type Sounds = 'ASKED_TO_UNMUTE_SOUND' |
    'E2EE_OFF_SOUND' |
    'E2EE_ON_SOUND' |
    'INCOMING_MSG_SOUND' |
    'KNOCKING_PARTICIPANT_SOUND' |
    'LIVE_STREAMING_OFF_SOUND' |
    'LIVE_STREAMING_ON_SOUND' |
    'NO_AUDIO_SIGNAL_SOUND' |
    'NOISY_AUDIO_INPUT_SOUND' |
    'OUTGOING_CALL_EXPIRED_SOUND' |
    'OUTGOING_CALL_REJECTED_SOUND' |
    'OUTGOING_CALL_RINGING_SOUND' |
    'OUTGOING_CALL_START_SOUND' |
    'PARTICIPANT_JOINED_SOUND' |
    'PARTICIPANT_LEFT_SOUND' |
    'RAISE_HAND_SOUND' |
    'REACTION_SOUND' |
    'RECORDING_OFF_SOUND' |
    'RECORDING_ON_SOUND' |
    'TALK_WHILE_MUTED_SOUND';


export interface IMobileDynamicLink {
    apn: string;
    appCode: string;
    customDomain?: string;
    ibi: string;
    isi: string;
}

export interface IDeeplinkingPlatformConfig {
    appName: string;
    appScheme: string;
}

export interface IDeeplinkingMobileConfig extends IDeeplinkingPlatformConfig {
    appPackage?: string;
    downloadLink: string;
    dynamicLink?: IMobileDynamicLink;
    fDroidUrl?: string;
}

export interface IDesktopDownloadConfig {
    linux?: string;
    macos?: string;
    windows?: string;
}

export interface IDeeplinkingDesktopConfig extends IDeeplinkingPlatformConfig {
    download?: IDesktopDownloadConfig;
    enabled: boolean;
}

export interface IDeeplinkingConfig {
    android?: IDeeplinkingMobileConfig;
    desktop?: IDeeplinkingDesktopConfig;
    disabled?: boolean;
    hideLogo?: boolean;
    ios?: IDeeplinkingMobileConfig;
}

export interface INoiseSuppressionConfig {
    krisp?: {
        debugLogs?: boolean;
        enabled?: boolean;
        logProcessStats?: boolean;
    };
}

export interface IWhiteboardConfig {
    collabServerBaseUrl?: string;
    enabled?: boolean;
    limitUrl?: string;
    userLimit?: number;
}

export interface IWatchRTCConfiguration {
    allowBrowserLogCollection?: boolean;
    collectionInterval?: number;
    console?: {
        level: string;
        override: boolean;
    };
    debug?: boolean;
    keys?: any;
    logGetStats?: boolean;
    proxyUrl?: string;
    rtcApiKey: string;
    rtcPeerId?: string;
    rtcRoomId?: string;
    rtcTags?: string[];
    rtcToken?: string;
    wsUrl?: string;
}

export interface IConfig {
    _desktopSharingSourceDevice?: string;
    _immediateReloadThreshold?: string;
    _screenshotHistoryRegionUrl?: number;
    analytics?: {
        amplitudeAPPKey?: string;
        amplitudeIncludeUTM?: boolean;
        blackListedEvents?: string[];
        disabled?: boolean;
        googleAnalyticsTrackingId?: string;
        matomoEndpoint?: string;
        matomoSiteID?: string;
        obfuscateRoomName?: boolean;
        rtcstatsEnabled?: boolean;
        rtcstatsEndpoint?: string;
        rtcstatsPollInterval?: number;
        rtcstatsSendSdp?: boolean;
        rtcstatsStoreLogs?: boolean;
        rtcstatsUseLegacy?: boolean;
        scriptURLs?: Array<string>;
        watchRTCEnabled?: boolean;
        whiteListedEvents?: string[];
    };
    apiLogLevels?: Array<'warn' | 'log' | 'error' | 'info' | 'debug'>;
    appId?: string;
    audioLevelsInterval?: number;
    audioQuality?: {
        opusMaxAverageBitrate?: number | null;
        stereo?: boolean;
    };
    autoCaptionOnRecord?: boolean;
    autoKnockLobby?: boolean;
    backgroundAlpha?: number;
    bosh?: string;
    brandingDataUrl?: string;
    brandingRoomAlias?: string;
    breakoutRooms?: {
        hideAddRoomButton?: boolean;
        hideAutoAssignButton?: boolean;
        hideJoinRoomButton?: boolean;
    };
    buttonsWithNotifyClick?: Array<ButtonsWithNotifyClick | {
        key: ButtonsWithNotifyClick;
        preventExecution: boolean;
    }>;
    callDisplayName?: string;
    callFlowsEnabled?: boolean;
    callHandle?: string;
    callUUID?: string;
    cameraFacingMode?: string;
    channelLastN?: number;
    chromeExtensionBanner?: {
        chromeExtensionsInfo?: Array<{ id: string; path: string; }>;
        edgeUrl?: string;
        url?: string;
    };
    conferenceInfo?: {
        alwaysVisible?: Array<string>;
        autoHide?: Array<string>;
    };
    conferenceRequestUrl?: string;
    connectionIndicators?: {
        autoHide?: boolean;
        autoHideTimeout?: number;
        disableDetails?: boolean;
        disabled?: boolean;
        inactiveDisabled?: boolean;
    };
    constraints?: {
        video?: {
            height?: {
                ideal?: number;
                max?: number;
                min?: number;
            };
        };
    };
    corsAvatarURLs?: Array<string>;
    customParticipantMenuButtons?: Array<{ icon: string; id: string; text: string; }>;
    customToolbarButtons?: Array<{ backgroundColor?: string; icon: string; id: string; text: string; }>;
    deeplinking?: IDeeplinkingConfig;
    defaultLanguage?: string;
    defaultLocalDisplayName?: string;
    defaultLogoUrl?: string;
    defaultRemoteDisplayName?: string;
    deploymentInfo?: {
        envType?: string;
        environment?: string;
        product?: string;
        region?: string;
        shard?: string;
        userRegion?: string;
    };
    deploymentUrls?: {
        downloadAppsUrl?: string;
        userDocumentationURL?: string;
    };
    desktopSharingFrameRate?: {
        max?: number;
        min?: number;
    };
    dialInConfCodeUrl?: string;
    dialInNumbersUrl?: string;
    dialOutAuthUrl?: string;
    dialOutRegionUrl?: string;
    disable1On1Mode?: boolean | null;
    disableAddingBackgroundImages?: boolean;
    disableAudioLevels?: boolean;
    disableBeforeUnloadHandlers?: boolean;
    disableChatSmileys?: boolean;
    disableDeepLinking?: boolean;
    disableFilmstripAutohiding?: boolean;
    disableFocus?: boolean;
    disableIframeAPI?: boolean;
    disableIncomingMessageSound?: boolean;
    disableInitialGUM?: boolean;
    disableInviteFunctions?: boolean;
    disableJoinLeaveSounds?: boolean;
    disableLocalVideoFlip?: boolean;
    disableModeratorIndicator?: boolean;
    disablePolls?: boolean;
    disableProfile?: boolean;
    disableReactions?: boolean;
    disableReactionsModeration?: boolean;
    disableRecordAudioNotification?: boolean;
    disableRemoteMute?: boolean;
    disableRemoveRaisedHandOnFocus?: boolean;
    disableResponsiveTiles?: boolean;
    disableRtx?: boolean;
    disableSelfDemote?: boolean;
    disableSelfView?: boolean;
    disableSelfViewSettings?: boolean;
    disableShortcuts?: boolean;
    disableShowMoreStats?: boolean;
    disableSimulcast?: boolean;
    disableSpeakerStatsSearch?: boolean;
    disableThirdPartyRequests?: boolean;
    disableTileEnlargement?: boolean;
    disableTileView?: boolean;
    disableVirtualBackground?: boolean;
    disabledNotifications?: Array<string>;
    disabledSounds?: Array<Sounds>;
    doNotFlipLocalVideo?: boolean;
    doNotStoreRoom?: boolean;
    dropbox?: {
        appKey: string;
        redirectURI?: string;
    };
    dynamicBrandingUrl?: string;
    e2ee?: {
        externallyManagedKey?: boolean;
        labels?: {
            description?: string;
            label?: string;
            tooltip?: string;
            warning?: string;
        };
    };
    e2eeLabels?: {
        description?: string;
        label?: string;
        tooltip?: string;
        warning?: string;
    };
    e2eping?: {
        enabled?: boolean;
        maxConferenceSize?: number;
        maxMessagesPerSecond?: number;
        numRequests?: number;
    };
    enableAutomaticUrlCopy?: boolean;
    enableCalendarIntegration?: boolean;
    enableClosePage?: boolean;
    enableDisplayNameInStats?: boolean;
    enableEmailInStats?: boolean;
    enableEncodedTransformSupport?: boolean;
    enableForcedReload?: boolean;
    enableInsecureRoomNameWarning?: boolean;
    enableLobbyChat?: boolean;
    enableNoAudioDetection?: boolean;
    enableNoisyMicDetection?: boolean;
    enableOpusRed?: boolean;
    enableRemb?: boolean;
    enableSaveLogs?: boolean;
    enableTcc?: boolean;
    enableWebHIDFeature?: boolean;
    enableWelcomePage?: boolean;
    etherpad_base?: string;
    faceLandmarks?: {
        captureInterval?: number;
        enableDisplayFaceExpressions?: boolean;
        enableFaceCentering?: boolean;
        enableFaceExpressionsDetection?: boolean;
        enableRTCStats?: boolean;
        faceCenteringThreshold?: number;
    };
    feedbackPercentage?: number;
    fileRecordingsEnabled?: boolean;
    fileRecordingsServiceEnabled?: boolean;
    fileRecordingsServiceSharingEnabled?: boolean;
    filmstrip?: {
        disableResizable?: boolean;
        disableStageFilmstrip?: boolean;
        disableTopPanel?: boolean;
        disabled?: boolean;
        minParticipantCountForTopPanel?: number;
    };
    firefox_fake_device?: string;
    flags?: {
        ssrcRewritingEnabled: boolean;
    };
    focusUserJid?: string;
    gatherStats?: boolean;
    giphy?: {
        displayMode?: 'all' | 'tile' | 'chat';
        enabled?: boolean;
        rating?: 'g' | 'pg' | 'pg-13' | 'r';
        sdkKey?: string;
        tileTime?: number;
    };
    googleApiApplicationClientID?: string;
    gravatar?: {
        baseUrl?: string;
        disabled?: boolean;
    };
    gravatarBaseURL?: string;
    guestDialOutStatusUrl?: string;
    guestDialOutUrl?: string;
    helpCentreURL?: string;
    hiddenPremeetingButtons?: Array<'microphone' | 'camera' | 'select-background' | 'invite' | 'settings'>;
    hideAddRoomButton?: boolean;
    hideConferenceSubject?: boolean;
    hideConferenceTimer?: boolean;
    hideDisplayName?: boolean;
    hideDominantSpeakerBadge?: boolean;
    hideEmailInSettings?: boolean;
    hideLobbyButton?: boolean;
    hideLoginButton?: boolean;
    hideParticipantsStats?: boolean;
    hideRecordingLabel?: boolean;
    hosts?: {
        anonymousdomain?: string;
        authdomain?: string;
        domain: string;
        focus?: string;
        muc: string;
        visitorFocus?: string;
    };
    iAmRecorder?: boolean;
    iAmSipGateway?: boolean;
    inviteAppName?: string | null;
    inviteServiceCallFlowsUrl?: string;
    inviteServiceUrl?: string;
    jaasActuatorUrl?: string;
    jaasConferenceCreatorUrl?: string;
    jaasFeedbackMetadataURL?: string;
    jaasTokenUrl?: string;
    legalUrls?: {
        helpCentre: string;
        privacy: string;
        security: string;
        terms: string;
    };
    liveStreaming?: {
        dataPrivacyLink?: string;
        enabled?: boolean;
        helpLink?: string;
        termsLink?: string;
        validatorRegExpString?: string;
    };
    liveStreamingEnabled?: boolean;
    lobby?: {
        autoKnock?: boolean;
        enableChat?: boolean;
    };
    localRecording?: {
        disable?: boolean;
        disableSelfRecording?: boolean;
        notifyAllParticipants?: boolean;
    };
    localSubject?: string;
    locationURL?: URL;
    mainToolbarButtons?: Array<Array<string>>;
    maxFullResolutionParticipants?: number;
    microsoftApiApplicationClientID?: string;
    moderatedRoomServiceUrl?: string;
    mouseMoveCallbackInterval?: number;
    noiseSuppression?: INoiseSuppressionConfig;
    noticeMessage?: string;
    notificationTimeouts?: {
        long?: number;
        medium?: number;
        short?: number;
    };
    notifications?: Array<string>;
    openSharedDocumentOnJoin?: boolean;
    opusMaxAverageBitrate?: number;
    p2p?: {
        backToP2PDelay?: number;
        codecPreferenceOrder?: Array<string>;
        enabled?: boolean;
        iceTransportPolicy?: string;
        mobileCodecPreferenceOrder?: Array<string>;
        stunServers?: Array<{ urls: string; }>;
    };
    participantMenuButtonsWithNotifyClick?: Array<string | ParticipantMenuButtonsWithNotifyClick | {
        key: string | ParticipantMenuButtonsWithNotifyClick;
        preventExecution: boolean;
    }>;
    participantsPane?: {
        enabled?: boolean;
        hideModeratorSettingsTab?: boolean;
        hideMoreActionsButton?: boolean;
        hideMuteAllButton?: boolean;
    };
    pcStatsInterval?: number;
    peopleSearchQueryTypes?: string[];
    peopleSearchTokenLocation?: string;
    peopleSearchUrl?: string;
    preferBosh?: boolean;
    preferVisitor?: boolean;
    preferredTranscribeLanguage?: string;
    prejoinConfig?: {
        enabled?: boolean;
        hideDisplayName?: boolean;
        hideExtraJoinButtons?: Array<string>;
    };
    prejoinPageEnabled?: boolean;
    raisedHands?: {
        disableLowerHandByModerator?: boolean;
        disableLowerHandNotification?: boolean;
        disableNextSpeakerNotification?: boolean;
        disableRemoveRaisedHandOnFocus?: boolean;
    };
    readOnlyName?: boolean;
    recordingLimit?: {
        appName?: string;
        appURL?: string;
        limit?: number;
    };
    recordingService?: {
        enabled?: boolean;
        hideStorageWarning?: boolean;
        sharingEnabled?: boolean;
    };
    recordingSharingUrl?: string;
    recordings?: {
        recordAudioAndVideo?: boolean;
        showPrejoinWarning?: boolean;
        suggestRecording?: boolean;
    };
    remoteVideoMenu?: {
        disableDemote?: boolean;
        disableGrantModerator?: boolean;
        disableKick?: boolean;
        disablePrivateChat?: boolean;
        disabled?: boolean;
    };
    replaceParticipant?: string;
    requireDisplayName?: boolean;
    resolution?: number;
    roomPasswordNumberOfDigits?: number;
    salesforceUrl?: string;
    screenshotCapture?: {
        enabled?: boolean;
        mode?: 'always' | 'recording';
    };
    securityUi?: {
        disableLobbyPassword?: boolean;
        hideLobbyButton?: boolean;
    };
    serviceUrl?: string;
    sharedVideoAllowedURLDomains?: Array<string>;
    sipInviteUrl?: string;
    speakerStats?: {
        disableSearch?: boolean;
        disabled?: boolean;
        order?: Array<'role' | 'name' | 'hasLeft'>;
    };
    speakerStatsOrder?: Array<'role' | 'name' | 'hasLeft'>;
    startAudioMuted?: number;
    startAudioOnly?: boolean;
    startLastN?: number;
    startScreenSharing?: boolean;
    startSilent?: boolean;
    startVideoMuted?: number;
    startWithAudioMuted?: boolean;
    startWithVideoMuted?: boolean;
    stereo?: boolean;
    subject?: string;
    testing?: {
        assumeBandwidth?: boolean;
        disableE2EE?: boolean;
        dumpTranscript?: boolean;
        noAutoPlayVideo?: boolean;
        p2pTestMode?: boolean;
        skipInterimTranscriptions?: boolean;
        testMode?: boolean;
    };
    tileView?: {
        disabled?: boolean;
        numberOfVisibleTiles?: number;
    };
    tokenAuthUrl?: string;
    tokenAuthUrlAutoRedirect?: string;
    tokenLogoutUrl?: string;
    toolbarButtons?: Array<ToolbarButton>;
    toolbarConfig?: {
        alwaysVisible?: boolean;
        autoHideWhileChatIsOpen?: boolean;
        initialTimeout?: number;
        timeout?: number;
    };
    transcribeWithAppLanguage?: boolean;
    transcribingEnabled?: boolean;
    transcription?: {
        autoTranscribeOnRecord?: boolean;
        enabled?: boolean;
        preferredLanguage?: string;
        translationLanguages?: Array<string>;
        translationLanguagesHead?: Array<string>;
        useAppLanguage?: boolean;
    };
    useHostPageLocalStorage?: boolean;
    useTurnUdp?: boolean;
    videoQuality?: {
        codecPreferenceOrder?: Array<string>;
        maxBitratesVideo?: {
            [key: string]: {
                high?: number;
                low?: number;
                standard?: number;
            };
        };
        minHeightForQualityLvl?: {
            [key: number]: string;
        };
        mobileCodecPreferenceOrder?: Array<string>;
        persist?: boolean;
    };
    watchRTCConfigParams?: IWatchRTCConfiguration;
    webhookProxyUrl?: string;
    webrtcIceTcpDisable?: boolean;
    webrtcIceUdpDisable?: boolean;
    websocket?: string;
    websocketKeepAliveUrl?: string;
    welcomePage?: {
        customUrl?: string;
        disabled?: boolean;
    };
    whiteboard?: IWhiteboardConfig;
}


################################################################################

## File: .\jitsi-meet\react\features\base\config\configWhitelist.ts

import extraConfigWhitelist from './extraConfigWhitelist';

/**
 * The config keys to whitelist, the keys that can be overridden.
 * Whitelisting a key allows all properties under that key to be overridden.
 * For example whitelisting 'p2p' allows 'p2p.enabled' to be overridden, and
 * overriding 'p2p.enabled' does not modify any other keys under 'p2p'.
 * The whitelist is used only for config.js.
 *
 * @type Array
 */
export default [
    '_desktopSharingSourceDevice',
    '_peerConnStatusOutOfLastNTimeout',
    '_peerConnStatusRtcMuteTimeout',
    'analytics.disabled',
    'analytics.rtcstatsEnabled',
    'analytics.watchRTCEnabled',
    'audioLevelsInterval',
    'audioQuality',
    'autoKnockLobby',
    'apiLogLevels',
    'avgRtpStatsN',
    'backgroundAlpha',
    'breakoutRooms',
    'bridgeChannel',
    'buttonsWithNotifyClick',

    /**
     * The display name of the CallKit call representing the conference/meeting
     * associated with this config.js including while the call is ongoing in the
     * UI presented by CallKit and in the system-wide call history. The property
     * is meant for use cases in which the room name is not desirable as a
     * display name for CallKit purposes and the desired display name is not
     * provided in the form of a JWT callee. As the value is associated with a
     * conference/meeting, the value makes sense not as a deployment-wide
     * configuration, only as a runtime configuration override/overwrite
     * provided by, for example, Jitsi Meet SDK for iOS.
     *
     * @type string
     */
    'callDisplayName',
    'callFlowsEnabled',

    /**
     * The handle
     * ({@link https://developer.apple.com/documentation/callkit/cxhandle}) of
     * the CallKit call representing the conference/meeting associated with this
     * config.js. The property is meant for use cases in which the room URL is
     * not desirable as the handle for CallKit purposes. As the value is
     * associated with a conference/meeting, the value makes sense not as a
     * deployment-wide configuration, only as a runtime configuration
     * override/overwrite provided by, for example, Jitsi Meet SDK for iOS.
     *
     * @type string
     */
    'callHandle',

    /**
     * The UUID of the CallKit call representing the conference/meeting
     * associated with this config.js. The property is meant for use cases in
     * which Jitsi Meet is to work with a CallKit call created outside of Jitsi
     * Meet and to be adopted by Jitsi Meet such as, for example, an incoming
     * and/or outgoing CallKit call created by Jitsi Meet SDK for iOS
     * clients/consumers prior to giving control to Jitsi Meet. As the value is
     * associated with a conference/meeting, the value makes sense not as a
     * deployment-wide configuration, only as a runtime configuration
     * override/overwrite provided by, for example, Jitsi Meet SDK for iOS.
     *
     * @type string
     */
    'callUUID',

    'cameraFacingMode',
    'conferenceInfo',
    'channelLastN',
    'connectionIndicators',
    'constraints',
    'customToolbarButtons',
    'brandingRoomAlias',
    'debug',
    'debugAudioLevels',
    'deeplinking.disabled',
    'deeplinking.desktop.enabled',
    'defaultLocalDisplayName',
    'defaultRemoteDisplayName',
    'deploymentUrls',
    'desktopSharingFrameRate',
    'desktopSharingSources',
    'disable1On1Mode',
    'disableAEC',
    'disableAGC',
    'disableAP',
    'disableAddingBackgroundImages',
    'disableAudioLevels',
    'disableBeforeUnloadHandlers',
    'disableChatSmileys',
    'disableDeepLinking',
    'disabledNotifications',
    'disabledSounds',
    'disableFilmstripAutohiding',
    'disableInitialGUM',
    'disableHPF',
    'disableInviteFunctions',
    'disableIncomingMessageSound',
    'disableJoinLeaveSounds',
    'disableLocalVideoFlip',
    'disableModeratorIndicator',
    'disableNS',
    'disablePolls',
    'disableProfile',
    'disableReactions',
    'disableReactionsModeration',
    'disableRecordAudioNotification',
    'disableRemoteControl',
    'disableRemoteMute',
    'disableResponsiveTiles',
    'disableRtx',
    'disableSelfDemote',
    'disableSelfView',
    'disableSelfViewSettings',
    'disableShortcuts',
    'disableShowMoreStats',
    'disableRemoveRaisedHandOnFocus',
    'disableSpeakerStatsSearch',
    'speakerStatsOrder',
    'disableSimulcast',
    'disableThirdPartyRequests',
    'disableTileView',
    'disableTileEnlargement',
    'disableVirtualBackground',
    'displayJids',
    'doNotStoreRoom',
    'doNotFlipLocalVideo',
    'dropbox',
    'e2eeLabels',
    'e2ee',
    'e2eping',
    'enableDisplayNameInStats',
    'enableEmailInStats',
    'enableEncodedTransformSupport',
    'enableInsecureRoomNameWarning',
    'enableLobbyChat',
    'enableOpusRed',
    'enableRemb',
    'enableSaveLogs',
    'enableTalkWhileMuted',
    'enableNoAudioDetection',
    'enableNoisyMicDetection',
    'enableTcc',
    'enableAutomaticUrlCopy',
    'etherpad_base',
    'faceLandmarks',
    'failICE',
    'feedbackPercentage',
    'fileRecordingsEnabled',
    'filmstrip',
    'firefox_fake_device',
    'flags',
    'forceTurnRelay',
    'gatherStats',
    'giphy',
    'googleApiApplicationClientID',
    'gravatar.disabled',
    'hiddenPremeetingButtons',
    'hideConferenceSubject',
    'hideDisplayName',
    'hideDominantSpeakerBadge',
    'hideRecordingLabel',
    'hideParticipantsStats',
    'hideConferenceTimer',
    'hiddenDomain',
    'hideAddRoomButton',
    'hideEmailInSettings',
    'hideLobbyButton',
    'hosts',
    'iAmRecorder',
    'iAmSipGateway',
    'iceTransportPolicy',
    'ignoreStartMuted',
    'inviteAppName',
    'liveStreaming',
    'liveStreamingEnabled',
    'lobby',
    'localRecording',
    'localSubject',
    'logging',
    'mainToolbarButtons',
    'maxFullResolutionParticipants',
    'mouseMoveCallbackInterval',
    'notifications',
    'notificationTimeouts',
    'openSharedDocumentOnJoin',
    'opusMaxAverageBitrate',
    'p2p',
    'participantMenuButtonsWithNotifyClick',
    'participantsPane',
    'pcStatsInterval',
    'preferBosh',
    'preferVisitor',
    'prejoinConfig',
    'prejoinPageEnabled',
    'raisedHands',
    'recordingService',
    'requireDisplayName',
    'remoteVideoMenu',
    'roomPasswordNumberOfDigits',
    'readOnlyName',
    'recordings',
    'replaceParticipant',
    'resolution',
    'salesforceUrl',
    'screenshotCapture',
    'securityUi',
    'speakerStats',
    'startAudioMuted',
    'startAudioOnly',
    'startLastN',
    'startScreenSharing',
    'startSilent',
    'startVideoMuted',
    'startWithAudioMuted',
    'startWithVideoMuted',
    'stereo',
    'subject',
    'testing',
    'toolbarButtons',
    'toolbarConfig',
    'tileView',
    'transcribingEnabled',
    'transcription',
    'useHostPageLocalStorage',
    'useTurnUdp',
    'videoQuality',
    'visitors',
    'watchRTCConfigParams',
    'webrtcIceTcpDisable',
    'webrtcIceUdpDisable',
    'whiteboard.enabled'
].concat(extraConfigWhitelist);


################################################################################

## File: .\jitsi-meet\react\features\base\config\constants.ts

/**
 * The prefix of the {@code localStorage} key into which {@link storeConfig}
 * stores and from which {@link restoreConfig} restores.
 *
 * @protected
 * @type string
 */
export const _CONFIG_STORE_PREFIX = 'config.js';

/**
 * The toolbar buttons to show on premeeting screens.
 */
export const PREMEETING_BUTTONS = [ 'microphone', 'camera', 'select-background', 'invite', 'settings' ];

/**
  * The toolbar buttons to show on 3rdParty prejoin screen.
  */
export const THIRD_PARTY_PREJOIN_BUTTONS = [ 'microphone', 'camera', 'select-background' ];

/**
 * The set of feature flags.
 *
 * @enum {string}
 */

export const FEATURE_FLAGS = {
    SSRC_REWRITING: 'ssrcRewritingEnabled'
};

/**
 * The URL at which the terms (of service/use) are available to the user.
 */
export const DEFAULT_TERMS_URL = 'https://jitsi.org/meet/terms';

/**
 * The URL at which the privacy policy is available to the user.
 */
export const DEFAULT_PRIVACY_URL = 'https://jitsi.org/meet/privacy';

/**
 * The URL at which the help centre is available to the user.
 */
export const DEFAULT_HELP_CENTRE_URL = 'https://web-cdn.jitsi.net/faq/meet-faq.html';


################################################################################

## File: .\jitsi-meet\react\features\base\config\extraConfigWhitelist.ts

/**
 * Deploy-specific configuration whitelists.
 */
export default [];


################################################################################

## File: .\jitsi-meet\react\features\base\config\functions.any.ts

// @ts-ignore
import { jitsiLocalStorage } from '@jitsi/js-utils';
// eslint-disable-next-line lines-around-comment
// @ts-ignore
import { safeJsonParse } from '@jitsi/js-utils/json';
import { isEmpty, mergeWith, pick } from 'lodash-es';

import { IReduxState } from '../../app/types';
import { getLocalParticipant } from '../participants/functions';
import { parseURLParams } from '../util/parseURLParams';

import { IConfig } from './configType';
import CONFIG_WHITELIST from './configWhitelist';
import {
    DEFAULT_HELP_CENTRE_URL,
    DEFAULT_PRIVACY_URL,
    DEFAULT_TERMS_URL,
    FEATURE_FLAGS,
    _CONFIG_STORE_PREFIX
} from './constants';
import INTERFACE_CONFIG_WHITELIST from './interfaceConfigWhitelist';
import logger from './logger';

// XXX The function getRoomName is split out of
// functions.any.js because it is bundled in both app.bundle and
// do_external_connect, webpack 1 does not support tree shaking, and we don't
// want all functions to be bundled in do_external_connect.
export { default as getRoomName } from './getRoomName';

/**
 * Create a "fake" configuration object for the given base URL. This is used in case the config
 * couldn't be loaded in the welcome page, so at least we have something to try with.
 *
 * @param {string} baseURL - URL of the deployment for which we want the fake config.
 * @returns {Object}
 */
export function createFakeConfig(baseURL: string) {
    const url = new URL(baseURL);

    return {
        hosts: {
            domain: url.hostname,
            muc: `conference.${url.hostname}`
        },
        bosh: `${baseURL}http-bind`,
        p2p: {
            enabled: true
        }
    };
}

/**
 * Selector used to get the meeting region.
 *
 * @param {Object} state - The global state.
 * @returns {string}
 */
export function getMeetingRegion(state: IReduxState) {
    return state['features/base/config']?.deploymentInfo?.region || '';
}

/**
 * Selector used to get the SSRC-rewriting feature flag.
 *
 * @param {Object} state - The global state.
 * @returns {boolean}
 */
export function getSsrcRewritingFeatureFlag(state: IReduxState) {
    return getFeatureFlag(state, FEATURE_FLAGS.SSRC_REWRITING) ?? true;
}

/**
 * Selector used to get a feature flag.
 *
 * @param {Object} state - The global state.
 * @param {string} featureFlag - The name of the feature flag.
 * @returns {boolean}
 */
export function getFeatureFlag(state: IReduxState, featureFlag: string) {
    const featureFlags = state['features/base/config']?.flags || {};

    return featureFlags[featureFlag as keyof typeof featureFlags];
}

/**
 * Selector used to get the disableRemoveRaisedHandOnFocus.
 *
 * @param {Object} state - The global state.
 * @returns {boolean}
 */
export function getDisableRemoveRaisedHandOnFocus(state: IReduxState) {
    return state['features/base/config']?.raisedHands?.disableRemoveRaisedHandOnFocus || false;
}

/**
 * Selector used to get the disableLowerHandByModerator.
 *
 * @param {Object} state - The global state.
 * @returns {boolean}
 */
export function getDisableLowerHandByModerator(state: IReduxState) {
    return state['features/base/config']?.raisedHands?.disableLowerHandByModerator || false;
}

/**
 * Selector used to get the disableLowerHandNotification.
 *
 * @param {Object} state - The global state.
 * @returns {boolean}
 */
export function getDisableLowerHandNotification(state: IReduxState) {
    return state['features/base/config']?.raisedHands?.disableLowerHandNotification || true;
}

/**
 * Selector used to get the disableNextSpeakerNotification.
 *
 * @param {Object} state - The global state.
 * @returns {boolean}
 */
export function getDisableNextSpeakerNotification(state: IReduxState) {
    return state['features/base/config']?.raisedHands?.disableNextSpeakerNotification || false;
}

/**
 * Selector used to get the endpoint used for fetching the recording.
 *
 * @param {Object} state - The global state.
 * @returns {string}
 */
export function getRecordingSharingUrl(state: IReduxState) {
    return state['features/base/config'].recordingSharingUrl;
}

/**
 * Overrides JSON properties in {@code config} and
 * {@code interfaceConfig} Objects with the values from {@code newConfig}.
 * Overrides only the whitelisted keys.
 *
 * @param {Object} config - The config Object in which we'll be overriding
 * properties.
 * @param {Object} interfaceConfig - The interfaceConfig Object in which we'll
 * be overriding properties.
 * @param {Object} json - Object containing configuration properties.
 * Destination object is selected based on root property name:
 * {
 *     config: {
 *         // config.js properties here
 *     },
 *     interfaceConfig: {
 *         // interface_config.js properties here
 *     }
 * }.
 * @returns {void}
 */
export function overrideConfigJSON(config: IConfig, interfaceConfig: any, json: any) {
    for (const configName of Object.keys(json)) {
        let configObj;

        if (configName === 'config') {
            configObj = config;
        } else if (configName === 'interfaceConfig') {
            configObj = interfaceConfig;
        }
        if (configObj) {
            const configJSON
                = getWhitelistedJSON(configName as 'interfaceConfig' | 'config', json[configName]);

            if (!isEmpty(configJSON)) {
                logger.info(`Extending ${configName} with: ${JSON.stringify(configJSON)}`);

                // eslint-disable-next-line arrow-body-style
                mergeWith(configObj, configJSON, (oldValue, newValue) => {

                    // XXX We don't want to merge the arrays, we want to
                    // overwrite them.
                    return Array.isArray(oldValue) ? newValue : undefined;
                });
            }
        }
    }
}

/* eslint-enable max-params, no-shadow */

/**
 * Apply whitelist filtering for configs with whitelists.
 * Only extracts overridden values for keys we allow to be overridden.
 *
 * @param {string} configName - The config name, one of config or interfaceConfig.
 * @param {Object} configJSON - The object with keys and values to override.
 * @returns {Object} - The result object only with the keys
 * that are whitelisted.
 */
export function getWhitelistedJSON(configName: 'interfaceConfig' | 'config', configJSON: any): Object {
    if (configName === 'interfaceConfig') {
        return pick(configJSON, INTERFACE_CONFIG_WHITELIST);
    } else if (configName === 'config') {
        return pick(configJSON, CONFIG_WHITELIST);
    }

    return configJSON;
}

/**
 * Selector for determining if the display name is read only.
 *
 * @param {Object} state - The state of the app.
 * @returns {boolean}
 */
export function isNameReadOnly(state: IReduxState): boolean {
    return Boolean(state['features/base/config'].disableProfile
        || state['features/base/config'].readOnlyName);
}

/**
 * Selector for determining if the participant is the next one in the queue to speak.
 *
 * @param {Object} state - The state of the app.
 * @returns {boolean}
 */
export function isNextToSpeak(state: IReduxState): boolean {
    const raisedHandsQueue = state['features/base/participants'].raisedHandsQueue || [];
    const participantId = getLocalParticipant(state)?.id;

    return participantId === raisedHandsQueue[0]?.id;
}

/**
 * Selector for determining if the next to speak participant in the queue has been notified.
 *
 * @param {Object} state - The state of the app.
 * @returns {boolean}
 */
export function hasBeenNotified(state: IReduxState): boolean {
    const raisedHandsQueue = state['features/base/participants'].raisedHandsQueue;

    return Boolean(raisedHandsQueue[0]?.hasBeenNotified);
}

/**
 * Selector for determining if the display name is visible.
 *
 * @param {Object} state - The state of the app.
 * @returns {boolean}
 */
export function isDisplayNameVisible(state: IReduxState): boolean {
    return !state['features/base/config'].hideDisplayName;
}

/**
 * Restores a Jitsi Meet config.js from {@code localStorage} if it was
 * previously downloaded from a specific {@code baseURL} and stored with
 * {@link storeConfig}.
 *
 * @param {string} baseURL - The base URL from which the config.js was
 * previously downloaded and stored with {@code storeConfig}.
 * @returns {?Object} The Jitsi Meet config.js which was previously downloaded
 * from {@code baseURL} and stored with {@code storeConfig} if it was restored;
 * otherwise, {@code undefined}.
 */
export function restoreConfig(baseURL: string) {
    const key = `${_CONFIG_STORE_PREFIX}/${baseURL}`;
    const config = jitsiLocalStorage.getItem(key);

    if (config) {
        try {
            return safeJsonParse(config) || undefined;
        } catch (e) {
            // Somehow incorrect data ended up in the storage. Clean it up.
            jitsiLocalStorage.removeItem(key);
        }
    }

    return undefined;
}

/**
 * Inspects the hash part of the location URI and overrides values specified
 * there in the corresponding config objects given as the arguments. The syntax
 * is: {@code https://server.com/room#config.debug=true
 * &interfaceConfig.showButton=false}.
 *
 * In the hash part each parameter will be parsed to JSON and then the root
 * object will be matched with the corresponding config object given as the
 * argument to this function.
 *
 * @param {Object} config - This is the general config.
 * @param {Object} interfaceConfig - This is the interface config.
 * @param {URI} location - The new location to which the app is navigating to.
 * @returns {void}
 */
export function setConfigFromURLParams(
        config: IConfig, interfaceConfig: any, location: string | URL) {
    const params = parseURLParams(location);
    const json: any = {};

    // At this point we have:
    // params = {
    //     "config.disableAudioLevels": false,
    //     "config.channelLastN": -1,
    //     "interfaceConfig.APP_NAME": "Jitsi Meet"
    // }
    // We want to have:
    // json = {
    //     config: {
    //         "disableAudioLevels": false,
    //         "channelLastN": -1
    //     },
    //     interfaceConfig: {
    //         "APP_NAME": "Jitsi Meet"
    //     }
    // }
    config && (json.config = {});
    interfaceConfig && (json.interfaceConfig = {});

    for (const param of Object.keys(params)) {
        let base = json;
        const names = param.split('.');
        const last = names.pop() ?? '';

        for (const name of names) {
            base = base[name] = base[name] || {};
        }

        base[last] = params[param];
    }

    overrideConfigJSON(config, interfaceConfig, json);
}

/* eslint-enable max-params */

/**
 * Returns the dial out url.
 *
 * @param {Object} state - The state of the app.
 * @returns {string}
 */
export function getDialOutStatusUrl(state: IReduxState) {
    return state['features/base/config'].guestDialOutStatusUrl;
}

/**
 * Returns the dial out status url.
 *
 * @param {Object} state - The state of the app.
 * @returns {string}
 */
export function getDialOutUrl(state: IReduxState) {
    return state['features/base/config'].guestDialOutUrl;
}

/**
 * Selector to return the security UI config.
 *
 * @param {IReduxState} state - State object.
 * @returns {Object}
 */
export function getSecurityUiConfig(state: IReduxState) {
    return state['features/base/config']?.securityUi || {};
}

/**
 * Returns the terms, privacy and help centre URL's.
 *
 * @param {IReduxState} state - The state of the application.
 * @returns {{
 *  privacy: string,
 *  helpCentre: string,
 *  terms: string
 * }}
 */
export function getLegalUrls(state: IReduxState) {
    const helpCentreURL = state['features/base/config']?.helpCentreURL;
    const configLegalUrls = state['features/base/config']?.legalUrls;

    return {
        privacy: configLegalUrls?.privacy || DEFAULT_PRIVACY_URL,
        helpCentre: helpCentreURL || configLegalUrls?.helpCentre || DEFAULT_HELP_CENTRE_URL,
        terms: configLegalUrls?.terms || DEFAULT_TERMS_URL
    };
}

/**
 * Utility function to debounce the execution of a callback function.
 *
 * @param {Function} callback - The callback to debounce.
 * @param {number} delay - The debounce delay in milliseconds.
 * @returns {Function} - A debounced function that delays the execution of the callback.
 */
export function debounce(callback: (...args: any[]) => void, delay: number) {
    let timerId: any;

    return (...args: any[]) => {
        if (timerId) {
            clearTimeout(timerId);
        }
        timerId = setTimeout(() => callback(...args), delay);
    };
}


################################################################################

## File: .\jitsi-meet\react\features\base\config\functions.native.ts

import { NativeModules } from 'react-native';

import { IReduxState } from '../../app/types';
import { REPLACE_PARTICIPANT } from '../flags/constants';
import { getFeatureFlag } from '../flags/functions';

import { IConfig, IDeeplinkingConfig } from './configType';

export * from './functions.any';

/**
 * Removes all analytics related options from the given configuration, in case of a libre build.
 *
 * @param {*} config - The configuration which needs to be cleaned up.
 * @returns {void}
 */
export function _cleanupConfig(config: IConfig) {
    config.analytics = config.analytics ?? {};
    config.analytics.scriptURLs = [];

    if (NativeModules.AppInfo.LIBRE_BUILD) {
        delete config.analytics?.amplitudeAPPKey;
        delete config.analytics?.googleAnalyticsTrackingId;
        delete config.analytics?.rtcstatsEnabled;
        delete config.analytics?.rtcstatsEndpoint;
        delete config.analytics?.rtcstatsPollInterval;
        delete config.analytics?.rtcstatsSendSdp;
        delete config.analytics?.rtcstatsUseLegacy;
        delete config.analytics?.obfuscateRoomName;
        delete config.analytics?.watchRTCEnabled;
        delete config.watchRTCConfigParams;
        config.giphy = { enabled: false };
    }
}

/**
 * Returns the replaceParticipant config.
 *
 * @param {Object} state - The state of the app.
 * @returns {boolean}
 */
export function getReplaceParticipant(state: IReduxState): string {
    return getFeatureFlag(state, REPLACE_PARTICIPANT, false);
}

/**
 * Sets the defaults for deeplinking.
 *
 * @param {IDeeplinkingConfig} _deeplinking - The deeplinking config.
 * @returns {void}
 */
export function _setDeeplinkingDefaults(_deeplinking: IDeeplinkingConfig) {
    return;
}



################################################################################

## File: .\jitsi-meet\react\features\base\config\functions.web.ts

import { IReduxState } from '../../app/types';
import JitsiMeetJS from '../../base/lib-jitsi-meet';

import {
    IConfig,
    IDeeplinkingConfig,
    IDeeplinkingDesktopConfig,
    IDeeplinkingMobileConfig
} from './configType';

export * from './functions.any';

/**
 * Removes all analytics related options from the given configuration, in case of a libre build.
 *
 * @param {*} _config - The configuration which needs to be cleaned up.
 * @returns {void}
 */
export function _cleanupConfig(_config: IConfig) {
    return;
}

/**
 * Returns the replaceParticipant config.
 *
 * @param {Object} state - The state of the app.
 * @returns {boolean}
 */
export function getReplaceParticipant(state: IReduxState): string | undefined {
    return state['features/base/config'].replaceParticipant;
}

/**
 * Returns the configuration value of web-hid feature.
 *
 * @param {Object} state - The state of the app.
 * @returns {boolean} True if web-hid feature should be enabled, otherwise false.
 */
export function getWebHIDFeatureConfig(state: IReduxState): boolean {
    return state['features/base/config'].enableWebHIDFeature || false;
}

/**
 * Returns whether audio level measurement is enabled or not.
 *
 * @param {Object} state - The state of the app.
 * @returns {boolean}
 */
export function areAudioLevelsEnabled(state: IReduxState): boolean {
    return !state['features/base/config'].disableAudioLevels && JitsiMeetJS.isCollectingLocalStats();
}

/**
 * Sets the defaults for deeplinking.
 *
 * @param {IDeeplinkingConfig} deeplinking - The deeplinking config.
 * @returns {void}
 */
export function _setDeeplinkingDefaults(deeplinking: IDeeplinkingConfig) {
    deeplinking.desktop = deeplinking.desktop || {} as IDeeplinkingDesktopConfig;
    deeplinking.android = deeplinking.android || {} as IDeeplinkingMobileConfig;
    deeplinking.ios = deeplinking.ios || {} as IDeeplinkingMobileConfig;

    const { android, desktop, ios } = deeplinking;

    desktop.appName = desktop.appName || 'Jitsi Meet';
    desktop.appScheme = desktop.appScheme || 'jitsi-meet';
    desktop.download = desktop.download || {};
    desktop.download.windows = desktop.download.windows
        || 'https://github.com/jitsi/jitsi-meet-electron/releases/latest/download/jitsi-meet.exe';
    desktop.download.macos = desktop.download.macos
        || 'https://github.com/jitsi/jitsi-meet-electron/releases/latest/download/jitsi-meet.dmg';
    desktop.download.linux = desktop.download.linux
        || 'https://github.com/jitsi/jitsi-meet-electron/releases/latest/download/jitsi-meet-x86_64.AppImage';

    ios.appName = ios.appName || 'Jitsi Meet';
    ios.appScheme = ios.appScheme || 'org.jitsi.meet';
    ios.downloadLink = ios.downloadLink
        || 'https://itunes.apple.com/us/app/jitsi-meet/id1165103905';
    if (ios.dynamicLink) {
        ios.dynamicLink.apn = ios.dynamicLink.apn || 'org.jitsi.meet';
        ios.dynamicLink.appCode = ios.dynamicLink.appCode || 'w2atb';
        ios.dynamicLink.ibi = ios.dynamicLink.ibi || 'com.atlassian.JitsiMeet.ios';
        ios.dynamicLink.isi = ios.dynamicLink.isi || '1165103905';
    }

    android.appName = android.appName || 'Jitsi Meet';
    android.appScheme = android.appScheme || 'org.jitsi.meet';
    android.downloadLink = android.downloadLink
        || 'https://play.google.com/store/apps/details?id=org.jitsi.meet';
    android.appPackage = android.appPackage || 'org.jitsi.meet';
    android.fDroidUrl = android.fDroidUrl || 'https://f-droid.org/en/packages/org.jitsi.meet/';
    if (android.dynamicLink) {
        android.dynamicLink.apn = android.dynamicLink.apn || 'org.jitsi.meet';
        android.dynamicLink.appCode = android.dynamicLink.appCode || 'w2atb';
        android.dynamicLink.ibi = android.dynamicLink.ibi || 'com.atlassian.JitsiMeet.ios';
        android.dynamicLink.isi = android.dynamicLink.isi || '1165103905';
    }
}


################################################################################

## File: .\jitsi-meet\react\features\base\config\getRoomName.ts

import { getBackendSafeRoomName } from '../util/uri';

/**
 * Builds and returns the room name.
 *
 * @returns {string}
 */
export default function getRoomName(): string | undefined {
    const path = window.location.pathname;

    // The last non-directory component of the path (name) is the room.
    const roomName = path.substring(path.lastIndexOf('/') + 1) || undefined;

    return getBackendSafeRoomName(roomName);
}


################################################################################

## File: .\jitsi-meet\react\features\base\config\interfaceConfigWhitelist.ts

/**
 * The interface config keys to whitelist, the keys that can be overridden.
 *
 * @private
 * @type Array
 */
export default [
    'AUDIO_LEVEL_PRIMARY_COLOR',
    'AUDIO_LEVEL_SECONDARY_COLOR',
    'AUTO_PIN_LATEST_SCREEN_SHARE',
    'CLOSE_PAGE_GUEST_HINT',
    'CONNECTION_INDICATOR_AUTO_HIDE_ENABLED',
    'CONNECTION_INDICATOR_AUTO_HIDE_TIMEOUT',
    'CONNECTION_INDICATOR_DISABLED',
    'DEFAULT_BACKGROUND',
    'DISABLE_PRESENCE_STATUS',
    'DISABLE_JOIN_LEAVE_NOTIFICATIONS',
    'DEFAULT_LOCAL_DISPLAY_NAME',
    'DEFAULT_REMOTE_DISPLAY_NAME',
    'DISABLE_DOMINANT_SPEAKER_INDICATOR',
    'DISABLE_FOCUS_INDICATOR',
    'DISABLE_PRIVATE_MESSAGES',
    'DISABLE_RINGING',
    'DISABLE_TRANSCRIPTION_SUBTITLES',
    'DISABLE_VIDEO_BACKGROUND',
    'DISPLAY_WELCOME_PAGE_CONTENT',
    'ENABLE_DIAL_OUT',
    'ENABLE_FEEDBACK_ANIMATION',
    'FILM_STRIP_MAX_HEIGHT',
    'GENERATE_ROOMNAMES_ON_WELCOME_PAGE',
    'HIDE_INVITE_MORE_HEADER',
    'INDICATOR_FONT_SIZES',
    'INITIAL_TOOLBAR_TIMEOUT',
    'LANG_DETECTION',
    'LIVE_STREAMING_HELP_LINK',
    'LOCAL_THUMBNAIL_RATIO',
    'MAXIMUM_ZOOMING_COEFFICIENT',
    'NATIVE_APP_NAME',
    'OPTIMAL_BROWSERS',
    'PHONE_NUMBER_REGEX',
    'PROVIDER_NAME',
    'RECENT_LIST_ENABLED',
    'REMOTE_THUMBNAIL_RATIO',
    'SETTINGS_SECTIONS',
    'SHARING_FEATURES',
    'SHOW_CHROME_EXTENSION_BANNER',
    'SHOW_POWERED_BY',
    'SUPPORT_URL',
    'TILE_VIEW_MAX_COLUMNS',
    'TOOLBAR_ALWAYS_VISIBLE',
    'TOOLBAR_BUTTONS',
    'TOOLBAR_TIMEOUT',
    'UNSUPPORTED_BROWSERS',
    'VERTICAL_FILMSTRIP',
    'VIDEO_LAYOUT_FIT',
    'VIDEO_QUALITY_LABEL_DISABLED'
];


################################################################################

## File: .\jitsi-meet\react\features\base\config\logger.ts

import { getLogger } from '../logging/functions';

export default getLogger('features/base/config');


################################################################################

## File: .\jitsi-meet\react\features\base\config\middleware.ts

import { AnyAction } from 'redux';

import { IStore } from '../../app/types';
import { getFeatureFlag } from '../flags/functions';
import MiddlewareRegistry from '../redux/MiddlewareRegistry';
import { updateSettings } from '../settings/actions';

import { OVERWRITE_CONFIG, SET_CONFIG } from './actionTypes';
import { updateConfig } from './actions';
import { IConfig } from './configType';

/**
 * The middleware of the feature {@code base/config}.
 *
 * @param {Store} store - The redux store.
 * @private
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {
    switch (action.type) {
    case SET_CONFIG:
        return _setConfig(store, next, action);

    case OVERWRITE_CONFIG:
        return _updateSettings(store, next, action);
    }

    return next(action);
});

/**
 * Notifies the feature {@code base/config} that the {@link SET_CONFIG} redux
 * action is being {@code dispatch}ed in a specific redux store.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @param {Dispatch} next - The redux {@code dispatch} function to dispatch the
 * specified {@code action} in the specified {@code store}.
 * @param {Action} action - The redux action which is being {@code dispatch}ed
 * in the specified {@code store}.
 * @private
 * @returns {*} The return value of {@code next(action)}.
 */
function _setConfig({ dispatch, getState }: IStore, next: Function, action: AnyAction) {
    // The reducer is doing some alterations to the config passed in the action,
    // so make sure it's the final state by waiting for the action to be
    // reduced.
    const result = next(action);
    const state = getState();

    // Update the config with user defined settings.
    const settings = state['features/base/settings'];
    const config: IConfig = {};

    if (typeof settings.disableP2P !== 'undefined') {
        config.p2p = { enabled: !settings.disableP2P };
    }

    const resolutionFlag = getFeatureFlag(state, 'resolution');

    if (typeof resolutionFlag !== 'undefined') {
        config.resolution = resolutionFlag;
    }

    if (action.config.doNotFlipLocalVideo === true) {
        dispatch(updateSettings({
            localFlipX: false
        }));
    }

    if (action.config.disableSelfView !== undefined) {
        dispatch(updateSettings({
            disableSelfView: action.config.disableSelfView
        }));
    }

    if (action.config.filmstrip?.stageFilmstripParticipants !== undefined) {
        dispatch(updateSettings({
            maxStageParticipants: action.config.filmstrip.stageFilmstripParticipants
        }));
    }

    dispatch(updateConfig(config));

    // FIXME On Web we rely on the global 'config' variable which gets altered
    // multiple times, before it makes it to the reducer. At some point it may
    // not be the global variable which is being modified anymore due to
    // different merge methods being used along the way. The global variable
    // must be synchronized with the final state resolved by the reducer.
    if (typeof window.config !== 'undefined') {
        window.config = state['features/base/config'];
    }

    return result;
}

/**
 * Updates settings based on some config values.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @param {Dispatch} next - The redux {@code dispatch} function to dispatch the
 * specified {@code action} in the specified {@code store}.
 * @param {Action} action - The redux action which is being {@code dispatch}ed
 * in the specified {@code store}.
 * @private
 * @returns {*} The return value of {@code next(action)}.
 */
function _updateSettings({ dispatch }: IStore, next: Function, action: AnyAction) {
    const { config: { doNotFlipLocalVideo } } = action;

    if (doNotFlipLocalVideo === true) {
        dispatch(updateSettings({
            localFlipX: false
        }));
    }

    return next(action);
}


################################################################################

## File: .\jitsi-meet\react\features\base\config\reducer.ts

import { merge, union } from 'lodash-es';

import { CONFERENCE_INFO } from '../../conference/components/constants';
import { TOOLBAR_BUTTONS } from '../../toolbox/constants';
import { ToolbarButton } from '../../toolbox/types';
import { CONNECTION_PROPERTIES_UPDATED } from '../connection/actionTypes';
import ReducerRegistry from '../redux/ReducerRegistry';
import { equals } from '../redux/functions';

import {
    CONFIG_WILL_LOAD,
    LOAD_CONFIG_ERROR,
    OVERWRITE_CONFIG,
    SET_CONFIG,
    UPDATE_CONFIG
} from './actionTypes';
import {
    IConfig,
    IDeeplinkingConfig,
    IDeeplinkingDesktopConfig,
    IDeeplinkingMobileConfig,
    IMobileDynamicLink
} from './configType';
import { _cleanupConfig, _setDeeplinkingDefaults } from './functions';

/**
 * The initial state of the feature base/config when executing in a
 * non-React Native environment. The mandatory configuration to be passed to
 * JitsiMeetJS#init(). The app will download config.js from the Jitsi Meet
 * deployment and take its values into account but the values below will be
 * enforced (because they are essential to the correct execution of the
 * application).
 *
 * @type {Object}
 */
const INITIAL_NON_RN_STATE: IConfig = {
};

/**
 * The initial state of the feature base/config when executing in a React Native
 * environment. The mandatory configuration to be passed to JitsiMeetJS#init().
 * The app will download config.js from the Jitsi Meet deployment and take its
 * values into account but the values below will be enforced (because they are
 * essential to the correct execution of the application).
 *
 * @type {Object}
 */
const INITIAL_RN_STATE: IConfig = {
};

/**
 * Mapping between old configs controlling the conference info headers visibility and the
 * new configs. Needed in order to keep backwards compatibility.
 */
const CONFERENCE_HEADER_MAPPING = {
    hideConferenceTimer: [ 'conference-timer' ],
    hideConferenceSubject: [ 'subject' ],
    hideParticipantsStats: [ 'participants-count' ],
    hideRecordingLabel: [ 'recording' ]
};

export interface IConfigState extends IConfig {
    analysis?: {
        obfuscateRoomName?: boolean;
    };
    disableRemoteControl?: boolean;
    error?: Error;
    oldConfig?: {
        bosh?: string;
        focusUserJid?: string;
        hosts: {
            domain: string;
            muc: string;
        };
        p2p?: object;
        websocket?: string;
    };
    visitors?: {
        enableMediaOnPromote?: {
            audio?: boolean;
            video?: boolean;
        };
        queueService: string;
    };
}

ReducerRegistry.register<IConfigState>('features/base/config', (state = _getInitialState(), action): IConfigState => {
    switch (action.type) {
    case UPDATE_CONFIG:
        return _updateConfig(state, action);

    case CONFIG_WILL_LOAD:
        return {
            error: undefined,

            /**
            * The URL of the location associated with/configured by this
            * configuration.
            *
            * @type URL
            */
            locationURL: action.locationURL
        };

    case CONNECTION_PROPERTIES_UPDATED: {
        const { region, shard } = action.properties;
        const { deploymentInfo } = state;

        if (deploymentInfo?.region === region && deploymentInfo?.shard === shard) {
            return state;
        }

        return {
            ...state,
            deploymentInfo: JSON.parse(JSON.stringify({
                ...deploymentInfo,
                region,
                shard
            }))
        };
    }

    case LOAD_CONFIG_ERROR:
        // XXX LOAD_CONFIG_ERROR is one of the settlement execution paths of
        // the asynchronous "loadConfig procedure/process" started with
        // CONFIG_WILL_LOAD. Due to the asynchronous nature of it, whoever
        // is settling the process needs to provide proof that they have
        // started it and that the iteration of the process being completed
        // now is still of interest to the app.
        if (state.locationURL === action.locationURL) {
            return {
                /**
                * The {@link Error} which prevented the loading of the
                * configuration of the associated {@code locationURL}.
                *
                * @type Error
                */
                error: action.error
            };
        }
        break;

    case SET_CONFIG:
        return _setConfig(state, action);

    case OVERWRITE_CONFIG:
        return {
            ...state,
            ...action.config
        };
    }

    return state;
});

/**
 * Gets the initial state of the feature base/config. The mandatory
 * configuration to be passed to JitsiMeetJS#init(). The app will download
 * config.js from the Jitsi Meet deployment and take its values into account but
 * the values below will be enforced (because they are essential to the correct
 * execution of the application).
 *
 * @returns {Object}
 */
function _getInitialState() {
    return (
        navigator.product === 'ReactNative'
            ? INITIAL_RN_STATE
            : INITIAL_NON_RN_STATE);
}

/**
 * Reduces a specific Redux action SET_CONFIG of the feature
 * base/lib-jitsi-meet.
 *
 * @param {IConfig} state - The Redux state of the feature base/config.
 * @param {Action} action - The Redux action SET_CONFIG to reduce.
 * @private
 * @returns {Object} The new state after the reduction of the specified action.
 */
function _setConfig(state: IConfig, { config }: { config: IConfig; }) {
    // eslint-disable-next-line no-param-reassign
    config = _translateLegacyConfig(config);

    const { audioQuality } = config;
    const hdAudioOptions = {};

    if (audioQuality?.stereo) {
        Object.assign(hdAudioOptions, {
            disableAP: true,
            enableNoAudioDetection: false,
            enableNoisyMicDetection: false,
            enableTalkWhileMuted: false
        });
    }

    const newState = merge(
        {},
        config,
        hdAudioOptions,
        { error: undefined },

        // The config of _getInitialState() is meant to override the config
        // downloaded from the Jitsi Meet deployment because the former contains
        // values that are mandatory.
        _getInitialState()
    );

    _cleanupConfig(newState);

    return equals(state, newState) ? state : newState;
}

/**
 * Processes the conferenceInfo object against the defaults.
 *
 * @param {IConfig} config - The old config.
 * @returns {Object} The processed conferenceInfo object.
 */
function _getConferenceInfo(config: IConfig) {
    const { conferenceInfo } = config;

    if (conferenceInfo) {
        return {
            alwaysVisible: conferenceInfo.alwaysVisible ?? [ ...CONFERENCE_INFO.alwaysVisible ],
            autoHide: conferenceInfo.autoHide ?? [ ...CONFERENCE_INFO.autoHide ]
        };
    }

    return {
        ...CONFERENCE_INFO
    };
}

/**
 * Constructs a new config {@code Object}, if necessary, out of a specific
 * interface_config {@code Object} which is in the latest format supported by jitsi-meet.
 *
 * @param {Object} oldValue - The config {@code Object} which may or may not be
 * in the latest form supported by jitsi-meet and from which a new config
 * {@code Object} is to be constructed if necessary.
 * @returns {Object} A config {@code Object} which is in the latest format
 * supported by jitsi-meet.
 */
function _translateInterfaceConfig(oldValue: IConfig) {
    const newValue = oldValue;

    if (!Array.isArray(oldValue.toolbarButtons)
        && typeof interfaceConfig === 'object' && Array.isArray(interfaceConfig.TOOLBAR_BUTTONS)) {
        newValue.toolbarButtons = interfaceConfig.TOOLBAR_BUTTONS;
    }

    if (!oldValue.toolbarConfig) {
        oldValue.toolbarConfig = {};
    }

    newValue.toolbarConfig = oldValue.toolbarConfig || {};
    if (typeof oldValue.toolbarConfig.alwaysVisible !== 'boolean'
        && typeof interfaceConfig === 'object'
        && typeof interfaceConfig.TOOLBAR_ALWAYS_VISIBLE === 'boolean') {
        newValue.toolbarConfig.alwaysVisible = interfaceConfig.TOOLBAR_ALWAYS_VISIBLE;
    }

    if (typeof oldValue.toolbarConfig.initialTimeout !== 'number'
        && typeof interfaceConfig === 'object'
        && typeof interfaceConfig.INITIAL_TOOLBAR_TIMEOUT === 'number') {
        newValue.toolbarConfig.initialTimeout = interfaceConfig.INITIAL_TOOLBAR_TIMEOUT;
    }

    if (typeof oldValue.toolbarConfig.timeout !== 'number'
        && typeof interfaceConfig === 'object'
        && typeof interfaceConfig.TOOLBAR_TIMEOUT === 'number') {
        newValue.toolbarConfig.timeout = interfaceConfig.TOOLBAR_TIMEOUT;
    }

    if (!oldValue.connectionIndicators
        && typeof interfaceConfig === 'object'
        && (interfaceConfig.hasOwnProperty('CONNECTION_INDICATOR_DISABLED')
            || interfaceConfig.hasOwnProperty('CONNECTION_INDICATOR_AUTO_HIDE_ENABLED')
            || interfaceConfig.hasOwnProperty('CONNECTION_INDICATOR_AUTO_HIDE_TIMEOUT'))) {
        newValue.connectionIndicators = {
            disabled: interfaceConfig.CONNECTION_INDICATOR_DISABLED,
            autoHide: interfaceConfig.CONNECTION_INDICATOR_AUTO_HIDE_ENABLED,
            autoHideTimeout: interfaceConfig.CONNECTION_INDICATOR_AUTO_HIDE_TIMEOUT
        };
    }

    if (oldValue.disableModeratorIndicator === undefined
        && typeof interfaceConfig === 'object'
        && interfaceConfig.hasOwnProperty('DISABLE_FOCUS_INDICATOR')) {
        newValue.disableModeratorIndicator = interfaceConfig.DISABLE_FOCUS_INDICATOR;
    }

    if (oldValue.defaultLocalDisplayName === undefined
        && typeof interfaceConfig === 'object'
        && interfaceConfig.hasOwnProperty('DEFAULT_LOCAL_DISPLAY_NAME')) {
        newValue.defaultLocalDisplayName = interfaceConfig.DEFAULT_LOCAL_DISPLAY_NAME;
    }

    if (oldValue.defaultRemoteDisplayName === undefined
        && typeof interfaceConfig === 'object'
        && interfaceConfig.hasOwnProperty('DEFAULT_REMOTE_DISPLAY_NAME')) {
        newValue.defaultRemoteDisplayName = interfaceConfig.DEFAULT_REMOTE_DISPLAY_NAME;
    }

    if (oldValue.defaultLogoUrl === undefined) {
        if (typeof interfaceConfig === 'object'
            && interfaceConfig.hasOwnProperty('DEFAULT_LOGO_URL')) {
            newValue.defaultLogoUrl = interfaceConfig.DEFAULT_LOGO_URL;
        } else {
            newValue.defaultLogoUrl = 'images/watermark.svg';
        }
    }

    // if we have `deeplinking` defined, ignore deprecated values, except `disableDeepLinking`.
    // Otherwise, compose the config.
    if (oldValue.deeplinking && newValue.deeplinking) { // make TS happy
        newValue.deeplinking.disabled = oldValue.deeplinking.hasOwnProperty('disabled')
            ? oldValue.deeplinking.disabled
            : Boolean(oldValue.disableDeepLinking);
    } else {
        const disabled = Boolean(oldValue.disableDeepLinking);
        const deeplinking: IDeeplinkingConfig = {
            desktop: {} as IDeeplinkingDesktopConfig,
            hideLogo: false,
            disabled,
            android: {} as IDeeplinkingMobileConfig,
            ios: {} as IDeeplinkingMobileConfig
        };

        if (typeof interfaceConfig === 'object') {
            const mobileDynamicLink = interfaceConfig.MOBILE_DYNAMIC_LINK;
            const dynamicLink: IMobileDynamicLink | undefined = mobileDynamicLink ? {
                apn: mobileDynamicLink.APN,
                appCode: mobileDynamicLink.APP_CODE,
                ibi: mobileDynamicLink.IBI,
                isi: mobileDynamicLink.ISI,
                customDomain: mobileDynamicLink.CUSTOM_DOMAIN
            } : undefined;

            if (deeplinking.desktop) {
                deeplinking.desktop.appName = interfaceConfig.NATIVE_APP_NAME;
            }

            deeplinking.hideLogo = Boolean(interfaceConfig.HIDE_DEEP_LINKING_LOGO);
            deeplinking.android = {
                appName: interfaceConfig.NATIVE_APP_NAME,
                appScheme: interfaceConfig.APP_SCHEME,
                downloadLink: interfaceConfig.MOBILE_DOWNLOAD_LINK_ANDROID,
                appPackage: interfaceConfig.ANDROID_APP_PACKAGE,
                fDroidUrl: interfaceConfig.MOBILE_DOWNLOAD_LINK_F_DROID,
                dynamicLink
            };
            deeplinking.ios = {
                appName: interfaceConfig.NATIVE_APP_NAME,
                appScheme: interfaceConfig.APP_SCHEME,
                downloadLink: interfaceConfig.MOBILE_DOWNLOAD_LINK_IOS,
                dynamicLink
            };
        }
        newValue.deeplinking = deeplinking;
    }

    return newValue;
}

/**
 * Constructs a new config {@code Object}, if necessary, out of a specific
 * config {@code Object} which is in the latest format supported by jitsi-meet.
 * Such a translation from an old config format to a new/the latest config
 * format is necessary because the mobile app bundles jitsi-meet and
 * lib-jitsi-meet at build time and does not download them at runtime from the
 * deployment on which it will join a conference.
 *
 * @param {Object} oldValue - The config {@code Object} which may or may not be
 * in the latest form supported by jitsi-meet and from which a new config
 * {@code Object} is to be constructed if necessary.
 * @returns {Object} A config {@code Object} which is in the latest format
 * supported by jitsi-meet.
 */
function _translateLegacyConfig(oldValue: IConfig) {
    const newValue = _translateInterfaceConfig(oldValue);

    // Translate deprecated config values to new config values.

    const filteredConferenceInfo = Object.keys(CONFERENCE_HEADER_MAPPING).filter(key => oldValue[key as keyof IConfig]);

    if (filteredConferenceInfo.length) {
        newValue.conferenceInfo = _getConferenceInfo(oldValue);

        filteredConferenceInfo.forEach(key => {
            newValue.conferenceInfo = oldValue.conferenceInfo ?? {};

            // hideRecordingLabel does not mean not render it at all, but autoHide it
            if (key === 'hideRecordingLabel') {
                newValue.conferenceInfo.alwaysVisible
                    = (newValue.conferenceInfo?.alwaysVisible ?? [])
                    .filter(c => !CONFERENCE_HEADER_MAPPING[key].includes(c));
                newValue.conferenceInfo.autoHide
                    = union(newValue.conferenceInfo.autoHide, CONFERENCE_HEADER_MAPPING[key]);
            } else {
                newValue.conferenceInfo.alwaysVisible
                    = (newValue.conferenceInfo.alwaysVisible ?? [])
                    .filter(c => !CONFERENCE_HEADER_MAPPING[key as keyof typeof CONFERENCE_HEADER_MAPPING].includes(c));
                newValue.conferenceInfo.autoHide
                    = (newValue.conferenceInfo.autoHide ?? []).filter(c =>
                        !CONFERENCE_HEADER_MAPPING[key as keyof typeof CONFERENCE_HEADER_MAPPING].includes(c));
            }
        });
    }

    newValue.welcomePage = oldValue.welcomePage || {};
    if (oldValue.hasOwnProperty('enableWelcomePage')
        && !newValue.welcomePage.hasOwnProperty('disabled')
    ) {
        newValue.welcomePage.disabled = !oldValue.enableWelcomePage;
    }

    newValue.prejoinConfig = oldValue.prejoinConfig || {};
    if (oldValue.hasOwnProperty('prejoinPageEnabled')
        && !newValue.prejoinConfig.hasOwnProperty('enabled')
    ) {
        newValue.prejoinConfig.enabled = oldValue.prejoinPageEnabled;
    }

    newValue.disabledSounds = newValue.disabledSounds || [];

    if (oldValue.disableJoinLeaveSounds) {
        newValue.disabledSounds.unshift('PARTICIPANT_LEFT_SOUND', 'PARTICIPANT_JOINED_SOUND');
    }

    if (oldValue.disableRecordAudioNotification) {
        newValue.disabledSounds.unshift(
            'RECORDING_ON_SOUND',
            'RECORDING_OFF_SOUND',
            'LIVE_STREAMING_ON_SOUND',
            'LIVE_STREAMING_OFF_SOUND'
        );
    }

    if (oldValue.disableIncomingMessageSound) {
        newValue.disabledSounds.unshift('INCOMING_MSG_SOUND');
    }

    newValue.raisedHands = newValue.raisedHands || {};

    if (oldValue.disableRemoveRaisedHandOnFocus) {
        newValue.raisedHands.disableRemoveRaisedHandOnFocus = oldValue.disableRemoveRaisedHandOnFocus;
    }

    if (oldValue.stereo || oldValue.opusMaxAverageBitrate) {
        newValue.audioQuality = {
            opusMaxAverageBitrate: oldValue.audioQuality?.opusMaxAverageBitrate ?? oldValue.opusMaxAverageBitrate,
            stereo: oldValue.audioQuality?.stereo ?? oldValue.stereo
        };
    }

    newValue.e2ee = newValue.e2ee || {};

    if (oldValue.e2eeLabels) {
        newValue.e2ee.labels = oldValue.e2eeLabels;
    }

    newValue.defaultLocalDisplayName
        = newValue.defaultLocalDisplayName || 'me';

    if (oldValue.hideAddRoomButton) {
        newValue.breakoutRooms = {
            /* eslint-disable-next-line no-extra-parens */
            ...(newValue.breakoutRooms || {}),
            hideAddRoomButton: oldValue.hideAddRoomButton
        };
    }

    newValue.defaultRemoteDisplayName
        = newValue.defaultRemoteDisplayName || 'Fellow Jitster';

    newValue.transcription = newValue.transcription || {};
    if (oldValue.transcribingEnabled !== undefined) {
        newValue.transcription = {
            ...newValue.transcription,
            enabled: oldValue.transcribingEnabled
        };
    }
    if (oldValue.transcribeWithAppLanguage !== undefined) {
        newValue.transcription = {
            ...newValue.transcription,
            useAppLanguage: oldValue.transcribeWithAppLanguage
        };
    }
    if (oldValue.preferredTranscribeLanguage !== undefined) {
        newValue.transcription = {
            ...newValue.transcription,
            preferredLanguage: oldValue.preferredTranscribeLanguage
        };
    }
    if (oldValue.autoCaptionOnRecord !== undefined) {
        newValue.transcription = {
            ...newValue.transcription,
            autoTranscribeOnRecord: oldValue.autoCaptionOnRecord
        };
    }

    newValue.recordingService = newValue.recordingService || {};
    if (oldValue.fileRecordingsServiceEnabled !== undefined
        && newValue.recordingService.enabled === undefined) {
        newValue.recordingService = {
            ...newValue.recordingService,
            enabled: oldValue.fileRecordingsServiceEnabled
        };
    }
    if (oldValue.fileRecordingsServiceSharingEnabled !== undefined
        && newValue.recordingService.sharingEnabled === undefined) {
        newValue.recordingService = {
            ...newValue.recordingService,
            sharingEnabled: oldValue.fileRecordingsServiceSharingEnabled
        };
    }

    newValue.liveStreaming = newValue.liveStreaming || {};

    // Migrate config.liveStreamingEnabled
    if (oldValue.liveStreamingEnabled !== undefined) {
        newValue.liveStreaming = {
            ...newValue.liveStreaming,
            enabled: oldValue.liveStreamingEnabled
        };
    }

    // Migrate interfaceConfig.LIVE_STREAMING_HELP_LINK
    if (oldValue.liveStreaming === undefined
        && typeof interfaceConfig === 'object'
        && interfaceConfig.hasOwnProperty('LIVE_STREAMING_HELP_LINK')) {
        newValue.liveStreaming = {
            ...newValue.liveStreaming,
            helpLink: interfaceConfig.LIVE_STREAMING_HELP_LINK
        };
    }

    newValue.speakerStats = newValue.speakerStats || {};

    if (oldValue.disableSpeakerStatsSearch !== undefined
        && newValue.speakerStats.disableSearch === undefined
    ) {
        newValue.speakerStats = {
            ...newValue.speakerStats,
            disableSearch: oldValue.disableSpeakerStatsSearch
        };
    }

    if (oldValue.speakerStatsOrder !== undefined
         && newValue.speakerStats.order === undefined) {
        newValue.speakerStats = {
            ...newValue.speakerStats,
            order: oldValue.speakerStatsOrder
        };
    }

    if (oldValue.autoKnockLobby !== undefined
        && newValue.lobby?.autoKnock === undefined) {
        newValue.lobby = {
            ...newValue.lobby || {},
            autoKnock: oldValue.autoKnockLobby
        };
    }

    if (oldValue.enableLobbyChat !== undefined
        && newValue.lobby?.enableChat === undefined) {
        newValue.lobby = {
            ...newValue.lobby || {},
            enableChat: oldValue.enableLobbyChat
        };
    }

    if (oldValue.hideLobbyButton !== undefined
        && newValue.securityUi?.hideLobbyButton === undefined) {
        newValue.securityUi = {
            ...newValue.securityUi || {},
            hideLobbyButton: oldValue.hideLobbyButton
        };
    }

    if (oldValue.disableProfile) {
        newValue.toolbarButtons = (newValue.toolbarButtons || TOOLBAR_BUTTONS)
            .filter((button: ToolbarButton) => button !== 'profile');
    }

    _setDeeplinkingDefaults(newValue.deeplinking as IDeeplinkingConfig);

    return newValue;
}

/**
 * Updates the stored configuration with the given extra options.
 *
 * @param {Object} state - The Redux state of the feature base/config.
 * @param {Action} action - The Redux action to reduce.
 * @private
 * @returns {Object} The new state after the reduction of the specified action.
 */
function _updateConfig(state: IConfig, { config }: { config: IConfig; }) {
    const newState = merge({}, state, config);

    _cleanupConfig(newState);

    return equals(state, newState) ? state : newState;
}


################################################################################

## File: .\jitsi-meet\react\features\base\connection\actions.any.ts

import { cloneDeep } from 'lodash-es';

import { IReduxState, IStore } from '../../app/types';
import { conferenceLeft, conferenceWillLeave, redirect } from '../conference/actions';
import { getCurrentConference } from '../conference/functions';
import { IConfigState } from '../config/reducer';
import JitsiMeetJS, { JitsiConnectionEvents } from '../lib-jitsi-meet';
import { parseURLParams } from '../util/parseURLParams';
import {
    appendURLParam,
    getBackendSafeRoomName
} from '../util/uri';

import {
    CONNECTION_DISCONNECTED,
    CONNECTION_ESTABLISHED,
    CONNECTION_FAILED,
    CONNECTION_PROPERTIES_UPDATED,
    CONNECTION_WILL_CONNECT,
    SET_LOCATION_URL,
    SET_PREFER_VISITOR
} from './actionTypes';
import { JITSI_CONNECTION_URL_KEY } from './constants';
import logger from './logger';
import { ConnectionFailedError, IIceServers } from './types';

/**
 * The options that will be passed to the JitsiConnection instance.
 */
interface IOptions extends IConfigState {
    iceServersOverride?: IIceServers;
    preferVisitor?: boolean;
}

/**
 * Create an action for when the signaling connection has been lost.
 *
 * @param {JitsiConnection} connection - The {@code JitsiConnection} which
 * disconnected.
 * @private
 * @returns {{
 *     type: CONNECTION_DISCONNECTED,
 *     connection: JitsiConnection
 * }}
 */
export function connectionDisconnected(connection?: Object) {
    return {
        type: CONNECTION_DISCONNECTED,
        connection
    };
}

/**
 * Create an action for when the signaling connection has been established.
 *
 * @param {JitsiConnection} connection - The {@code JitsiConnection} which was
 * established.
 * @param {number} timeEstablished - The time at which the
 * {@code JitsiConnection} which was established.
 * @public
 * @returns {{
 *     type: CONNECTION_ESTABLISHED,
 *     connection: JitsiConnection,
 *     timeEstablished: number
 * }}
 */
export function connectionEstablished(
        connection: Object, timeEstablished: number) {
    return {
        type: CONNECTION_ESTABLISHED,
        connection,
        timeEstablished
    };
}

/**
 * Create an action for when the signaling connection could not be created.
 *
 * @param {JitsiConnection} connection - The {@code JitsiConnection} which
 * failed.
 * @param {ConnectionFailedError} error - Error.
 * @public
 * @returns {{
 *     type: CONNECTION_FAILED,
 *     connection: JitsiConnection,
 *     error: ConnectionFailedError
 * }}
 */
export function connectionFailed(
        connection: Object,
        error: ConnectionFailedError) {
    const { credentials } = error;

    if (credentials && !Object.keys(credentials).length) {
        error.credentials = undefined;
    }

    return {
        type: CONNECTION_FAILED,
        connection,
        error
    };
}

/**
 * Constructs options to be passed to the constructor of {@code JitsiConnection}
 * based on the redux state.
 *
 * @param {Object} state - The redux state.
 * @returns {Object} The options to be passed to the constructor of
 * {@code JitsiConnection}.
 */
export function constructOptions(state: IReduxState) {
    // Deep clone the options to make sure we don't modify the object in the
    // redux store.
    const options: IOptions = cloneDeep(state['features/base/config']);

    const { locationURL, preferVisitor } = state['features/base/connection'];
    const params = parseURLParams(locationURL || '');
    const iceServersOverride = params['iceServers.replace'];

    if (iceServersOverride) {
        options.iceServersOverride = iceServersOverride;
    }

    const { bosh, preferBosh, flags } = options;
    let { websocket } = options;

    if (preferBosh) {
        websocket = undefined;
    }

    // WebSocket is preferred over BOSH.
    const serviceUrl = websocket || bosh;

    logger.log(`Using service URL ${serviceUrl}`);

    // Append room to the URL's search.
    const { room } = state['features/base/conference'];

    if (serviceUrl && room) {
        const roomName = getBackendSafeRoomName(room);

        options.serviceUrl = appendURLParam(serviceUrl, 'room', roomName ?? '');

        if (options.websocketKeepAliveUrl) {
            options.websocketKeepAliveUrl = appendURLParam(options.websocketKeepAliveUrl, 'room', roomName ?? '');
        }
        if (options.conferenceRequestUrl) {
            options.conferenceRequestUrl = appendURLParam(options.conferenceRequestUrl, 'room', roomName ?? '');
        }
    }

    if (preferVisitor) {
        options.preferVisitor = true;
    }

    // Enable ssrc-rewriting by default.
    if (typeof flags?.ssrcRewritingEnabled === 'undefined') {
        const { ...otherFlags } = flags ?? {};

        options.flags = {
            ...otherFlags,
            ssrcRewritingEnabled: true
        };
    }

    return options;
}

/**
 * Sets the location URL of the application, connection, conference, etc.
 *
 * @param {URL} [locationURL] - The location URL of the application,
 * connection, conference, etc.
 * @returns {{
 *     type: SET_LOCATION_URL,
 *     locationURL: URL
 * }}
 */
export function setLocationURL(locationURL?: URL) {
    return {
        type: SET_LOCATION_URL,
        locationURL
    };
}

/**
 * To change prefer visitor in the store. Used later to decide what to request from jicofo on connection.
 *
 * @param {boolean} preferVisitor - The value to set.
 * @returns {{
 *     type: SET_PREFER_VISITOR,
 *     preferVisitor: boolean
 * }}
 */
export function setPreferVisitor(preferVisitor: boolean) {
    return {
        type: SET_PREFER_VISITOR,
        preferVisitor
    };
}

/**
 * Opens new connection.
 *
 * @param {string} [id] - The XMPP user's ID (e.g. {@code user@server.com}).
 * @param {string} [password] - The XMPP user's password.
 * @returns {Function}
 */
export function _connectInternal(id?: string, password?: string) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const options = constructOptions(state);
        const { locationURL } = state['features/base/connection'];
        const { jwt } = state['features/base/jwt'];

        const connection = new JitsiMeetJS.JitsiConnection(options.appId, jwt, options);

        connection[JITSI_CONNECTION_URL_KEY] = locationURL;

        dispatch(_connectionWillConnect(connection));

        return new Promise((resolve, reject) => {
            connection.addEventListener(
                JitsiConnectionEvents.CONNECTION_DISCONNECTED,
                _onConnectionDisconnected);
            connection.addEventListener(
                JitsiConnectionEvents.CONNECTION_ESTABLISHED,
                _onConnectionEstablished);
            connection.addEventListener(
                JitsiConnectionEvents.CONNECTION_FAILED,
                _onConnectionFailed);
            connection.addEventListener(
                JitsiConnectionEvents.CONNECTION_REDIRECTED,
                _onConnectionRedirected);
            connection.addEventListener(
                JitsiConnectionEvents.PROPERTIES_UPDATED,
                _onPropertiesUpdate);

            /**
             * Unsubscribe the connection instance from
             * {@code CONNECTION_DISCONNECTED} and {@code CONNECTION_FAILED} events.
             *
             * @returns {void}
             */
            function unsubscribe() {
                connection.removeEventListener(
                    JitsiConnectionEvents.CONNECTION_DISCONNECTED, _onConnectionDisconnected);
                connection.removeEventListener(JitsiConnectionEvents.CONNECTION_FAILED, _onConnectionFailed);
                connection.removeEventListener(JitsiConnectionEvents.PROPERTIES_UPDATED, _onPropertiesUpdate);
            }

            /**
             * Dispatches {@code CONNECTION_DISCONNECTED} action when connection is
             * disconnected.
             *
             * @private
             * @returns {void}
             */
            function _onConnectionDisconnected() {
                unsubscribe();
                dispatch(connectionDisconnected(connection));
                resolve(connection);
            }

            /**
             * Rejects external promise when connection fails.
             *
             * @param {JitsiConnectionErrors} err - Connection error.
             * @param {string} [message] - Error message supplied by lib-jitsi-meet.
             * @param {Object} [credentials] - The invalid credentials that were
             * used to authenticate and the authentication failed.
             * @param {string} [credentials.jid] - The XMPP user's ID.
             * @param {string} [credentials.password] - The XMPP user's password.
             * @param {Object} details - Additional information about the error.
             * @private
             * @returns {void}
             */
            function _onConnectionFailed( // eslint-disable-line max-params
                    err: string,
                    message: string,
                    credentials: any,
                    details: Object) {
                unsubscribe();

                dispatch(connectionFailed(connection, {
                    credentials,
                    details,
                    name: err,
                    message
                }));

                reject(err);
            }

            /**
             * Resolves external promise when connection is established.
             *
             * @private
             * @returns {void}
             */
            function _onConnectionEstablished() {
                connection.removeEventListener(JitsiConnectionEvents.CONNECTION_ESTABLISHED, _onConnectionEstablished);
                dispatch(connectionEstablished(connection, Date.now()));
                resolve(connection);
            }

            /**
             * Connection was redirected.
             *
             * @param {string|undefined} vnode - The vnode to connect to.
             * @param {string} focusJid - The focus jid to use.
             * @param {string|undefined} username - The username to use when joining. This is after promotion from
             * visitor to main participant.
             * @private
             * @returns {void}
             */
            function _onConnectionRedirected(vnode: string, focusJid: string, username: string) {
                connection.removeEventListener(JitsiConnectionEvents.CONNECTION_REDIRECTED, _onConnectionRedirected);
                dispatch(redirect(vnode, focusJid, username));
            }

            /**
             * Connection properties were updated.
             *
             * @param {Object} properties - The properties which were updated.
             * @private
             * @returns {void}
             */
            function _onPropertiesUpdate(properties: object) {
                dispatch(_propertiesUpdate(properties));
            }

            // in case of configured http url for conference request we need the room name
            const name = getBackendSafeRoomName(state['features/base/conference'].room);

            connection.connect({
                id,
                password,
                name
            });
        });
    };
}

/**
 * Create an action for when a connection will connect.
 *
 * @param {JitsiConnection} connection - The {@code JitsiConnection} which will
 * connect.
 * @private
 * @returns {{
 *     type: CONNECTION_WILL_CONNECT,
 *     connection: JitsiConnection
 * }}
 */
function _connectionWillConnect(connection: Object) {
    return {
        type: CONNECTION_WILL_CONNECT,
        connection
    };
}

/**
 * Create an action for when connection properties are updated.
 *
 * @param {Object} properties - The properties which were updated.
 * @private
 * @returns {{
 *     type: CONNECTION_PROPERTIES_UPDATED,
 *     properties: Object
 * }}
 */
function _propertiesUpdate(properties: object) {
    return {
        type: CONNECTION_PROPERTIES_UPDATED,
        properties
    };
}

/**
 * Closes connection.
 *
 * @param {boolean} isRedirect - Indicates if the action has been dispatched as part of visitor promotion.
 *
 * @returns {Function}
 */
export function disconnect(isRedirect?: boolean) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']): Promise<void> => {
        const state = getState();

        // The conference we have already joined or are joining.
        const conference_ = getCurrentConference(state);

        // Promise which completes when the conference has been left and the
        // connection has been disconnected.
        let promise;

        // Leave the conference.
        if (conference_) {
            // In a fashion similar to JitsiConference's CONFERENCE_LEFT event
            // (and the respective Redux action) which is fired after the
            // conference has been left, notify the application about the
            // intention to leave the conference.
            dispatch(conferenceWillLeave(conference_, isRedirect));

            promise
                = conference_.leave()
                .catch((error: Error) => {
                    logger.warn(
                        'JitsiConference.leave() rejected with:',
                        error);

                    // The library lib-jitsi-meet failed to make the
                    // JitsiConference leave. Which may be because
                    // JitsiConference thinks it has already left.
                    // Regardless of the failure reason, continue in
                    // jitsi-meet as if the leave has succeeded.
                    dispatch(conferenceLeft(conference_));
                });
        } else {
            promise = Promise.resolve();
        }

        // Disconnect the connection.
        const { connecting, connection } = state['features/base/connection'];

        // The connection we have already connected or are connecting.
        const connection_ = connection || connecting;

        if (connection_) {
            promise = promise.then(() => connection_.disconnect());
        } else {
            logger.info('No connection found while disconnecting.');
        }

        return promise;
    };
}


################################################################################

## File: .\jitsi-meet\react\features\base\connection\actions.native.ts

import { appNavigate } from '../../app/actions.native';
import { IStore } from '../../app/types';
import { navigateRoot } from '../../mobile/navigation/rootNavigationContainerRef';
import { screen } from '../../mobile/navigation/routes';
import { JitsiConnectionErrors } from '../lib-jitsi-meet';

import { _connectInternal } from './actions.any';

export * from './actions.any';

/**
 * Opens new connection.
 *
 * @param {string} [id] - The XMPP user's ID (e.g. {@code user@server.com}).
 * @param {string} [password] - The XMPP user's password.
 * @returns {Function}
 */
export function connect(id?: string, password?: string) {
    return (dispatch: IStore['dispatch']) => dispatch(_connectInternal(id, password))
        .catch(error => {
            if (error === JitsiConnectionErrors.NOT_LIVE_ERROR) {
                navigateRoot(screen.visitorsQueue);
            }
        });
}

/**
 * Hangup.
 *
 * @param {boolean} [_requestFeedback] - Whether to attempt showing a
 * request for call feedback.
 * @returns {Function}
 */
export function hangup(_requestFeedback = false) {
    return (dispatch: IStore['dispatch']) => dispatch(appNavigate(undefined));
}


################################################################################

## File: .\jitsi-meet\react\features\base\connection\actions.web.ts

// @ts-expect-error
import { jitsiLocalStorage } from '@jitsi/js-utils';

import { IStore } from '../../app/types';
import { getCustomerDetails } from '../../jaas/actions.any';
import { getJaasJWT, isVpaasMeeting } from '../../jaas/functions';
import { showWarningNotification } from '../../notifications/actions';
import { NOTIFICATION_TIMEOUT_TYPE } from '../../notifications/constants';
import { stopLocalVideoRecording } from '../../recording/actions.any';
import LocalRecordingManager from '../../recording/components/Recording/LocalRecordingManager.web';
import { setJWT } from '../jwt/actions';

import { _connectInternal } from './actions.any';

export * from './actions.any';

/**
 * Opens new connection.
 *
 * @param {string} [id] - The XMPP user's ID (e.g. {@code user@server.com}).
 * @param {string} [password] - The XMPP user's password.
 * @returns {Function}
 */
export function connect(id?: string, password?: string) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const { jwt } = state['features/base/jwt'];
        const { iAmRecorder, iAmSipGateway } = state['features/base/config'];

        if (!iAmRecorder && !iAmSipGateway && isVpaasMeeting(state)) {
            return dispatch(getCustomerDetails())
                .then(() => {
                    if (!jwt) {
                        return getJaasJWT(state);
                    }
                })
                .then(j => {
                    j && dispatch(setJWT(j));

                    return dispatch(_connectInternal(id, password));
                });
        }

        // used by jibri
        const usernameOverride = jitsiLocalStorage.getItem('xmpp_username_override');
        const passwordOverride = jitsiLocalStorage.getItem('xmpp_password_override');

        if (usernameOverride && usernameOverride.length > 0) {
            id = usernameOverride; // eslint-disable-line no-param-reassign
        }
        if (passwordOverride && passwordOverride.length > 0) {
            password = passwordOverride; // eslint-disable-line no-param-reassign
        }

        return dispatch(_connectInternal(id, password));
    };
}

/**
 * Closes connection.
 *
 * @param {boolean} [requestFeedback] - Whether to attempt showing a
 * request for call feedback.
 * @param {string} [feedbackTitle] - The feedback title.
 * @returns {Function}
 */
export function hangup(requestFeedback = false, feedbackTitle?: string) {
    // XXX For web based version we use conference hanging up logic from the old app.
    return async (dispatch: IStore['dispatch']) => {
        if (LocalRecordingManager.isRecordingLocally()) {
            dispatch(stopLocalVideoRecording());
            dispatch(showWarningNotification({
                titleKey: 'localRecording.stopping',
                descriptionKey: 'localRecording.wait'
            }, NOTIFICATION_TIMEOUT_TYPE.STICKY));

            // wait 1000ms for the recording to end and start downloading
            await new Promise(res => {
                setTimeout(res, 1000);
            });
        }

        return APP.conference.hangup(requestFeedback, feedbackTitle);
    };
}


################################################################################

## File: .\jitsi-meet\react\features\base\connection\actionTypes.ts

/**
 * The type of (redux) action which signals that a connection disconnected.
 *
 * {
 *     type: CONNECTION_DISCONNECTED,
 *     connection: JitsiConnection
 * }
 */
export const CONNECTION_DISCONNECTED = 'CONNECTION_DISCONNECTED';

/**
 * The type of (redux) action which signals that a connection was successfully
 * established.
 *
 * {
 *     type: CONNECTION_ESTABLISHED,
 *     connection: JitsiConnection,
 *     timeEstablished: number,
 * }
 */
export const CONNECTION_ESTABLISHED = 'CONNECTION_ESTABLISHED';

/**
 * The type of (redux) action which signals that a connection failed.
 *
 * {
 *     type: CONNECTION_FAILED,
 *     connection: JitsiConnection,
 *     error: Object | string
 * }
 */
export const CONNECTION_FAILED = 'CONNECTION_FAILED';

/**
 * The type of (redux) action which signals that connection properties were updated.
 *
 * {
 *     type: CONNECTION_PROPERTIES_UPDATED,
 *     properties: Object
 * }
 */
export const CONNECTION_PROPERTIES_UPDATED = 'CONNECTION_PROPERTIES_UPDATED';

/**
 * The type of (redux) action which signals that a connection will connect.
 *
 * {
 *     type: CONNECTION_WILL_CONNECT,
 *     connection: JitsiConnection
 * }
 */
export const CONNECTION_WILL_CONNECT = 'CONNECTION_WILL_CONNECT';

/**
 * The type of (redux) action which sets the location URL of the application,
 * connection, conference, etc.
 *
 * {
 *     type: SET_LOCATION_URL,
 *     locationURL: ?URL
 * }
 */
export const SET_LOCATION_URL = 'SET_LOCATION_URL';

/**
 * The type of (redux) action which sets the preferVisitor in store.
 *
 * {
 *     type: SET_PREFER_VISITOR,
 *     preferVisitor: ?boolean
 * }
 */
export const SET_PREFER_VISITOR = 'SET_PREFER_VISITOR';

/**
 * The type of (redux) action which tells whether connection info should be displayed
 * on context menu.
 *
 * {
 *     type: SHOW_CONNECTION_INFO,
 *     showConnectionInfo: boolean
 * }
 */
export const SHOW_CONNECTION_INFO = 'SHOW_CONNECTION_INFO';


################################################################################

## File: .\jitsi-meet\react\features\base\connection\constants.ts

/**
 * The name of the {@code JitsiConnection} property which identifies the {@code JitsiConference} currently associated
 * with it.
 *
 * FIXME: This is a hack. It was introduced to solve the following case: if a user presses hangup quickly, they may
 * "leave the conference" before the actual conference was ever created. While we might have a connection in place,
 * there is no conference which can be left, thus no CONFERENCE_LEFT action will ever be fired.
 *
 * This is problematic because the external API module used to send events to the native SDK won't know what to send.
 * So, in order to detect this situation we are attaching the conference object to the connection which runs it.
 */
export const JITSI_CONNECTION_CONFERENCE_KEY = Symbol('conference');

/**
 * The name of the {@code JitsiConnection} property which identifies the location URL where the connection will be made.
 */
export const JITSI_CONNECTION_URL_KEY = Symbol('url');


################################################################################

## File: .\jitsi-meet\react\features\base\connection\functions.ts

import { IStateful } from '../app/types';
import { toState } from '../redux/functions';
import { toURLString } from '../util/uri';

import { getURLWithoutParams } from './utils';

/**
 * Figures out what's the current conference URL which is supposed to indicate what conference is currently active.
 * When not currently in any conference and not trying to join any then 'undefined' is returned.
 *
 * @param {Object|Function} stateful - Either the whole Redux state object or the Redux store's {@code getState} method.
 * @returns {string|undefined}
 * @private
 */
export function getCurrentConferenceUrl(stateful: IStateful) {
    const state = toState(stateful);
    let currentUrl;

    if (isInviteURLReady(state)) {
        currentUrl = toURLString(getInviteURL(state));
    }

    // Check if the URL doesn't end with a slash
    if (currentUrl && currentUrl.substr(-1) === '/') {
        currentUrl = undefined;
    }

    return currentUrl ? currentUrl : undefined;
}

/**
 * Retrieves a simplified version of the conference/location URL stripped of URL params (i.e. Query/search and hash)
 * which should be used for sending invites.
 * NOTE that the method will throw an error if called too early. That is before the conference is joined or before
 * the process of joining one has started. This limitation does not apply to the case when called with the URL object
 * instance. Use {@link isInviteURLReady} to check if it's safe to call the method already.
 *
 * @param {Function|Object} stateOrGetState - The redux state or redux's {@code getState} function or the URL object
 * to be stripped.
 * @returns {string}
 */
export function getInviteURL(stateOrGetState: IStateful): string {
    const state = toState(stateOrGetState);
    let locationURL
        = state instanceof URL
            ? state
            : state['features/base/connection'].locationURL;

    // If there's no locationURL on the base/connection feature try the base/config where it's set earlier.
    if (!locationURL) {
        locationURL = state['features/base/config'].locationURL;
    }

    if (!locationURL) {
        throw new Error('Can not get invite URL - the app is not ready');
    }

    const { inviteDomain } = state['features/dynamic-branding'];
    const urlWithoutParams = getURLWithoutParams(locationURL);

    if (inviteDomain) {
        const meetingId
            = state['features/base/config'].brandingRoomAlias || urlWithoutParams.pathname.replace(/\//, '');

        return `${inviteDomain}/${meetingId}`;
    }

    return urlWithoutParams.href;
}

/**
 * Checks whether or not is safe to call the {@link getInviteURL} method already.
 *
 * @param {Function|Object} stateOrGetState - The redux state or redux's {@code getState} function.
 * @returns {boolean}
 */
export function isInviteURLReady(stateOrGetState: IStateful): boolean {
    const state = toState(stateOrGetState);

    return Boolean(state['features/base/connection'].locationURL || state['features/base/config'].locationURL);
}

/**
 * Converts a specific id to jid if it's not jid yet.
 *
 * @param {string} id - User id or jid.
 * @param {Object} configHosts - The {@code hosts} part of the {@code config}
 * object.
 * @returns {string} A string in the form of a JID (i.e.
 * {@code user@server.com}).
 */
export function toJid(id: string, { authdomain, domain }: {
    anonymousdomain?: string;
    authdomain?: string;
    domain?: string;
    focus?: string;
    muc?: string;
    visitorFocus?: string;
}): string {
    return id.indexOf('@') >= 0 ? id : `${id}@${authdomain || domain}`;
}


################################################################################

## File: .\jitsi-meet\react\features\base\connection\logger.ts

import { getLogger } from '../logging/functions';

export default getLogger('features/base/connection');


################################################################################

## File: .\jitsi-meet\react\features\base\connection\middleware.web.ts

import MiddlewareRegistry from '../redux/MiddlewareRegistry';

import { CONNECTION_WILL_CONNECT } from './actionTypes';

/**
 * The feature announced so we can distinguish jibri participants.
 *
 * @type {string}
 */
export const DISCO_JIBRI_FEATURE = 'http://jitsi.org/protocol/jibri';

MiddlewareRegistry.register(({ getState }) => next => action => {
    switch (action.type) {
    case CONNECTION_WILL_CONNECT: {
        const { connection } = action;
        const { iAmRecorder } = getState()['features/base/config'];

        if (iAmRecorder) {
            connection.addFeature(DISCO_JIBRI_FEATURE);
        }

        // @ts-ignore
        APP.connection = connection;

        break;
    }
    }

    return next(action);
});


################################################################################

## File: .\jitsi-meet\react\features\base\connection\reducer.ts

import { SET_ROOM } from '../conference/actionTypes';
import { SET_JWT } from '../jwt/actionTypes';
import { JitsiConnectionErrors } from '../lib-jitsi-meet';
import ReducerRegistry from '../redux/ReducerRegistry';
import { assign, set } from '../redux/functions';

import {
    CONNECTION_DISCONNECTED,
    CONNECTION_ESTABLISHED,
    CONNECTION_FAILED,
    CONNECTION_WILL_CONNECT,
    SET_LOCATION_URL,
    SET_PREFER_VISITOR,
    SHOW_CONNECTION_INFO
} from './actionTypes';
import { ConnectionFailedError } from './types';

export interface IConnectionState {
    connecting?: any;
    connection?: {
        addFeature: Function;
        disconnect: Function;
        getJid: () => string;
        getLogs: () => Object;
        initJitsiConference: Function;
        removeFeature: Function;
    };
    error?: ConnectionFailedError;
    locationURL?: URL;
    passwordRequired?: Object;
    preferVisitor?: boolean;
    showConnectionInfo?: boolean;
    timeEstablished?: number;
}

/**
 * Reduces the Redux actions of the feature base/connection.
 */
ReducerRegistry.register<IConnectionState>(
    'features/base/connection',
    (state = {}, action): IConnectionState => {
        switch (action.type) {
        case CONNECTION_DISCONNECTED:
            return _connectionDisconnected(state, action);

        case CONNECTION_ESTABLISHED:
            return _connectionEstablished(state, action);

        case CONNECTION_FAILED:
            return _connectionFailed(state, action);

        case CONNECTION_WILL_CONNECT:
            return _connectionWillConnect(state, action);

        case SET_JWT:
            return _setJWT(state, action);

        case SET_LOCATION_URL:
            return _setLocationURL(state, action);

        case SET_PREFER_VISITOR:
            return assign(state, {
                preferVisitor: action.preferVisitor
            });

        case SET_ROOM:
            return _setRoom(state);

        case SHOW_CONNECTION_INFO:
            return _setShowConnectionInfo(state, action);
        }

        return state;
    });

/**
 * Reduces a specific Redux action CONNECTION_DISCONNECTED of the feature
 * base/connection.
 *
 * @param {IConnectionState} state - The Redux state of the feature base/connection.
 * @param {Action} action - The Redux action CONNECTION_DISCONNECTED to reduce.
 * @private
 * @returns {Object} The new state of the feature base/connection after the
 * reduction of the specified action.
 */
function _connectionDisconnected(
        state: IConnectionState,
        { connection }: { connection: Object; }) {
    const connection_ = _getCurrentConnection(state);

    if (connection_ !== connection) {
        return state;
    }

    return assign(state, {
        connecting: undefined,
        connection: undefined,
        preferVisitor: undefined,
        timeEstablished: undefined
    });
}

/**
 * Reduces a specific Redux action CONNECTION_ESTABLISHED of the feature
 * base/connection.
 *
 * @param {IConnectionState} state - The Redux state of the feature base/connection.
 * @param {Action} action - The Redux action CONNECTION_ESTABLISHED to reduce.
 * @private
 * @returns {Object} The new state of the feature base/connection after the
 * reduction of the specified action.
 */
function _connectionEstablished(
        state: IConnectionState,
        { connection, timeEstablished }: {
            connection: any;
            timeEstablished: number;
        }) {
    return assign(state, {
        connecting: undefined,
        connection,
        error: undefined,
        passwordRequired: undefined,
        timeEstablished
    });
}

/**
 * Reduces a specific Redux action CONNECTION_FAILED of the feature
 * base/connection.
 *
 * @param {IConnectionState} state - The Redux state of the feature base/connection.
 * @param {Action} action - The Redux action CONNECTION_FAILED to reduce.
 * @private
 * @returns {Object} The new state of the feature base/connection after the
 * reduction of the specified action.
 */
function _connectionFailed(
        state: IConnectionState,
        { connection, error }: {
            connection: Object;
            error: ConnectionFailedError;
        }) {
    const connection_ = _getCurrentConnection(state);

    if (connection_ && connection_ !== connection) {
        return state;
    }

    let preferVisitor;

    if (error.name === JitsiConnectionErrors.NOT_LIVE_ERROR) {
        // we want to keep the state for the moment when the meeting is live
        preferVisitor = state.preferVisitor;
    }

    return assign(state, {
        connecting: undefined,
        connection: undefined,
        error,
        passwordRequired:
            error.name === JitsiConnectionErrors.PASSWORD_REQUIRED
                ? connection : undefined,
        preferVisitor
    });
}

/**
 * Reduces a specific Redux action CONNECTION_WILL_CONNECT of the feature
 * base/connection.
 *
 * @param {IConnectionState} state - The Redux state of the feature base/connection.
 * @param {Action} action - The Redux action CONNECTION_WILL_CONNECT to reduce.
 * @private
 * @returns {Object} The new state of the feature base/connection after the
 * reduction of the specified action.
 */
function _connectionWillConnect(
        state: IConnectionState,
        { connection }: { connection: Object; }) {
    return assign(state, {
        connecting: connection,

        // We don't care if the previous connection has been closed already,
        // because it's an async process and there's no guarantee if it'll be
        // done before the new one is established.
        connection: undefined,
        error: undefined,
        passwordRequired: undefined,
        timeEstablished: undefined
    });
}

/**
 * The current (similar to getCurrentConference in base/conference/functions.any.js)
 * connection which is {@code connection} or {@code connecting}.
 *
 * @param {IConnectionState} baseConnectionState - The current state of the
 * {@code 'base/connection'} feature.
 * @returns {JitsiConnection} - The current {@code JitsiConnection} if any.
 * @private
 */
function _getCurrentConnection(baseConnectionState: IConnectionState): IConnectionState | undefined {
    return baseConnectionState.connection || baseConnectionState.connecting;
}

/**
 * Reduces a specific redux action {@link SET_JWT} of the feature
 * base/connection.
 *
 * @param {IConnectionState} state - The redux state of the feature base/connection.
 * @param {Action} action - The Redux action SET_JWT to reduce.
 * @private
 * @returns {Object} The new state of the feature base/connection after the
 * reduction of the specified action.
 */
function _setJWT(state: IConnectionState, { preferVisitor }: { preferVisitor: boolean; }) {
    return assign(state, {
        preferVisitor
    });
}

/**
 * Reduces a specific redux action {@link SET_LOCATION_URL} of the feature
 * base/connection.
 *
 * @param {IConnectionState} state - The redux state of the feature base/connection.
 * @param {Action} action - The redux action {@code SET_LOCATION_URL} to reduce.
 * @private
 * @returns {Object} The new state of the feature base/connection after the
 * reduction of the specified action.
 */
function _setLocationURL(
        state: IConnectionState,
        { locationURL }: { locationURL?: URL; }) {
    return set(state, 'locationURL', locationURL);
}

/**
 * Reduces a specific redux action {@link SET_ROOM} of the feature
 * base/connection.
 *
 * @param {IConnectionState} state - The redux state of the feature base/connection.
 * @private
 * @returns {Object} The new state of the feature base/connection after the
 * reduction of the specified action.
 */
function _setRoom(state: IConnectionState) {
    return assign(state, {
        error: undefined,
        passwordRequired: undefined
    });
}

/**
 * Reduces a specific redux action {@link SHOW_CONNECTION_INFO} of the feature
 * base/connection.
 *
 * @param {IConnectionState} state - The redux state of the feature base/connection.
 * @param {Action} action - The redux action {@code SHOW_CONNECTION_INFO} to reduce.
 * @private
 * @returns {Object} The new state of the feature base/connection after the
 * reduction of the specified action.
 */
function _setShowConnectionInfo(
        state: IConnectionState,
        { showConnectionInfo }: { showConnectionInfo: boolean; }) {
    return set(state, 'showConnectionInfo', showConnectionInfo);
}


################################################################################

## File: .\jitsi-meet\react\features\base\connection\types.ts

/**
 * The error structure passed to the {@link connectionFailed} action.
 *
 * Note there was an intention to make the error resemble an Error instance (to
 * the extent that jitsi-meet needs it).
 */
export type ConnectionFailedError = {

    /**
     * The invalid credentials that were used to authenticate and the
     * authentication failed.
     */
    credentials?: {

        /**
         * The XMPP user's ID.
         */
        jid: string;

        /**
         * The XMPP user's password.
         */
        password: string;
    };

    /**
     * The details about the connection failed event.
     */
    details?: Object;

    /**
     * Error message.
     */
    message?: string;

    /**
     * One of {@link JitsiConnectionError} constants (defined in
     * lib-jitsi-meet).
     */
    name: string;

    /**
     * Indicates whether this event is recoverable or not.
     */
    recoverable?: boolean;
};

/**
 * The value for the username or credential property.
 */
type ReplaceIceServersField = string | null;

/**
 * The value for the urls property.
 */
type IceServerUrls = null | string | Array<string>;

/**
 * The types of ice servers.
 */
enum IceServerType {
    STUN = 'stun',
    TURN = 'turn',
    TURNS = 'turns'
}

/**
 * Represents a single override rule.
 */
interface IReplaceIceServer {

    /**
     * The value the credential prop will be replaced with.
     *
     * NOTE: If the value is null we will remove the credential property in entry that matches the target type. If the
     * value is undefined or missing we won't change the credential property in the entry that matches the target type.
     */
    credential?: ReplaceIceServersField;

    /**
     * Target type that will be used to match the already received ice server and modify/remove it based on the values
     * of credential, urls and username.
     */
    targetType: IceServerType;

    /**
     * The value the urls prop will be replaced with.
     *
     * NOTE: If the value is null we will remove the whole entry that matches the target type. If the value is undefined
     * or missing we won't change the urls property in the entry that matches the target type.
     */
    urls?: IceServerUrls;

    /**
     * The value the username prop will be replaced with.
     *
     * NOTE: If the value is null we will remove the username property in entry that matches the target type. If the
     * value is undefined or missing we won't change the username property in the entry that matches the target type.
     */
    username?: ReplaceIceServersField;
}

/**
 * An object with rules for changing the existing ice server configuration.
 */
export interface IIceServers {

    /**
     * An array of rules for replacing parts from the existing ice server configuration.
     */
    replace: Array<IReplaceIceServer>;
}



################################################################################

## File: .\jitsi-meet\react\features\base\connection\utils.ts

/**
 * Gets a {@link URL} without hash and query/search params from a specific
 * {@code URL}.
 *
 * @param {URL} url - The {@code URL} which may have hash and query/search
 * params.
 * @returns {URL}
 */
export function getURLWithoutParams(url: URL): URL {
    const { hash, search } = url;

    if ((hash && hash.length > 1) || (search && search.length > 1)) {
        url = new URL(url.href); // eslint-disable-line no-param-reassign
        url.hash = '';
        url.search = '';

        // XXX The implementation of URL at least on React Native appends ? and
        // # at the end of the href which is not desired.
        let { href } = url;

        if (href) {
            href.endsWith('#') && (href = href.substring(0, href.length - 1));
            href.endsWith('?') && (href = href.substring(0, href.length - 1));

            // eslint-disable-next-line no-param-reassign
            url.href === href || (url = new URL(href));
        }
    }

    return url;
}

/**
 * Gets a URL string without hash and query/search params from a specific
 * {@code URL}.
 *
 * @param {URL} url - The {@code URL} which may have hash and query/search
 * params.
 * @returns {string}
 */
export function getURLWithoutParamsNormalized(url: URL): string {
    const urlWithoutParams = getURLWithoutParams(url).href;

    if (urlWithoutParams) {
        return urlWithoutParams.toLowerCase();
    }

    return '';
}


################################################################################

## File: .\jitsi-meet\react\features\base\devices\actions.web.ts

import { IStore } from '../../app/types';
import JitsiMeetJS from '../lib-jitsi-meet';
import { updateSettings } from '../settings/actions';
import { getUserSelectedOutputDeviceId } from '../settings/functions.web';

import {
    ADD_PENDING_DEVICE_REQUEST,
    CHECK_AND_NOTIFY_FOR_NEW_DEVICE,
    DEVICE_PERMISSIONS_CHANGED,
    NOTIFY_CAMERA_ERROR,
    NOTIFY_MIC_ERROR,
    REMOVE_PENDING_DEVICE_REQUESTS,
    SET_AUDIO_INPUT_DEVICE,
    SET_VIDEO_INPUT_DEVICE,
    UPDATE_DEVICE_LIST
} from './actionTypes';
import {
    areDeviceLabelsInitialized,
    areDevicesDifferent,
    filterIgnoredDevices,
    flattenAvailableDevices,
    getDeviceIdByLabel,
    getDeviceLabelById,
    getDevicesFromURL,
    logDevices,
    setAudioOutputDeviceId
} from './functions';
import logger from './logger';

/**
 * Maps the WebRTC string for device type to the keys used to store configure,
 * within redux, which devices should be used by default.
 */
const DEVICE_TYPE_TO_SETTINGS_KEYS = {
    audioInput: {
        currentDeviceId: 'micDeviceId',
        userSelectedDeviceId: 'userSelectedMicDeviceId',
        userSelectedDeviceLabel: 'userSelectedMicDeviceLabel'
    },
    audioOutput: {
        currentDeviceId: 'audioOutputDeviceId',
        userSelectedDeviceId: 'userSelectedAudioOutputDeviceId',
        userSelectedDeviceLabel: 'userSelectedAudioOutputDeviceLabel'
    },
    videoInput: {
        currentDeviceId: 'cameraDeviceId',
        userSelectedDeviceId: 'userSelectedCameraDeviceId',
        userSelectedDeviceLabel: 'userSelectedCameraDeviceLabel'
    }
};

/**
 * Adds a pending device request.
 *
 * @param {Object} request - The request to be added.
 * @returns {{
 *      type: ADD_PENDING_DEVICE_REQUEST,
 *      request: Object
 * }}
 */
export function addPendingDeviceRequest(request: Object) {
    return {
        type: ADD_PENDING_DEVICE_REQUEST,
        request
    };
}

/**
 * Configures the initial A/V devices before the conference has started.
 *
 * @returns {Function}
 */
export function configureInitialDevices() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const deviceLabels = getDevicesFromURL(getState());
        let updateSettingsPromise;

        if (deviceLabels) {
            updateSettingsPromise = dispatch(getAvailableDevices()).then(() => {
                const state = getState();

                if (!areDeviceLabelsInitialized(state)) {
                    // The labels are not available if the A/V permissions are
                    // not yet granted.

                    Object.keys(deviceLabels).forEach(key => {
                        dispatch(addPendingDeviceRequest({
                            type: 'devices',
                            name: 'setDevice',
                            device: {
                                kind: key.toLowerCase(),
                                label: deviceLabels[key as keyof typeof deviceLabels]
                            },
                            // eslint-disable-next-line @typescript-eslint/no-empty-function
                            responseCallback() {}
                        }));
                    });

                    return;
                }

                const newSettings: any = {};

                Object.keys(deviceLabels).forEach(key => {
                    const label = deviceLabels[key as keyof typeof deviceLabels];

                    // @ts-ignore
                    const deviceId = getDeviceIdByLabel(state, label, key);

                    if (deviceId) {
                        const settingsTranslationMap = DEVICE_TYPE_TO_SETTINGS_KEYS[
                            key as keyof typeof DEVICE_TYPE_TO_SETTINGS_KEYS];

                        newSettings[settingsTranslationMap.currentDeviceId] = deviceId;
                        newSettings[settingsTranslationMap.userSelectedDeviceId] = deviceId;
                        newSettings[settingsTranslationMap.userSelectedDeviceLabel] = label;
                    }
                });

                dispatch(updateSettings(newSettings));
            });
        } else {
            updateSettingsPromise = Promise.resolve();
        }

        return updateSettingsPromise
            .then(() => {
                const userSelectedAudioOutputDeviceId = getUserSelectedOutputDeviceId(getState());

                return setAudioOutputDeviceId(userSelectedAudioOutputDeviceId, dispatch)
                    .catch(ex => logger.warn(`Failed to set audio output device.
                        Default audio output device will be used instead ${ex}`));
            });
    };
}

/**
 * Queries for connected A/V input and output devices and updates the redux
 * state of known devices.
 *
 * @returns {Function}
 */
export function getAvailableDevices() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => new Promise(resolve => {
        const { mediaDevices } = JitsiMeetJS;

        if (mediaDevices.isDeviceListAvailable()
                && mediaDevices.isDeviceChangeAvailable()) {
            mediaDevices.enumerateDevices((devices: MediaDeviceInfo[]) => {
                const { filteredDevices, ignoredDevices } = filterIgnoredDevices(devices);
                const oldDevices = flattenAvailableDevices(getState()['features/base/devices'].availableDevices);

                if (areDevicesDifferent(oldDevices, filteredDevices)) {
                    logDevices(ignoredDevices, 'Ignored devices on device list changed:');
                    dispatch(updateDeviceList(filteredDevices));
                }

                resolve(filteredDevices);
            });
        } else {
            resolve([]);
        }
    });
}

/**
 * Signals that an error occurred while trying to obtain a track from a camera.
 *
 * @param {Object} error - The device error, as provided by lib-jitsi-meet.
 * @param {string} error.name - The constant for the type of the error.
 * @param {string} error.message - Optional additional information about the
 * error.
 * @returns {{
 *     type: NOTIFY_CAMERA_ERROR,
 *     error: Object
 * }}
 */
export function notifyCameraError(error: Error) {
    return {
        type: NOTIFY_CAMERA_ERROR,
        error
    };
}

/**
 * Signals that an error occurred while trying to obtain a track from a mic.
 *
 * @param {Object} error - The device error, as provided by lib-jitsi-meet.
 * @param {Object} error.name - The constant for the type of the error.
 * @param {string} error.message - Optional additional information about the
 * error.
 * @returns {{
 *     type: NOTIFY_MIC_ERROR,
 *     error: Object
 * }}
 */
export function notifyMicError(error: Error) {
    return {
        type: NOTIFY_MIC_ERROR,
        error
    };
}

/**
 * Remove all pending device requests.
 *
 * @returns {{
 *      type: REMOVE_PENDING_DEVICE_REQUESTS
 * }}
 */
export function removePendingDeviceRequests() {
    return {
        type: REMOVE_PENDING_DEVICE_REQUESTS
    };
}

/**
 * Signals to update the currently used audio input device.
 *
 * @param {string} deviceId - The id of the new audio input device.
 * @returns {{
 *      type: SET_AUDIO_INPUT_DEVICE,
 *      deviceId: string
 * }}
 */
export function setAudioInputDevice(deviceId: string) {
    return {
        type: SET_AUDIO_INPUT_DEVICE,
        deviceId
    };
}

/**
 * Sets the audio input device id and updates the settings
 * so they are persisted across sessions.
 *
 * @param {string} deviceId - The id of the new audio input device.
 * @returns {Function}
 */
export function setAudioInputDeviceAndUpdateSettings(deviceId: string) {
    return function(dispatch: IStore['dispatch'], getState: IStore['getState']) {
        const deviceLabel = getDeviceLabelById(getState(), deviceId, 'audioInput');

        dispatch(setAudioInputDevice(deviceId));
        dispatch(updateSettings({
            userSelectedMicDeviceId: deviceId,
            userSelectedMicDeviceLabel: deviceLabel
        }));
    };
}

/**
 * Updates the output device id.
 *
 * @param {string} deviceId - The id of the new output device.
 * @returns {Function}
 */
export function setAudioOutputDevice(deviceId: string) {
    return function(dispatch: IStore['dispatch'], getState: IStore['getState']) {
        const deviceLabel = getDeviceLabelById(getState(), deviceId, 'audioOutput');

        return setAudioOutputDeviceId(deviceId, dispatch, true, deviceLabel);
    };
}

/**
 * Signals to update the currently used video input device.
 *
 * @param {string} deviceId - The id of the new video input device.
 * @returns {{
 *      type: SET_VIDEO_INPUT_DEVICE,
 *      deviceId: string
 * }}
 */
export function setVideoInputDevice(deviceId: string) {
    return {
        type: SET_VIDEO_INPUT_DEVICE,
        deviceId
    };
}

/**
 * Sets the video input device id and updates the settings
 * so they are persisted across sessions.
 *
 * @param {string} deviceId - The id of the new video input device.
 * @returns {Function}
 */
export function setVideoInputDeviceAndUpdateSettings(deviceId: string) {
    return function(dispatch: IStore['dispatch'], getState: IStore['getState']) {
        const deviceLabel = getDeviceLabelById(getState(), deviceId, 'videoInput');

        dispatch(setVideoInputDevice(deviceId));
        dispatch(updateSettings({
            userSelectedCameraDeviceId: deviceId,
            userSelectedCameraDeviceLabel: deviceLabel
        }));
    };
}

/**
 * Signals to update the list of known audio and video devices.
 *
 * @param {Array<MediaDeviceInfo>} devices - All known available audio input,
 * audio output, and video input devices.
 * @returns {{
 *      type: UPDATE_DEVICE_LIST,
 *      devices: Array<MediaDeviceInfo>
 * }}
 */
export function updateDeviceList(devices: MediaDeviceInfo[]) {
    return {
        type: UPDATE_DEVICE_LIST,
        devices
    };
}

/**
 * Signals to check new and old devices for newly added devices and notify.
 *
 * @param {Array<MediaDeviceInfo>} newDevices - Array of the new devices.
 * @param {Array<MediaDeviceInfo>} oldDevices - Array of the old devices.
 * @returns {{
 *      type: CHECK_AND_NOTIFY_FOR_NEW_DEVICE,
 *      newDevices: Array<MediaDeviceInfo>,
 *      oldDevices: Array<MediaDeviceInfo>
 * }}
 */
export function checkAndNotifyForNewDevice(newDevices: MediaDeviceInfo[], oldDevices: MediaDeviceInfo[]) {
    return {
        type: CHECK_AND_NOTIFY_FOR_NEW_DEVICE,
        newDevices,
        oldDevices
    };
}

/**
 * Signals that the device permissions have changed.
 *
 * @param {Object} permissions - Object with the permissions.
 * @returns {{
 *      type: DEVICE_PERMISSIONS_CHANGED,
 *      permissions: Object
 * }}
 */
export function devicePermissionsChanged(permissions: Object) {
    return {
        type: DEVICE_PERMISSIONS_CHANGED,
        permissions
    };
}


################################################################################

## File: .\jitsi-meet\react\features\base\devices\actionTypes.ts

/**
 * The type of Redux action which signals that an error occurred while obtaining
 * a camera.
 *
 * {
 *     type: NOTIFY_CAMERA_ERROR,
 *     error: Object
 * }
 */
export const NOTIFY_CAMERA_ERROR = 'NOTIFY_CAMERA_ERROR';

/**
 * The type of Redux action which signals that an error occurred while obtaining
 * a microphone.
 *
 * {
 *     type: NOTIFY_MIC_ERROR,
 *     error: Object
 * }
 */
export const NOTIFY_MIC_ERROR = 'NOTIFY_MIC_ERROR';

/**
 * The type of Redux action which signals that the currently used audio
 * input device should be changed.
 *
 * {
 *     type: SET_AUDIO_INPUT_DEVICE,
 *     deviceId: string,
 * }
 */
export const SET_AUDIO_INPUT_DEVICE = 'SET_AUDIO_INPUT_DEVICE';

/**
 * The type of Redux action which signals that the currently used video
 * input device should be changed.
 *
 * {
 *     type: SET_VIDEO_INPUT_DEVICE,
 *     deviceId: string,
 * }
 */
export const SET_VIDEO_INPUT_DEVICE = 'SET_VIDEO_INPUT_DEVICE';

/**
 * The type of Redux action which signals that the list of known available
 * audio and video sources has changed.
 *
 * {
 *     type: UPDATE_DEVICE_LIST,
 *     devices: Array<MediaDeviceInfo>,
 * }
 */
export const UPDATE_DEVICE_LIST = 'UPDATE_DEVICE_LIST';

/**
 * The type of Redux action which will add a pending device requests that will
 * be executed later when it is possible (when the conference is joined).
 *
 * {
 *     type: ADD_PENDING_DEVICE_REQUEST,
 *     request: Object
 * }
 */
export const ADD_PENDING_DEVICE_REQUEST = 'ADD_PENDING_DEVICE_REQUEST';

/**
 * The type of Redux action which will remove all pending device requests.
 *
 * {
 *     type: REMOVE_PENDING_DEVICE_REQUESTS
 * }
 */
export const REMOVE_PENDING_DEVICE_REQUESTS = 'REMOVE_PENDING_DEVICE_REQUESTS';

/**
 * The type of Redux action which will check passed old and passed new devices
 * and if needed will show notifications asking the user whether to use those.
 *
 * {
 *     type: CHECK_AND_NOTIFY_FOR_NEW_DEVICE
 *     newDevices: Array<MediaDeviceInfo>
 *     oldDevices: Array<MediaDeviceInfo>
 * }
 */
export const CHECK_AND_NOTIFY_FOR_NEW_DEVICE = 'CHECK_AND_NOTIFY_FOR_NEW_DEVICE';

/**
 * The type of Redux action which signals that the device permissions have changed.
 *
 * {
 *     type: CHECK_AND_NOTIFY_FOR_NEW_DEVICE
 *     permissions: Object
 * }
 */
export const DEVICE_PERMISSIONS_CHANGED = 'DEVICE_PERMISSIONS_CHANGED';


################################################################################

## File: .\jitsi-meet\react\features\base\devices\constants.ts

/**
 * Prefixes of devices that will be filtered from the device list.
 *
 * NOTE: Currently we filter only 'Microsoft Teams Audio Device' virtual device. It seems that it can't be set
 * as default device on the OS level and this use case is not handled in the code. If we add more device prefixes that
 * can be default devices we should make sure to handle the default device use case.
 */
export const DEVICE_LABEL_PREFIXES_TO_IGNORE = [ 'Microsoft Teams Audio Device' ];


################################################################################

## File: .\jitsi-meet\react\features\base\devices\functions.any.ts

import { IReduxState } from '../../app/types';

/**
 * Returns true if there are devices of a specific type or on native platform.
 *
 * @param {Object} state - The state of the application.
 * @param {string} type - The type of device: VideoOutput | audioOutput | audioInput.
 *
 * @returns {boolean}
 */
export function hasAvailableDevices(state: IReduxState, type: string) {
    if (state['features/base/devices'] === undefined) {
        return true;
    }

    const availableDevices = state['features/base/devices'].availableDevices;

    return Number(availableDevices[type as keyof typeof availableDevices]?.length) > 0;
}


################################################################################

## File: .\jitsi-meet\react\features\base\devices\functions.native.ts

export * from './functions.any';


################################################################################

## File: .\jitsi-meet\react\features\base\devices\functions.web.ts

import { IReduxState, IStore } from '../../app/types';
import JitsiMeetJS from '../lib-jitsi-meet';
import { updateSettings } from '../settings/actions';
import { ISettingsState } from '../settings/reducer';
import { setNewAudioOutputDevice } from '../sounds/functions.web';
import { parseURLParams } from '../util/parseURLParams';

import { DEVICE_LABEL_PREFIXES_TO_IGNORE } from './constants';
import logger from './logger';
import { IDevicesState } from './types';

export * from './functions.any';

const webrtcKindToJitsiKindTranslator = {
    audioinput: 'audioInput',
    audiooutput: 'audioOutput',
    videoinput: 'videoInput'
};

/**
 * Detects the use case when the labels are not available if the A/V permissions
 * are not yet granted.
 *
 * @param {Object} state - The redux state.
 * @returns {boolean} - True if the labels are already initialized and false
 * otherwise.
 */
export function areDeviceLabelsInitialized(state: IReduxState) {
    // TODO: Replace with something that doesn't use APP when the conference.js logic is reactified.
    if (APP.conference._localTracksInitialized) {
        return true;
    }

    for (const type of [ 'audioInput', 'audioOutput', 'videoInput' ]) {
        const availableDevices = state['features/base/devices'].availableDevices;

        if ((availableDevices[type as keyof typeof availableDevices] || []).find(d => Boolean(d.label))) {
            return true;
        }
    }

    return false;
}

/**
 * Get device id of the audio output device which is currently in use.
 * Empty string stands for default device.
 *
 * @returns {string}
 */
export function getAudioOutputDeviceId() {
    return JitsiMeetJS.mediaDevices.getAudioOutputDevice();
}

/**
 * Finds the real device id of the default device of the given type.
 *
 * @param {Object} state - The redux state.
 * @param {*} kind - The type of the device. One of "audioInput",
 * "audioOutput", and "videoInput". Also supported is all lowercase versions
 * of the preceding types.
 * @returns {string|undefined}
 */
export function getDefaultDeviceId(state: IReduxState, kind: string) {
    const kindToSearch = webrtcKindToJitsiKindTranslator[kind as keyof typeof webrtcKindToJitsiKindTranslator] || kind;
    const availableDevices = state['features/base/devices'].availableDevices;
    const defaultDevice = (availableDevices[kindToSearch as keyof typeof availableDevices] || [])
        .find(d => d.deviceId === 'default');

    // Find the device with a matching group id.
    const matchingDevice = (availableDevices[kindToSearch as keyof typeof availableDevices] || [])
        .find(d => d.deviceId !== 'default' && d.groupId === defaultDevice?.groupId);

    if (matchingDevice) {
        return matchingDevice.deviceId;
    }
}

/**
 * Finds a device with a label that matches the passed label and returns its id.
 *
 * @param {Object} state - The redux state.
 * @param {string} label - The label.
 * @param {string} kind - The type of the device. One of "audioInput",
 * "audioOutput", and "videoInput". Also supported is all lowercase versions
 * of the preceding types.
 * @returns {string|undefined}
 */
export function getDeviceIdByLabel(state: IReduxState, label: string, kind: string) {
    const kindToSearch = webrtcKindToJitsiKindTranslator[kind as keyof typeof webrtcKindToJitsiKindTranslator] || kind;

    const availableDevices = state['features/base/devices'].availableDevices;
    const device
        = (availableDevices[kindToSearch as keyof typeof availableDevices] || [])
            .find(d => d.label === label);

    if (device) {
        return device.deviceId;
    }
}

/**
 * Finds a device with a label that matches the passed id and returns its label.
 *
 * @param {Object} state - The redux state.
 * @param {string} id - The device id.
 * @param {string} kind - The type of the device. One of "audioInput",
 * "audioOutput", and "videoInput". Also supported is all lowercase versions
 * of the preceding types.
 * @returns {string|undefined}
 */
export function getDeviceLabelById(state: IReduxState, id: string, kind: string) {
    const kindToSearch = webrtcKindToJitsiKindTranslator[kind as keyof typeof webrtcKindToJitsiKindTranslator] || kind;

    const availableDevices = state['features/base/devices'].availableDevices;
    const device
        = (availableDevices[kindToSearch as keyof typeof availableDevices] || [])
        .find(d => d.deviceId === id);

    if (device) {
        return device.label;
    }
}

/**
 * Returns the devices set in the URL.
 *
 * @param {Object} state - The redux state.
 * @returns {Object|undefined}
 */
export function getDevicesFromURL(state: IReduxState) {
    const urlParams
        = parseURLParams(state['features/base/connection'].locationURL ?? '');

    const audioOutput = urlParams['devices.audioOutput'];
    const videoInput = urlParams['devices.videoInput'];
    const audioInput = urlParams['devices.audioInput'];

    if (!audioOutput && !videoInput && !audioInput) {
        return undefined;
    }

    const devices: IDevicesState['availableDevices'] = {};

    audioOutput && (devices.audioOutput = audioOutput);
    videoInput && (devices.videoInput = videoInput);
    audioInput && (devices.audioInput = audioInput);

    return devices;
}

/**
 * Converts an array of media devices into an object organized by device kind.
 *
 * @param {Array<MediaDeviceInfo>} devices - Available media devices.
 * @private
 * @returns {Object} An object with the media devices split by type. The keys
 * are device type and the values are arrays with devices matching the device
 * type.
 */
export function groupDevicesByKind(devices: MediaDeviceInfo[]): IDevicesState['availableDevices'] {
    return {
        audioInput: devices.filter(device => device.kind === 'audioinput'),
        audioOutput: devices.filter(device => device.kind === 'audiooutput'),
        videoInput: devices.filter(device => device.kind === 'videoinput')
    };
}

/**
 * Filters audio devices from a list of MediaDeviceInfo objects.
 *
 * @param {Array<MediaDeviceInfo>} devices - Unfiltered media devices.
 * @private
 * @returns {Array<MediaDeviceInfo>} Filtered audio devices.
 */
export function filterAudioDevices(devices: MediaDeviceInfo[]) {
    return devices.filter(device => device.kind === 'audioinput');
}

/**
 * Filters the devices that start with one of the prefixes from DEVICE_LABEL_PREFIXES_TO_IGNORE.
 *
 * @param {MediaDeviceInfo[]} devices - The devices to be filtered.
 * @returns {MediaDeviceInfo[]} - The filtered devices.
 */
export function filterIgnoredDevices(devices: MediaDeviceInfo[] = []) {
    const ignoredDevices: MediaDeviceInfo[] = [];
    const filteredDevices = devices.filter(device => {
        if (!device.label) {
            return true;
        }

        if (DEVICE_LABEL_PREFIXES_TO_IGNORE.find(prefix => device.label?.startsWith(prefix))) {
            ignoredDevices.push(device);

            return false;
        }

        return true;
    });

    return {
        filteredDevices,
        ignoredDevices
    };
}

/**
 * Check if the passed device arrays are different.
 *
 * @param {MediaDeviceInfo[]} devices1 - Array with devices to be compared.
 * @param {MediaDeviceInfo[]} devices2 - Array with devices to be compared.
 * @returns {boolean} - True if the device arrays are different and false otherwise.
*/
export function areDevicesDifferent(devices1: MediaDeviceInfo[] = [], devices2: MediaDeviceInfo[] = []) {
    if (devices1.length !== devices2.length) {
        return true;
    }

    for (let i = 0; i < devices1.length; i++) {
        const device1 = devices1[i];
        const found = devices2.find(({ deviceId, groupId, kind, label }) =>
            device1.deviceId === deviceId
            && device1.groupId === groupId
            && device1.kind === kind
            && device1.label === label
        );

        if (!found) {
            return true;
        }
    }

    return false;
}

/**
 * Flattens the availableDevices from redux.
 *
 * @param {IDevicesState.availableDevices} devices - The available devices from redux.
 * @returns {MediaDeviceInfo[]} - The flattened array of devices.
 */
export function flattenAvailableDevices(
        { audioInput = [], audioOutput = [], videoInput = [] }: IDevicesState['availableDevices']) {
    return audioInput.concat(audioOutput).concat(videoInput);
}

/**
 * We want to strip any device details that are not very user friendly, like usb ids put in brackets at the end.
 *
 * @param {string} label - Device label to format.
 *
 * @returns {string} - Formatted string.
 */
export function formatDeviceLabel(label: string) {

    let formattedLabel = label;

    // Remove braked description at the end as it contains non user friendly strings i.e.
    // Microsoft® LifeCam HD-3000 (045e:0779:31dg:d1231)
    const ix = formattedLabel.lastIndexOf('(');

    if (ix !== -1) {
        formattedLabel = formattedLabel.substr(0, ix);
    }

    return formattedLabel;
}

/**
 * Returns a list of objects containing all the microphone device ids and labels.
 *
 * @param {Object} state - The state of the application.
 * @returns {Object[]}
 */
export function getAudioInputDeviceData(state: IReduxState) {
    return state['features/base/devices'].availableDevices.audioInput?.map(
        ({ deviceId, label }) => {
            return {
                deviceId,
                label
            };
        });
}

/**
 * Returns a list of objectes containing all the output device ids and labels.
 *
 * @param {Object} state - The state of the application.
 * @returns {Object[]}
 */
export function getAudioOutputDeviceData(state: IReduxState) {
    return state['features/base/devices'].availableDevices.audioOutput?.map(
        ({ deviceId, label }) => {
            return {
                deviceId,
                label
            };
        });
}

/**
 * Returns a list of all the camera device ids.
 *
 * @param {Object} state - The state of the application.
 * @returns {string[]}
 */
export function getVideoDeviceIds(state: IReduxState) {
    return state['features/base/devices'].availableDevices.videoInput?.map(({ deviceId }) => deviceId);
}

/**
 * Converts an array of device info objects into string.
 *
 * @param {MediaDeviceInfo[]} devices - The devices.
 * @returns {string}
 */
function devicesToStr(devices?: MediaDeviceInfo[]) {
    return devices?.map(device => `\t\t${device.label}[${device.deviceId}]`).join('\n');
}

/**
 * Logs an array of devices.
 *
 * @param {MediaDeviceInfo[]} devices - The array of devices.
 * @param {string} title - The title that will be printed in the log.
 * @returns {void}
 */
export function logDevices(devices: MediaDeviceInfo[], title = '') {
    const deviceList = groupDevicesByKind(devices);
    const audioInputs = devicesToStr(deviceList.audioInput);
    const audioOutputs = devicesToStr(deviceList.audioOutput);
    const videoInputs = devicesToStr(deviceList.videoInput);

    logger.debug(`${title}:\n`
        + `audioInput:\n${audioInputs}\n`
        + `audioOutput:\n${audioOutputs}\n`
        + `videoInput:\n${videoInputs}`);
}

/**
 * Set device id of the audio output device which is currently in use.
 * Empty string stands for default device.
 *
 * @param {string} newId - New audio output device id.
 * @param {Function} dispatch - The Redux dispatch function.
 * @param {boolean} userSelection - Whether this is a user selection update.
 * @param {?string} newLabel - New audio output device label to store.
 * @returns {Promise}
 */
export function setAudioOutputDeviceId(
        newId = 'default',
        dispatch: IStore['dispatch'],
        userSelection = false,
        newLabel?: string): Promise<any> {

    logger.debug(`setAudioOutputDevice: ${String(newLabel)}[${newId}]`);

    if (!JitsiMeetJS.mediaDevices.isDeviceChangeAvailable('output')) {
        logger.warn('Adjusting audio output is not supported');

        return Promise.resolve();
    }

    return JitsiMeetJS.mediaDevices.setAudioOutputDevice(newId)
        .then(() => {
            dispatch(setNewAudioOutputDevice(newId));
            const newSettings: Partial<ISettingsState> = {
                audioOutputDeviceId: newId,
                userSelectedAudioOutputDeviceId: undefined,
                userSelectedAudioOutputDeviceLabel: undefined
            };

            if (userSelection) {
                newSettings.userSelectedAudioOutputDeviceId = newId;
                newSettings.userSelectedAudioOutputDeviceLabel = newLabel;
            } else {
                // a flow workaround, I needed to add 'userSelectedAudioOutputDeviceId: undefined'
                delete newSettings.userSelectedAudioOutputDeviceId;
                delete newSettings.userSelectedAudioOutputDeviceLabel;
            }

            return dispatch(updateSettings(newSettings));
        });
}


################################################################################

## File: .\jitsi-meet\react\features\base\devices\logger.ts

import { getLogger } from '../logging/functions';

export default getLogger('features/base/devices');


################################################################################

## File: .\jitsi-meet\react\features\base\devices\middleware.web.ts

import { AnyAction } from 'redux';

import { IStore } from '../../app/types';
import { processExternalDeviceRequest } from '../../device-selection/functions';
import { showNotification, showWarningNotification } from '../../notifications/actions';
import { NOTIFICATION_TIMEOUT_TYPE } from '../../notifications/constants';
import { replaceAudioTrackById, replaceVideoTrackById, setDeviceStatusWarning } from '../../prejoin/actions';
import { isPrejoinPageVisible } from '../../prejoin/functions';
import { APP_WILL_MOUNT, APP_WILL_UNMOUNT } from '../app/actionTypes';
import { isMobileBrowser } from '../environment/utils';
import JitsiMeetJS, { JitsiMediaDevicesEvents, JitsiTrackErrors } from '../lib-jitsi-meet';
import { MEDIA_TYPE } from '../media/constants';
import MiddlewareRegistry from '../redux/MiddlewareRegistry';
import { updateSettings } from '../settings/actions';
import { getLocalTrack } from '../tracks/functions';

import {
    CHECK_AND_NOTIFY_FOR_NEW_DEVICE,
    NOTIFY_CAMERA_ERROR,
    NOTIFY_MIC_ERROR,
    SET_AUDIO_INPUT_DEVICE,
    SET_VIDEO_INPUT_DEVICE,
    UPDATE_DEVICE_LIST
} from './actionTypes';
import {
    devicePermissionsChanged,
    removePendingDeviceRequests,
    setAudioInputDevice,
    setVideoInputDevice
} from './actions';
import {
    areDeviceLabelsInitialized,
    formatDeviceLabel,
    logDevices,
    setAudioOutputDeviceId
} from './functions';
import logger from './logger';

const JITSI_TRACK_ERROR_TO_MESSAGE_KEY_MAP = {
    microphone: {
        [JitsiTrackErrors.CONSTRAINT_FAILED]: 'dialog.micConstraintFailedError',
        [JitsiTrackErrors.GENERAL]: 'dialog.micUnknownError',
        [JitsiTrackErrors.NOT_FOUND]: 'dialog.micNotFoundError',
        [JitsiTrackErrors.PERMISSION_DENIED]: 'dialog.micPermissionDeniedError',
        [JitsiTrackErrors.TIMEOUT]: 'dialog.micTimeoutError'
    },
    camera: {
        [JitsiTrackErrors.CONSTRAINT_FAILED]: 'dialog.cameraConstraintFailedError',
        [JitsiTrackErrors.GENERAL]: 'dialog.cameraUnknownError',
        [JitsiTrackErrors.NOT_FOUND]: 'dialog.cameraNotFoundError',
        [JitsiTrackErrors.PERMISSION_DENIED]: 'dialog.cameraPermissionDeniedError',
        [JitsiTrackErrors.UNSUPPORTED_RESOLUTION]: 'dialog.cameraUnsupportedResolutionError',
        [JitsiTrackErrors.TIMEOUT]: 'dialog.cameraTimeoutError'
    }
};

/**
 * A listener for device permissions changed reported from lib-jitsi-meet.
 */
let permissionsListener: Function | undefined;

/**
 * Implements the middleware of the feature base/devices.
 *
 * @param {Store} store - Redux store.
 * @returns {Function}
 */
// eslint-disable-next-line no-unused-vars
MiddlewareRegistry.register(store => next => action => {
    switch (action.type) {
    case APP_WILL_MOUNT: {
        const _permissionsListener = (permissions: Object) => {
            store.dispatch(devicePermissionsChanged(permissions));
        };
        const { mediaDevices } = JitsiMeetJS;

        permissionsListener = _permissionsListener;
        mediaDevices.addEventListener(JitsiMediaDevicesEvents.PERMISSIONS_CHANGED, permissionsListener);
        Promise.all([
            mediaDevices.isDevicePermissionGranted('audio'),
            mediaDevices.isDevicePermissionGranted('video')
        ])
        .then(results => {
            _permissionsListener({
                audio: results[0],
                video: results[1]
            });
        })
        .catch(() => {
            // Ignore errors.
        });
        break;
    }
    case APP_WILL_UNMOUNT:
        if (typeof permissionsListener === 'function') {
            JitsiMeetJS.mediaDevices.removeEventListener(
                JitsiMediaDevicesEvents.PERMISSIONS_CHANGED, permissionsListener);
            permissionsListener = undefined;
        }
        break;
    case NOTIFY_CAMERA_ERROR: {
        if (!action.error) {
            break;
        }

        const { message, name } = action.error;

        const cameraJitsiTrackErrorMsg
            = JITSI_TRACK_ERROR_TO_MESSAGE_KEY_MAP.camera[name];
        const cameraErrorMsg = cameraJitsiTrackErrorMsg
            || JITSI_TRACK_ERROR_TO_MESSAGE_KEY_MAP
                .camera[JitsiTrackErrors.GENERAL];
        const additionalCameraErrorMsg = cameraJitsiTrackErrorMsg ? null : message;
        const titleKey = name === JitsiTrackErrors.PERMISSION_DENIED
            ? 'deviceError.cameraPermission' : 'deviceError.cameraError';

        store.dispatch(showWarningNotification({
            description: additionalCameraErrorMsg,
            descriptionKey: cameraErrorMsg,
            titleKey
        }, NOTIFICATION_TIMEOUT_TYPE.MEDIUM));

        if (isPrejoinPageVisible(store.getState())) {
            store.dispatch(setDeviceStatusWarning(titleKey));
        }

        break;
    }
    case NOTIFY_MIC_ERROR: {
        if (!action.error) {
            break;
        }

        const { message, name } = action.error;

        const micJitsiTrackErrorMsg
            = JITSI_TRACK_ERROR_TO_MESSAGE_KEY_MAP.microphone[name];
        const micErrorMsg = micJitsiTrackErrorMsg
            || JITSI_TRACK_ERROR_TO_MESSAGE_KEY_MAP
                .microphone[JitsiTrackErrors.GENERAL];
        const additionalMicErrorMsg = micJitsiTrackErrorMsg ? null : message;
        const titleKey = name === JitsiTrackErrors.PERMISSION_DENIED
            ? 'deviceError.microphonePermission'
            : 'deviceError.microphoneError';

        store.dispatch(showWarningNotification({
            description: additionalMicErrorMsg,
            descriptionKey: micErrorMsg,
            titleKey
        }, NOTIFICATION_TIMEOUT_TYPE.MEDIUM));

        if (isPrejoinPageVisible(store.getState())) {
            store.dispatch(setDeviceStatusWarning(titleKey));
        }

        break;
    }
    case SET_AUDIO_INPUT_DEVICE:
        if (isPrejoinPageVisible(store.getState())) {
            store.dispatch(replaceAudioTrackById(action.deviceId));
        } else {
            APP.conference.onAudioDeviceChanged(action.deviceId);
        }
        break;
    case SET_VIDEO_INPUT_DEVICE: {
        const localTrack = getLocalTrack(store.getState()['features/base/tracks'], MEDIA_TYPE.VIDEO);

        // on mobile devices the video stream has to be stopped before replacing it
        if (isMobileBrowser() && localTrack && !localTrack.muted) {
            localTrack.jitsiTrack.stopStream();
        }
        if (isPrejoinPageVisible(store.getState())) {
            store.dispatch(replaceVideoTrackById(action.deviceId));
        } else {
            APP.conference.onVideoDeviceChanged(action.deviceId);
        }
        break;
    }
    case UPDATE_DEVICE_LIST:
        logDevices(action.devices, 'Device list updated');
        if (areDeviceLabelsInitialized(store.getState())) {
            return _processPendingRequests(store, next, action);
        }
        break;
    case CHECK_AND_NOTIFY_FOR_NEW_DEVICE:
        _checkAndNotifyForNewDevice(store, action.newDevices, action.oldDevices);
        break;
    }

    return next(action);
});

/**
 * Does extra sync up on properties that may need to be updated after the
 * conference was joined.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @param {Dispatch} next - The redux {@code dispatch} function to dispatch the
 * specified {@code action} to the specified {@code store}.
 * @param {Action} action - The redux action {@code CONFERENCE_JOINED} which is
 * being dispatched in the specified {@code store}.
 * @private
 * @returns {Object} The value returned by {@code next(action)}.
 */
function _processPendingRequests({ dispatch, getState }: IStore, next: Function, action: AnyAction) {
    const result = next(action);
    const state = getState();
    const { pendingRequests } = state['features/base/devices'];

    if (!pendingRequests || pendingRequests.length === 0) {
        return result;
    }

    pendingRequests.forEach((request: any) => {
        processExternalDeviceRequest(
            dispatch,
            getState,
            request,
            request.responseCallback);
    });
    dispatch(removePendingDeviceRequests());

    return result;
}

/**
 * Finds a new device by comparing new and old array of devices and dispatches
 * notification with the new device. For new devices with same groupId only one
 * notification will be shown, this is so to avoid showing multiple notifications
 * for audio input and audio output devices.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @param {MediaDeviceInfo[]} newDevices - The array of new devices we received.
 * @param {MediaDeviceInfo[]} oldDevices - The array of the old devices we have.
 * @private
 * @returns {void}
 */
function _checkAndNotifyForNewDevice(store: IStore, newDevices: MediaDeviceInfo[], oldDevices: MediaDeviceInfo[]) {
    const { dispatch } = store;

    // let's intersect both newDevices and oldDevices and handle thew newly
    // added devices
    const onlyNewDevices = newDevices.filter(
        nDevice => !oldDevices.find(
            device => device.deviceId === nDevice.deviceId));

    // we group devices by groupID which normally is the grouping by physical device
    // plugging in headset we provide normally two device, one input and one output
    // and we want to show only one notification for this physical audio device
    const devicesGroupBy: {
        [key: string]: MediaDeviceInfo[];
    } = onlyNewDevices.reduce((accumulated: any, value) => {
        accumulated[value.groupId] = accumulated[value.groupId] || [];
        accumulated[value.groupId].push(value);

        return accumulated;
    }, {});

    Object.values(devicesGroupBy).forEach(devicesArray => {

        if (devicesArray.length < 1) {
            return;
        }

        // let's get the first device as a reference, we will use it for
        // label and type
        const newDevice = devicesArray[0];

        // we want to strip any device details that are not very
        // user friendly, like usb ids put in brackets at the end
        const description = formatDeviceLabel(newDevice.label);

        let titleKey;

        switch (newDevice.kind) {
        case 'videoinput': {
            titleKey = 'notify.newDeviceCameraTitle';
            break;
        }
        case 'audioinput' :
        case 'audiooutput': {
            titleKey = 'notify.newDeviceAudioTitle';
            break;
        }
        }
        if (!isPrejoinPageVisible(store.getState())) {
            dispatch(showNotification({
                description,
                titleKey,
                customActionNameKey: [ 'notify.newDeviceAction' ],
                customActionHandler: [ _useDevice.bind(undefined, store, devicesArray) ]
            }, NOTIFICATION_TIMEOUT_TYPE.MEDIUM));
        }
    });
}

/**
 * Set a device to be currently used, selected by the user.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @param {Array<MediaDeviceInfo|InputDeviceInfo>} devices - The devices to save.
 * @returns {boolean} - Returns true in order notifications to be dismissed.
 * @private
 */
function _useDevice({ dispatch }: IStore, devices: MediaDeviceInfo[]) {
    devices.forEach(device => {
        switch (device.kind) {
        case 'videoinput': {
            dispatch(updateSettings({
                userSelectedCameraDeviceId: device.deviceId,
                userSelectedCameraDeviceLabel: device.label
            }));

            dispatch(setVideoInputDevice(device.deviceId));
            break;
        }
        case 'audioinput': {
            dispatch(updateSettings({
                userSelectedMicDeviceId: device.deviceId,
                userSelectedMicDeviceLabel: device.label
            }));

            dispatch(setAudioInputDevice(device.deviceId));
            break;
        }
        case 'audiooutput': {
            setAudioOutputDeviceId(
                device.deviceId,
                dispatch,
                true,
                device.label)
                .then(() => logger.log('changed audio output device'))
                .catch(err => {
                    logger.warn(
                        'Failed to change audio output device.',
                        'Default or previously set audio output device will',
                        ' be used instead.',
                        err);
                });
            break;
        }
        }
    });

    return true;
}


################################################################################

## File: .\jitsi-meet\react\features\base\devices\reducer.web.ts

import ReducerRegistry from '../redux/ReducerRegistry';

import {
    ADD_PENDING_DEVICE_REQUEST,
    DEVICE_PERMISSIONS_CHANGED,
    REMOVE_PENDING_DEVICE_REQUESTS,
    SET_AUDIO_INPUT_DEVICE,
    SET_VIDEO_INPUT_DEVICE,
    UPDATE_DEVICE_LIST
} from './actionTypes';
import { groupDevicesByKind } from './functions.web';
import logger from './logger';
import { IDevicesState } from './types';


const DEFAULT_STATE: IDevicesState = {
    availableDevices: {
        audioInput: [],
        audioOutput: [],
        videoInput: []
    },
    pendingRequests: [],
    permissions: {
        audio: false,
        video: false
    }
};

/**
 * Listen for actions which changes the state of known and used devices.
 *
 * @param {IDevicesState} state - The Redux state of the feature features/base/devices.
 * @param {Object} action - Action object.
 * @param {string} action.type - Type of action.
 * @param {Array<MediaDeviceInfo>} action.devices - All available audio and
 * video devices.
 * @returns {Object}
 */
ReducerRegistry.register<IDevicesState>(
    'features/base/devices',
    (state = DEFAULT_STATE, action): IDevicesState => {
        switch (action.type) {
        case UPDATE_DEVICE_LIST: {
            const deviceList = groupDevicesByKind(action.devices);

            return {
                ...state,
                availableDevices: deviceList
            };
        }

        case ADD_PENDING_DEVICE_REQUEST:
            return {
                ...state,
                pendingRequests: [
                    ...state.pendingRequests,
                    action.request
                ]
            };

        case REMOVE_PENDING_DEVICE_REQUESTS:
            return {
                ...state,
                pendingRequests: [ ]
            };

        // TODO: Changing of current audio and video device id is currently handled outside of react/redux.
        case SET_AUDIO_INPUT_DEVICE: {
            logger.debug(`set audio input device: ${action.deviceId}`);

            return state;
        }
        case SET_VIDEO_INPUT_DEVICE: {
            logger.debug(`set video input device: ${action.deviceId}`);

            return state;
        }
        case DEVICE_PERMISSIONS_CHANGED: {
            return {
                ...state,
                permissions: action.permissions
            };
        }
        default:
            return state;
        }
    });



################################################################################

## File: .\jitsi-meet\react\features\base\devices\types.ts

/* eslint-disable lines-around-comment */

export interface IDevicesState {
    availableDevices: {
        // @ts-ignore
        audioInput?: MediaDeviceInfo[];
        // @ts-ignore
        audioOutput?: MediaDeviceInfo[];
        // @ts-ignore
        videoInput?: MediaDeviceInfo[];
    };
    pendingRequests: any[];
    permissions: {
        audio: boolean;
        video: boolean;
    };
}


################################################################################

## File: .\jitsi-meet\react\features\base\dialog\actions.ts

import { ComponentType } from 'react';

import { IStore } from '../../app/types';

import {
    HIDE_DIALOG,
    HIDE_SHEET,
    OPEN_DIALOG,
    OPEN_SHEET
} from './actionTypes';
import { isDialogOpen } from './functions';

/**
 * Signals Dialog to close its dialog.
 *
 * @param {Object} [component] - The {@code Dialog} component to close/hide. If
 * {@code undefined}, closes/hides {@code Dialog} regardless of which
 * component it's rendering; otherwise, closes/hides {@code Dialog} only if
 * it's rendering the specified {@code component}.
 * @returns {{
 *     type: HIDE_DIALOG,
 *     component: (React.Component | undefined)
 * }}
 */
export function hideDialog(component?: ComponentType<any>) {
    return {
        type: HIDE_DIALOG,
        component
    };
}

/**
 * Closes the active sheet.
 *
 * @returns {{
 *     type: HIDE_SHEET,
 * }}
 */
export function hideSheet() {
    return {
        type: HIDE_SHEET
    };
}

/**
 * Signals Dialog to open dialog.
 *
 * @param {Object} component - The component to display as dialog.
 * @param {Object} [componentProps] - The React {@code Component} props of the
 * specified {@code component}.
 * @returns {{
 *     type: OPEN_DIALOG,
 *     component: React.Component,
 *     componentProps: (Object | undefined)
 * }}
 */
export function openDialog(component: ComponentType<any>, componentProps?: Object) {
    return {
        type: OPEN_DIALOG,
        component,
        componentProps
    };
}

/**
 * Opens the requested sheet.
 *
 * @param {Object} component - The component to display as a sheet.
 * @param {Object} [componentProps] - The React {@code Component} props of the
 * specified {@code component}.
 * @returns {{
 *     type: OPEN_SHEET,
 *     component: React.Component,
 *     componentProps: (Object | undefined)
 * }}
 */
export function openSheet(component: ComponentType<any>, componentProps?: Object) {
    return {
        type: OPEN_SHEET,
        component,
        componentProps
    };
}

/**
 * Signals Dialog to open a dialog with the specified component if the component
 * is not already open. If it is open, then Dialog is signaled to close its
 * dialog.
 *
 * @param {Object} component - The component to display as dialog.
 * @param {Object} [componentProps] - The React {@code Component} props of the
 * specified {@code component}.
 * @returns {Function}
 */
export function toggleDialog(component: ComponentType<any>, componentProps?: Object) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        if (isDialogOpen(getState, component)) {
            dispatch(hideDialog(component));
        } else {
            dispatch(openDialog(component, componentProps));
        }
    };
}


################################################################################

## File: .\jitsi-meet\react\features\base\dialog\actionTypes.ts

/**
 * The type of Redux action which closes a dialog
 *
 * {
 *     type: HIDE_DIALOG
 * }
 */
export const HIDE_DIALOG = 'HIDE_DIALOG';

/**
 * The type of Redux action which closes a sheet.
 *
 * {
 *     type: HIDE_SHEET
 * }
 */
export const HIDE_SHEET = 'HIDE_SHEET';

/**
 * The type of Redux action which begins a request to open a dialog.
 *
 * {
 *     type: OPEN_DIALOG,
 *     component: React.Component,
 *     props: PropTypes
 * }
 *
 */
export const OPEN_DIALOG = 'OPEN_DIALOG';

/**
 * The type of Redux action which begins a request to open a sheet.
 *
 * {
 *     type: OPEN_SHEET,
 *     component: React.Component,
 *     props: PropTypes
 * }
 *
 */
export const OPEN_SHEET = 'OPEN_SHEET';


################################################################################

## File: .\jitsi-meet\react\features\base\dialog\constants.ts

import { ReactNode } from 'react';

export type DialogProps = {

    /**
     * Whether cancel button is disabled. Enabled by default.
     */
    cancelDisabled?: boolean;

    /**
     * Optional i18n key to change the cancel button title.
     */
    cancelKey?: string;

    /**
     * The React {@code Component} children which represents the dialog's body.
     */
    children?: ReactNode;

    /**
     * Is ok button enabled/disabled. Enabled by default.
     */
    okDisabled?: boolean;

    /**
     * Optional i18n key to change the ok button title.
     */
    okKey?: string;

    /**
     * The handler for onCancel event.
     */
    onCancel?: Function;

    /**
     * The handler for the event when submitting the dialog.
     */
    onSubmit?: Function;

    /**
     * Additional style to be applied on the dialog.
     *
     * NOTE: Not all dialog types support this!
     */
    style?: Object;

    /**
     * Key to use for showing a title.
     */
    titleKey?: string;

    /**
     * The string to use as a title instead of {@code titleKey}. If a truthy
     * value is specified, it takes precedence over {@code titleKey} i.e.
     * The latter is unused.
     */
    titleString?: string;
};

/**
 * A preferred (or optimal) dialog size. This constant is reused in many
 * components, where dialog size optimization is suggested.
 *
 * NOTE: Even though we support valious devices, including tablets, we don't
 * want the dialogs to be oversized even on larger devices. This number seems
 * to be a good compromise, but also easy to update.
 */
export const PREFERRED_DIALOG_SIZE = 300;


################################################################################

## File: .\jitsi-meet\react\features\base\dialog\functions.ts

import { ComponentType } from 'react';

import { IReduxState } from '../../app/types';
import { IStateful } from '../app/types';
import ColorSchemeRegistry from '../color-scheme/ColorSchemeRegistry';
import { toState } from '../redux/functions';

/**
 * Checks if any {@code Dialog} is currently open.
 *
 * @param {IStateful} stateful - The redux store, the redux
 * {@code getState} function, or the redux state itself.
 * @returns {boolean}
 */
export function isAnyDialogOpen(stateful: IStateful) {
    return Boolean(toState(stateful)['features/base/dialog'].component);
}

/**
 * Checks if a {@code Dialog} with a specific {@code component} is currently
 * open.
 *
 * @param {IStateful} stateful - The redux store, the redux
 * {@code getState} function, or the redux state itself.
 * @param {React.Component} component - The {@code component} of a
 * {@code Dialog} to be checked.
 * @returns {boolean}
 */
export function isDialogOpen(stateful: IStateful, component: ComponentType<any>) {
    return toState(stateful)['features/base/dialog'].component === component;
}

/**
 * Maps part of the Redux state to the props of any Dialog based component.
 *
 * @param {IReduxState} state - The Redux state.
 * @returns {{
 *     _dialogStyles: StyleType
 * }}
 */
export function _abstractMapStateToProps(state: IReduxState) {
    return {
        _dialogStyles: ColorSchemeRegistry.get(state, 'Dialog')
    };
}


################################################################################

## File: .\jitsi-meet\react\features\base\dialog\logger.ts

import { getLogger } from '../logging/functions';

export default getLogger('features/base/dialog');


################################################################################

## File: .\jitsi-meet\react\features\base\dialog\reducer.ts

import { ComponentType } from 'react';

import ReducerRegistry from '../redux/ReducerRegistry';
import { assign } from '../redux/functions';

import {
    HIDE_DIALOG,
    HIDE_SHEET,
    OPEN_DIALOG,
    OPEN_SHEET
} from './actionTypes';

export interface IDialogState {
    component?: ComponentType;
    componentProps?: Object;
    sheet?: ComponentType;
    sheetProps?: Object;
}

/**
 * Reduces redux actions which show or hide dialogs.
 *
 * @param {IDialogState} state - The current redux state.
 * @param {Action} action - The redux action to reduce.
 * @param {string} action.type - The type of the redux action to reduce..
 * @returns {State} The next redux state that is the result of reducing the
 * specified action.
 */
ReducerRegistry.register<IDialogState>('features/base/dialog', (state = {}, action): IDialogState => {
    switch (action.type) {
    case HIDE_DIALOG: {
        const { component } = action;

        if (typeof component === 'undefined' || state.component === component) {
            return assign(state, {
                component: undefined,
                componentProps: undefined
            });
        }
        break;
    }

    case OPEN_DIALOG:
        return assign(state, {
            component: action.component,
            componentProps: action.componentProps
        });

    case HIDE_SHEET:
        return assign(state, {
            sheet: undefined,
            sheetProps: undefined
        });

    case OPEN_SHEET:
        return assign(state, {
            sheet: action.component,
            sheetProps: action.componentProps
        });
    }

    return state;
});


################################################################################

## File: .\jitsi-meet\react\features\base\dialog\components\AbstractDialogContainer.ts

import React, { Component, ComponentType } from 'react';

import { IReduxState } from '../../../app/types';
import { IReactionEmojiProps } from '../../../reactions/constants';

/**
 * The type of the React {@code Component} props of {@link DialogContainer}.
 */
interface IProps {

    /**
     * The component to render.
     */
    _component?: ComponentType<any>;

    /**
     * The props to pass to the component that will be rendered.
     */
    _componentProps?: Object;

    /**
     * Array of reactions to be displayed.
     */
    _reactionsQueue: Array<IReactionEmojiProps>;

    /**
     * True if the UI is in a compact state where we don't show dialogs.
     */
    _reducedUI: boolean;
}

/**
 * Implements a DialogContainer responsible for showing all dialogs.
 */
export default class AbstractDialogContainer extends Component<IProps> {
    /**
     * Returns the dialog to be displayed.
     *
     * @private
     * @returns {ReactElement|null}
     */
    _renderDialogContent() {
        const {
            _component: component,
            _reducedUI: reducedUI
        } = this.props;

        return (
            component && !reducedUI
                ? React.createElement(component, this.props._componentProps)
                : null);
    }
}

/**
 * Maps (parts of) the redux state to the associated
 * {@code AbstractDialogContainer}'s props.
 *
 * @param {Object} state - The redux state.
 * @private
 * @returns {IProps}
 */
export function abstractMapStateToProps(state: IReduxState) {
    const stateFeaturesBaseDialog = state['features/base/dialog'];
    const { reducedUI } = state['features/base/responsive-ui'];

    return {
        _component: stateFeaturesBaseDialog.component,
        _componentProps: stateFeaturesBaseDialog.componentProps,
        _reducedUI: reducedUI
    };
}


################################################################################

## File: .\jitsi-meet\react\features\base\dialog\components\native\AbstractDialog.ts

import { Component } from 'react';

import { IStore } from '../../../../app/types';
import { hideDialog } from '../../actions';
import { DialogProps } from '../../constants';

/**
 * The type of the React {@code Component} props of {@link AbstractDialog}.
 */
export interface IProps extends DialogProps {

    /**
     * Used to show/hide the dialog on cancel.
     */
    dispatch: IStore['dispatch'];
}

/**
 * The type of the React {@code Component} state of {@link AbstractDialog}.
 */
export interface IState {
    submitting?: boolean;
}

/**
 * An abstract implementation of a dialog on Web/React and mobile/react-native.
 */
export default class AbstractDialog<P extends IProps, S extends IState = IState>
    extends Component<P, S> {

    _mounted: boolean;

    /**
     * Initializes a new {@code AbstractDialog} instance.
     *
     * @param {Object} props - The read-only React {@code Component} props with
     * which the new instance is to be initialized.
     */
    constructor(props: P) {
        super(props);

        // Bind event handlers so they are only bound once per instance.
        this._onCancel = this._onCancel.bind(this);
        this._onSubmit = this._onSubmit.bind(this);
        this._onSubmitFulfilled = this._onSubmitFulfilled.bind(this);
        this._onSubmitRejected = this._onSubmitRejected.bind(this);
    }

    /**
     * Implements React's {@link Component#componentDidMount()}. Invoked
     * immediately before mounting occurs.
     *
     * @inheritdoc
     */
    componentDidMount() {
        this._mounted = true;
    }

    /**
     * Implements React's {@link Component#componentWillUnmount()}. Invoked
     * immediately before this component is unmounted and destroyed.
     *
     * @inheritdoc
     */
    componentWillUnmount() {
        this._mounted = false;
    }

    /**
     * Dispatches a redux action to hide this dialog.
     *
     * @returns {*} The return value of {@link hideDialog}.
     */
    _hide() {
        return this.props.dispatch(hideDialog());
    }

    /**
     * Dispatches a redux action to hide this dialog when it's canceled.
     *
     * @protected
     * @returns {void}
     */
    _onCancel() {
        const { cancelDisabled = false, onCancel } = this.props;

        if (!cancelDisabled && (!onCancel || onCancel())) {
            this._hide();
        }
    }

    /**
     * Submits this {@code Dialog}. If the React {@code Component} prop
     * {@code onSubmit} is defined, the function that is the value of the prop
     * is invoked. If the function returns a {@code thenable}, then the
     * resolution of the {@code thenable} is awaited. If the submission
     * completes successfully, a redux action will be dispatched to hide this
     * dialog.
     *
     * @protected
     * @param {string} [value] - The submitted value if any.
     * @returns {void}
     */
    _onSubmit(value?: string) {
        const { okDisabled = false, onSubmit } = this.props;

        if (!okDisabled) {
            this.setState({ submitting: true });

            // Invoke the React Component prop onSubmit if any.
            const r = !onSubmit || onSubmit(value);

            // If the invocation returns a thenable, await its resolution;
            // otherwise, treat the return value as a boolean indicating whether
            // the submission has completed successfully.
            let then;

            if (r) {
                switch (typeof r) {
                case 'function':
                case 'object':
                    then = r.then;
                    break;
                }
            }
            if (typeof then === 'function' && then.length === 2) {
                then.call(r, this._onSubmitFulfilled, this._onSubmitRejected);
            } else if (r) {
                this._onSubmitFulfilled();
            } else {
                this._onSubmitRejected();
            }
        }
    }

    /**
     * Notifies this {@code AbstractDialog} that it has been submitted
     * successfully. Dispatches a redux action to hide this dialog after it has
     * been submitted.
     *
     * @private
     * @returns {void}
     */
    _onSubmitFulfilled() {
        this._mounted && this.setState({ submitting: false });

        this._hide();
    }

    /**
     * Notifies this {@code AbstractDialog} that its submission has failed.
     *
     * @private
     * @returns {void}
     */
    _onSubmitRejected() {
        this._mounted && this.setState({ submitting: false });
    }
}


################################################################################

## File: .\jitsi-meet\react\features\base\dialog\components\native\styles.ts

import { StyleSheet } from 'react-native';

import ColorSchemeRegistry from '../../../color-scheme/ColorSchemeRegistry';
import { schemeColor } from '../../../color-scheme/functions';
import { BoxModel } from '../../../styles/components/styles/BoxModel';
import BaseTheme from '../../../ui/components/BaseTheme.native';
import { PREFERRED_DIALOG_SIZE } from '../../constants';

const BORDER_RADIUS = 5;

/**
 * NOTE: These Material guidelines based values are currently only used in
 * dialogs (and related) but later on it would be nice to export it into a base
 * Material feature.
 */
export const MD_FONT_SIZE = 16;
export const MD_ITEM_HEIGHT = 48;
export const MD_ITEM_MARGIN_PADDING = BaseTheme.spacing[3];

/**
 * Reusable (colored) style for text in any branded dialogs.
 */
const brandedDialogText = {
    color: schemeColor('text'),
    fontSize: MD_FONT_SIZE,
    textAlign: 'center'
};

const brandedDialogLabelStyle = {
    color: BaseTheme.palette.text01,
    flexShrink: 1,
    fontSize: MD_FONT_SIZE,
    opacity: 0.90
};

const brandedDialogItemContainerStyle = {
    alignItems: 'center',
    flexDirection: 'row',
    height: MD_ITEM_HEIGHT
};

const brandedDialogIconStyle = {
    color: BaseTheme.palette.icon01,
    fontSize: 24
};

export const inputDialog = {
    formMessage: {
        alignSelf: 'flex-start',
        fontStyle: 'italic',
        fontWeight: 'bold',
        marginTop: BaseTheme.spacing[3]
    }
};

/**
 * The React {@code Component} styles of {@code BottomSheet}. These have
 * been implemented as per the Material Design guidelines:
 * {@link https://material.io/guidelines/components/bottom-sheets.html}.
 */
export const bottomSheetStyles = {
    sheetAreaCover: {
        backgroundColor: 'transparent',
        flex: 1
    },

    scrollView: {
        paddingHorizontal: 0
    },

    /**
     * Style for the container of the sheet.
     */
    sheetContainer: {
        alignItems: 'stretch',
        flex: 1,
        flexDirection: 'column',
        justifyContent: 'flex-end',
        maxWidth: 500,
        marginLeft: 'auto',
        marginRight: 'auto',
        width: '100%'
    },

    sheetItemContainer: {
        flex: -1,
        maxHeight: '75%'
    },

    buttons: {
        /**
         * Style for the {@code Icon} element in a generic item of the menu.
         */
        iconStyle: {
            ...brandedDialogIconStyle
        },

        /**
         * Style for the label in a generic item rendered in the menu.
         */
        labelStyle: {
            ...brandedDialogLabelStyle,
            marginLeft: 16
        },

        /**
         * Container style for a generic item rendered in the menu.
         */
        style: {
            ...brandedDialogItemContainerStyle,
            paddingHorizontal: MD_ITEM_MARGIN_PADDING
        },

        /**
         * Additional style that is not directly used as a style object.
         */
        underlayColor: BaseTheme.palette.ui04
    },

    /**
     * Bottom sheet's base style.
     */
    sheet: {
        backgroundColor: BaseTheme.palette.ui02,
        borderTopLeftRadius: 16,
        borderTopRightRadius: 16
    },

    /**
     * Bottom sheet's base style with header.
     */
    sheetHeader: {
        backgroundColor: BaseTheme.palette.ui02
    },

    /**
     * Bottom sheet's background color with footer.
     */
    sheetFooter: {
        backgroundColor: BaseTheme.palette.ui01
    }
};

export default {
    dialogButton: {
        ...BaseTheme.typography.bodyLongBold
    },

    destructiveDialogButton: {
        ...BaseTheme.typography.bodyLongBold,
        color: BaseTheme.palette.actionDanger
    }
};

export const brandedDialog = {

    /**
     * The style of bold {@code Text} rendered by the {@code Dialog}s of the
     * feature authentication.
     */
    boldDialogText: {
        fontWeight: 'bold'
    },

    buttonFarRight: {
        borderBottomRightRadius: BORDER_RADIUS
    },

    buttonWrapper: {
        alignItems: 'stretch',
        borderRadius: BORDER_RADIUS,
        flexDirection: 'row'
    },

    mainWrapper: {
        alignSelf: 'stretch',
        padding: BoxModel.padding * 2,

        // The added bottom padding is to compensate the empty space around the
        // close icon.
        paddingBottom: BoxModel.padding * 3
    },

    overlayTouchable: {
        ...StyleSheet.absoluteFillObject
    }
};


/**
 * Color schemed styles for all the component based on the abstract dialog.
 */
ColorSchemeRegistry.register('Dialog', {
    button: {
        backgroundColor: '#44A5FF',
        flex: 1,
        padding: BoxModel.padding * 1.5
    },

    /**
     * Separator line for the buttons in a dialog.
     */
    buttonSeparator: {
        borderRightColor: schemeColor('border'),
        borderRightWidth: 1
    },

    buttonLabel: {
        color: schemeColor('buttonLabel'),
        fontSize: MD_FONT_SIZE,
        textAlign: 'center'
    },

    /**
     * Style of the close icon on a dialog.
     */
    closeStyle: {
        color: schemeColor('icon'),
        fontSize: MD_FONT_SIZE
    },

    /**
     * Base style of the dialogs.
     */
    dialog: {
        alignItems: 'stretch',
        backgroundColor: schemeColor('background'),
        borderColor: schemeColor('border'),
        borderRadius: BORDER_RADIUS,
        borderWidth: 1,
        flex: 1,
        flexDirection: 'column',
        maxWidth: PREFERRED_DIALOG_SIZE
    },

    /**
     * Field on an input dialog.
     */
    field: {
        ...brandedDialogText,
        borderBottomWidth: 1,
        borderColor: schemeColor('border'),
        margin: BoxModel.margin,
        textAlign: 'left'
    },

    /**
     * Style for the field label on an input dialog.
     */
    fieldLabel: {
        ...brandedDialogText,
        margin: BoxModel.margin,
        textAlign: 'left'
    },

    text: {
        ...brandedDialogText,
        color: BaseTheme.palette.text01
    },

    topBorderContainer: {
        borderTopColor: BaseTheme.palette.ui07,
        borderTopWidth: 1
    }
});


################################################################################

## File: .\jitsi-meet\react\features\base\dialog\components\web\AbstractDialogTab.ts

import { Component } from 'react';

/**
 * The type of the React {@code Component} props of {@link AbstractDialogTab}.
 */
export interface IProps {

    /**
     * Callback to invoke on change.
     */
    onTabStateChange: Function;

    /**
     * The id of the tab.
     */
    tabId: number;
}


/**
 * Abstract React {@code Component} for tabs of the DialogWithTabs component.
 *
 * @augments Component
 */
class AbstractDialogTab<P extends IProps, S> extends Component<P, S> {
    /**
     * Initializes a new {@code AbstractDialogTab} instance.
     *
     * @param {P} props - The read-only properties with which the new
     * instance is to be initialized.
     */
    constructor(props: P) {
        super(props);

        // Bind event handler so it is only bound once for every instance.
        this._onChange = this._onChange.bind(this);
    }

    /**
     * Uses the onTabStateChange function to pass the changed state of the
     * controlled tab component to the controlling DialogWithTabs component.
     *
     * @param {Object} change - Object that contains the changed property and
     * value.
     * @returns {void}
     */
    _onChange(change: Object) {
        const { onTabStateChange, tabId } = this.props;

        onTabStateChange(tabId, {
            ...this.props,
            ...change
        });
    }

}

export default AbstractDialogTab;


################################################################################

## File: .\jitsi-meet\react\features\base\environment\checkChromeExtensionsInstalled.native.ts

/**
 * Checks whether the chrome extensions defined in the config file are installed or not.
 *
 * @param {Object} _config - Objects containing info about the configured extensions.
 *
 * @returns {Promise[]}
 */
export default function checkChromeExtensionsInstalled(_config: any = {}) {
    return Promise.resolve([]);
}


################################################################################

## File: .\jitsi-meet\react\features\base\environment\checkChromeExtensionsInstalled.web.ts

/**
 * Checks whether the chrome extensions defined in the config file are installed or not.
 *
 * @param {Object} config - Objects containing info about the configured extensions.
 *
 * @returns {Promise[]}
 */
export default function checkChromeExtensionsInstalled(config: any = {}) {
    const isExtensionInstalled = (info: any) => new Promise(resolve => {
        const img = new Image();

        img.src = `chrome-extension://${info.id}/${info.path}`;
        img.setAttribute('aria-hidden', 'true');
        img.onload = function() {
            resolve(true);
        };
        img.onerror = function() {
            resolve(false);
        };
    });
    const extensionInstalledFunction = (info: any) => isExtensionInstalled(info);

    return Promise.all(
        (config.chromeExtensionsInfo || []).map((info: any) => extensionInstalledFunction(info))
    );
}


################################################################################

## File: .\jitsi-meet\react\features\base\environment\environment.ts

import JitsiMeetJS from '../lib-jitsi-meet';
import Platform from '../react/Platform';

import { isMobileBrowser } from './utils';

const { browser } = JitsiMeetJS.util;

const DEFAULT_OPTIMAL_BROWSERS = [
    'chrome',
    'chromium',
    'electron',
    'firefox',
    'safari',
    'webkit'
];

const DEFAULT_UNSUPPORTED_BROWSERS: string[] = [];

const browserNameToCheck = {
    chrome: browser.isChrome.bind(browser),
    chromium: browser.isChromiumBased.bind(browser),
    electron: browser.isElectron.bind(browser),
    firefox: browser.isFirefox.bind(browser),
    safari: browser.isSafari.bind(browser),
    webkit: browser.isWebKitBased.bind(browser)
};

/**
 * Returns whether or not jitsi is optimized and targeted for the  provided
 * browser name.
 *
 * @param {string} browserName - The name of the browser to check.
 * @returns {boolean}
 */
export function isBrowsersOptimal(browserName: string) {
    return (interfaceConfig.OPTIMAL_BROWSERS || DEFAULT_OPTIMAL_BROWSERS)
        .includes(browserName);
}

/**
 * Returns whether or not the current OS is Mac.
 *
 * @returns {boolean}
 */
export function isMacOS() {
    return Platform.OS === 'macos';
}

/**
 * Returns whether or not the current OS is Windows.
 *
 * @returns {boolean}
 */
export function isWindows() {
    return Platform.OS === 'windows';
}

/**
 * Returns whether or not the current browser or the list of passed in browsers
 * is considered suboptimal. Suboptimal means it is a supported browser but has
 * not been explicitly listed as being optimal, possibly due to functionality
 * issues.
 *
 * @param {Array<string>} [browsers] - A list of browser names to check. Will
 * default to a whitelist.
 * @returns {boolean}
 */
export function isSuboptimalBrowser() {
    const optimalBrowsers
        = interfaceConfig.OPTIMAL_BROWSERS || DEFAULT_OPTIMAL_BROWSERS;

    return !_isCurrentBrowserInList(optimalBrowsers) && isSupportedBrowser();
}

/**
 * Returns whether or not the current browser should allow the app to display.
 * A supported browser is assumed to be able to support WebRtc.
 *
 * @returns {boolean}
 */
export function isSupportedBrowser() {
    if (navigator.product === 'ReactNative') {
        return false;
    }

    // Blacklists apply to desktop browsers only right now.
    if (!isMobileBrowser() && _isCurrentBrowserInList(
        interfaceConfig.UNSUPPORTED_BROWSERS || DEFAULT_UNSUPPORTED_BROWSERS
    )) {
        return false;
    }

    return isMobileBrowser() ? isSupportedMobileBrowser() : JitsiMeetJS.isWebRtcSupported();
}

/**
 * Returns whether or not the current environment is a supported
 * browser on a mobile device.
 *
 * @returns {boolean}
 */
export function isSupportedMobileBrowser() {
    return (Platform.OS === 'android' && browser.isSupportedAndroidBrowser())
        || (Platform.OS === 'ios' && browser.isSupportedIOSBrowser());
}

/**
 * Runs various browser checks to know if the current browser is found within
 * the list.
 *
 * @param {Array<string>} list - Browser names to check. The names should be
 * keys in {@link browserNameToCheck}.
 * @private
 * @returns {boolean}
 */
function _isCurrentBrowserInList(list: string[]) {
    return Boolean(list.find(browserName => {
        const checkFunction = browserNameToCheck[browserName as keyof typeof browserNameToCheck];

        return checkFunction ? checkFunction.call(browser) : false;
    }));
}


################################################################################

## File: .\jitsi-meet\react\features\base\environment\utils.ts

import Platform from '../react/Platform';

/**
 * Returns whether or not the current environment is a mobile device.
 *
 * @returns {boolean}
 */
export function isMobileBrowser() {
    return Platform.OS === 'android' || Platform.OS === 'ios';
}


/**
 * Returns whether or not the current environment is an ios mobile device.
 *
 * @returns {boolean}
 */
export function isIosMobileBrowser() {
    return Platform.OS === 'ios';
}

/**
 * Returns whether or not the current environment is an ipad device.
 *
 * @returns {boolean}
 */
export function isIpadMobileBrowser() {

    // @ts-ignore
    return isIosMobileBrowser() && Platform.isPad;
}



################################################################################

## File: .\jitsi-meet\react\features\base\flags\actions.ts

import { UPDATE_FLAGS } from './actionTypes';

/**
 * Updates the current features flags with the given ones. They will be merged.
 *
 * @param {Object} flags - The new flags object.
 * @returns {{
 *     type: UPDATE_FLAGS,
 *     flags: Object
 * }}
 */
export function updateFlags(flags: Object) {
    return {
        type: UPDATE_FLAGS,
        flags
    };
}


################################################################################

## File: .\jitsi-meet\react\features\base\flags\actionTypes.ts

/**
 * The type of Redux action which updates the feature flags.
 *
 * {
 *     type: UPDATE_FLAGS,
 *     flags: Object
 * }
 *
 */
export const UPDATE_FLAGS = 'UPDATE_FLAGS';


################################################################################

## File: .\jitsi-meet\react\features\base\flags\constants.ts

/**
 * Flag indicating if add-people functionality should be enabled.
 * Default: enabled (true).
 */
export const ADD_PEOPLE_ENABLED = 'add-people.enabled';

/**
 * Flag indicating if the SDK should not require the audio focus.
 * Used by apps that do not use Jitsi audio.
 * Default: disabled (false).
 */
export const AUDIO_FOCUS_DISABLED = 'audio-focus.disabled';

/**
 * Flag indicating if the audio mute button should be displayed.
 * Default: enabled (true).
 */
export const AUDIO_MUTE_BUTTON_ENABLED = 'audio-mute.enabled';

/**
 * Flag indicating that the Audio only button in the overflow menu is enabled.
 * Default: enabled (true).
 */
export const AUDIO_ONLY_BUTTON_ENABLED = 'audio-only.enabled';

/**
 * Flag indicating that the Breakout Rooms button in the overflow menu is enabled.
 * Default: enabled (true).
 */
export const BREAKOUT_ROOMS_BUTTON_ENABLED = 'breakout-rooms.enabled';

/**
 * Flag indicating if calendar integration should be enabled.
 * Default: enabled (true) on Android, auto-detected on iOS.
 */
export const CALENDAR_ENABLED = 'calendar.enabled';

/**
 * Flag indicating if call integration (CallKit on iOS, ConnectionService on Android)
 * should be enabled.
 * Default: enabled (true).
 */
export const CALL_INTEGRATION_ENABLED = 'call-integration.enabled';

/**
 * Flag indicating if car mode should be enabled.
 * Default: enabled (true).
 */
export const CAR_MODE_ENABLED = 'car-mode.enabled';

/**
 * Flag indicating if close captions should be enabled.
 * Default: enabled (true).
 */
export const CLOSE_CAPTIONS_ENABLED = 'close-captions.enabled';

/**
 * Flag indicating if conference timer should be enabled.
 * Default: enabled (true).
 */
export const CONFERENCE_TIMER_ENABLED = 'conference-timer.enabled';

/**
 * Flag indicating if chat should be enabled.
 * Default: enabled (true).
 */
export const CHAT_ENABLED = 'chat.enabled';

/**
 * Flag indicating if the filmstrip should be enabled.
 * Default: enabled (true).
 */
export const FILMSTRIP_ENABLED = 'filmstrip.enabled';

/**
 * Flag indicating if fullscreen (immersive) mode should be enabled.
 * Default: enabled (true).
 */
export const FULLSCREEN_ENABLED = 'fullscreen.enabled';

/**
 * Flag indicating if the Help button should be enabled.
 * Default: enabled (true).
 */
export const HELP_BUTTON_ENABLED = 'help.enabled';

/**
 * Flag indicating if invite functionality should be enabled.
 * Default: enabled (true).
 */
export const INVITE_ENABLED = 'invite.enabled';

/**
 * Flag indicating if dial-in invite functionality should be enabled.
 * Default: enabled (true).
 */
export const INVITE_DIAL_IN_ENABLED = 'invite-dial-in.enabled';

/**
 * Flag indicating if recording should be enabled in iOS.
 * Default: disabled (false).
 */
export const IOS_RECORDING_ENABLED = 'ios.recording.enabled';

/**
 * Flag indicating if screen sharing should be enabled in iOS.
 * Default: disabled (false).
 */
export const IOS_SCREENSHARING_ENABLED = 'ios.screensharing.enabled';

/**
 * Flag indicating if screen sharing should be enabled in android.
 * Default: enabled (true).
 */
export const ANDROID_SCREENSHARING_ENABLED = 'android.screensharing.enabled';

/**
 * Flag indicating if speaker statistics should be enabled.
 * Default: enabled (true).
 */
export const SPEAKERSTATS_ENABLED = 'speakerstats.enabled';

/**
 * Flag indicating if kickout is enabled.
 * Default: enabled (true).
 */
export const KICK_OUT_ENABLED = 'kick-out.enabled';

/**
 * Flag indicating if live-streaming should be enabled.
 * Default: auto-detected.
 */
export const LIVE_STREAMING_ENABLED = 'live-streaming.enabled';

/**
 * Flag indicating if lobby mode button should be enabled.
 * Default: enabled.
 */
export const LOBBY_MODE_ENABLED = 'lobby-mode.enabled';

/**
 * Flag indicating if displaying the meeting name should be enabled.
 * Default: enabled (true).
 */
export const MEETING_NAME_ENABLED = 'meeting-name.enabled';

/**
 * Flag indicating if the meeting password button should be enabled.
 * Note that this flag just decides on the button, if a meeting has a password
 * set, the password dialog will still show up.
 * Default: enabled (true).
 */
export const MEETING_PASSWORD_ENABLED = 'meeting-password.enabled';

/**
 * Flag indicating if the notifications should be enabled.
 * Default: enabled (true).
 */
export const NOTIFICATIONS_ENABLED = 'notifications.enabled';

/**
 * Flag indicating if the audio overflow menu button should be displayed.
 * Default: enabled (true).
 */
export const OVERFLOW_MENU_ENABLED = 'overflow-menu.enabled';

/**
 * Flag indicating if participants should be enabled.
 * Default: enabled (true).
 */
export const PARTICIPANTS_ENABLED = 'participants.enabled';

/**
 * Flag indicating if Picture-in-Picture should be enabled.
 * Default: auto-detected.
 */
export const PIP_ENABLED = 'pip.enabled';

/**
 * Flag indicating if Picture-in-Picture button should be shown while screen sharing.
 * Default: disabled (false).
 */
export const PIP_WHILE_SCREEN_SHARING_ENABLED = 'pip-while-screen-sharing.enabled';

/**
 * Flag indicating if the prejoin page should be enabled.
 * Default: enabled (true).
 */
export const PREJOIN_PAGE_ENABLED = 'prejoinpage.enabled';

/**
 * Flag indicating if the participant name editing field should be displayed on the prejoin page.
 * Default: disabled (false).
 */
export const PREJOIN_PAGE_HIDE_DISPLAY_NAME = 'prejoinpage.hideDisplayName';

/**
 * Flag indicating if raise hand feature should be enabled.
 * Default: enabled.
 */
export const RAISE_HAND_ENABLED = 'raise-hand.enabled';

/**
 * Flag indicating if the reactions feature should be enabled.
 * Default: enabled (true).
 */
export const REACTIONS_ENABLED = 'reactions.enabled';

/**
 * Flag indicating if recording should be enabled.
 * Default: auto-detected.
 */
export const RECORDING_ENABLED = 'recording.enabled';

/**
 * Flag indicating if the user should join the conference with the replaceParticipant functionality.
 * Default: (false).
 */
export const REPLACE_PARTICIPANT = 'replace.participant';

/**
 * Flag indicating the local and (maximum) remote video resolution. Overrides
 * the server configuration.
 * Default: (unset).
 */
export const RESOLUTION = 'resolution';

/**
 * Flag indicating if the security options button should be enabled.
 * Default: enabled (true).
 */
export const SECURITY_OPTIONS_ENABLED = 'security-options.enabled';

/**
 * Flag indicating if server URL change is enabled.
 * Default: enabled (true).
 */
export const SERVER_URL_CHANGE_ENABLED = 'server-url-change.enabled';

/**
 * Flag indicating if settings should be enabled.
 * Default: enabled (true).
 */
export const SETTINGS_ENABLED = 'settings.enabled';

/**
 * Flag indicating if tile view feature should be enabled.
 * Default: enabled.
 */
export const TILE_VIEW_ENABLED = 'tile-view.enabled';

/**
 * Flag indicating if the toolbox should be always be visible
 * Default: disabled (false).
 */
export const TOOLBOX_ALWAYS_VISIBLE = 'toolbox.alwaysVisible';

/**
 * Flag indicating if the toolbox should be enabled
 * Default: enabled.
 */
export const TOOLBOX_ENABLED = 'toolbox.enabled';

/**
 * Flag indicating if the unsafe room warning should be enabled.
 * Default: disabled (false).
 */
export const UNSAFE_ROOM_WARNING = 'unsaferoomwarning.enabled';

/**
 * Flag indicating if the video mute button should be displayed.
 * Default: enabled (true).
 */
export const VIDEO_MUTE_BUTTON_ENABLED = 'video-mute.enabled';

/**
 * Flag indicating if the video share button should be enabled
 * Default: enabled (true).
 */
export const VIDEO_SHARE_BUTTON_ENABLED = 'video-share.enabled';

/**
 * Flag indicating if the welcome page should be enabled.
 * Default: disabled (false).
 */
export const WELCOME_PAGE_ENABLED = 'welcomepage.enabled';


################################################################################

## File: .\jitsi-meet\react\features\base\flags\functions.ts

import { getAppProp } from '../app/functions';
import { IStateful } from '../app/types';
import { toState } from '../redux/functions';

/**
 * Gets the value of a specific feature flag.
 *
 * @param {Function|Object} stateful - The redux store or {@code getState}
 * function.
 * @param {string} flag - The name of the React {@code Component} prop of
 * the currently mounted {@code App} to get.
 * @param {*} defaultValue - A default value for the flag, in case it's not defined.
 * @returns {*} The value of the specified React {@code Component} prop of the
 * currently mounted {@code App}.
 */
export function getFeatureFlag(stateful: IStateful, flag: string, defaultValue?: boolean | string) {
    const state = toState(stateful)['features/base/flags'];

    if (state) {
        const value = state[flag as keyof typeof state];

        if (typeof value !== 'undefined') {
            return value;
        }
    }

    // Maybe the value hasn't made it to the redux store yet, check the app props.
    const flags = getAppProp(stateful, 'flags') || {};

    return flags[flag] || defaultValue;
}


################################################################################

## File: .\jitsi-meet\react\features\base\flags\reducer.ts

import { isEqual, merge } from 'lodash-es';

import ReducerRegistry from '../redux/ReducerRegistry';

import { UPDATE_FLAGS } from './actionTypes';

/**
 * Default state value for the feature flags.
 */
const DEFAULT_STATE = {};

export interface IFlagsState {
    flags?: Object;
}

/**
 * Reduces redux actions which handle feature flags.
 *
 * @param {State} state - The current redux state.
 * @param {Action} action - The redux action to reduce.
 * @param {string} action.type - The type of the redux action to reduce.
 * @returns {State} The next redux state that is the result of reducing the
 * specified action.
 */
ReducerRegistry.register<IFlagsState>('features/base/flags', (state = DEFAULT_STATE, action): IFlagsState => {
    switch (action.type) {
    case UPDATE_FLAGS: {
        const newState = merge({}, state, action.flags);

        return isEqual(state, newState) ? state : newState;
    }
    }

    return state;
});


################################################################################

## File: .\jitsi-meet\react\features\base\i18n\actionTypes.ts

/**
 * The type of (redux) action which signals that i18next has been initialized.
 */
export const I18NEXT_INITIALIZED = 'I18NEXT_INITIALIZED';

/**
 * The type of (redux) action which signals that language has been changed.
 */
export const LANGUAGE_CHANGED = 'LANGUAGE_CHANGED';


################################################################################

## File: .\jitsi-meet\react\features\base\i18n\BuiltinLanguages.native.ts

import i18next from 'i18next';

/**
 * The builtin languages.
 */
const _LANGUAGES = {

    // Afrikaans
    'af': {
        main: require('../../../../lang/main-af')
    },

    // Arabic
    'ar': {
        main: require('../../../../lang/main-ar')
    },

    // Bulgarian
    'bg': {
        main: require('../../../../lang/main-bg')
    },

    // Catalan
    'ca': {
        main: require('../../../../lang/main-ca')
    },

    // German
    'de': {
        main: require('../../../../lang/main-de')
    },

    // Esperanto
    'eo': {
        main: require('../../../../lang/main-eo')
    },

    // Spanish
    'es': {
        main: require('../../../../lang/main-es')
    },

    // Spanish (Latin America)
    'esUS': {
        main: require('../../../../lang/main-esUS')
    },

    // Estonian
    'et': {
        main: require('../../../../lang/main-et')
    },

    // Persian
    'fa': {
        main: require('../../../../lang/main-fa')
    },

    // Finnish
    'fi': {
        main: require('../../../../lang/main-fi')
    },

    // French
    'fr': {
        main: require('../../../../lang/main-fr')
    },

    // French (Canadian)
    'frCA': {
        main: require('../../../../lang/main-frCA')
    },

    // Croatian
    'hr': {
        main: require('../../../../lang/main-hr')
    },

    // Hungarian
    'hu': {
        main: require('../../../../lang/main-hu')
    },

    // Italian
    'it': {
        main: require('../../../../lang/main-it')
    },

    // Japanese
    'ja': {
        main: require('../../../../lang/main-ja')
    },

    // Korean
    'ko': {
        main: require('../../../../lang/main-ko')
    },

    // Mongolian
    'mn': {
        main: require('../../../../lang/main-mn')
    },

    // Dutch
    'nl': {
        main: require('../../../../lang/main-nl')
    },

    // Occitan
    'oc': {
        main: require('../../../../lang/main-oc')
    },

    // Polish
    'pl': {
        main: require('../../../../lang/main-pl')
    },

    // Portuguese (Brazil)
    'ptBR': {
        main: require('../../../../lang/main-ptBR')
    },

    // Romanian
    'ro': {
        main: require('../../../../lang/main-ro')
    },

    // Russian
    'ru': {
        main: require('../../../../lang/main-ru')
    },

    // Sardinian (Sardinia)
    'sc': {
        main: require('../../../../lang/main-sc')
    },

    // Slovak
    'sk': {
        main: require('../../../../lang/main-sk')
    },

    // Slovenian
    'sl': {
        main: require('../../../../lang/main-sl')
    },

    // Swedish
    'sv': {
        main: require('../../../../lang/main-sv')
    },

    // Turkish
    'tr': {
        main: require('../../../../lang/main-tr')
    },

    // Ukrainian
    'uk': {
        main: require('../../../../lang/main-uk')
    },

    // Vietnamese
    'vi': {
        main: require('../../../../lang/main-vi')
    },

    // Chinese (Simplified)
    'zhCN': {
        main: require('../../../../lang/main-zhCN')
    },

    // Chinese (Traditional)
    'zhTW': {
        main: require('../../../../lang/main-zhTW')
    }
};

// Register all builtin languages with the i18n library.
for (const name in _LANGUAGES) { // eslint-disable-line guard-for-in
    const { main } = _LANGUAGES[name as keyof typeof _LANGUAGES];

    i18next.addResourceBundle(
        name,
        'main',
        main,
        /* deep */ true,
        /* overwrite */ true);
}


################################################################################

## File: .\jitsi-meet\react\features\base\i18n\BuiltinLanguages.web.ts



################################################################################

## File: .\jitsi-meet\react\features\base\i18n\configLanguageDetector.ts


declare let config: any;

/**
 * Custom language detection, just returns the config property if any.
 */
export default {
    /**
     * Does not support caching.
     *
     * @returns {void}
     */
    cacheUserLanguage: Function.prototype,

    /**
     * Looks the language up in the config.
     *
     * @returns {string} The default language if any.
     */
    lookup() {
        return config.defaultLanguage;
    },

    /**
     * Name of the language detector.
     */
    name: 'configLanguageDetector'
};


################################################################################

## File: .\jitsi-meet\react\features\base\i18n\customNavigatorDetector.ts


declare let navigator: any;

/**
 * Custom language detection, just returns the config property if any.
 */
export default {
    /**
     * Does not support caching.
     *
     * @returns {void}
     */
    cacheUserLanguage: Function.prototype,

    /**
     * Looks the language up in the config.
     *
     * @returns {string} The default language if any.
     */
    lookup() {
        let found = [];

        if (typeof navigator !== 'undefined') {
            if (navigator.languages) {
                // chrome only; not an array, so can't use .push.apply instead of iterating
                for (let i = 0; i < navigator.languages.length; i++) {
                    found.push(navigator.languages[i]);
                }
            }
            if (navigator.userLanguage) {
                found.push(navigator.userLanguage);
            }
            if (navigator.language) {
                found.push(navigator.language);
            }
        }

        found = found.map<string>(normalizeLanguage);

        return found.length > 0 ? found : undefined;
    },

    /**
     * Name of the language detector.
     */
    name: 'customNavigatorDetector'
};

/**
 * Normalize language format.
 *
 * (en-US => enUS)
 * (en-gb => enGB)
 * (es-es => es).
 *
 * @param {string} language - Language.
 * @returns {string} The normalized language.
 */
function normalizeLanguage(language: string) {
    const [ lang, variant ] = language.replace('_', '-').split('-');

    if (!variant || lang.toUpperCase() === variant.toUpperCase()) {
        return lang;
    }

    return lang + variant.toUpperCase();
}


################################################################################

## File: .\jitsi-meet\react\features\base\i18n\dateUtil.ts

import moment from 'moment';
import momentDurationFormatSetup from 'moment-duration-format';

import i18next from './i18next';

// allows for moment durations to be formatted
momentDurationFormatSetup(moment);

// MomentJS uses static language bundle loading, so in order to support dynamic
// language selection in the app we need to load all bundles that we support in
// the app.
require('moment/locale/af');
require('moment/locale/ar');
require('moment/locale/be');
require('moment/locale/bg');
require('moment/locale/ca');
require('moment/locale/cs');
require('moment/locale/da');
require('moment/locale/de');
require('moment/locale/el');
require('moment/locale/en-gb');
require('moment/locale/eo');
require('moment/locale/es-us');
require('moment/locale/es');
require('moment/locale/et');
require('moment/locale/eu');
require('moment/locale/fa');
require('moment/locale/fi');
require('moment/locale/fr-ca');
require('moment/locale/fr');
require('moment/locale/gl');
require('moment/locale/he');
require('moment/locale/hr');
require('moment/locale/hu');
require('moment/locale/hy-am');
require('moment/locale/id');
require('moment/locale/is');
require('moment/locale/it');
require('moment/locale/ja');
require('moment/locale/ko');
require('moment/locale/lt');
require('moment/locale/lv');
require('moment/locale/ml');
require('moment/locale/mn');
require('moment/locale/mr');
require('moment/locale/nb');
require('moment/locale/nl');
require('moment/locale/oc-lnc');
require('moment/locale/pl');
require('moment/locale/pt');
require('moment/locale/pt-br');
require('moment/locale/ro');
require('moment/locale/ru');
require('moment/locale/sk');
require('moment/locale/sl');
require('moment/locale/sr');
require('moment/locale/sv');
require('moment/locale/tr');
require('moment/locale/uk');
require('moment/locale/vi');
require('moment/locale/zh-cn');
require('moment/locale/zh-tw');

/**
 * Returns a localized date formatter initialized with a specific {@code Date}
 * or timestamp ({@code number}).
 *
 * @private
 * @param {Date | number} dateOrTimeStamp - The date or unix timestamp (ms)
 * to format.
 * @returns {Object}
 */
export function getLocalizedDateFormatter(dateOrTimeStamp: Date | number) {
    return moment(dateOrTimeStamp).locale(_getSupportedLocale());
}

/**
 * Returns a localized duration formatter initialized with a
 * specific duration ({@code number}).
 *
 * @private
 * @param {number} duration - The duration (ms)
 * to format.
 * @returns {Object}
 */
export function getLocalizedDurationFormatter(duration: number) {
    // FIXME The flow-type definition of moment is v2.3 while our package.json
    // states v2.19 so maybe locale on moment's duration was introduced in
    // between?
    //

    // If the conference is under an hour long we want to display it without
    // showing the hour and we want to include the hour if the conference is
    // more than an hour long

    // @ts-ignore
    if (moment.duration(duration).format('h') !== '0') {
        // @ts-ignore
        return moment.duration(duration).format('h:mm:ss');
    }

    // @ts-ignore
    return moment.duration(duration).format('mm:ss', { trim: false });
}

/**
 * A lenient locale matcher to match language and dialect if possible.
 *
 * @private
 * @returns {string}
 */
function _getSupportedLocale() {
    const i18nLocale = i18next.language;
    let supportedLocale;

    if (i18nLocale) {
        const localeRegexp = new RegExp('^([a-z]{2,2})(-)*([a-z]{2,2})*$');
        const localeResult = localeRegexp.exec(i18nLocale.toLowerCase());

        if (localeResult) {
            const currentLocaleRegexp
                = new RegExp(
                    `^${localeResult[1]}(-)*${`(${localeResult[3]})*` || ''}`);

            supportedLocale

                // FIXME The flow-type definition of moment is v2.3 while our
                // package.json states v2.19 so maybe locales on moment was
                // introduced in between?
                = moment.locales().find(lang => currentLocaleRegexp.exec(lang));
        }
    }

    return supportedLocale || 'en';
}


################################################################################

## File: .\jitsi-meet\react\features\base\i18n\i18next.ts

import COUNTRIES_RESOURCES from 'i18n-iso-countries/langs/en.json';
import i18next from 'i18next';
import I18nextXHRBackend, { HttpBackendOptions } from 'i18next-http-backend';
import { merge } from 'lodash-es';

import LANGUAGES_RESOURCES from '../../../../lang/languages.json';
import MAIN_RESOURCES from '../../../../lang/main.json';
import TRANSLATION_LANGUAGES_RESOURCES from '../../../../lang/translation-languages.json';

import { I18NEXT_INITIALIZED, LANGUAGE_CHANGED } from './actionTypes';
import languageDetector from './languageDetector';

/**
 * Override certain country names.
 */
const COUNTRIES_RESOURCES_OVERRIDES = {
    countries: {
        TW: 'Taiwan'
    }
};

/**
 * Merged country names.
 */
const COUNTRIES = merge({}, COUNTRIES_RESOURCES, COUNTRIES_RESOURCES_OVERRIDES);

/**
 * The available/supported languages.
 *
 * @public
 * @type {Array<string>}
 */
export const LANGUAGES: Array<string> = Object.keys(LANGUAGES_RESOURCES);

/**
 * The available/supported translation languages.
 *
 * @public
 * @type {Array<string>}
 */
export const TRANSLATION_LANGUAGES: Array<string> = Object.keys(TRANSLATION_LANGUAGES_RESOURCES);

/**
 * The default language.
 *
 * English is the default language.
 *
 * @public
 * @type {string} The default language.
 */
export const DEFAULT_LANGUAGE = 'en';

/**
 * The available/supported translation languages head. (Languages displayed on the top ).
 *
 * @public
 * @type {Array<string>}
 */
export const TRANSLATION_LANGUAGES_HEAD: Array<string> = [ DEFAULT_LANGUAGE ];

/**
 * The options to initialize i18next with.
 *
 * @type {i18next.InitOptions}
 */
const options: i18next.InitOptions = {
    backend: <HttpBackendOptions>{
        loadPath: (lng: string[], ns: string[]) => {
            switch (ns[0]) {
            case 'countries':
            case 'main':
                return 'lang/{{ns}}-{{lng}}.json';
            default:
                return 'lang/{{ns}}.json';
            }
        }
    },
    defaultNS: 'main',
    fallbackLng: DEFAULT_LANGUAGE,
    interpolation: {
        escapeValue: false // not needed for react as it escapes by default
    },
    load: 'languageOnly',
    ns: [ 'main', 'languages', 'countries', 'translation-languages' ],
    react: {
        // re-render when a new resource bundle is added
        // @ts-expect-error. Fixed in i18next 19.6.1.
        bindI18nStore: 'added',
        useSuspense: false
    },
    returnEmptyString: false,
    returnNull: false,

    // XXX i18next modifies the array lngWhitelist so make sure to clone
    // LANGUAGES.
    whitelist: LANGUAGES.slice()
};

i18next
    .use(navigator.product === 'ReactNative' ? {} : I18nextXHRBackend)
    .use(languageDetector)
    .init(options);

// Add default language which is preloaded from the source code.
i18next.addResourceBundle(
    DEFAULT_LANGUAGE,
    'countries',
    COUNTRIES,
    /* deep */ true,
    /* overwrite */ true);
i18next.addResourceBundle(
    DEFAULT_LANGUAGE,
    'languages',
    LANGUAGES_RESOURCES,
    /* deep */ true,
    /* overwrite */ true);
i18next.addResourceBundle(
    DEFAULT_LANGUAGE,
    'translation-languages',
    TRANSLATION_LANGUAGES_RESOURCES,
    /* deep */ true,
    /* overwrite */ true);
i18next.addResourceBundle(
    DEFAULT_LANGUAGE,
    'main',
    MAIN_RESOURCES,
    /* deep */ true,
    /* overwrite */ true);

// Add builtin languages.
// XXX: Note we are using require here, because we want the side-effects of the
// import, but imports can only be placed at the top, and it would be too early,
// since i18next is not yet initialized at that point.
require('./BuiltinLanguages');

// Label change through dynamic branding is available only for web
if (typeof APP !== 'undefined') {
    i18next.on('initialized', () => {
        APP.store.dispatch({ type: I18NEXT_INITIALIZED });
    });

    i18next.on('languageChanged', () => {
        APP.store.dispatch({ type: LANGUAGE_CHANGED });
    });
}

export default i18next;


################################################################################

## File: .\jitsi-meet\react\features\base\i18n\languageDetector.native.ts

import { NativeModules } from 'react-native';

import LANGUAGES_RESOURCES from '../../../../lang/languages.json';

const LANGUAGES = Object.keys(LANGUAGES_RESOURCES);

/**
 * The singleton language detector for React Native which uses the system-wide
 * locale.
 */
export default {
    /**
     * Does not support caching.
     *
     * @returns {void}
     */
    cacheUserLanguage: Function.prototype,

    detect() {
        const { LocaleDetector } = NativeModules;
        const parts = LocaleDetector.locale.replace(/_/, '-').split('-');
        const [ lang, regionOrScript, region ] = parts;
        let locale;

        if (parts.length >= 3) {
            locale = `${lang}${region}`;
        } else if (parts.length === 2) {
            locale = `${lang}${regionOrScript}`;
        } else {
            locale = lang;
        }

        if (LANGUAGES.includes(locale)) {
            return locale;
        }

        return lang;
    },

    init: Function.prototype,

    type: 'languageDetector'
};


################################################################################

## File: .\jitsi-meet\react\features\base\i18n\languageDetector.web.ts

import BrowserLanguageDetector from 'i18next-browser-languagedetector';

import configLanguageDetector from './configLanguageDetector';
import customNavigatorDetector from './customNavigatorDetector';

/**
 * The ordered list (by name) of language detectors to be utilized as backends
 * by the singleton language detector for Web.
 *
 * @type {Array<string>}
 */
const order = [
    'querystring',
    'localStorage'
];

// Allow i18next to detect the system language reported by the Web browser
// itself.
interfaceConfig.LANG_DETECTION && order.push(customNavigatorDetector.name);

// Default use configured language
order.push(configLanguageDetector.name);

/**
 * The singleton language detector for Web.
 */
const languageDetector
    = new BrowserLanguageDetector(
        /* services */ null,
        /* options */ {
            caches: [ 'localStorage' ],
            lookupLocalStorage: 'language',
            lookupQuerystring: 'lang',
            order
        });

// Add the language detector which looks the language up in the config. Its
// order has already been established above.
// @ts-ignore
languageDetector.addDetector(customNavigatorDetector);

// @ts-ignore
languageDetector.addDetector(configLanguageDetector);

export default languageDetector;


################################################################################

## File: .\jitsi-meet\react\features\base\i18n\logger.ts

import { getLogger } from '../logging/functions';

export default getLogger('features/base/i18n');


################################################################################

## File: .\jitsi-meet\react\features\base\i18n\middleware.ts

import { SET_DYNAMIC_BRANDING_DATA } from '../../dynamic-branding/actionTypes';
import MiddlewareRegistry from '../redux/MiddlewareRegistry';

import { I18NEXT_INITIALIZED, LANGUAGE_CHANGED } from './actionTypes';
import { changeLanguageBundle } from './functions';
import i18next from './i18next';
import logger from './logger';

/**
 * Implements the entry point of the middleware of the feature base/i18n.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {
    switch (action.type) {
    case I18NEXT_INITIALIZED:
    case LANGUAGE_CHANGED:
    case SET_DYNAMIC_BRANDING_DATA: {
        const { language } = i18next;
        const { labels } = action.type === SET_DYNAMIC_BRANDING_DATA
            ? action.value
            : store.getState()['features/dynamic-branding'];

        if (language && labels && labels[language]) {
            changeLanguageBundle(language, labels[language])
            .catch(err => {
                logger.log('Error setting dynamic language bundle', err);
            });
        }
        break;
    }
    }

    return next(action);
});


################################################################################

## File: .\jitsi-meet\react\features\base\icons\components\types.native.ts

import { GestureResponderEvent } from 'react-native';

export interface IIconProps {
    onClick?: (e?: GestureResponderEvent) => void;
}


################################################################################

## File: .\jitsi-meet\react\features\base\icons\components\types.web.ts

import React from 'react';

export interface IIconProps {
    onClick?: (e?: React.MouseEvent) => void;
}


################################################################################

## File: .\jitsi-meet\react\features\base\icons\svg\constants.ts

import { default as IconRecordAccount } from './account-record.svg';
import { default as IconAddUser } from './add-user.svg';
import { default as IconArrowBack } from './arrow-back.svg';
import { default as IconArrowDownLarge } from './arrow-down-large.svg';
import { default as IconArrowDown } from './arrow-down.svg';
import { default as IconArrowLeft } from './arrow-left.svg';
import { default as IconArrowRight } from './arrow-right.svg';
import { default as IconArrowUpLarge } from './arrow-up-large.svg';
import { default as IconArrowUp } from './arrow-up.svg';
import { default as IconBell } from './bell.svg';
import { default as IconBluetooth } from './bluetooth.svg';
import { default as IconCalendar } from './calendar.svg';
import { default as IconCameraRefresh } from './camera-refresh.svg';
import { default as IconCar } from './car.svg';
import { default as IconChatUnread } from './chat-unread.svg';
import { default as IconCheck } from './check.svg';
import { default as IconCloseCircle } from './close-circle.svg';
import { default as IconCloseLarge } from './close-large.svg';
import { default as IconCloudUpload } from './cloud-upload.svg';
import { default as IconCode } from './code.svg';
import { default as IconConnection } from './connection.svg';
import { default as IconRecordContact } from './contact-record.svg';
import { default as IconCopy } from './copy.svg';
import { default as IconDotsHorizontal } from './dots-horizontal.svg';
import { default as IconDownload } from './download.svg';
import { default as IconE2EE } from './e2ee.svg';
import { default as IconEdit } from './edit.svg';
import { default as IconEmotionsAngry } from './emotions-angry.svg';
import { default as IconEmotionsDisgusted } from './emotions-disgusted.svg';
import { default as IconEmotionsFearful } from './emotions-fearful.svg';
import { default as IconEmotionsHappy } from './emotions-happy.svg';
import { default as IconEmotionsNeutral } from './emotions-neutral.svg';
import { default as IconEmotionsSad } from './emotions-sad.svg';
import { default as IconEmotionsSurprised } from './emotions-surprised.svg';
import { default as IconEnlarge } from './enlarge.svg';
import { default as IconEnterFullscreen } from './enter-fullscreen.svg';
import { default as IconEnvelope } from './envelope.svg';
import { default as IconExclamationSolid } from './exclamation-solid.svg';
import { default as IconExclamationTriangle } from './exclamation-triangle.svg';
import { default as IconExitFullscreen } from './exit-fullscreen.svg';
import { default as IconFaceSmile } from './face-smile.svg';
import { default as IconFavoriteSolid } from './favorite-solid.svg';
import { default as IconFavorite } from './favorite.svg';
import { default as IconFeedback } from './feedback.svg';
import { default as IconGear } from './gear.svg';
import { default as IconGoogle } from './google.svg';
import { default as IconHangup } from './hangup.svg';
import { default as IconDeviceHeadphone } from './headset.svg';
import { default as IconHelp } from './help.svg';
import { default as IconHighlight } from './highlight.svg';
import { default as IconRingGroup } from './icon-ring-group.svg';
import { default as IconImage } from './image.svg';
import { default as IconInfoCircle } from './info-circle.svg';
import { default as IconInfo } from './info.svg';
import { default as IconRecordLead } from './lead-record.svg';
import { default as IconMessage } from './message.svg';
import { default as IconMeter } from './meter.svg';
import { default as IconMicSlash } from './mic-slash.svg';
import { default as IconMic } from './mic.svg';
import { default as IconModerator } from './moderator.svg';
import { default as IconConnectionInactive } from './ninja.svg';
import { default as IconNoiseSuppressionOff } from './noise-suppression-off.svg';
import { default as IconNoiseSuppressionOn } from './noise-suppression-on.svg';
import { default as IconOffice365 } from './office365.svg';
import { default as IconRecordOpportunity } from './opportunity-record.svg';
import { default as IconPerformance } from './performance.svg';
import { default as IconPhoneRinging } from './phone-ringing.svg';
import { default as IconPin } from './pin.svg';
import { default as IconPinned } from './pinned.svg';
import { default as IconPlay } from './play.svg';
import { default as IconPlus } from './plus.svg';
import { default as IconRaiseHand } from './raise-hand.svg';
import { default as IconRecord } from './record.svg';
import { default as IconReply } from './reply.svg';
import { default as IconRestore } from './restore.svg';
import { default as IconScreenshare } from './screenshare.svg';
import { default as IconSearch } from './search.svg';
import { default as IconSecurityOff } from './security-off.svg';
import { default as IconSecurityOn } from './security-on.svg';
import { default as IconSend } from './send.svg';
import { default as IconShareDoc } from './share-doc.svg';
import { default as IconShare } from './share.svg';
import { default as IconShortcuts } from './shortcuts.svg';
import { default as IconSip } from './sip.svg';
import { default as IconSites } from './sites.svg';
import { default as IconRemoteControlStart } from './start-remote-control.svg';
import { default as IconRemoteControlStop } from './stop-remote-control.svg';
import { default as IconStop } from './stop.svg';
import { default as IconSubtitles } from './subtitles.svg';
import { default as IconTileView } from './tile-view.svg';
import { default as IconTrash } from './trash.svg';
import { default as IconUserDeleted } from './user-deleted.svg';
import { default as IconUser } from './user.svg';
import { default as IconUsers } from './users.svg';
import { default as IconVideoOff } from './video-off.svg';
import { default as IconVideo } from './video.svg';
import { default as IconAudioOnlyOff } from './visibility-off.svg';
import { default as IconAudioOnly } from './visibility.svg';
import { default as IconVolumeOff } from './volume-off.svg';
import { default as IconVolumeUp } from './volume-up.svg';
import { default as IconWarningCircle } from './warning-circle.svg';
import { default as IconWarning } from './warning.svg';
import { default as IconWhiteboardHide } from './whiteboard-hide.svg';
import { default as IconWhiteboard } from './whiteboard.svg';
import { default as IconWifi1Bar } from './wifi-1.svg';
import { default as IconWifi2Bars } from './wifi-2.svg';
import { default as IconWifi3Bars } from './wifi-3.svg';
import { default as IconYahoo } from './yahoo.svg';

/**
 * Map containing the default icons.
 */
export const DEFAULT_ICON: Record<string, any> = {
    IconAddUser,
    IconArrowBack,
    IconArrowDown,
    IconArrowDownLarge,
    IconArrowLeft,
    IconArrowUp,
    IconArrowUpLarge,
    IconAudioOnly,
    IconAudioOnlyOff,
    IconBluetooth,
    IconBell,
    IconCalendar,
    IconCameraRefresh,
    IconCar,
    IconChatUnread,
    IconCheck,
    IconCloseCircle,
    IconCloseLarge,
    IconCloudUpload,
    IconCode,
    IconConnection,
    IconConnectionInactive,
    IconCopy,
    IconDeviceHeadphone,
    IconDotsHorizontal,
    IconDownload,
    IconE2EE,
    IconEdit,
    IconEnlarge,
    IconEnterFullscreen,
    IconEnvelope,
    IconEmotionsAngry,
    IconEmotionsDisgusted,
    IconEmotionsFearful,
    IconEmotionsHappy,
    IconEmotionsNeutral,
    IconEmotionsSad,
    IconEmotionsSurprised,
    IconExclamationSolid,
    IconExclamationTriangle,
    IconExitFullscreen,
    IconFaceSmile,
    IconFavorite,
    IconFavoriteSolid,
    IconFeedback,
    IconGear,
    IconGoogle,
    IconHangup,
    IconHelp,
    IconHighlight,
    IconImage,
    IconInfo,
    IconInfoCircle,
    IconMessage,
    IconMeter,
    IconMic,
    IconMicSlash,
    IconModerator,
    IconNoiseSuppressionOff,
    IconNoiseSuppressionOn,
    IconArrowRight,
    IconOffice365,
    IconPerformance,
    IconPhoneRinging,
    IconPin,
    IconPinned,
    IconPlay,
    IconPlus,
    IconRaiseHand,
    IconRecord,
    IconRecordAccount,
    IconRecordContact,
    IconRecordLead,
    IconRecordOpportunity,
    IconRemoteControlStart,
    IconRemoteControlStop,
    IconReply,
    IconRestore,
    IconRingGroup,
    IconScreenshare,
    IconSearch,
    IconSecurityOff,
    IconSecurityOn,
    IconSend,
    IconShare,
    IconShareDoc,
    IconShortcuts,
    IconSip,
    IconSites,
    IconStop,
    IconSubtitles,
    IconTileView,
    IconTrash,
    IconUserDeleted,
    IconUsers,
    IconUser,
    IconVideo,
    IconVideoOff,
    IconVolumeOff,
    IconVolumeUp,
    IconWarning,
    IconWarningCircle,
    IconWhiteboard,
    IconWhiteboardHide,
    IconWifi1Bar,
    IconWifi2Bars,
    IconWifi3Bars,
    IconYahoo
};


################################################################################

## File: .\jitsi-meet\react\features\base\icons\svg\index.ts

import withBranding from '../components/withBranding';

import { DEFAULT_ICON } from './constants';

const {
    IconAddUser,
    IconArrowBack,
    IconArrowDown,
    IconArrowDownLarge,
    IconArrowLeft,
    IconArrowUp,
    IconArrowUpLarge,
    IconAudioOnly,
    IconAudioOnlyOff,
    IconBluetooth,
    IconBell,
    IconCalendar,
    IconCameraRefresh,
    IconCar,
    IconChatUnread,
    IconCheck,
    IconCloseCircle,
    IconCloseLarge,
    IconCloudUpload,
    IconCode,
    IconConnection,
    IconConnectionInactive,
    IconCopy,
    IconDeviceHeadphone,
    IconDotsHorizontal,
    IconDownload,
    IconE2EE,
    IconEdit,
    IconEnlarge,
    IconEnterFullscreen,
    IconEnvelope,
    IconEmotionsAngry,
    IconEmotionsDisgusted,
    IconEmotionsFearful,
    IconEmotionsHappy,
    IconEmotionsNeutral,
    IconEmotionsSad,
    IconEmotionsSurprised,
    IconExclamationSolid,
    IconExclamationTriangle,
    IconExitFullscreen,
    IconFaceSmile,
    IconFavorite,
    IconFavoriteSolid,
    IconFeedback,
    IconGear,
    IconGoogle,
    IconHangup,
    IconHelp,
    IconHighlight,
    IconImage,
    IconInfo,
    IconInfoCircle,
    IconMessage,
    IconMeter,
    IconMic,
    IconMicSlash,
    IconModerator,
    IconNoiseSuppressionOff,
    IconNoiseSuppressionOn,
    IconArrowRight,
    IconOffice365,
    IconPerformance,
    IconPhoneRinging,
    IconPin,
    IconPinned,
    IconPlay,
    IconPlus,
    IconRaiseHand,
    IconRecord,
    IconRecordAccount,
    IconRecordContact,
    IconRecordLead,
    IconRecordOpportunity,
    IconRemoteControlStart,
    IconRemoteControlStop,
    IconReply,
    IconRestore,
    IconRingGroup,
    IconScreenshare,
    IconSearch,
    IconSecurityOff,
    IconSecurityOn,
    IconSend,
    IconShare,
    IconShareDoc,
    IconShortcuts,
    IconSip,
    IconSites,
    IconStop,
    IconSubtitles,
    IconTileView,
    IconTrash,
    IconUserDeleted,
    IconUsers,
    IconUser,
    IconVideo,
    IconVideoOff,
    IconVolumeOff,
    IconVolumeUp,
    IconWarning,
    IconWarningCircle,
    IconWhiteboard,
    IconWhiteboardHide,
    IconWifi1Bar,
    IconWifi2Bars,
    IconWifi3Bars,
    IconYahoo
} = Object.keys(DEFAULT_ICON).reduce((exportedIcons: Record<string, any>, key) => {
    return {
        ...exportedIcons,
        [key]: withBranding({
            iconName: key,
            DefaultIcon: DEFAULT_ICON[key]
        })
    };
}, {});

export {
    IconAddUser,
    IconArrowBack,
    IconArrowDown,
    IconArrowDownLarge,
    IconArrowLeft,
    IconArrowUp,
    IconArrowUpLarge,
    IconAudioOnly,
    IconAudioOnlyOff,
    IconBluetooth,
    IconBell,
    IconCalendar,
    IconCameraRefresh,
    IconCar,
    IconChatUnread,
    IconCheck,
    IconCloseCircle,
    IconCloseLarge,
    IconCloudUpload,
    IconCode,
    IconConnection,
    IconConnectionInactive,
    IconCopy,
    IconDeviceHeadphone,
    IconDotsHorizontal,
    IconDownload,
    IconE2EE,
    IconEdit,
    IconEnlarge,
    IconEnterFullscreen,
    IconEnvelope,
    IconEmotionsAngry,
    IconEmotionsDisgusted,
    IconEmotionsFearful,
    IconEmotionsHappy,
    IconEmotionsNeutral,
    IconEmotionsSad,
    IconEmotionsSurprised,
    IconExclamationSolid,
    IconExclamationTriangle,
    IconExitFullscreen,
    IconFaceSmile,
    IconFavorite,
    IconFavoriteSolid,
    IconFeedback,
    IconGear,
    IconGoogle,
    IconHangup,
    IconHelp,
    IconHighlight,
    IconImage,
    IconInfo,
    IconInfoCircle,
    IconMessage,
    IconMeter,
    IconMic,
    IconMicSlash,
    IconModerator,
    IconNoiseSuppressionOff,
    IconNoiseSuppressionOn,
    IconArrowRight,
    IconOffice365,
    IconPerformance,
    IconPhoneRinging,
    IconPin,
    IconPinned,
    IconPlay,
    IconPlus,
    IconRaiseHand,
    IconRecord,
    IconRecordAccount,
    IconRecordContact,
    IconRecordLead,
    IconRecordOpportunity,
    IconRemoteControlStart,
    IconRemoteControlStop,
    IconReply,
    IconRestore,
    IconRingGroup,
    IconScreenshare,
    IconSearch,
    IconSecurityOff,
    IconSecurityOn,
    IconSend,
    IconShare,
    IconShareDoc,
    IconShortcuts,
    IconSip,
    IconSites,
    IconStop,
    IconSubtitles,
    IconTileView,
    IconTrash,
    IconUserDeleted,
    IconUsers,
    IconUser,
    IconVideo,
    IconVideoOff,
    IconVolumeOff,
    IconVolumeUp,
    IconWarning,
    IconWarningCircle,
    IconWhiteboard,
    IconWhiteboardHide,
    IconWifi1Bar,
    IconWifi2Bars,
    IconWifi3Bars,
    IconYahoo
};


################################################################################

## File: .\jitsi-meet\react\features\base\jitsi-local-storage\logger.ts

import { getLogger } from '../logging/functions';

export default getLogger('features/base/jitsi-local-storage');


################################################################################

## File: .\jitsi-meet\react\features\base\jitsi-local-storage\setup.web.ts

// @ts-ignore
import { jitsiLocalStorage } from '@jitsi/js-utils/jitsi-local-storage';
// eslint-disable-next-line lines-around-comment
// @ts-ignore
import { safeJsonParse } from '@jitsi/js-utils/json';

import { browser } from '../lib-jitsi-meet';
import { inIframe } from '../util/iframeUtils';
import { parseURLParams } from '../util/parseURLParams';

import logger from './logger';


/**
 * Handles changes of the fake local storage.
 *
 * @returns {void}
 */
function onFakeLocalStorageChanged() {
    APP.API.notifyLocalStorageChanged(jitsiLocalStorage.serialize([ 'jitsiLocalStorage' ]));
}

/**
 * Checks if the local storage of the host page needs to be used instead jitsi-meet's local storage.
 *
 * @param {Object} urlParams - Object with parsed URL params.
 * @returns {boolean} - True if the local storage of the host page needs to be used instead jitsi-meet's local storage
 * and false otherwise.
 */
function shouldUseHostPageLocalStorage(urlParams: { 'config.useHostPageLocalStorage'?: boolean; }) {
    // NOTE: normally the url params and the config will be merged into the redux store. But we want to setup the local
    // storage as soon as possible, the store is not created yet and the merging of the URL params and the config
    // haven't been executed yet. That's why we need to manually parse the URL params and also access the config through
    // the global variable.
    if (urlParams['config.useHostPageLocalStorage'] === true
        || (typeof config === 'object' && config.useHostPageLocalStorage)) {
        return true;
    }

    if (jitsiLocalStorage.isLocalStorageDisabled()) { // We have detected that ou own local storage is not working.
        return true;
    }

    if (browser.isWebKitBased() && inIframe()) {
        // WebKit browsers don't persist local storage for third-party iframes.

        return true;
    }

    return false;
}

/**
 * Performs initial setup of the jitsiLocalStorage.
 *
 * @returns {void}
 */
function setupJitsiLocalStorage() {
    // @ts-ignore
    const urlParams = parseURLParams(window.location);

    if (shouldUseHostPageLocalStorage(urlParams)) {
        try {
            const localStorageContent = safeJsonParse(urlParams['appData.localStorageContent']);

            // We need to disable the local storage before setting the data in case the browser local storage doesn't
            // throw exception (in some cases when this happens the local storage may be cleared for every session.
            // Example: when loading meet from cross-domain with the IFrame API with Brave with the default
            // configuration). Otherwise we will set the data in the browser local storage and then switch to the dummy
            // local storage from jitsiLocalStorage and we will loose the data.
            jitsiLocalStorage.setLocalStorageDisabled(true);

            if (typeof localStorageContent === 'object') {
                Object.keys(localStorageContent).forEach(key => {
                    jitsiLocalStorage.setItem(key, localStorageContent[key]);
                });
            }
        } catch (error) {
            logger.error('Can\'t parse localStorageContent.', error);
        }

        jitsiLocalStorage.on('changed', onFakeLocalStorageChanged);
    }
}

setupJitsiLocalStorage();


################################################################################

## File: .\jitsi-meet\react\features\base\jwt\actions.ts

import { SET_JWT } from './actionTypes';

/**
 * Stores a specific JSON Web Token (JWT) into the redux store.
 *
 * @param {string} [jwt] - The JSON Web Token (JWT) to store.
 * @returns {{
 *     type: SET_TOKEN_DATA,
 *     jwt: (string|undefined)
 * }}
 */
export function setJWT(jwt?: string) {
    return {
        type: SET_JWT,
        jwt
    };
}


################################################################################

## File: .\jitsi-meet\react\features\base\jwt\actionTypes.ts

/**
 * The type of redux action which stores a specific JSON Web Token (JWT) into
 * the redux store.
 *
 * {
 *     type: SET_JWT,
 *     jwt: string
 * }
 */
export const SET_JWT = 'SET_JWT';


################################################################################

## File: .\jitsi-meet\react\features\base\jwt\constants.ts

/**
 * The list of supported meeting features to enable/disable through jwt.
 */
export const MEET_FEATURES = {
    BRANDING: 'branding',
    CALENDAR: 'calendar',
    FLIP: 'flip',
    INBOUND_CALL: 'inbound-call',
    LIVESTREAMING: 'livestreaming',
    LOBBY: 'lobby',
    MODERATION: 'moderation',
    OUTBOUND_CALL: 'outbound-call',
    RECORDING: 'recording',
    ROOM: 'room',
    SCREEN_SHARING: 'screen-sharing',
    SIP_INBOUND_CALL: 'sip-inbound-call',
    SIP_OUTBOUND_CALL: 'sip-outbound-call',
    TRANSCRIPTION: 'transcription'
};

/**
 * The JWT validation errors for JaaS.
 */
export const JWT_VALIDATION_ERRORS = {
    AUD_INVALID: 'audInvalid',
    CONTEXT_NOT_FOUND: 'contextNotFound',
    EXP_INVALID: 'expInvalid',
    FEATURE_INVALID: 'featureInvalid',
    FEATURE_VALUE_INVALID: 'featureValueInvalid',
    FEATURES_NOT_FOUND: 'featuresNotFound',
    HEADER_NOT_FOUND: 'headerNotFound',
    ISS_INVALID: 'issInvalid',
    KID_NOT_FOUND: 'kidNotFound',
    KID_MISMATCH: 'kidMismatch',
    NBF_FUTURE: 'nbfFuture',
    NBF_INVALID: 'nbfInvalid',
    PAYLOAD_NOT_FOUND: 'payloadNotFound',
    TOKEN_EXPIRED: 'tokenExpired'
};


################################################################################

## File: .\jitsi-meet\react\features\base\jwt\functions.ts

// @ts-expect-error
import jwtDecode from 'jwt-decode';

import { IReduxState } from '../../app/types';
import { isVpaasMeeting } from '../../jaas/functions';
import { getLocalParticipant } from '../participants/functions';
import { IParticipantFeatures } from '../participants/types';
import { parseURLParams } from '../util/parseURLParams';

import { JWT_VALIDATION_ERRORS, MEET_FEATURES } from './constants';
import logger from './logger';

/**
 * Retrieves the JSON Web Token (JWT), if any, defined by a specific
 * {@link URL}.
 *
 * @param {URL} url - The {@code URL} to parse and retrieve the JSON Web Token
 * (JWT), if any, from.
 * @returns {string} The JSON Web Token (JWT), if any, defined by the specified
 * {@code url}; otherwise, {@code undefined}.
 */
export function parseJWTFromURLParams(url: URL | typeof window.location = window.location) {
    // @ts-ignore
    const jwt = parseURLParams(url, false, 'hash').jwt;

    // TODO: eventually remove the search param and only pull from the hash
    // @ts-ignore
    return jwt ? jwt : parseURLParams(url, true, 'search').jwt;
}

/**
 * Returns the user name after decoding the jwt.
 *
 * @param {IReduxState} state - The app state.
 * @returns {string}
 */
export function getJwtName(state: IReduxState) {
    const { user } = state['features/base/jwt'];

    return user?.name;
}

/**
 * Check if the given JWT feature is enabled.
 *
 * @param {IReduxState} state - The app state.
 * @param {string} feature - The feature we want to check.
 * @param {boolean} ifNoToken - Default value if there is no token.
 * @param {boolean} ifNotInFeatures - Default value if features prop exists but does not have the {@code feature}.
 * @returns {boolean}
 */
export function isJwtFeatureEnabled(state: IReduxState, feature: string, ifNoToken: boolean, ifNotInFeatures: boolean) {
    const { jwt } = state['features/base/jwt'];
    let { features } = getLocalParticipant(state) || {};

    if (typeof features === 'undefined' && isVpaasMeeting(state)) {
        // for vpaas the backend is always initialized with empty features if those are missing
        features = {};
    }

    return isJwtFeatureEnabledStateless({
        jwt,
        localParticipantFeatures: features,
        feature,
        ifNoToken,
        ifNotInFeatures
    });
}

interface IIsJwtFeatureEnabledStatelessParams {
    feature: string;
    ifNoToken: boolean;
    ifNotInFeatures: boolean;
    jwt?: string;
    localParticipantFeatures?: IParticipantFeatures;
}

/**
 * Check if the given JWT feature is enabled.
 *
 * @param {string | undefined} jwt - The jwt token.
 * @param {ILocalParticipant} localParticipantFeatures - The features of the local participant.
 * @param {string} feature - The feature we want to check.
 * @param {boolean} ifNoToken - Default value if there is no token.
 * @param {boolean} ifNotInFeatures - Default value if features is missing
 * or prop exists but does not have the {@code feature}.
 * @returns {boolean}
 */
export function isJwtFeatureEnabledStateless({
    jwt,
    localParticipantFeatures: features,
    feature,
    ifNoToken,
    ifNotInFeatures
}: IIsJwtFeatureEnabledStatelessParams) {
    if (!jwt) {
        return ifNoToken;
    }

    if (typeof features === 'undefined') {
        return ifNoToken;
    }

    if (typeof features[feature as keyof typeof features] === 'undefined') {
        return ifNotInFeatures;
    }

    return String(features[feature as keyof typeof features]) === 'true';
}

/**
 * Checks whether a given timestamp is a valid UNIX timestamp in seconds.
 * We convert to milliseconds during the check since `Date` works with milliseconds for UNIX timestamp values.
 *
 * @param {any} timestamp - A UNIX timestamp in seconds as stored in the jwt.
 * @returns {boolean} - Whether the timestamp is indeed a valid UNIX timestamp or not.
 */
function isValidUnixTimestamp(timestamp: number | string) {
    return typeof timestamp === 'number' && timestamp * 1000 === new Date(timestamp * 1000).getTime();
}

/**
 * Returns a list with all validation errors for the given jwt.
 *
 * @param {string} jwt - The jwt.
 * @returns {Array} - An array containing all jwt validation errors.
 */
export function validateJwt(jwt: string) {
    const errors: Object[] = [];
    const currentTimestamp = new Date().getTime();

    try {
        const header = jwtDecode(jwt, { header: true });
        const payload = jwtDecode(jwt);

        if (!header) {
            errors.push({ key: JWT_VALIDATION_ERRORS.HEADER_NOT_FOUND });

            return errors;
        }

        if (!payload) {
            errors.push({ key: JWT_VALIDATION_ERRORS.PAYLOAD_NOT_FOUND });

            return errors;
        }

        const {
            aud,
            context,
            exp,
            iss,
            nbf,
            sub
        } = payload;

        // JaaS only
        if (sub?.startsWith('vpaas-magic-cookie')) {
            const { kid } = header;

            // if Key ID is missing, we return the error immediately without further validations.
            if (!kid) {
                errors.push({ key: JWT_VALIDATION_ERRORS.KID_NOT_FOUND });

                return errors;
            }

            if (kid.substring(0, kid.indexOf('/')) !== sub) {
                errors.push({ key: JWT_VALIDATION_ERRORS.KID_MISMATCH });
            }

            if (aud !== 'jitsi') {
                errors.push({ key: JWT_VALIDATION_ERRORS.AUD_INVALID });
            }

            if (iss !== 'chat') {
                errors.push({ key: JWT_VALIDATION_ERRORS.ISS_INVALID });
            }

            if (!context?.features) {
                errors.push({ key: JWT_VALIDATION_ERRORS.FEATURES_NOT_FOUND });
            }
        }

        if (nbf) { // nbf value is optional
            if (!isValidUnixTimestamp(nbf)) {
                errors.push({ key: JWT_VALIDATION_ERRORS.NBF_INVALID });
            } else if (currentTimestamp < nbf * 1000) {
                errors.push({ key: JWT_VALIDATION_ERRORS.NBF_FUTURE });
            }
        }

        if (!isValidUnixTimestamp(exp)) {
            errors.push({ key: JWT_VALIDATION_ERRORS.EXP_INVALID });
        } else if (currentTimestamp > exp * 1000) {
            errors.push({ key: JWT_VALIDATION_ERRORS.TOKEN_EXPIRED });
        }

        if (!context) {
            errors.push({ key: JWT_VALIDATION_ERRORS.CONTEXT_NOT_FOUND });
        } else if (context.features) {
            const { features } = context;
            const meetFeatures = Object.values(MEET_FEATURES);

            Object.keys(features).forEach(feature => {
                if (meetFeatures.includes(feature)) {
                    const featureValue = features[feature];

                    // cannot use truthy or falsy because we need the exact value and type check.
                    if (
                        featureValue !== true
                        && featureValue !== false
                        && featureValue !== 'true'
                        && featureValue !== 'false'
                    ) {
                        errors.push({
                            key: JWT_VALIDATION_ERRORS.FEATURE_VALUE_INVALID,
                            args: { feature }
                        });
                    }
                } else {
                    errors.push({
                        key: JWT_VALIDATION_ERRORS.FEATURE_INVALID,
                        args: { feature }
                    });
                }
            });
        }
    } catch (e: any) {
        logger.error(`Unspecified JWT error${e?.message ? `: ${e.message}` : ''}`);
    }

    return errors;
}

/**
 * Extracts and returns the expiration date of jwt.
 *
 * @param {string|undefined} jwt - The jwt to check.
 * @returns {Date} The expiration date of the jwt.
 */
export function getJwtExpirationDate(jwt: string | undefined) {
    if (!jwt) {
        return;
    }

    const payload = jwtDecode(jwt);

    if (payload) {
        const { exp } = payload;

        return new Date(exp * 1000);
    }
}


################################################################################

## File: .\jitsi-meet\react\features\base\jwt\logger.ts

import { getLogger } from '../logging/functions';

export default getLogger('features/base/jwt');


################################################################################

## File: .\jitsi-meet\react\features\base\jwt\middleware.ts

// @ts-expect-error
import jwtDecode from 'jwt-decode';
import { AnyAction } from 'redux';

import { IStore } from '../../app/types';
import { SET_CONFIG } from '../config/actionTypes';
import { SET_LOCATION_URL } from '../connection/actionTypes';
import { participantUpdated } from '../participants/actions';
import { getLocalParticipant } from '../participants/functions';
import { IParticipant } from '../participants/types';
import MiddlewareRegistry from '../redux/MiddlewareRegistry';

import { SET_JWT } from './actionTypes';
import { setJWT } from './actions';
import { parseJWTFromURLParams } from './functions';
import logger from './logger';

/**
 * Middleware to parse token data upon setting a new room URL.
 *
 * @param {Store} store - The redux store.
 * @private
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {
    switch (action.type) {
    case SET_CONFIG:
    case SET_LOCATION_URL:
        // XXX The JSON Web Token (JWT) is not the only piece of state that we
        // have decided to store in the feature jwt
        return _setConfigOrLocationURL(store, next, action);

    case SET_JWT:
        return _setJWT(store, next, action);
    }

    return next(action);
});

/**
 * Overwrites the properties {@code avatarURL}, {@code email}, and {@code name}
 * of the local participant stored in the redux state base/participants.
 *
 * @param {Store} store - The redux store.
 * @param {Object} localParticipant - The {@code Participant} structure to
 * overwrite the local participant stored in the redux store base/participants
 * with.
 * @private
 * @returns {void}
 */
function _overwriteLocalParticipant(
        { dispatch, getState }: IStore,
        { avatarURL, email, id: jwtId, name, features }:
        { avatarURL?: string; email?: string; features?: any; id?: string; name?: string; }) {
    let localParticipant;

    if ((avatarURL || email || name || features) && (localParticipant = getLocalParticipant(getState))) {
        const newProperties: IParticipant = {
            id: localParticipant.id,
            local: true
        };

        if (avatarURL) {
            newProperties.avatarURL = avatarURL;
        }
        if (email) {
            newProperties.email = email;
        }
        if (jwtId) {
            newProperties.jwtId = jwtId;
        }
        if (name) {
            newProperties.name = name;
        }
        if (features) {
            newProperties.features = features;
        }
        dispatch(participantUpdated(newProperties));
    }
}

/**
 * Notifies the feature jwt that the action {@link SET_CONFIG} or
 * {@link SET_LOCATION_URL} is being dispatched within a specific redux
 * {@code store}.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @param {Dispatch} next - The redux dispatch function to dispatch the
 * specified {@code action} to the specified {@code store}.
 * @param {Action} action - The redux action {@code SET_CONFIG} or
 * {@code SET_LOCATION_URL} which is being dispatched in the specified
 * {@code store}.
 * @private
 * @returns {Object} The new state that is the result of the reduction of the
 * specified {@code action}.
 */
function _setConfigOrLocationURL({ dispatch, getState }: IStore, next: Function, action: AnyAction) {
    const result = next(action);

    const { locationURL } = getState()['features/base/connection'];

    dispatch(
        setJWT(locationURL ? parseJWTFromURLParams(locationURL) : undefined));

    return result;
}

/**
 * Notifies the feature jwt that the action {@link SET_JWT} is being dispatched
 * within a specific redux {@code store}.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @param {Dispatch} next - The redux dispatch function to dispatch the
 * specified {@code action} to the specified {@code store}.
 * @param {Action} action - The redux action {@code SET_JWT} which is being
 * dispatched in the specified {@code store}.
 * @private
 * @returns {Object} The new state that is the result of the reduction of the
 * specified {@code action}.
 */
function _setJWT(store: IStore, next: Function, action: AnyAction) {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { jwt, type, ...actionPayload } = action;

    if (!Object.keys(actionPayload).length) {
        if (jwt) {
            let jwtPayload;

            try {
                jwtPayload = jwtDecode(jwt);
            } catch (e) {
                logger.error(e);
            }

            if (jwtPayload) {
                const { context, iss, sub } = jwtPayload;

                action.jwt = jwt;
                action.issuer = iss;
                if (context) {
                    const user = _user2participant(context.user || {});

                    action.callee = context.callee;
                    action.group = context.group;
                    action.server = context.server;
                    action.tenant = context.tenant || sub || undefined;
                    action.user = user;

                    const newUser = user ? { ...user } : {};

                    _overwriteLocalParticipant(
                        store, { ...newUser,
                            features: context.features });

                    // eslint-disable-next-line max-depth
                    if (context.user && context.user.role === 'visitor') {
                        action.preferVisitor = true;
                    }
                } else if (jwtPayload.name || jwtPayload.picture || jwtPayload.email) {
                    // there are some tokens (firebase) having picture and name on the main level.
                    _overwriteLocalParticipant(store, {
                        avatarURL: jwtPayload.picture,
                        name: jwtPayload.name,
                        email: jwtPayload.email
                    });
                }
            }
        } else if (typeof APP === 'undefined') {
            // The logic of restoring JWT overrides make sense only on mobile.
            // On Web it should eventually be restored from storage, but there's
            // no such use case yet.

            const { user } = store.getState()['features/base/jwt'];

            user && _undoOverwriteLocalParticipant(store, user);
        }
    }

    return next(action);
}

/**
 * Undoes/resets the values overwritten by {@link _overwriteLocalParticipant}
 * by either clearing them or setting to default values. Only the values that
 * have not changed since the overwrite happened will be restored.
 *
 * NOTE Once it is possible to edit and save participant properties, this
 * function should restore values from the storage instead.
 *
 * @param {Store} store - The redux store.
 * @param {Object} localParticipant - The {@code Participant} structure used
 * previously to {@link _overwriteLocalParticipant}.
 * @private
 * @returns {void}
 */
function _undoOverwriteLocalParticipant(
        { dispatch, getState }: IStore,
        { avatarURL, name, email }: { avatarURL?: string; email?: string; name?: string; }) {
    let localParticipant;

    if ((avatarURL || name || email)
            && (localParticipant = getLocalParticipant(getState))) {
        const newProperties: IParticipant = {
            id: localParticipant.id,
            local: true
        };

        if (avatarURL === localParticipant.avatarURL) {
            newProperties.avatarURL = undefined;
        }
        if (email === localParticipant.email) {
            newProperties.email = undefined;
        }
        if (name === localParticipant.name) {
            newProperties.name = undefined;
        }
        newProperties.features = undefined;

        dispatch(participantUpdated(newProperties));
    }
}

/**
 * Converts the JWT {@code context.user} structure to the {@code Participant}
 * structure stored in the redux state base/participants.
 *
 * @param {Object} user - The JWT {@code context.user} structure to convert.
 * @private
 * @returns {{
 *     avatarURL: ?string,
 *     email: ?string,
 *     id: ?string,
 *     name: ?string,
 *     hidden-from-recorder: ?boolean
 * }}
 */
function _user2participant({ avatar, avatarUrl, email, id, name, 'hidden-from-recorder': hiddenFromRecorder }:
    { avatar?: string; avatarUrl?: string; email: string; 'hidden-from-recorder': string | boolean;
    id: string; name: string; }) {
    const participant: {
        avatarURL?: string;
        email?: string;
        hiddenFromRecorder?: boolean;
        id?: string;
        name?: string;
    } = {};

    if (typeof avatarUrl === 'string') {
        participant.avatarURL = avatarUrl.trim();
    } else if (typeof avatar === 'string') {
        participant.avatarURL = avatar.trim();
    }
    if (typeof email === 'string') {
        participant.email = email.trim();
    }
    if (typeof id === 'string') {
        participant.id = id.trim();
    }
    if (typeof name === 'string') {
        participant.name = name.trim();
    }

    if (hiddenFromRecorder === 'true' || hiddenFromRecorder === true) {
        participant.hiddenFromRecorder = true;
    }

    return Object.keys(participant).length ? participant : undefined;
}


################################################################################

## File: .\jitsi-meet\react\features\base\jwt\reducer.ts

import ReducerRegistry from '../redux/ReducerRegistry';
import { equals } from '../redux/functions';

import { SET_JWT } from './actionTypes';

export interface IJwtState {
    callee?: {
        name: string;
    };
    group?: string;
    jwt?: string;
    server?: string;
    tenant?: string;
    user?: {
        id: string;
        name: string;
    };
}

/**
 * Reduces redux actions which affect the JSON Web Token (JWT) stored in the
 * redux store.
 *
 * @param {Object} state - The current redux state.
 * @param {Object} action - The redux action to reduce.
 * @returns {Object} The next redux state which is the result of reducing the
 * specified {@code action}.
 */
ReducerRegistry.register<IJwtState>(
    'features/base/jwt',
    (state = {}, action): IJwtState => {
        switch (action.type) {
        case SET_JWT: {
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            const { type, ...payload } = action;
            const nextState = {
                ...payload
            };

            return equals(state, nextState) ? state : nextState;
        }
        }

        return state;
    });


################################################################################

## File: .\jitsi-meet\react\features\base\known-domains\actions.ts

import { ADD_KNOWN_DOMAINS } from './actionTypes';

/**
 * Creates a (redux) action to add known domains to the list of domains known to
 * the feature base/known-domains.
 *
 * @param {string | Array<string>} knownDomains - The known domain(s) to add to
 * the list of domains known to the feature base/known-domains.
 * @returns {{
 *     type: ADD_KNOWN_DOMAINS,
 *     knownDomains: Array<string>
 * }}
 */
export function addKnownDomains(knownDomains: string | Array<string>) {
    return {
        type: ADD_KNOWN_DOMAINS,
        knownDomains:
            typeof knownDomains === 'string' ? [ knownDomains ] : knownDomains
    };
}


################################################################################

## File: .\jitsi-meet\react\features\base\known-domains\actionTypes.ts

/**
 * The type of (redux) action to add known domains to the list of domains known
 * to the feature base/known-domains.
 *
 * {
 *     type: ADD_KNOWN_DOMAINS,
 *     knownDomains: Array<string>
 * }
 */
export const ADD_KNOWN_DOMAINS = 'ADD_KNOWN_DOMAINS';


################################################################################

## File: .\jitsi-meet\react\features\base\known-domains\middleware.ts

import { getDefaultURL } from '../../app/functions';
import { IStore } from '../../app/types';
import { APP_WILL_MOUNT } from '../app/actionTypes';
import { SET_ROOM } from '../conference/actionTypes';
import MiddlewareRegistry from '../redux/MiddlewareRegistry';
import { parseURIString } from '../util/uri';

import { addKnownDomains } from './actions';

MiddlewareRegistry.register(store => next => action => {
    const result = next(action);

    switch (action.type) {
    case APP_WILL_MOUNT:
        _appWillMount(store);
        break;

    case SET_ROOM:
        _setRoom(store);
        break;
    }

    return result;
});

/**
 * Adds the domain of the app's {@code defaultURL} to the list of domains known
 * to the feature base/known-domains.
 *
 * @param {Object} store - The redux store.
 * @private
 * @returns {Promise}
 */
function _appWillMount({ dispatch, getState }: IStore) {
    const defaultURL = parseURIString(getDefaultURL(getState));

    dispatch(addKnownDomains(defaultURL?.host));
}

/**
 * Adds the domain of {@code locationURL} to the list of domains known to the
 * feature base/known-domains.
 *
 * @param {Object} store - The redux store.
 * @private
 * @returns {Promise}
 */
function _setRoom({ dispatch, getState }: IStore) {
    const { locationURL } = getState()['features/base/connection'];
    let host;

    locationURL
        && (host = locationURL.host)
        && dispatch(addKnownDomains(host));
}


################################################################################

## File: .\jitsi-meet\react\features\base\known-domains\reducer.ts

import PersistenceRegistry from '../redux/PersistenceRegistry';
import ReducerRegistry from '../redux/ReducerRegistry';

import { ADD_KNOWN_DOMAINS } from './actionTypes';

/**
 * The default list of domains known to the feature base/known-domains.
 * Generally, it should be in sync with the domains associated with the app
 * through its manifest (in other words, Universal Links, deep linking). Anyway,
 * we need a hardcoded list because it has proven impossible to programmatically
 * read the information out of the app's manifests: App Store strips the
 * associated domains manifest out of the app so it's never downloaded on the
 * client and we did not spend a lot of effort to read the associated domains
 * out of the Android manifest.
 */
export const DEFAULT_STATE = [
    'alpha.jitsi.net',
    'beta.meet.jit.si',
    'meet.jit.si',
    '8x8.vc'
];

const STORE_NAME = 'features/base/known-domains';

PersistenceRegistry.register(STORE_NAME);

export type IKnownDomainsState = Array<string>;

ReducerRegistry.register<IKnownDomainsState>(STORE_NAME, (state = DEFAULT_STATE, action): IKnownDomainsState => {
    switch (action.type) {
    case ADD_KNOWN_DOMAINS:
        return _addKnownDomains(state, action.knownDomains);
    default:
        return state;
    }
});

/**
 * Adds an array of known domains to the list of domains known to the feature
 * base/known-domains.
 *
 * @param {Object} state - The redux state.
 * @param {Array<string>} knownDomains - The array of known domains to add to
 * the list of domains known to the feature base/known-domains.
 * @private
 * @returns {Object} The next redux state.
 */
function _addKnownDomains(state: IKnownDomainsState, knownDomains: Array<string>) {
    // In case persistence has deserialized a weird redux state:
    let nextState = Array.isArray(state) ? state : [];

    if (Array.isArray(knownDomains)) {
        nextState = Array.from(state);
        for (let knownDomain of knownDomains) {
            knownDomain = knownDomain.toLowerCase();
            !nextState.includes(knownDomain) && nextState.push(knownDomain);
        }
    }

    return nextState;
}


################################################################################

## File: .\jitsi-meet\react\features\base\label\constants.ts

export const COLORS = {
    white: 'white',
    green: 'green',
    red: 'red'
};


################################################################################

## File: .\jitsi-meet\react\features\base\label\components\native\styles.ts

import { ColorPalette } from '../../../styles/components/styles/ColorPalette';
import BaseTheme from '../../../ui/components/BaseTheme.native';

/**
 * The default color of the {@code Label} and {@code ExpandedLabel}.
 */
export const DEFAULT_COLOR = '#36383C';

/**
 * Margin of the {@Label} - to be reused when rendering the
 * {@code ExpandedLabel}.
 */
export const LABEL_MARGIN = 8;

/**
 * Size of the {@Label} - to be reused when rendering the
 * {@code ExpandedLabel}.
 */
export const LABEL_SIZE = 28;

/**
 * The styles of the native base/label feature.
 */
export default {
    expandedLabelContainer: {
        position: 'absolute',
        left: 0,
        right: 0,
        top: 36,
        flexDirection: 'row',
        justifyContent: 'center',
        zIndex: 1
    },

    expandedLabelTextContainer: {
        borderRadius: 3,
        paddingHorizontal: LABEL_MARGIN,
        paddingVertical: LABEL_MARGIN / 2
    },

    expandedLabelText: {
        color: ColorPalette.white
    },

    /**
     * The outermost view.
     */
    labelContainer: {
        alignItems: 'space-between',
        backgroundColor: DEFAULT_COLOR,
        borderRadius: 3,
        flex: 0,
        height: LABEL_SIZE,
        justifyContent: 'center',
        marginLeft: LABEL_MARGIN,
        marginBottom: LABEL_MARGIN,
        paddingHorizontal: 8
    },

    labelText: {
        color: ColorPalette.white,
        ...BaseTheme.typography.labelBold
    },

    labelOff: {
        opacity: 0.3
    }
};


################################################################################

## File: .\jitsi-meet\react\features\base\label\components\web\ExpandedLabel.ts



################################################################################

## File: .\jitsi-meet\react\features\base\lastn\actions.ts

import { SET_LAST_N } from './actionTypes';

/**
 * Sets the last-n, i.e., the number of remote videos to be requested from the bridge for the conference.
 *
 * @param {number} lastN - The number of remote videos to be requested.
 * @returns {{
 *     type: SET_LAST_N,
 *     lastN: number
 * }}
 */
export function setLastN(lastN: number) {
    return {
        type: SET_LAST_N,
        lastN
    };
}


################################################################################

## File: .\jitsi-meet\react\features\base\lastn\actionTypes.ts

/**
 * The type of (redux) action which sets the last-n for the conference.
 *
 * {
 *     type: SET_LAST_N,
 *     lastN: number
 * }
 */
export const SET_LAST_N = 'SET_LAST_N';


################################################################################

## File: .\jitsi-meet\react\features\base\lastn\functions.ts

import { VIDEO_QUALITY_LEVELS } from '../../video-quality/constants';

/**
 * Determines the lastN value to be used for the conference based on the video quality selected.
 *
 * @param {string} qualityLevel - Quality level (height) selected.
 * @param {number} channelLastN - LastN value set for the whole conference.
 * @returns {number} LastN value applicable to the quality level specified.
 */
export function getLastNForQualityLevel(qualityLevel: number, channelLastN: number) {
    let lastN = channelLastN;

    const videoQualityLevels = Object.values(VIDEO_QUALITY_LEVELS);

    for (const lvl in videoQualityLevels) {
        if (videoQualityLevels.hasOwnProperty(lvl)
            && qualityLevel === videoQualityLevels[lvl]
            && Number(lvl) > 1) {
            lastN = Math.floor(channelLastN / Math.pow(2, Number(lvl) - 1));
        }
    }

    return lastN;
}


################################################################################

## File: .\jitsi-meet\react\features\base\lastn\logger.ts

import { getLogger } from '../logging/functions';

export default getLogger('features/base/lastn');


################################################################################

## File: .\jitsi-meet\react\features\base\lastn\middleware.ts

import { debounce } from 'lodash-es';

import { IStore } from '../../app/types';
import { SET_FILMSTRIP_ENABLED } from '../../filmstrip/actionTypes';
import { APP_STATE_CHANGED } from '../../mobile/background/actionTypes';
import {
    SET_CAR_MODE,
    VIRTUAL_SCREENSHARE_REMOTE_PARTICIPANTS_UPDATED
} from '../../video-layout/actionTypes';
import { SET_AUDIO_ONLY } from '../audio-only/actionTypes';
import { CONFERENCE_JOINED } from '../conference/actionTypes';
import { getParticipantById } from '../participants/functions';
import MiddlewareRegistry from '../redux/MiddlewareRegistry';

import { setLastN } from './actions';
import logger from './logger';

/**
 * Updates the last N value in the conference based on the current state of the redux store.
 *
 * @param {Store} store - The redux store.
 * @private
 * @returns {void}
 */
const _updateLastN = debounce(({ dispatch, getState }: IStore) => {
    const state = getState();
    const { conference } = state['features/base/conference'];

    if (!conference) {
        logger.debug('There is no active conference, not updating last N');

        return;
    }

    const { enabled: audioOnly } = state['features/base/audio-only'];
    const { appState } = state['features/background'] || {};
    const { enabled: filmStripEnabled } = state['features/filmstrip'];
    const config = state['features/base/config'];
    const { carMode } = state['features/video-layout'];

    // Select the (initial) lastN value based on the following preference order.
    // 1. The last-n value from 'startLastN' if it is specified in config.js
    // 2. The last-n value from 'channelLastN' if specified in config.js.
    // 3. -1 as the default value.
    let lastNSelected = config.startLastN ?? (config.channelLastN ?? -1);

    if (appState === 'background' || carMode) {
        lastNSelected = 0;
    } else if (audioOnly) {
        const { remoteScreenShares, tileViewEnabled } = state['features/video-layout'];
        const largeVideoParticipantId = state['features/large-video'].participantId;
        const largeVideoParticipant
            = largeVideoParticipantId ? getParticipantById(state, largeVideoParticipantId) : undefined;

        // Use tileViewEnabled state from redux here instead of determining if client should be in tile
        // view since we make an exception only for screenshare when in audio-only mode. If the user unpins
        // the screenshare, lastN will be set to 0 here. It will be set to 1 if screenshare has been auto pinned.
        if (!tileViewEnabled && largeVideoParticipant && !largeVideoParticipant.local) {
            lastNSelected = (remoteScreenShares || []).includes(largeVideoParticipantId ?? '') ? 1 : 0;
        } else {
            lastNSelected = 0;
        }
    } else if (!filmStripEnabled) {
        lastNSelected = 1;
    }

    const { lastN } = state['features/base/lastn'];

    if (lastN !== lastNSelected) {
        dispatch(setLastN(lastNSelected));
    }
}, 1000); /* Don't send this more often than once a second. */


MiddlewareRegistry.register(store => next => action => {
    const result = next(action);

    switch (action.type) {
    case APP_STATE_CHANGED:
    case CONFERENCE_JOINED:
    case SET_AUDIO_ONLY:
    case SET_CAR_MODE:
    case SET_FILMSTRIP_ENABLED:
    case VIRTUAL_SCREENSHARE_REMOTE_PARTICIPANTS_UPDATED:
        _updateLastN(store);
        break;
    }

    return result;
});


################################################################################

## File: .\jitsi-meet\react\features\base\lastn\reducer.ts

import ReducerRegistry from '../redux/ReducerRegistry';

import { SET_LAST_N } from './actionTypes';

export interface ILastNState {
    lastN?: number;
}

ReducerRegistry.register<ILastNState>('features/base/lastn', (state = {}, action): ILastNState => {
    switch (action.type) {
    case SET_LAST_N: {
        const { lastN } = action;

        return {
            ...state,
            lastN
        };
    }
    }

    return state;
});


################################################################################

## File: .\jitsi-meet\react\features\base\lib-jitsi-meet\actions.ts

// @ts-expect-error
import { jitsiLocalStorage } from '@jitsi/js-utils';

import { IStore } from '../../app/types';
import { isOnline } from '../net-info/selectors';

import JitsiMeetJS from './_';
import {
    LIB_DID_DISPOSE,
    LIB_DID_INIT,
    LIB_INIT_ERROR,
    LIB_WILL_DISPOSE,
    LIB_WILL_INIT
} from './actionTypes';
import { isAnalyticsEnabled } from './functions.any';
import logger from './logger';

/**
 * Disposes (of) lib-jitsi-meet.
 *
 * @returns {Function}
 */
export function disposeLib() {
    return (dispatch: IStore['dispatch']) => {
        dispatch({ type: LIB_WILL_DISPOSE });

        // TODO Currently, lib-jitsi-meet doesn't have the functionality to
        // dispose itself.
        dispatch({ type: LIB_DID_DISPOSE });
    };
}

/**
 * Initializes lib-jitsi-meet (i.e. {@link invokes JitsiMeetJS.init()}) with the
 * current config(uration).
 *
 * @returns {Function}
 */
export function initLib() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const config = state['features/base/config'];

        if (!config) {
            throw new Error('Cannot init lib-jitsi-meet without config');
        }

        dispatch({ type: LIB_WILL_INIT });

        try {
            JitsiMeetJS.init({
                enableAnalyticsLogging: isAnalyticsEnabled(getState),
                ...config,
                externalStorage: jitsiLocalStorage.isLocalStorageDisabled() ? jitsiLocalStorage : undefined
            });
            JitsiMeetJS.setNetworkInfo({
                isOnline: isOnline(state)
            });

            logger.info(`lib-jitsi-meet version:${JitsiMeetJS.version}`);

            dispatch({ type: LIB_DID_INIT });
        } catch (error: any) {
            dispatch(libInitError(error));
        }
    };
}

/**
 * Notifies about a specific error raised by {@link JitsiMeetJS.init()}.
 *
 * @param {Error} error - The Error raised by JitsiMeetJS.init().
 * @returns {{
 *     type: LIB_INIT_ERROR,
 *     error: Error
 * }}
 */
export function libInitError(error: Error) {
    return {
        type: LIB_INIT_ERROR,
        error
    };
}


################################################################################

## File: .\jitsi-meet\react\features\base\lib-jitsi-meet\actionTypes.ts

/**
 * The type of Redux action which signals that {@link JitsiMeetJS} was disposed.
 *
 * {
 *     type: LIB_DID_DISPOSE
 * }
 */
export const LIB_DID_DISPOSE = 'LIB_DID_DISPOSE';

/**
 * The type of Redux action which signals that {@link JitsiMeetJS.init()} was
 * invoked and completed successfully.
 *
 * {
 *     type: LIB_DID_INIT
 * }
 */
export const LIB_DID_INIT = 'LIB_DID_INIT';

/**
 * Action to signal that lib-jitsi-meet initialized failed with error.
 *
 * {
 *     type: LIB_INIT_ERROR,
 *     error: Error
 * }
 */
export const LIB_INIT_ERROR = 'LIB_INIT_ERROR';

/**
 * The type of Redux action which signals that {@link JitsiMeetJS} will be
 * disposed.
 *
 * {
 *     type: LIB_WILL_DISPOSE
 * }
 */
export const LIB_WILL_DISPOSE = 'LIB_WILL_DISPOSE';

/**
 * The type of Redux action which signals that {@link JitsiMeetJS.init()} will
 * be invoked.
 *
 * {
 *     type: LIB_WILL_INIT
 * }
 */
export const LIB_WILL_INIT = 'LIB_WILL_INIT';


################################################################################

## File: .\jitsi-meet\react\features\base\lib-jitsi-meet\functions.any.ts

import { IStateful } from '../app/types';
import { ConnectionFailedError } from '../connection/types';
import { toState } from '../redux/functions';

import JitsiMeetJS from './_';


const JitsiConferenceErrors = JitsiMeetJS.errors.conference;
const JitsiConnectionErrors = JitsiMeetJS.errors.connection;

/**
 * Creates a {@link JitsiLocalTrack} model from the given device id.
 *
 * @param {string} type - The media type of track being created. Expected values
 * are "video" or "audio".
 * @param {string} deviceId - The id of the target media source.
 * @param {number} [timeout] - A timeout for the JitsiMeetJS.createLocalTracks function call.
 * @param {Object} additionalOptions - Extra options to be passed to lib-jitsi-meet's {@code createLocalTracks}.
 *
 * @returns {Promise<JitsiLocalTrack>}
 */
export function createLocalTrack(type: string, deviceId: string | null, timeout?: number | null,
        additionalOptions?: Object) {
    return (
        JitsiMeetJS.createLocalTracks({
            cameraDeviceId: deviceId,
            devices: [ type ],

            // eslint-disable-next-line camelcase
            firefox_fake_device:
                window.config?.firefox_fake_device,
            micDeviceId: deviceId,
            timeout,
            ...additionalOptions
        })
            .then(([ jitsiLocalTrack ]: any[]) => jitsiLocalTrack));
}

/**
 * Determines whether analytics is enabled in a specific redux {@code store}.
 *
 * @param {IStateful} stateful - The redux store, state, or
 * {@code getState} function.
 * @returns {boolean} If analytics is enabled, {@code true}; {@code false},
 * otherwise.
 */
export function isAnalyticsEnabled(stateful: IStateful) {
    const { disableThirdPartyRequests, analytics = {} } = toState(stateful)['features/base/config'];

    return !(disableThirdPartyRequests || analytics.disabled);
}

/**
 * Determines whether a specific {@link JitsiConferenceErrors} instance
 * indicates a fatal {@link JitsiConference} error.
 *
 * FIXME Figure out the category of errors defined by the function and describe
 * that category. I've currently named the category fatal because it appears to
 * be used in the cases of unrecoverable errors that necessitate a reload.
 *
 * @param {Error|string} error - The {@code JitsiConferenceErrors} instance to
 * categorize/classify or an {@link Error}-like object.
 * @returns {boolean} If the specified {@code JitsiConferenceErrors} instance
 * indicates a fatal {@code JitsiConference} error, {@code true}; otherwise,
 * {@code false}.
 */
export function isFatalJitsiConferenceError(error: Error | string) {
    if (typeof error !== 'string') {
        error = error.name; // eslint-disable-line no-param-reassign
    }

    return (
        error === JitsiConferenceErrors.FOCUS_DISCONNECTED
            || error === JitsiConferenceErrors.FOCUS_LEFT
            || error === JitsiConferenceErrors.ICE_FAILED
            || error === JitsiConferenceErrors.OFFER_ANSWER_FAILED
            || error === JitsiConferenceErrors.VIDEOBRIDGE_NOT_AVAILABLE);
}

/**
 * Determines whether a specific {@link JitsiConnectionErrors} instance
 * indicates a fatal {@link JitsiConnection} error.
 *
 * FIXME Figure out the category of errors defined by the function and describe
 * that category. I've currently named the category fatal because it appears to
 * be used in the cases of unrecoverable errors that necessitate a reload.
 *
 * @param {Error|string} error - The {@code JitsiConnectionErrors} instance to
 * categorize/classify or an {@link Error}-like object.
 * @returns {boolean} If the specified {@code JitsiConnectionErrors} instance
 * indicates a fatal {@code JitsiConnection} error, {@code true}; otherwise,
 * {@code false}.
 */
export function isFatalJitsiConnectionError(error: Error | string | ConnectionFailedError) {
    if (typeof error !== 'string') {
        error = error.name; // eslint-disable-line no-param-reassign
    }

    return (
        error === JitsiConnectionErrors.CONNECTION_DROPPED_ERROR
            || error === JitsiConnectionErrors.OTHER_ERROR
            || error === JitsiConnectionErrors.SERVER_ERROR);
}


################################################################################

## File: .\jitsi-meet\react\features\base\lib-jitsi-meet\functions.native.ts

// @ts-ignore
import { safeJsonParse } from '@jitsi/js-utils/json';
import { NativeModules } from 'react-native';

import { loadScript } from '../util/loadScript.native';

import logger from './logger';

export * from './functions.any';

const { JavaScriptSandbox } = NativeModules;

/**
 * Loads config.js from a specific remote server.
 *
 * @param {string} url - The URL to load.
 * @returns {Promise<Object>}
 */
export async function loadConfig(url: string): Promise<Object> {
    try {
        const configTxt = await loadScript(url, 10 * 1000 /* Timeout in ms */, true /* skipeval */);
        const configJson = await JavaScriptSandbox.evaluate(`${configTxt}\nJSON.stringify(config);`);
        const config = safeJsonParse(configJson);

        if (typeof config !== 'object') {
            throw new Error('config is not an object');
        }

        logger.info(`Config loaded from ${url}`);

        return config;
    } catch (err) {
        logger.error(`Failed to load config from ${url}`, err);

        throw err;
    }
}


################################################################################

## File: .\jitsi-meet\react\features\base\lib-jitsi-meet\functions.web.ts

export * from './functions.any';

/**
 * Loads config.js from a specific remote server.
 *
 * @param {string} _url - The URL to load.
 * @returns {Promise<IConfig>}
 */
export async function loadConfig(_url?: string) {
    // Return "the config.js file" from the global scope - that is how the
    // Web app on both the client and the server was implemented before the
    // React Native app was even conceived.
    return window.config;
}


################################################################################

## File: .\jitsi-meet\react\features\base\lib-jitsi-meet\index.ts

// Re-export JitsiMeetJS from the library lib-jitsi-meet to (the other features
// of) the project jitsi-meet.
import JitsiMeetJS from './_';
export { JitsiMeetJS as default };

// XXX Re-export the properties exported by JitsiMeetJS in order to prevent
// undefined imported JitsiMeetJS. It may be caused by import cycles but I have
// not confirmed the theory.
export const analytics = JitsiMeetJS.analytics;
export const browser = JitsiMeetJS.util.browser;
export const JitsiConferenceErrors = JitsiMeetJS.errors.conference;
export const JitsiConferenceEvents = JitsiMeetJS.events.conference;
export const JitsiConnectionErrors = JitsiMeetJS.errors.connection;
export const JitsiConnectionEvents = JitsiMeetJS.events.connection;
export const JitsiConnectionQualityEvents = JitsiMeetJS.events.connectionQuality;
export const JitsiDetectionEvents = JitsiMeetJS.events.detection;
export const JitsiE2ePingEvents = JitsiMeetJS.events.e2eping;
export const JitsiMediaDevicesEvents = JitsiMeetJS.events.mediaDevices;
export const JitsiTrackStreamingStatus = JitsiMeetJS.constants.trackStreamingStatus;
export const JitsiRecordingConstants = JitsiMeetJS.constants.recording;
export const JitsiSIPVideoGWStatus = JitsiMeetJS.constants.sipVideoGW;
export const JitsiTrackErrors = JitsiMeetJS.errors.track;
export const JitsiTrackEvents = JitsiMeetJS.events.track;
export const RTCStatsEvents = JitsiMeetJS.events.rtcstats;


################################################################################

## File: .\jitsi-meet\react\features\base\lib-jitsi-meet\logger.ts

import { getLogger } from '../logging/functions';

export default getLogger('features/base/lib-jitsi-meet');


################################################################################

## File: .\jitsi-meet\react\features\base\lib-jitsi-meet\middleware.ts

import { AnyAction } from 'redux';

import { IStore } from '../../app/types';
import { SET_CONFIG } from '../config/actionTypes';
import { SET_NETWORK_INFO } from '../net-info/actionTypes';
import { PARTICIPANT_LEFT } from '../participants/actionTypes';
import MiddlewareRegistry from '../redux/MiddlewareRegistry';

import JitsiMeetJS from './_';
import { disposeLib, initLib } from './actions';

/**
 * Middleware that captures PARTICIPANT_LEFT action for a local participant
 * (which signalizes that we finally left the app) and disposes lib-jitsi-meet.
 * Also captures SET_CONFIG action and disposes previous instance (if any) of
 * lib-jitsi-meet, and initializes a new one with new config.
 *
 * @param {Store} store - Redux store.
 * @private
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {
    switch (action.type) {
    case SET_NETWORK_INFO:
        JitsiMeetJS.setNetworkInfo({
            isOnline: action.isOnline
        });
        break;

    case PARTICIPANT_LEFT:
        action.participant.local && store.dispatch(disposeLib());
        break;

    case SET_CONFIG:
        return _setConfig(store, next, action);
    }

    return next(action);
});

/**
 * Notifies the feature base/lib-jitsi-meet that the action SET_CONFIG is being
 * dispatched within a specific Redux store.
 *
 * @param {Store} store - The Redux store in which the specified action is being
 * dispatched.
 * @param {Dispatch} next - The Redux dispatch function to dispatch the
 * specified action to the specified store.
 * @param {Action} action - The Redux action SET_CONFIG which is being
 * dispatched in the specified store.
 * @private
 * @returns {Object} The new state that is the result of the reduction of the
 * specified action.
 */
function _setConfig({ dispatch, getState }: IStore, next: Function, action: AnyAction) {
    const { initialized } = getState()['features/base/lib-jitsi-meet'];

    // XXX Since the config is changing, the library lib-jitsi-meet must be
    // initialized again with the new config. Consequently, it may need to be
    // disposed of first.
    // TODO Currently, disposeLib actually does not dispose of lib-jitsi-meet
    // because lib-jitsi-meet does not implement such functionality.
    if (initialized) {
        dispatch(disposeLib());
    }

    // Let the new config into the Redux store (because initLib will read it
    // from there).
    const result = next(action);

    dispatch(initLib());

    return result;
}


################################################################################

## File: .\jitsi-meet\react\features\base\lib-jitsi-meet\reducer.ts

import ReducerRegistry from '../redux/ReducerRegistry';

import {
    LIB_DID_DISPOSE,
    LIB_DID_INIT,
    LIB_INIT_ERROR
} from './actionTypes';

/**
 * The default/initial redux state of the feature base/lib-jitsi-meet.
 *
 * @type {Object}
 */
const DEFAULT_STATE = {};

export interface ILibJitsiMeetState {
    initError?: Error;
    initialized?: boolean;
}

ReducerRegistry.register<ILibJitsiMeetState>(
    'features/base/lib-jitsi-meet',
    (state = DEFAULT_STATE, action): ILibJitsiMeetState => {
        switch (action.type) {
        case LIB_DID_DISPOSE:
            return DEFAULT_STATE;

        case LIB_DID_INIT:
            return {
                ...state,
                initError: undefined,
                initialized: true
            };

        case LIB_INIT_ERROR:
            return {
                ...state,
                initError: action.error,
                initialized: false
            };

        default:
            return state;
        }
    });


################################################################################

## File: .\jitsi-meet\react\features\base\lib-jitsi-meet\_.native.ts

// Re-export JitsiMeetJS from the library lib-jitsi-meet to (the other features
// of) the project jitsi-meet.
//

// @ts-ignore
import JitsiMeetJS from 'lib-jitsi-meet';
export { JitsiMeetJS as default };


################################################################################

## File: .\jitsi-meet\react\features\base\lib-jitsi-meet\_.web.ts

declare let JitsiMeetJS: any;

export default JitsiMeetJS;


################################################################################

## File: .\jitsi-meet\react\features\base\logging\actions.ts

import { SET_LOGGING_CONFIG, SET_LOG_COLLECTOR } from './actionTypes';

/**
 * Stores a {@code Logger.LogCollector} instance which will be uploading logs.
 *
 * @param {Logger.LogCollector} logCollector - The log collector instance to be
 * stored in the Redux state of base/logging feature.
 * @returns {{
 *     type,
 *     logCollector: Object
 * }}
 */
export function setLogCollector(logCollector?: Object) {
    return {
        type: SET_LOG_COLLECTOR,
        logCollector
    };
}

/**
 * Sets the configuration of the feature base/logging.
 *
 * @param {Object} config - The configuration to set on the features
 * base/logging.
 * @returns {{
 *     type: SET_LOGGING_CONFIG,
 *     config: Object
 * }}
 */
export function setLoggingConfig(config: Object) {
    return {
        type: SET_LOGGING_CONFIG,
        config
    };
}


################################################################################

## File: .\jitsi-meet\react\features\base\logging\actionTypes.ts

/**
 * The type of redux action which stores the log collector that will be
 * submitting the logs to a service
 *
 * {
 *     type: SET_LOG_COLLECTOR,
 *     logCollector: Logger.LogCollector
 * }
 */
export const SET_LOG_COLLECTOR = 'SET_LOG_COLLECTOR';

/**
 * The type of redux action which sets the configuration of the feature
 * base/logging.
 *
 * {
 *     type: SET_LOGGING_CONFIG,
 *     config: Object
 * }
 */
export const SET_LOGGING_CONFIG = 'SET_LOGGING_CONFIG';


################################################################################

## File: .\jitsi-meet\react\features\base\logging\ExternalApiLogTransport.ts

/**
 * Constructs a log transport object for use with external API.
 *
 * @param {Array} levels - The log levels forwarded to the external API.

 * @returns {Object} - The transport object.
 */
function buildTransport(levels: Array<string>) {
    return levels.reduce((logger: any, level) => {
        logger[level] = (...args: any) => {
            APP.API.notifyLog(level, args);
        };

        return logger;
    }, {});
}

export default buildTransport;


################################################################################

## File: .\jitsi-meet\react\features\base\logging\functions.ts

// @ts-expect-error
import Logger, { getLogger as _getLogger } from '@jitsi/logger';
import { once } from 'lodash-es';

import LogTransport from './LogTransport';

/**
 * Options for building the logger. We disable the callee info on RN because it's
 * almost always empty anyway.
 */
const DEFAULT_OPTS = {};
const DEFAULT_RN_OPTS = { disableCallerInfo: true };

/**
 * Gets a logger for the given id.
 *
 * @param {string} id - Name for the logger.
 * @returns {Object} - The logger object.
 */
export function getLogger(id: string) {
    const opts = navigator.product === 'ReactNative' ? DEFAULT_RN_OPTS : DEFAULT_OPTS;

    return _getLogger(id, undefined, opts);
}

/**
 * Initializes native logging. This operations must be done as early as possible.
 */
export const _initLogging = once(() => {
    if (navigator.product !== 'ReactNative') {
        return;
    }

    // Lazy load it to avoid cycles in early web bootstrap code.
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const { default: JitsiMeetJS } = require('../lib-jitsi-meet/_');

    Logger.setGlobalOptions(DEFAULT_RN_OPTS);
    JitsiMeetJS.setGlobalLogOptions(DEFAULT_RN_OPTS);
    Logger.removeGlobalTransport(console);
    JitsiMeetJS.removeGlobalLogTransport(console);
    Logger.addGlobalTransport(LogTransport);
    JitsiMeetJS.addGlobalLogTransport(LogTransport);
});


################################################################################

## File: .\jitsi-meet\react\features\base\logging\JitsiMeetInMemoryLogStorage.ts

/**
 * Implements in memory logs storage, used for testing/debugging.
 *
 */
export default class JitsiMeetInMemoryLogStorage {
    logs: string[] = [];

    /**
     * Creates new <tt>JitsiMeetInMemoryLogStorage</tt>.
     */
    constructor() {
        /**
         * Array of the log entries to keep.
         *
         * @type {array}
         */
        this.logs = [];
    }

    /**
     * Checks if this storage instance is ready.
     *
     * @returns {boolean} <tt>true</tt> when this storage is ready or
     * <tt>false</tt> otherwise.
     */
    isReady() {
        return true;
    }

    /**
     * Called by the <tt>LogCollector</tt> to store a series of log lines into
     * batch.
     *
     * @param {string|Object[]} logEntries - An array containing strings
     * representing log lines or aggregated lines objects.
     * @returns {void}
     */
    storeLogs(logEntries: (string | { text: string; })[]) {
        for (let i = 0, len = logEntries.length; i < len; i++) {
            const logEntry = logEntries[i];

            if (typeof logEntry === 'object') {
                this.logs.push(logEntry.text);
            } else {
                // Regular message
                this.logs.push(logEntry);
            }
        }
    }

    /**
     * Returns the logs stored in the memory.
     *
     * @returns {Array<string>} The collected log entries.
     */
    getLogs() {
        return this.logs;
    }
}


################################################################################

## File: .\jitsi-meet\react\features\base\logging\JitsiMeetLogStorage.ts

import { IStore } from '../../app/types';
import RTCStats from '../../rtcstats/RTCStats';
import { isRTCStatsEnabled } from '../../rtcstats/functions';

/**
 * Implements log storage interface from the @jitsi/logger lib.
 */
export default class JitsiMeetLogStorage {
    counter: number;
    getState: IStore['getState'];

    /**
     * Creates new <tt>JitsiMeetLogStorage</tt>.
     *
     * @param {Function} getState - The Redux store's {@code getState} method.
     */
    constructor(getState: IStore['getState']) {
        /**
         * Counts each log entry, increases on every batch log entry stored.
         *
         * @type {number}
         */
        this.counter = 1;

        /**
         * The Redux store's {@code getState} method.
         *
         * @type {Function}
         */
        this.getState = getState;
    }

    /**
     * The JitsiMeetLogStorage is ready when the conference has been joined.
     * A conference is considered joined when the 'conference' field is defined
     * in the base/conference state.
     *
     * @returns {boolean} <tt>true</tt> when this storage is ready or
     * <tt>false</tt> otherwise.
     */
    isReady() {
        const { conference } = this.getState()['features/base/conference'];

        return Boolean(conference);
    }

    /**
     * Checks whether rtcstats logs storage is enabled.
     *
     * @returns {boolean} <tt>true</tt> when this storage can store logs to
     * rtcstats, <tt>false</tt> otherwise.
     */
    canStoreLogsRtcstats() {

        const config = this.getState()['features/base/config'];

        // Saving the logs in RTCStats is a new feature and so there is no prior behavior that needs to be maintained.
        // That said, this is still experimental and needs to be rolled out gradually so we want this to be off by
        // default.
        return config?.analytics?.rtcstatsStoreLogs && isRTCStatsEnabled(this.getState());
    }

    /**
     * Called by the <tt>LogCollector</tt> to store a series of log lines into
     * batch.
     *
     * @param {Array<string|Object>} logEntries - An array containing strings
     * representing log lines or aggregated lines objects.
     * @returns {void}
     */
    storeLogs(logEntries: Array<string | any>) {

        if (this.canStoreLogsRtcstats()) {
            RTCStats.sendLogs(logEntries);
        }
    }
}


################################################################################

## File: .\jitsi-meet\react\features\base\logging\LogTransport.native.ts

import { NativeModules } from 'react-native';
// eslint-disable-next-line lines-around-comment
// @ts-expect-error
import { format } from 'util';

// Some code adapted from https://github.com/houserater/react-native-lumberjack
// License: MIT

const { LogBridge } = NativeModules;

/**
 * Returns the stack trace for a given @code {Error} object.
 *
 * @param {Error} e - The error.
 * @returns {string} - The stack trace.
 */
function stackToString(e: any) {
    let ce;
    let s = e.stack;

    if (typeof e.cause === 'function' && (ce = e.cause())) {
        s += `\nCaused by: ${stackToString(ce)}`;
    }

    return s;
}

/**
 * Constructs a log transport object for use with @jitsi/logger.
 *
 * @returns {Object} - The transport object.
 */
function buildTransport() {
    return [
        'trace',
        'debug',
        'info',
        'log',
        'warn',
        'error'
    ].reduce((logger: any, logName) => {
        logger[logName] = (timestamp: string, ...args: Array<string>) => {
            // It ignores the timestamp argument, because LogBridge will add it on the native side anyway
            const nargs = args.map((arg: any) => {
                if (arg instanceof Error) {
                    const errorBody = {
                        message: arg.message,

                        // @ts-ignore
                        code: arg.code,
                        stack: stackToString(arg)
                    };

                    return `Error(${arg.name})${JSON.stringify(errorBody)}`;
                }

                return arg;
            });
            const message = format(...nargs);

            LogBridge[logName](message);
        };

        return logger;
    }, {});
}

export default buildTransport();


################################################################################

## File: .\jitsi-meet\react\features\base\logging\LogTransport.web.ts

export default {};


################################################################################

## File: .\jitsi-meet\react\features\base\logging\middleware.ts

// @ts-expect-error
import Logger from '@jitsi/logger';
import { AnyAction } from 'redux';

import { IStore } from '../../app/types';
import { APP_WILL_MOUNT } from '../app/actionTypes';
import { CONFERENCE_JOINED } from '../conference/actionTypes';
import { getCurrentConference } from '../conference/functions';
import { SET_CONFIG } from '../config/actionTypes';
import JitsiMeetJS, {
    JitsiConferenceEvents
} from '../lib-jitsi-meet';
import { LIB_WILL_INIT } from '../lib-jitsi-meet/actionTypes';
import MiddlewareRegistry from '../redux/MiddlewareRegistry';
import { isTestModeEnabled } from '../testing/functions';

import buildExternalApiLogTransport from './ExternalApiLogTransport';
import JitsiMeetInMemoryLogStorage from './JitsiMeetInMemoryLogStorage';
import JitsiMeetLogStorage from './JitsiMeetLogStorage';
import { SET_LOGGING_CONFIG } from './actionTypes';
import { setLogCollector, setLoggingConfig } from './actions';

/**
 * The Redux middleware of the feature base/logging.
 *
 * @param {Store} store - The Redux store.
 * @returns {Function}
 * @private
 */
MiddlewareRegistry.register(store => next => action => {
    switch (action.type) {
    case APP_WILL_MOUNT:
        return _appWillMount(store, next, action);

    case CONFERENCE_JOINED:
        return _conferenceJoined(store, next, action);

    case LIB_WILL_INIT:
        return _libWillInit(store, next, action);

    case SET_CONFIG:
        return _setConfig(store, next, action);

    case SET_LOGGING_CONFIG:
        return _setLoggingConfig(store, next, action);
    }

    return next(action);
});

/**
 * Notifies the feature base/logging that the action {@link APP_WILL_MOUNT} is
 * being dispatched within a specific Redux {@code store}.
 *
 * @param {Store} store - The Redux store in which the specified {@code action}
 * is being dispatched.
 * @param {Dispatch} next - The Redux {@code dispatch} function to dispatch the
 * specified {@code action} to the specified {@code store}.
 * @param {Action} action - The Redux action {@code APP_WILL_MOUNT} which is
 * being dispatched in the specified {@code store}.
 * @private
 * @returns {Object} The new state that is the result of the reduction of the
 * specified {@code action}.
 */
function _appWillMount({ getState }: IStore, next: Function, action: AnyAction) {
    const { config } = getState()['features/base/logging'];

    _setLogLevels(Logger, config);

    // FIXME Until the logic of conference.js is rewritten into the React
    // app we, JitsiMeetJS.init is to not be used for the React app.
    // Consequently, LIB_WILL_INIT will not be dispatched. In the meantime, do
    // the following:
    typeof APP === 'undefined' || _setLogLevels(JitsiMeetJS, config);

    return next(action);
}

/**
 * Starts the log collector, after {@link CONFERENCE_JOINED} action is reduced.
 *
 * @param {Store} store - The Redux store in which the specified {@code action}
 * is being dispatched.
 * @param {Dispatch} next - The Redux {@code dispatch} function to dispatch the
 * specified {@code action} to the specified {@code store}.
 * @param {Action} action - The Redux action {@code CONFERENCE_JOINED} which is
 * being dispatched in the specified {@code store}.
 * @private
 * @returns {*}
 */
function _conferenceJoined({ getState }: IStore, next: Function, action: AnyAction) {

    // Wait until the joined event is processed, so that the JitsiMeetLogStorage
    // will be ready.
    const result = next(action);

    const { conference } = action;
    const { logCollector } = getState()['features/base/logging'];

    if (logCollector && conference === getCurrentConference(getState())) {
        // Start the LogCollector's periodic "store logs" task
        logCollector.start();

        // Make an attempt to flush in case a lot of logs have been cached,
        // before the collector was started.
        logCollector.flush();

        // This event listener will flush the logs, before the statistics module
        // is stopped.
        //
        // NOTE The LogCollector is not stopped, because this event can be
        // triggered multiple times during single conference (whenever
        // statistics module is stopped). That includes the case when Jicofo
        // terminates a single person conference (one person left in the room
        // waiting for someone to join). It will then restart the media session
        // when someone eventually joins the room which will start the stats
        // again.
        conference.on(
            JitsiConferenceEvents.BEFORE_STATISTICS_DISPOSED,
            () => logCollector.flush()
        );
    }

    return result;
}

/**
 * Initializes logging in the app.
 *
 * @param {Store} store - The Redux store in which context the logging is to be
 * initialized.
 * @param {Object} loggingConfig - The configuration with which logging is to be
 * initialized.
 * @param {boolean} isTestingEnabled - Is debug logging enabled.
 * @private
 * @returns {void}
 */
function _initLogging({ dispatch, getState }: IStore,
        loggingConfig: any, isTestingEnabled: boolean) {
    const { logCollector } = getState()['features/base/logging'];

    // Create the LogCollector and register it as the global log transport. It
    // is done early to capture as much logs as possible. Captured logs will be
    // cached, before the JitsiMeetLogStorage gets ready (statistics module is
    // initialized).
    if (!logCollector && !loggingConfig.disableLogCollector) {
        const _logCollector = new Logger.LogCollector(new JitsiMeetLogStorage(getState));

        const { apiLogLevels } = getState()['features/base/config'];

        if (apiLogLevels && Array.isArray(apiLogLevels) && typeof APP === 'object') {
            const transport = buildExternalApiLogTransport(apiLogLevels);

            Logger.addGlobalTransport(transport);
            JitsiMeetJS.addGlobalLogTransport(transport);
        }

        Logger.addGlobalTransport(_logCollector);
        JitsiMeetJS.addGlobalLogTransport(_logCollector);
        dispatch(setLogCollector(_logCollector));

        // The JitsiMeetInMemoryLogStorage can not be accessed on mobile through
        // the 'executeScript' method like it's done in torture tests for WEB.
        if (isTestingEnabled && typeof APP === 'object') {
            APP.debugLogs = new JitsiMeetInMemoryLogStorage();
            const debugLogCollector = new Logger.LogCollector(
                APP.debugLogs, { storeInterval: 1000 });

            Logger.addGlobalTransport(debugLogCollector);
            JitsiMeetJS.addGlobalLogTransport(debugLogCollector);
            debugLogCollector.start();
        }
    } else if (logCollector && loggingConfig.disableLogCollector) {
        Logger.removeGlobalTransport(logCollector);
        JitsiMeetJS.removeGlobalLogTransport(logCollector);
        logCollector.stop();
        dispatch(setLogCollector(undefined));
    }
}

/**
 * Notifies the feature base/logging that the action {@link LIB_WILL_INIT} is
 * being dispatched within a specific Redux {@code store}.
 *
 * @param {Store} store - The Redux store in which the specified {@code action}
 * is being dispatched.
 * @param {Dispatch} next - The Redux {@code dispatch} function to dispatch the
 * specified {@code action} to the specified {@code store}.
 * @param {Action} action - The Redux action {@code LIB_WILL_INIT} which is
 * being dispatched in the specified {@code store}.
 * @private
 * @returns {Object} The new state that is the result of the reduction of the
 * specified {@code action}.
 */
function _libWillInit({ getState }: IStore, next: Function, action: AnyAction) {
    // Adding the if in order to preserve the logic for web after enabling
    // LIB_WILL_INIT action for web in initLib action.
    if (typeof APP === 'undefined') {
        _setLogLevels(JitsiMeetJS, getState()['features/base/logging'].config);
    }

    return next(action);
}

/**
 * This feature that the action SET_CONFIG is being
 * dispatched within a specific Redux store.
 *
 * @param {Store} store - The Redux store in which the specified action is being
 * dispatched.
 * @param {Dispatch} next - The Redux dispatch function to dispatch the
 * specified action to the specified store.
 * @param {Action} action - The Redux action SET_CONFIG which is being
 * dispatched in the specified store.
 * @private
 * @returns {Object} The new state that is the result of the reduction of the
 * specified action.
 */
function _setConfig({ dispatch }: IStore, next: Function, action: AnyAction) {
    const result = next(action);

    dispatch(setLoggingConfig(action.config?.logging));

    return result;
}

/**
 * Notifies the feature base/logging that the action {@link SET_LOGGING_CONFIG}
 * is being dispatched within a specific Redux {@code store}.
 *
 * @param {Store} store - The Redux store in which the specified {@code action}
 * is being dispatched.
 * @param {Dispatch} next - The Redux {@code dispatch} function to dispatch the
 * specified {@code action} to the specified {@code store}.
 * @param {Action} action - The Redux action {@code SET_LOGGING_CONFIG} which is
 * being dispatched in the specified {@code store}.
 * @private
 * @returns {Object} The new state that is the result of the reduction of the
 * specified {@code action}.
 */
function _setLoggingConfig({ dispatch, getState }: IStore,
        next: Function, action: AnyAction) {
    const result = next(action);
    const newValue = getState()['features/base/logging'].config;
    const isTestingEnabled = isTestModeEnabled(getState());

    // TODO Generally, we'll want to _setLogLevels and _initLogging only if the
    // logging config values actually change.
    // XXX Unfortunately, we don't currently have a (nice) way of determining
    // whether _setLogLevels or _initLogging have been invoked so we have to
    // invoke them unconditionally even if none of the values have actually
    // changed.
    _setLogLevels(Logger, newValue);
    _setLogLevels(JitsiMeetJS, newValue);

    _initLogging({
        dispatch,
        getState
    }, newValue, isTestingEnabled);

    return result;
}

/**
 * Sets the log levels of {@link Logger} or {@link JitsiMeetJS} in accord with
 * a specific configuration.
 *
 * @param {Object} logger - The object on which the log levels are to be set.
 * @param {Object} config - The configuration specifying the log levels to be
 * set on {@code Logger} or {@code JitsiMeetJS}.
 * @private
 * @returns {void}
 */
function _setLogLevels(logger: any, config: any) {
    // XXX The loggers of the library lib-jitsi-meet and the application
    // jitsi-meet are separate, so the log levels have to be set in both.

    // First, set the default log level.
    logger.setLogLevel(config.defaultLogLevel);

    // Second, set the log level of each logger explicitly overridden by config.
    for (const [ id, level ] of Object.entries(config.loggers)) {
        logger.setLogLevelById(level, id);
    }
}


################################################################################

## File: .\jitsi-meet\react\features\base\logging\reducer.ts

import { merge } from 'lodash-es';
import { AnyAction } from 'redux';

import ReducerRegistry from '../redux/ReducerRegistry';
import { equals, set } from '../redux/functions';

import { SET_LOGGING_CONFIG, SET_LOG_COLLECTOR } from './actionTypes';

const DEFAULT_LOGGING_CONFIG = {
    // default log level for the app and lib-jitsi-meet
    defaultLogLevel: 'trace' as LogLevel,

    // Option to disable LogCollector (which stores the logs)
    // disableLogCollector: true,

    loggers: {
        // The following are too verbose in their logging with the
        // {@link #defaultLogLevel}:
        'modules/RTC/TraceablePeerConnection.js': 'info' as LogLevel,
        'modules/xmpp/strophe.util.js': 'log' as LogLevel
    }
};

/**
 * The default/initial redux state of the feature base/logging.
 *
 * @type {{
 *     config: Object
 * }}
 */
const DEFAULT_STATE = {
    config: DEFAULT_LOGGING_CONFIG,

    /**
     * The log collector.
     */
    logCollector: undefined
};

// Reduce default verbosity on mobile, it kills performance.
if (navigator.product === 'ReactNative') {
    const RN_LOGGERS = {
        'modules/sdp/SDPUtil.js': 'info' as LogLevel,
        'modules/xmpp/ChatRoom.js': 'warn' as LogLevel,
        'modules/xmpp/JingleSessionPC.js': 'info' as LogLevel,
        'modules/xmpp/strophe.jingle.js': 'info' as LogLevel
    };

    DEFAULT_STATE.config.loggers = {
        ...DEFAULT_LOGGING_CONFIG.loggers,
        ...RN_LOGGERS
    };
}

type LogLevel = 'trace' | 'log' | 'info' | 'warn' | 'error';

export interface ILoggingState {
    config: {
        defaultLogLevel: LogLevel;
        disableLogCollector?: boolean;
        loggers: {
            [key: string]: LogLevel;
        };
    };
    logCollector?: {
        flush: () => void;
        start: () => void;
        stop: () => void;
    };
}

ReducerRegistry.register<ILoggingState>(
    'features/base/logging',
    (state = DEFAULT_STATE, action): ILoggingState => {
        switch (action.type) {
        case SET_LOGGING_CONFIG:
            return _setLoggingConfig(state, action);
        case SET_LOG_COLLECTOR: {
            return _setLogCollector(state, action);
        }

        default:
            return state;
        }
    });

/**
 * Reduces a specific Redux action SET_LOGGING_CONFIG of the feature
 * base/logging.
 *
 * @param {Object} state - The Redux state of the feature base/logging.
 * @param {Action} action - The Redux action SET_LOGGING_CONFIG to reduce.
 * @private
 * @returns {Object} The new state of the feature base/logging after the
 * reduction of the specified action.
 */
function _setLoggingConfig(state: ILoggingState, action: AnyAction) {
    const newConfig = merge({}, DEFAULT_STATE.config, action.config);

    if (equals(state.config, newConfig)) {
        return state;
    }

    return {
        ...state,
        config: newConfig
    };
}

/**
 * Reduces a specific Redux action SET_LOG_COLLECTOR of the feature
 * base/logging.
 *
 * @param {Object} state - The Redux state of the feature base/logging.
 * @param {Action} action - The Redux action SET_LOG_COLLECTOR to reduce.
 * @private
 * @returns {Object} The new state of the feature base/logging after the
 * reduction of the specified action.
 */
function _setLogCollector(state: ILoggingState, action: AnyAction) {
    return set(state, 'logCollector', action.logCollector);
}


################################################################################

## File: .\jitsi-meet\react\features\base\media\actions.ts

import { IStore } from '../../app/types';
import { showModeratedNotification } from '../../av-moderation/actions';
import { shouldShowModeratedNotification } from '../../av-moderation/functions';
import { isModerationNotificationDisplayed } from '../../notifications/functions';

import {
    GUM_PENDING,
    SET_AUDIO_AVAILABLE,
    SET_AUDIO_MUTED,
    SET_AUDIO_UNMUTE_PERMISSIONS,
    SET_CAMERA_FACING_MODE,
    SET_INITIAL_GUM_PROMISE,
    SET_SCREENSHARE_MUTED,
    SET_VIDEO_AVAILABLE,
    SET_VIDEO_MUTED,
    SET_VIDEO_UNMUTE_PERMISSIONS,
    STORE_VIDEO_TRANSFORM,
    TOGGLE_CAMERA_FACING_MODE
} from './actionTypes';
import {
    MEDIA_TYPE,
    MediaType,
    SCREENSHARE_MUTISM_AUTHORITY,
    VIDEO_MUTISM_AUTHORITY
} from './constants';
import { IGUMPendingState } from './types';

/**
 * Action to adjust the availability of the local audio.
 *
 * @param {boolean} available - True if the local audio is to be marked as
 * available or false if the local audio is not available.
 * @returns {{
 *     type: SET_AUDIO_AVAILABLE,
 *     available: boolean
 * }}
 */
export function setAudioAvailable(available: boolean) {
    return {
        type: SET_AUDIO_AVAILABLE,
        available
    };
}

/**
 * Action to set the muted state of the local audio.
 *
 * @param {boolean} muted - True if the local audio is to be muted or false if
 * the local audio is to be unmuted.
 * @param {boolean} ensureTrack - True if we want to ensure that a new track is
 * created if missing.
 * @returns {{
 *     type: SET_AUDIO_MUTED,
 *     ensureTrack: boolean,
 *     muted: boolean
 * }}
 */
export function setAudioMuted(muted: boolean, ensureTrack = false) {
    return {
        type: SET_AUDIO_MUTED,
        ensureTrack,
        muted
    };
}

/**
 * Action to disable/enable the audio mute icon.
 *
 * @param {boolean} blocked - True if the audio mute icon needs to be disabled.
 * @param {boolean|undefined} skipNotification - True if we want to skip showing the notification.
 * @returns {Function}
 */
export function setAudioUnmutePermissions(blocked: boolean, skipNotification = false) {
    return {
        type: SET_AUDIO_UNMUTE_PERMISSIONS,
        blocked,
        skipNotification
    };
}

/**
 * Action to set the facing mode of the local camera.
 *
 * @param {CAMERA_FACING_MODE} cameraFacingMode - The camera facing mode to set.
 * @returns {{
 *     type: SET_CAMERA_FACING_MODE,
 *     cameraFacingMode: CAMERA_FACING_MODE
 * }}
 */
export function setCameraFacingMode(cameraFacingMode: string) {
    return {
        type: SET_CAMERA_FACING_MODE,
        cameraFacingMode
    };
}

/**
 * Sets the initial GUM promise.
 *
 * @param {Promise<Array<Object>> | undefined} promise - The promise.
 * @returns {{
 *     type: SET_INITIAL_GUM_PROMISE,
 *     promise: Promise
 * }}
 */
export function setInitialGUMPromise(promise: Promise<{ errors: any; tracks: Array<any>; }> | null = null) {
    return {
        type: SET_INITIAL_GUM_PROMISE,
        promise
    };
}

/**
 * Action to set the muted state of the local screenshare.
 *
 * @param {boolean} muted - True if the local screenshare is to be enabled or false otherwise.
 * @param {number} authority - The {@link SCREENSHARE_MUTISM_AUTHORITY} which is muting/unmuting the local screenshare.
 * @param {boolean} ensureTrack - True if we want to ensure that a new track is created if missing.
 * @returns {Function}
 */
export function setScreenshareMuted(
        muted: boolean,
        authority: number = SCREENSHARE_MUTISM_AUTHORITY.USER,
        ensureTrack = false) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();

        // check for A/V Moderation when trying to unmute
        if (!muted && shouldShowModeratedNotification(MEDIA_TYPE.SCREENSHARE, state)) {
            if (!isModerationNotificationDisplayed(MEDIA_TYPE.SCREENSHARE, state)) {
                ensureTrack && dispatch(showModeratedNotification(MEDIA_TYPE.SCREENSHARE));
            }

            return;
        }

        const oldValue = state['features/base/media'].screenshare.muted;

        // eslint-disable-next-line no-bitwise
        const newValue = muted ? oldValue | authority : oldValue & ~authority;

        dispatch({
            type: SET_SCREENSHARE_MUTED,
            authority,
            ensureTrack,
            muted: newValue
        });
    };
}

/**
 * Action to adjust the availability of the local video.
 *
 * @param {boolean} available - True if the local video is to be marked as
 * available or false if the local video is not available.
 * @returns {{
 *     type: SET_VIDEO_AVAILABLE,
 *     available: boolean
 * }}
 */
export function setVideoAvailable(available: boolean) {
    return {
        type: SET_VIDEO_AVAILABLE,
        available
    };
}

/**
 * Action to set the muted state of the local video.
 *
 * @param {boolean} muted - True if the local video is to be muted or false if
 * the local video is to be unmuted.
 * @param {number} authority - The {@link VIDEO_MUTISM_AUTHORITY} which is
 * muting/unmuting the local video.
 * @param {boolean} ensureTrack - True if we want to ensure that a new track is
 * created if missing.
 * @returns {Function}
 */
export function setVideoMuted(
        muted: boolean | number,
        authority: number = VIDEO_MUTISM_AUTHORITY.USER,
        ensureTrack = false) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();

        // check for A/V Moderation when trying to unmute
        if (!muted && shouldShowModeratedNotification(MEDIA_TYPE.VIDEO, state)) {
            if (!isModerationNotificationDisplayed(MEDIA_TYPE.VIDEO, state)) {
                ensureTrack && dispatch(showModeratedNotification(MEDIA_TYPE.VIDEO));
            }

            return;
        }

        const oldValue = state['features/base/media'].video.muted;

        // eslint-disable-next-line no-bitwise
        const newValue = muted ? oldValue | authority : oldValue & ~authority;

        dispatch({
            type: SET_VIDEO_MUTED,
            authority,
            ensureTrack,
            muted: newValue
        });
    };
}

/**
 * Action to disable/enable the video mute icon.
 *
 * @param {boolean} blocked - True if the video mute icon needs to be disabled.
 * @param {boolean|undefined} skipNotification - True if we want to skip showing the notification.
 * @returns {Function}
 */
export function setVideoUnmutePermissions(blocked: boolean, skipNotification = false) {
    return {
        type: SET_VIDEO_UNMUTE_PERMISSIONS,
        blocked,
        skipNotification
    };
}

/**
 * Creates an action to store the last video {@link Transform} applied to a
 * stream.
 *
 * @param {string} streamId - The ID of the stream.
 * @param {Object} transform - The {@code Transform} to store.
 * @returns {{
 *     type: STORE_VIDEO_TRANSFORM,
 *     streamId: string,
 *     transform: Object
 * }}
 */
export function storeVideoTransform(streamId: string, transform: Object) {
    return {
        type: STORE_VIDEO_TRANSFORM,
        streamId,
        transform
    };
}

/**
 * Toggles the camera facing mode. Most commonly, for example, mobile devices
 * such as phones have a front/user-facing and a back/environment-facing
 * cameras. In contrast to setCameraFacingMode, allows the toggling to be
 * optimally and/or natively implemented without the overhead of separate reads
 * and writes of the current/effective camera facing mode.
 *
 * @returns {{
 *     type: TOGGLE_CAMERA_FACING_MODE
 * }}
 */
export function toggleCameraFacingMode() {
    return {
        type: TOGGLE_CAMERA_FACING_MODE
    };
}

/**
 * Sets the GUM pending status from unmute and initial track creation operation.
 *
 * @param {Array<MediaType>} mediaTypes - An array with the media types that GUM is called with.
 * @param {IGUMPendingState} status - The GUM status.
 * @returns {{
 *     type: TOGGLE_CAMERA_FACING_MODE,
 *     mediaTypes: Array<MediaType>,
 *     status: IGUMPendingState
 * }}
 */
export function gumPending(mediaTypes: Array<MediaType>, status: IGUMPendingState) {
    return {
        type: GUM_PENDING,
        mediaTypes,
        status
    };
}


################################################################################

## File: .\jitsi-meet\react\features\base\media\actionTypes.ts


/**
 * The type of (redux) action to store the gum pending state for unmute and initial track creation.
 *
 * {
 *     type: GUM_PENDING,
 *     mediaTypes: Array<MediaType>,
 *     status: IGUMPendingState
 * }
 */
export const GUM_PENDING = 'GUM_PENDING';

/**
 * The type of (redux) action to adjust the availability of the local audio.
 *
 * {
 *     type: SET_AUDIO_AVAILABLE,
 *     muted: boolean
 * }
 */
export const SET_AUDIO_AVAILABLE = 'SET_AUDIO_AVAILABLE';

/**
 * The type of (redux) action to set the muted state of the local audio.
 *
 * {
 *     type: SET_AUDIO_MUTED,
 *     muted: boolean
 * }
 */
export const SET_AUDIO_MUTED = 'SET_AUDIO_MUTED';

/**
 * The type of (redux) action to enable/disable the audio mute icon.
 *
 * {
 *     type: SET_AUDIO_UNMUTE_PERMISSIONS,
 *     blocked: boolean
 * }
 */
export const SET_AUDIO_UNMUTE_PERMISSIONS = 'SET_AUDIO_UNMUTE_PERMISSIONS';

/**
 * The type of (redux) action to set the facing mode of the local video camera
 * to a specific value.
 *
 * {
 *     type: SET_CAMERA_FACING_MODE,
 *     cameraFacingMode: CAMERA_FACING_MODE
 * }
 */
export const SET_CAMERA_FACING_MODE = 'SET_CAMERA_FACING_MODE';

/**
 * Sets the initial GUM promise.
 *
 * {
 *     type: SET_INITIAL_GUM_PROMISE,
 *     promise: Promise
 * }}
 */
export const SET_INITIAL_GUM_PROMISE = 'SET_INITIAL_GUM_PROMISE';

/**
 * The type of (redux) action to set the muted state of the local screenshare.
 *
 * {
 *     type: SET_SCREENSHARE_MUTED,
 *     muted: boolean
 * }
 */
export const SET_SCREENSHARE_MUTED = 'SET_SCREENSHARE_MUTED';

/**
 * The type of (redux) action to adjust the availability of the local video.
 *
 * {
 *     type: SET_VIDEO_AVAILABLE,
 *     available: boolean
 * }
 */
export const SET_VIDEO_AVAILABLE = 'SET_VIDEO_AVAILABLE';

/**
 * The type of (redux) action to set the muted state of the local video.
 *
 * {
 *     type: SET_VIDEO_MUTED,
 *     muted: boolean
 * }
 */
export const SET_VIDEO_MUTED = 'SET_VIDEO_MUTED';

/**
 * The type of (redux) action to store the last video {@link Transform} applied
 * to a stream.
 *
 * {
 *     type: STORE_VIDEO_TRANSFORM,
 *     streamId: string,
 *     transform: Transform
 * }
 */
export const STORE_VIDEO_TRANSFORM = 'STORE_VIDEO_TRANSFORM';

/**
 * The type of (redux) action to enable/disable the video mute icon.
 *
 * {
 *     type: SET_VIDEO_UNMUTE_PERMISSIONS,
 *     blocked: boolean
 * }
 */
 export const SET_VIDEO_UNMUTE_PERMISSIONS = 'SET_VIDEO_UNMUTE_PERMISSIONS';

/**
 * The type of (redux) action to toggle the local video camera facing mode. In
 * contrast to SET_CAMERA_FACING_MODE, allows the toggling to be optimally
 * and/or natively implemented without the overhead of separate reads and writes
 * of the current/effective camera facing mode.
 *
 * {
 *     type: TOGGLE_CAMERA_FACING_MODE
 * }
 */
export const TOGGLE_CAMERA_FACING_MODE = 'TOGGLE_CAMERA_FACING_MODE';


################################################################################

## File: .\jitsi-meet\react\features\base\media\constants.ts

/**
 * The set of facing modes for camera.
 *
 * @enum {string}
 */
export const CAMERA_FACING_MODE = {
    ENVIRONMENT: 'environment',
    USER: 'user'
};

export type MediaType = 'audio' | 'video' | 'screenshare';

/**
 * The set of media types.
 *
 * @enum {string}
 */
export const MEDIA_TYPE: {
    AUDIO: MediaType;
    SCREENSHARE: MediaType;
    VIDEO: MediaType;
    } = {
        AUDIO: 'audio',
        SCREENSHARE: 'screenshare',
        VIDEO: 'video'
    };


/* eslint-disable no-bitwise */

/**
 * The types of authorities which may mute/unmute the local screenshare.
 *
 * @enum {number}
 */
export const SCREENSHARE_MUTISM_AUTHORITY = {
    AUDIO_ONLY: 1 << 0,
    USER: 1 << 2
};

/**
 * The languages supported for audio files.
 */
export enum AudioSupportedLanguage {
    en = 'en',
    fr = 'fr',
    frCA = 'frCA'
}

/**
 * The types of authorities which may mute/unmute the local video.
 *
 * @enum {number}
 */
export const VIDEO_MUTISM_AUTHORITY = {
    AUDIO_ONLY: 1 << 0,
    BACKGROUND: 1 << 1,
    USER: 1 << 2,
    CAR_MODE: 1 << 3,
    SCREEN_SHARE: 1 << 4
};

/* eslint-enable no-bitwise */

/**
 * The types of video tracks.
 *
 * @enum {string}
 */
export const VIDEO_TYPE: { [key: string]: VideoType; } = {
    CAMERA: 'camera',
    DESKTOP: 'desktop'
};

export type VideoType = 'camera' | 'desktop';


################################################################################

## File: .\jitsi-meet\react\features\base\media\functions.ts

import { IStateful } from '../app/types';
import { toState } from '../redux/functions';
import { getPropertyValue } from '../settings/functions';

import { AudioSupportedLanguage, VIDEO_MUTISM_AUTHORITY } from './constants';


// XXX The configurations/preferences/settings startWithAudioMuted and startWithVideoMuted were introduced for
// conferences/meetings. So it makes sense for these to not be considered outside of conferences/meetings
// (e.g. WelcomePage). Later on, though, we introduced a "Video <-> Voice" toggle on the WelcomePage which utilizes
// startAudioOnly outside of conferences/meetings so that particular configuration/preference/setting employs slightly
// exclusive logic.
const START_WITH_AUDIO_VIDEO_MUTED_SOURCES = {
    // We have startWithAudioMuted and startWithVideoMuted here:
    config: true,
    settings: true,

    // XXX We've already overwritten base/config with urlParams. However,
    // settings are more important than the server-side config.
    // Consequently, we need to read from urlParams anyway:
    urlParams: true,

    // We don't have startWithAudioMuted and startWithVideoMuted here:
    jwt: false
};

/**
 * Determines whether audio is currently muted.
 *
 * @param {Function|Object} stateful - The redux store, state, or
 * {@code getState} function.
 * @returns {boolean}
 */
export function isAudioMuted(stateful: IStateful) {
    return Boolean(toState(stateful)['features/base/media'].audio.muted);
}

/**
 * Determines whether video is currently muted by the audio-only authority.
 *
 * @param {Function|Object} stateful - The redux store, state, or
 * {@code getState} function.
 * @returns {boolean}
 */
export function isVideoMutedByAudioOnly(stateful: IStateful) {
    return (
        _isVideoMutedByAuthority(stateful, VIDEO_MUTISM_AUTHORITY.AUDIO_ONLY));
}

/**
 * Determines whether video is currently muted by a specific
 * {@code VIDEO_MUTISM_AUTHORITY}.
 *
 * @param {Function|Object} stateful - The redux store, state, or
 * {@code getState} function.
 * @param {number} videoMutismAuthority - The {@code VIDEO_MUTISM_AUTHORITY}
 * which is to be checked whether it has muted video.
 * @returns {boolean} If video is currently muted by the specified
 * {@code videoMutismAuthority}, then {@code true}; otherwise, {@code false}.
 */
function _isVideoMutedByAuthority(
        stateful: IStateful,
        videoMutismAuthority: number) {
    const { muted } = toState(stateful)['features/base/media'].video;

    // eslint-disable-next-line no-bitwise
    return Boolean(muted & videoMutismAuthority);
}

/**
 * Computes the startWithAudioMuted by retrieving its values from config, URL and settings.
 *
 * @param {Object|Function} stateful - The redux state object or {@code getState} function.
 * @returns {boolean} - The computed startWithAudioMuted value that will be used.
 */
export function getStartWithAudioMuted(stateful: IStateful) {
    return Boolean(getPropertyValue(stateful, 'startWithAudioMuted', START_WITH_AUDIO_VIDEO_MUTED_SOURCES))
        || Boolean(getPropertyValue(stateful, 'startSilent', START_WITH_AUDIO_VIDEO_MUTED_SOURCES));
}

/**
 * Computes the startWithVideoMuted by retrieving its values from config, URL and settings.
 *
 * @param {Object|Function} stateful - The redux state object or {@code getState} function.
 * @returns {boolean} - The computed startWithVideoMuted value that will be used.
 */
export function getStartWithVideoMuted(stateful: IStateful) {
    return Boolean(getPropertyValue(stateful, 'startWithVideoMuted', START_WITH_AUDIO_VIDEO_MUTED_SOURCES));
}

/**
 * Determines whether video is currently muted.
 *
 * @param {Function|Object} stateful - The redux store, state, or {@code getState} function.
 * @returns {boolean}
 */
export function isVideoMuted(stateful: IStateful) {
    return Boolean(toState(stateful)['features/base/media'].video.muted);
}

/**
 * Determines whether video is currently muted by the user authority.
 *
 * @param {Function|Object} stateful - The redux store, state, or
 * {@code getState} function.
 * @returns {boolean}
 */
export function isVideoMutedByUser(stateful: IStateful) {
    return _isVideoMutedByAuthority(stateful, VIDEO_MUTISM_AUTHORITY.USER);
}

/**
 * Determines whether a specific videoTrack should be rendered.
 *
 * @param {Track} videoTrack - The video track which is to be rendered.
 * @param {boolean} waitForVideoStarted - True if the specified videoTrack
 * should be rendered only after its associated video has started;
 * otherwise, false.
 * @returns {boolean} True if the specified videoTrack should be rendered;
 * otherwise, false.
 */
export function shouldRenderVideoTrack(
        videoTrack: { muted: boolean; videoStarted: boolean; } | undefined,
        waitForVideoStarted: boolean) {
    return (
        videoTrack
            && !videoTrack.muted
            && (!waitForVideoStarted || videoTrack.videoStarted));
}

/**
 * Computes the localized sound file source.
 *
 * @param {string} file - The default file source.
 * @param {string} language - The language to use for localization.
 * @returns {string}
 */
export const getSoundFileSrc = (file: string, language: string): string => {
    if (!AudioSupportedLanguage[language as keyof typeof AudioSupportedLanguage]
        || language === AudioSupportedLanguage.en) {
        return file;
    }
    const fileTokens = file.split('.');

    return `${fileTokens[0]}_${language}.${fileTokens[1]}`;
};


################################################################################

## File: .\jitsi-meet\react\features\base\media\logger.ts

import { getLogger } from '../logging/functions';

export default getLogger('features/base/media');


################################################################################

## File: .\jitsi-meet\react\features\base\media\middleware.any.ts

import { AnyAction } from 'redux';

import {
    createStartAudioOnlyEvent,
    createStartMutedConfigurationEvent,
    createSyncTrackStateEvent,
    createTrackMutedEvent
} from '../../analytics/AnalyticsEvents';
import { sendAnalytics } from '../../analytics/functions';
import { IStore } from '../../app/types';
import { APP_STATE_CHANGED } from '../../mobile/background/actionTypes';
import { showWarningNotification } from '../../notifications/actions';
import { NOTIFICATION_TIMEOUT_TYPE } from '../../notifications/constants';
import { isForceMuted } from '../../participants-pane/functions';
import { isScreenMediaShared } from '../../screen-share/functions';
import { SET_AUDIO_ONLY } from '../audio-only/actionTypes';
import { setAudioOnly } from '../audio-only/actions';
import { SET_ROOM } from '../conference/actionTypes';
import { isRoomValid } from '../conference/functions';
import { getLocalParticipant } from '../participants/functions';
import MiddlewareRegistry from '../redux/MiddlewareRegistry';
import { getPropertyValue } from '../settings/functions.any';
import { TRACK_ADDED } from '../tracks/actionTypes';
import { destroyLocalTracks } from '../tracks/actions.any';
import {
    getCameraFacingMode,
    isLocalTrackMuted,
    isLocalVideoTrackDesktop,
    setTrackMuted
} from '../tracks/functions.any';
import { ITrack } from '../tracks/types';

import {
    SET_AUDIO_MUTED,
    SET_AUDIO_UNMUTE_PERMISSIONS,
    SET_SCREENSHARE_MUTED,
    SET_VIDEO_MUTED,
    SET_VIDEO_UNMUTE_PERMISSIONS
} from './actionTypes';
import {
    setAudioMuted,
    setCameraFacingMode,
    setScreenshareMuted,
    setVideoMuted
} from './actions';
import {
    MEDIA_TYPE,
    SCREENSHARE_MUTISM_AUTHORITY,
    VIDEO_MUTISM_AUTHORITY
} from './constants';
import { getStartWithAudioMuted, getStartWithVideoMuted } from './functions';
import logger from './logger';
import {
    _AUDIO_INITIAL_MEDIA_STATE,
    _VIDEO_INITIAL_MEDIA_STATE
} from './reducer';

/**
 * Implements the entry point of the middleware of the feature base/media.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {
    switch (action.type) {
    case APP_STATE_CHANGED:
        return _appStateChanged(store, next, action);

    case SET_AUDIO_ONLY:
        return _setAudioOnly(store, next, action);

    case SET_ROOM:
        return _setRoom(store, next, action);

    case TRACK_ADDED: {
        const result = next(action);
        const { track } = action;

        // Don't sync track mute state with the redux store for screenshare
        // since video mute state represents local camera mute state only.
        track.local && track.videoType !== 'desktop'
            && _syncTrackMutedState(store, track);

        return result;
    }

    case SET_AUDIO_MUTED: {
        const state = store.getState();
        const participant = getLocalParticipant(state);

        if (!action.muted && isForceMuted(participant, MEDIA_TYPE.AUDIO, state)) {
            return;
        }
        break;
    }

    case SET_AUDIO_UNMUTE_PERMISSIONS: {
        const { blocked, skipNotification } = action;
        const state = store.getState();
        const tracks = state['features/base/tracks'];
        const isAudioMuted = isLocalTrackMuted(tracks, MEDIA_TYPE.AUDIO);

        if (blocked && isAudioMuted && !skipNotification) {
            store.dispatch(showWarningNotification({
                descriptionKey: 'notify.audioUnmuteBlockedDescription',
                titleKey: 'notify.audioUnmuteBlockedTitle'
            }, NOTIFICATION_TIMEOUT_TYPE.MEDIUM));
        }
        break;
    }

    case SET_SCREENSHARE_MUTED: {
        const state = store.getState();
        const participant = getLocalParticipant(state);

        if (!action.muted && isForceMuted(participant, MEDIA_TYPE.SCREENSHARE, state)) {
            return;
        }
        break;
    }
    case SET_VIDEO_MUTED: {
        const state = store.getState();
        const participant = getLocalParticipant(state);

        if (!action.muted && isForceMuted(participant, MEDIA_TYPE.VIDEO, state)) {
            return;
        }
        break;
    }

    case SET_VIDEO_UNMUTE_PERMISSIONS: {
        const { blocked, skipNotification } = action;
        const state = store.getState();
        const tracks = state['features/base/tracks'];
        const isVideoMuted = isLocalTrackMuted(tracks, MEDIA_TYPE.VIDEO);
        const isMediaShared = isScreenMediaShared(state);

        if (blocked && isVideoMuted && !isMediaShared && !skipNotification) {
            store.dispatch(showWarningNotification({
                descriptionKey: 'notify.videoUnmuteBlockedDescription',
                titleKey: 'notify.videoUnmuteBlockedTitle'
            }, NOTIFICATION_TIMEOUT_TYPE.MEDIUM));
        }
        break;
    }
    }

    return next(action);
});

/**
 * Adjusts the video muted state based on the app state.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @param {Dispatch} next - The redux {@code dispatch} function to dispatch the
 * specified {@code action} to the specified {@code store}.
 * @param {Action} action - The redux action {@code APP_STATE_CHANGED} which is
 * being dispatched in the specified {@code store}.
 * @private
 * @returns {Object} The value returned by {@code next(action)}.
 */
function _appStateChanged({ dispatch, getState }: IStore, next: Function, action: AnyAction) {
    if (navigator.product === 'ReactNative') {
        const { appState } = action;
        const mute = appState !== 'active' && !isLocalVideoTrackDesktop(getState());

        sendAnalytics(createTrackMutedEvent('video', 'background mode', mute));

        dispatch(setVideoMuted(mute, VIDEO_MUTISM_AUTHORITY.BACKGROUND));
    }

    return next(action);
}

/**
 * Adjusts the video muted state based on the audio-only state.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @param {Dispatch} next - The redux {@code dispatch} function to dispatch the
 * specified {@code action} to the specified {@code store}.
 * @param {Action} action - The redux action {@code SET_AUDIO_ONLY} which is
 * being dispatched in the specified {@code store}.
 * @private
 * @returns {Object} The value returned by {@code next(action)}.
 */
function _setAudioOnly({ dispatch }: IStore, next: Function, action: AnyAction) {
    const { audioOnly } = action;

    sendAnalytics(createTrackMutedEvent('video', 'audio-only mode', audioOnly));

    // Make sure we mute both the desktop and video tracks.
    dispatch(setVideoMuted(audioOnly, VIDEO_MUTISM_AUTHORITY.AUDIO_ONLY));
    dispatch(setScreenshareMuted(audioOnly, SCREENSHARE_MUTISM_AUTHORITY.AUDIO_ONLY));

    return next(action);
}

/**
 * Notifies the feature base/media that the action {@link SET_ROOM} is being
 * dispatched within a specific redux {@code store}.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @param {Dispatch} next - The redux {@code dispatch} function to dispatch the
 * specified {@code action} to the specified {@code store}.
 * @param {Action} action - The redux action, {@code SET_ROOM}, which is being
 * dispatched in the specified {@code store}.
 * @private
 * @returns {Object} The new state that is the result of the reduction of the
 * specified {@code action}.
 */
function _setRoom({ dispatch, getState }: IStore, next: Function, action: AnyAction) {
    // Figure out the desires/intents i.e. the state of base/media. There are
    // multiple desires/intents ordered by precedence such as server-side
    // config, config overrides in the user-supplied URL, user's own app
    // settings, etc.

    const state = getState();
    const { room } = action;
    const roomIsValid = isRoomValid(room);

    // when going to welcomepage on web(room is not valid) we want to skip resetting the values of startWithA/V
    if (roomIsValid || navigator.product === 'ReactNative') {
        const audioMuted = roomIsValid ? getStartWithAudioMuted(state) : _AUDIO_INITIAL_MEDIA_STATE.muted;
        const videoMuted = roomIsValid ? getStartWithVideoMuted(state) : _VIDEO_INITIAL_MEDIA_STATE.muted;

        sendAnalytics(createStartMutedConfigurationEvent('local', audioMuted, Boolean(videoMuted)));
        logger.log(`Start muted: ${audioMuted ? 'audio, ' : ''}${videoMuted ? 'video' : ''}`);

        // Unconditionally express the desires/expectations/intents of the app and
        // the user i.e. the state of base/media. Eventually, practice/reality i.e.
        // the state of base/tracks will or will not agree with the desires.
        dispatch(setAudioMuted(audioMuted));
        dispatch(setCameraFacingMode(getCameraFacingMode(state)));
        dispatch(setVideoMuted(videoMuted));
    }

    // startAudioOnly
    //
    // FIXME Technically, the audio-only feature is owned by base/conference,
    // not base/media so the following should be in base/conference.
    // Practically, I presume it was easier to write the source code here
    // because it looks like startWithAudioMuted and startWithVideoMuted.
    //
    // XXX After the introduction of the "Video <-> Voice" toggle on the
    // WelcomePage, startAudioOnly is utilized even outside of
    // conferences/meetings.
    const audioOnly
        = Boolean(
            getPropertyValue(
                state,
                'startAudioOnly',
                /* sources */ {
                    // FIXME Practically, base/config is (really) correct
                    // only if roomIsValid. At the time of this writing,
                    // base/config is overwritten by URL params which leaves
                    // base/config incorrect on the WelcomePage after
                    // leaving a conference which explicitly overwrites
                    // base/config with URL params.
                    config: roomIsValid,

                    // XXX We've already overwritten base/config with
                    // urlParams if roomIsValid. However, settings are more
                    // important than the server-side config. Consequently,
                    // we need to read from urlParams anyway. We also
                    // probably want to read from urlParams when
                    // !roomIsValid.
                    urlParams: true,

                    // The following don't have complications around whether
                    // they are defined or not:
                    jwt: false,

                    // We need to look for 'startAudioOnly' in settings only for react native clients. Otherwise, the
                    // default value from ISettingsState (false) will override the value set in config for web clients.
                    settings: typeof APP === 'undefined'
                }));

    sendAnalytics(createStartAudioOnlyEvent(audioOnly));
    logger.log(`Start audio only set to ${audioOnly.toString()}`);

    dispatch(setAudioOnly(audioOnly));

    if (!roomIsValid) {
        dispatch(destroyLocalTracks());
    }

    return next(action);
}

/**
 * Syncs muted state of local media track with muted state from media state.
 *
 * @param {Store} store - The redux store.
 * @param {Track} track - The local media track.
 * @private
 * @returns {void}
 */
function _syncTrackMutedState({ getState, dispatch }: IStore, track: ITrack) {
    const state = getState()['features/base/media'];
    const mediaType = track.mediaType;
    const muted = Boolean(state[mediaType].muted);

    // XXX If muted state of track when it was added is different from our media
    // muted state, we need to mute track and explicitly modify 'muted' property
    // on track. This is because though TRACK_ADDED action was dispatched it's
    // not yet in redux state and JitsiTrackEvents.TRACK_MUTE_CHANGED may be
    // fired before track gets to state.
    if (track.muted !== muted) {
        sendAnalytics(createSyncTrackStateEvent(mediaType, muted));
        logger.log(`Sync ${mediaType} track muted state to ${muted ? 'muted' : 'unmuted'}`);

        track.muted = muted;
        setTrackMuted(track.jitsiTrack, muted, state, dispatch);
    }
}


################################################################################

## File: .\jitsi-meet\react\features\base\media\middleware.native.ts

import './middleware.any';


################################################################################

## File: .\jitsi-meet\react\features\base\media\middleware.web.ts

import './middleware.any';
import { AnyAction } from 'redux';

import { IStore } from '../../app/types';
import { showNotification } from '../../notifications/actions';
import { NOTIFICATION_TIMEOUT_TYPE } from '../../notifications/constants';
import LocalRecordingManager from '../../recording/components/Recording/LocalRecordingManager.web';
import StopRecordingDialog from '../../recording/components/Recording/web/StopRecordingDialog';
import { openDialog } from '../dialog/actions';
import MiddlewareRegistry from '../redux/MiddlewareRegistry';

import { SET_VIDEO_MUTED } from './actionTypes';

import './subscriber';

/**
 * Implements the entry point of the middleware of the feature base/media.
 *
 * @param {IStore} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register((store: IStore) => (next: Function) => (action: AnyAction) => {
    const { dispatch } = store;

    switch (action.type) {
    case SET_VIDEO_MUTED: {
        if (LocalRecordingManager.isRecordingLocally() && LocalRecordingManager.selfRecording.on) {
            if (action.muted && LocalRecordingManager.selfRecording.withVideo) {
                dispatch(openDialog(StopRecordingDialog, { localRecordingVideoStop: true }));

                return;
            } else if (!action.muted && !LocalRecordingManager.selfRecording.withVideo) {
                dispatch(showNotification({
                    titleKey: 'recording.localRecordingNoVideo',
                    descriptionKey: 'recording.localRecordingVideoWarning',
                    uid: 'recording.localRecordingNoVideo'
                }, NOTIFICATION_TIMEOUT_TYPE.MEDIUM));
            }
        }
    }
    }

    return next(action);
});


################################################################################

## File: .\jitsi-meet\react\features\base\media\reducer.ts

import { AnyAction, combineReducers } from 'redux';

import { CONFERENCE_FAILED, CONFERENCE_LEFT } from '../conference/actionTypes';
import ReducerRegistry from '../redux/ReducerRegistry';
import { TRACK_REMOVED } from '../tracks/actionTypes';

import {
    GUM_PENDING,
    SET_AUDIO_AVAILABLE,
    SET_AUDIO_MUTED,
    SET_AUDIO_UNMUTE_PERMISSIONS,
    SET_CAMERA_FACING_MODE,
    SET_INITIAL_GUM_PROMISE,
    SET_SCREENSHARE_MUTED,
    SET_VIDEO_AVAILABLE,
    SET_VIDEO_MUTED,
    SET_VIDEO_UNMUTE_PERMISSIONS,
    STORE_VIDEO_TRANSFORM,
    TOGGLE_CAMERA_FACING_MODE
} from './actionTypes';
import { CAMERA_FACING_MODE, MEDIA_TYPE, SCREENSHARE_MUTISM_AUTHORITY } from './constants';
import { IGUMPendingState } from './types';

/**
 * Media state object for local audio.
 *
 * @typedef {Object} AudioMediaState
 * @property {boolean} muted=false - Audio muted state.
 */

// FIXME Technically, _AUDIO_INITIAL_MEDIA_STATE is a constant internal to the
// feature base/media and used in multiple files so it should be in
// constants.js. Practically though, AudioMediaState would then be used in
// multiple files as well so I don't know where and how to move it.
/**
 * Initial state for local audio.
 *
 * @type {AudioMediaState}
 */
export const _AUDIO_INITIAL_MEDIA_STATE = {
    available: true,
    gumPending: IGUMPendingState.NONE,
    unmuteBlocked: false,
    muted: false
};

/**
 * Reducer for audio media state.
 *
 * @param {AudioMediaState} state - Media state of local audio.
 * @param {Object} action - Action object.
 * @param {string} action.type - Type of action.
 * @private
 * @returns {AudioMediaState}
 */
function _audio(state: IAudioState = _AUDIO_INITIAL_MEDIA_STATE, action: AnyAction) {
    switch (action.type) {
    case SET_AUDIO_AVAILABLE:
        return {
            ...state,
            available: action.available
        };

    case GUM_PENDING:
        if (action.mediaTypes.includes(MEDIA_TYPE.AUDIO)) {
            return {
                ...state,
                gumPending: action.status
            };
        }

        return state;

    case SET_AUDIO_MUTED:
        return {
            ...state,
            muted: action.muted
        };

    case SET_AUDIO_UNMUTE_PERMISSIONS:
        return {
            ...state,
            unmuteBlocked: action.blocked
        };

    default:
        return state;
    }
}

/**
 * Reducer fot the common properties in media state.
 *
 * @param {ICommonState} state - Common media state.
 * @param {Object} action - Action object.
 * @param {string} action.type - Type of action.
 * @returns {ICommonState}
 */
function _initialGUMPromise(state: initialGUMPromise | null = null, action: AnyAction) {
    if (action.type === SET_INITIAL_GUM_PROMISE) {
        return action.promise ?? null;
    }

    return state;
}

/**
 * Media state object for local screenshare.
 *
 * @typedef {Object} ScreenshareMediaState
 * @property {boolean} available=true - Screenshare available state.
 * @property {boolean} muted=true - Screenshare muted state.
 * @property {boolean} unmuteBlocked=false - Screenshare unmute blocked state.
 */

/**
 * Initial state for video.
 *
 * @type {ScreenshareMediaState}
 */
export const _SCREENSHARE_INITIAL_MEDIA_STATE = {
    available: true,
    muted: SCREENSHARE_MUTISM_AUTHORITY.USER,
    unmuteBlocked: false
};

/**
 * Reducer for screenshare media state.
 *
 * @param {VideoMediaState} state - Media state of local screenshare.
 * @param {Object} action - Action object.
 * @param {string} action.type - Type of action.
 * @private
 * @returns {ScreenshareMediaState}
 */
function _screenshare(state: IScreenshareState = _SCREENSHARE_INITIAL_MEDIA_STATE, action: AnyAction) {
    switch (action.type) {
    case SET_SCREENSHARE_MUTED:
        return {
            ...state,
            muted: action.muted
        };

    case SET_VIDEO_UNMUTE_PERMISSIONS:
        return {
            ...state,
            unmuteBlocked: action.blocked
        };

    default:
        return state;
    }
}

/**
 * Media state object for local video.
 *
 * @typedef {Object} VideoMediaState
 * @property {CAMERA_FACING_MODE} facingMode='user' - Camera facing mode.
 * @property {boolean} muted=false - Video muted state.
 */

// FIXME Technically, _VIDEO_INITIAL_MEDIA_STATE is a constant internal to the
// feature base/media and used in multiple files so it should be in
// constants.js. Practically though, VideoMediaState would then be used in
// multiple files as well so I don't know where and how to move it.
/**
 * Initial state for video.
 *
 * @type {VideoMediaState}
 */
export const _VIDEO_INITIAL_MEDIA_STATE = {
    available: true,
    gumPending: IGUMPendingState.NONE,
    unmuteBlocked: false,
    facingMode: CAMERA_FACING_MODE.USER,
    muted: 0,

    /**
     * The video {@link Transform}s applied to {@code MediaStream}s by
     * {@code id} i.e. "pinch to zoom".
     */
    transforms: {}
};

/**
 * Reducer for camera media state.
 *
 * @param {VideoMediaState} state - Media state of local video.
 * @param {Object} action - Action object.
 * @param {string} action.type - Type of action.
 * @private
 * @returns {VideoMediaState}
 */
function _video(state: IVideoState = _VIDEO_INITIAL_MEDIA_STATE, action: any) {
    switch (action.type) {
    case CONFERENCE_FAILED:
    case CONFERENCE_LEFT:
        return _clearAllVideoTransforms(state);

    case GUM_PENDING:
        if (action.mediaTypes.includes(MEDIA_TYPE.VIDEO)) {
            return {
                ...state,
                gumPending: action.status
            };
        }

        return state;

    case SET_CAMERA_FACING_MODE:
        return {
            ...state,
            facingMode: action.cameraFacingMode
        };

    case SET_VIDEO_AVAILABLE:
        return {
            ...state,
            available: action.available
        };

    case SET_VIDEO_MUTED:
        return {
            ...state,
            muted: action.muted
        };

    case SET_VIDEO_UNMUTE_PERMISSIONS:
        return {
            ...state,
            unmuteBlocked: action.blocked
        };

    case STORE_VIDEO_TRANSFORM:
        return _storeVideoTransform(state, action);

    case TOGGLE_CAMERA_FACING_MODE: {
        let cameraFacingMode = state.facingMode;

        cameraFacingMode
            = cameraFacingMode === CAMERA_FACING_MODE.USER
                ? CAMERA_FACING_MODE.ENVIRONMENT
                : CAMERA_FACING_MODE.USER;

        return {
            ...state,
            facingMode: cameraFacingMode
        };
    }

    case TRACK_REMOVED:
        return _trackRemoved(state, action);

    default:
        return state;
    }
}

interface IAudioState {
    available: boolean;
    gumPending: IGUMPendingState;
    muted: boolean;
    unmuteBlocked: boolean;
}

type initialGUMPromise = Promise<{
        errors?: any;
        tracks: Array<any>;
    }> | null;

interface IScreenshareState {
    available: boolean;
    muted: number;
    unmuteBlocked: boolean;
}

interface IVideoState {
    available: boolean;
    facingMode: string;
    gumPending: IGUMPendingState;
    muted: number;
    transforms: Object;
    unmuteBlocked: boolean;
}

export interface IMediaState {
    audio: IAudioState;
    initialGUMPromise: initialGUMPromise;
    screenshare: IScreenshareState;
    video: IVideoState;
}

/**
 * Listen for various actions related to media devices.
 *
 * @param {Object} state - State of media devices.
 * @param {Object} action - Action object.
 * @param {string} action.type - Type of action.
 * @param {Object} action.media - Information about media devices to be
 * modified.
 * @returns {Object}
 */
ReducerRegistry.register<IMediaState>('features/base/media', combineReducers({
    audio: _audio,
    initialGUMPromise: _initialGUMPromise,
    screenshare: _screenshare,
    video: _video
}));

/**
 * Removes all stored video {@link Transform}s.
 *
 * @param {Object} state - The {@code video} state of the feature base/media.
 * @private
 * @returns {Object}
 */
function _clearAllVideoTransforms(state: IVideoState) {
    return {
        ...state,
        transforms: _VIDEO_INITIAL_MEDIA_STATE.transforms
    };
}

/**
 * Stores the last applied transform to a stream.
 *
 * @param {Object} state - The {@code video} state of the feature base/media.
 * @param {Object} action - The redux action {@link STORE_VIDEO_TRANSFORM}.
 * @private
 * @returns {Object}
 */
function _storeVideoTransform(state: IVideoState, { streamId, transform }: { streamId: string; transform: string; }) {
    return {
        ...state,
        transforms: {
            ...state.transforms,
            [streamId]: transform
        }
    };
}

/**
 * Removes the stored video {@link Transform} associated with a
 * {@code MediaStream} when its respective track is removed.
 *
 * @param {Object} state - The {@code video} state of the feature base/media.
 * @param {Object} action - The redux action {@link TRACK_REMOVED}.
 * @private
 * @returns {Object}
 */
function _trackRemoved(state: IVideoState, { track: { jitsiTrack } }: { track: { jitsiTrack: any; }; }) {
    if (jitsiTrack) {
        const streamId = jitsiTrack.getStreamId();

        if (streamId && streamId in state.transforms) {
            const nextTransforms: any = {
                ...state.transforms
            };

            delete nextTransforms[streamId];

            return {
                ...state,
                transforms: nextTransforms
            };
        }
    }

    return state;
}


################################################################################

## File: .\jitsi-meet\react\features\base\media\subscriber.ts

import { IReduxState, IStore } from '../../app/types';
import StateListenerRegistry from '../redux/StateListenerRegistry';

/**
 * Notifies when the local audio mute state changes.
 */
StateListenerRegistry.register(
    /* selector */ (state: IReduxState) => state['features/base/media'].audio.muted,
    /* listener */ (muted: boolean, store: IStore, previousMuted: boolean) => {
        if (typeof APP !== 'object') {
            return;
        }

        if (muted !== previousMuted) {
            APP.API.notifyAudioMutedStatusChanged(muted);
        }
    }
);


################################################################################

## File: .\jitsi-meet\react\features\base\media\types.ts

export enum IGUMPendingState {
    PENDING_UNMUTE = 1,
    NONE = 2
}


################################################################################

## File: .\jitsi-meet\react\features\base\media\components\AbstractAudio.ts

import { Component } from 'react';

import logger from '../logger';

/**
 * Describes audio element interface used in the base/media feature for audio
 * playback.
 */
export type AudioElement = {
    currentTime: number;
    pause: () => void;
    play: () => void;
    setSinkId?: (id: string) => Promise<any>;
    stop: () => void;
};

/**
 * {@code AbstractAudio} Component's property types.
 */
export interface IProps {

    loop?: boolean;

    /**
     * A callback which will be called with {@code AbstractAudio} instance once
     * the audio element is loaded.
     */
    setRef?: (ref?: any) => void;

    /**
     * The URL of a media resource to use in the element.
     *
     * NOTE on react-native sound files are imported through 'require' and then
     * passed as the 'src' parameter which means their type will be 'any'.
     *
     * @type {Object | string}
     */
    src: any | string;
    stream?: Object;
}

/**
 * The React {@link Component} which is similar to Web's
 * {@code HTMLAudioElement}.
 */
export default class AbstractAudio extends Component<IProps> {
    /**
     * The {@link AudioElement} instance which implements the audio playback
     * functionality.
     */
    _audioElementImpl?: AudioElement | null;

    /**
     * Initializes a new {@code AbstractAudio} instance.
     *
     * @param {IProps} props - The read-only properties with which the new
     * instance is to be initialized.
     */
    constructor(props: IProps) {
        super(props);

        // Bind event handlers so they are only bound once per instance.
        this.setAudioElementImpl = this.setAudioElementImpl.bind(this);
    }

    /**
     * Attempts to pause the playback of the media.
     *
     * @public
     * @returns {void}
     */
    pause() {
        this._audioElementImpl?.pause();
    }

    /**
     * Attempts to begin the playback of the media.
     *
     * @public
     * @returns {void}
     */
    play() {
        this._audioElementImpl?.play();
    }

    /**
     * Set the (reference to the) {@link AudioElement} object which implements
     * the audio playback functionality.
     *
     * @param {AudioElement} element - The {@link AudioElement} instance
     * which implements the audio playback functionality.
     * @protected
     * @returns {void}
     */
    setAudioElementImpl(element?: AudioElement | null | any) {
        this._audioElementImpl = element;

        const { setRef } = this.props;

        typeof setRef === 'function' && setRef(element ? this : null);
    }

    /**
     * Sets the sink ID (output device ID) on the underlying audio element.
     * NOTE: Currently, implemented only on Web.
     *
     * @param {string} sinkId - The sink ID (output device ID).
     * @returns {void}
     */
    setSinkId(sinkId: string) {
        this._audioElementImpl
            && typeof this._audioElementImpl.setSinkId === 'function'
            && this._audioElementImpl.setSinkId(sinkId)
                .catch(error => logger.error('Error setting sink', error));
    }

    /**
     * Attempts to stop the playback of the media.
     *
     * @public
     * @returns {void}
     */
    stop() {
        this._audioElementImpl?.stop();
    }
}


################################################################################

## File: .\jitsi-meet\react\features\base\media\components\index.native.ts

export { default as Audio } from './native/Audio';
export { default as Video } from './native/Video';


################################################################################

## File: .\jitsi-meet\react\features\base\media\components\index.web.ts

export { default as Audio } from './web/Audio';
export { default as Video } from './web/Video';


################################################################################

## File: .\jitsi-meet\react\features\base\media\components\native\Audio.ts

import Sound from 'react-native-sound';

import logger from '../../logger';
import AbstractAudio, { IProps } from '../AbstractAudio';

/**
 * The React Native/mobile {@link Component} which is similar to Web's
 * {@code HTMLAudioElement} and wraps around react-native-webrtc's
 * {@link RTCView}.
 */
export default class Audio extends AbstractAudio {
    /**
     * Reference to 'react-native-sound} {@link Sound} instance.
     */
    _sound: Sound | undefined | null;

    /**
     * A callback passed to the 'react-native-sound''s {@link Sound} instance,
     * called when loading sound is finished.
     *
     * @param {Object} error - The error object passed by
     * the 'react-native-sound' library.
     * @returns {void}
     * @private
     */
    _soundLoadedCallback(error: Error) {
        if (error) {
            logger.error('Failed to load sound', error);
        } else {
            this.setAudioElementImpl(this._sound);
        }
    }

    /**
     * Implements React's {@link Component#componentDidUpdate()}.
     *
     * @inheritdoc
     */
    async componentDidUpdate(prevProps: IProps): Promise<void> {
        // source is different !! call didunmount and call didmount
        if (prevProps.src !== this.props.src) {
            await this.componentWillUnmount();
            await this.componentDidMount();
        }
    }

    /**
     * Will load the sound, after the component did mount.
     *
     * @returns {void}
     */
    async componentDidMount() {
        this._sound
            = this.props.src
                ? new Sound(
                    this.props.src, undefined,
                    this._soundLoadedCallback.bind(this))
                : null;
    }

    /**
     * Will dispose sound resources (if any) when component is about to unmount.
     *
     * @returns {void}
     */
    async componentWillUnmount() {
        if (this._sound) {
            this._sound.release();
            this._sound = null;
            this.setAudioElementImpl(null);
        }
    }

    /**
     * Attempts to begin the playback of the media.
     *
     * @inheritdoc
     * @override
     */
    play() {
        if (this._sound) {
            this._sound.setNumberOfLoops(this.props.loop ? -1 : 0);
            this._sound.play(success => {
                if (!success) {
                    logger.warn(`Failed to play ${this.props.src}`);
                }
            });
        }
    }

    /**
     * Implements React's {@link Component#render()}.
     *
     * @inheritdoc
     * @returns {null}
     */
    render() {
        // TODO react-native-webrtc's RTCView doesn't do anything with the audio
        // MediaStream specified to it so it's easier at the time of this
        // writing to not render anything.
        return null;
    }

    /**
     * Stops the sound if it's currently playing.
     *
     * @returns {void}
     */
    stop() {
        if (this._sound) {
            this._sound.stop();
        }
    }
}


################################################################################

## File: .\jitsi-meet\react\features\base\media\components\native\styles.ts

import { StyleSheet } from 'react-native';

/**
 * The styles of the feature base/media.
 */
export default StyleSheet.create({

    /**
     * Base style of the transformed video view.
     */
    videoTranformedView: {
        flex: 1
    },

    /**
     * A basic style to avoid rendering a transformed view off the component,
     * that can be visible on special occasions, such as during device rotate
     * animation, or PiP mode.
     */
    videoTransformedViewContainer: {
        overflow: 'hidden'
    },

    videoTransformedViewContainerWide: {
        overflow: 'hidden',
        paddingRight: '16%'
    },

    /**
     * Make {@code Video} fill its container.
     */
    video: {
        flex: 1
    }
});


################################################################################

## File: .\jitsi-meet\react\features\base\modal\components\functions.native.ts

import { IStateful } from '../../app/types';
import { toState } from '../../redux/functions';

/**
 *
 * Returns the client width.
 *
 * @param {(Function|Object)} stateful - The (whole) redux state, or redux's
 * {@code getState} function to be used to retrieve the state
 * features/base/config.
 * @returns {number}
 */
export function getClientWidth(stateful: IStateful) {
    const state = toState(stateful)['features/base/responsive-ui'];

    return state.clientWidth;
}

/**
 *
 * Returns the client height.
 *
 * @param {(Function|Object)} stateful - The (whole) redux state, or redux's
 * {@code getState} function to be used to retrieve the state
 * features/base/config.
 * @returns {number}
 */
export function getClientHeight(stateful: IStateful) {
    const state = toState(stateful)['features/base/responsive-ui'];

    return state.clientHeight;
}


################################################################################

## File: .\jitsi-meet\react\features\base\modal\components\styles.ts


export default {

    jitsiScreenContainer: {
        flex: 1
    },

    safeArea: {
        flex: 1
    }
};


################################################################################

## File: .\jitsi-meet\react\features\base\net-info\actions.ts

import { SET_NETWORK_INFO, _STORE_NETWORK_INFO_CLEANUP } from './actionTypes';
import { NetworkInfo } from './types';

/**
 * Up[dates the network info state.
 *
 * @param {NetworkInfo} networkInfo - The new network state to be set.
 * @returns {{
 *     type: SET_NETWORK_INFO,
 *     isOnline: boolean,
 *     networkType: string,
 *     details: Object
 * }}
 */
export function setNetworkInfo({ isOnline, networkType, details }: NetworkInfo) {
    return {
        type: SET_NETWORK_INFO,
        isOnline,
        networkType,
        details
    };
}

/**
 * Stored the cleanup function used to shutdown the {@code NetworkInfoService}.
 *
 * @param {Function} cleanup - The cleanup function to be called on {@code APP_WILL_UNMOUNT}.
 * @returns {{
 *     type: _STORE_NETWORK_INFO_CLEANUP,
 *     cleanup: Function
 * }}
 * @private
 */
export function _storeNetworkInfoCleanup(cleanup?: Function) {
    return {
        type: _STORE_NETWORK_INFO_CLEANUP,
        cleanup
    };
}


################################################################################

## File: .\jitsi-meet\react\features\base\net-info\actionTypes.ts

/**
 * The action dispatched when the {@link NetworkInfo} structure is being updated.
 *
 * @type {string}
 */
export const SET_NETWORK_INFO = 'SET_NETWORK_INFO';

/**
 * The action dispatched by 'base/net-info' middleware in order to store the cleanup function for later use.
 * @type {string}
 * @private
 */
export const _STORE_NETWORK_INFO_CLEANUP = 'STORE_NETWORK_INFO_CLEANUP';


################################################################################

## File: .\jitsi-meet\react\features\base\net-info\constants.ts

/**
 * The name for Redux store key used by the 'base/net-info' feature.
 *
 * @type {string}
 */
export const STORE_NAME = 'features/base/net-info';


################################################################################

## File: .\jitsi-meet\react\features\base\net-info\events.ts

export const ONLINE_STATE_CHANGED_EVENT = 'network-info-online-status-change';


################################################################################

## File: .\jitsi-meet\react\features\base\net-info\logger.ts

import { getLogger } from '../logging/functions';

export default getLogger('features/base/net-info');


################################################################################

## File: .\jitsi-meet\react\features\base\net-info\middleware.ts

import { APP_WILL_MOUNT, APP_WILL_UNMOUNT } from '../app/actionTypes';
import MiddlewareRegistry from '../redux/MiddlewareRegistry';

import NetworkInfoService from './NetworkInfoService';
import { _storeNetworkInfoCleanup, setNetworkInfo } from './actions';
import { STORE_NAME } from './constants';
import { ONLINE_STATE_CHANGED_EVENT } from './events';
import logger from './logger';
import type { NetworkInfo } from './types';

/**
 * Middleware for 'base/net-info' feature.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(({ dispatch, getState }) => next => action => {
    const result = next(action);

    switch (action.type) {
    case APP_WILL_MOUNT:
        if (NetworkInfoService.isSupported()) {
            const networkInfoService = new NetworkInfoService();
            const stop = () => {
                networkInfoService.stop();

                // @ts-ignore
                networkInfoService.removeAllListeners();
            };

            // @ts-ignore
            networkInfoService.addListener(
                ONLINE_STATE_CHANGED_EVENT,
                ({ isOnline, networkType, details }: NetworkInfo) => {
                    logger.info('Network changed', JSON.stringify({
                        isOnline,
                        details,
                        networkType
                    }));
                    dispatch(setNetworkInfo({
                        isOnline,
                        networkType,
                        details
                    }));
                });

            dispatch(_storeNetworkInfoCleanup(stop));

            networkInfoService.start();
        }
        break;
    case APP_WILL_UNMOUNT: {
        const { _cleanup } = getState()[STORE_NAME];

        if (_cleanup) {
            _cleanup();
            dispatch(_storeNetworkInfoCleanup(undefined));
        }
    }
        break;
    }

    return result;
});


################################################################################

## File: .\jitsi-meet\react\features\base\net-info\NetworkInfoService.native.ts

import NetInfo from '@react-native-community/netinfo';
import type { NetInfoState, NetInfoSubscription } from '@react-native-community/netinfo';
// eslint-disable-next-line lines-around-comment
// @ts-expect-error
import EventEmitter from 'events';

import { ONLINE_STATE_CHANGED_EVENT } from './events';
import type { NetworkInfo } from './types';

/**
 * The network info service implementation for iOS and Android. 'react-native-netinfo' seems to support windows as well,
 * but that has not been tested and is nto used by jitsi-meet.
 */
export default class NetworkInfoService extends EventEmitter {
    /**
     * Stores the native subscription for future cleanup.
     */
    _subscription?: NetInfoSubscription;

    /**
     * Converts library's structure to {@link NetworkInfo} used by jitsi-meet.
     *
     * @param {NetInfoState} netInfoState - The new state given by the native library.
     * @private
     * @returns {NetworkInfo}
     */
    static _convertNetInfoState(netInfoState: NetInfoState): NetworkInfo {
        return {
            isOnline: Boolean(netInfoState.isInternetReachable),

            details: netInfoState.details,
            networkType: netInfoState.type
        };
    }

    /**
     * Checks for support.
     *
     * @returns {boolean}
     */
    static isSupported() {
        return Boolean(NetInfo);
    }

    /**
     * Starts the service.
     *
     * @returns {void}
     */
    start() {
        this._subscription = NetInfo.addEventListener(netInfoState => {
            super.emit(ONLINE_STATE_CHANGED_EVENT, NetworkInfoService._convertNetInfoState(netInfoState));
        });
    }

    /**
     * Stops the service.
     *
     * @returns {void}
     */
    stop() {
        if (this._subscription) {
            this._subscription();
            this._subscription = undefined;
        }
    }
}


################################################################################

## File: .\jitsi-meet\react\features\base\net-info\NetworkInfoService.web.ts

import EventEmitter from 'events';

import { ONLINE_STATE_CHANGED_EVENT } from './events';

/**
 * The network info service implementation for web (Chrome, Firefox and Safari).
 */
export default class NetworkInfoService extends EventEmitter {
    _onlineStateListener: any;
    _offlineStateListener: any;

    /**
     * Creates new instance...
     */
    constructor() {
        super();
        this._onlineStateListener = this._handleOnlineStatusChange.bind(this, /* online */ true);
        this._offlineStateListener = this._handleOnlineStatusChange.bind(this, /* offline */ false);
    }

    /**
     * Callback function to track the online state.
     *
     * @param {boolean} isOnline - Is the browser online or not.
     * @private
     * @returns {void}
     */
    _handleOnlineStatusChange(isOnline: boolean) {
        this.emit(ONLINE_STATE_CHANGED_EVENT, { isOnline });
    }

    /**
     * Checks for support.
     *
     * @returns {boolean}
     */
    static isSupported() {
        return Boolean(window.addEventListener) && typeof navigator.onLine !== 'undefined';
    }

    /**
     * Starts the service.
     *
     * @returns {void}
     */
    start() {
        window.addEventListener('online', this._onlineStateListener);
        window.addEventListener('offline', this._offlineStateListener);
    }

    /**
     * Stops the service.
     *
     * @returns {void}
     */
    stop() {
        window.removeEventListener('online', this._onlineStateListener);
        window.removeEventListener('offline', this._offlineStateListener);
    }
}


################################################################################

## File: .\jitsi-meet\react\features\base\net-info\reducer.ts

import { NetInfoCellularGeneration, NetInfoStateType } from '@react-native-community/netinfo';

import ReducerRegistry from '../redux/ReducerRegistry';
import { assign } from '../redux/functions';

import { SET_NETWORK_INFO, _STORE_NETWORK_INFO_CLEANUP } from './actionTypes';
import { STORE_NAME } from './constants';

const DEFAULT_STATE = {
    isOnline: true
};

export interface INetInfoState {
    _cleanup?: Function;
    cellularGeneration?: NetInfoCellularGeneration;
    details?: Object;
    isOnline?: boolean;
    networkType?: NetInfoStateType;
}

/**
 * The base/net-info feature's reducer.
 */
ReducerRegistry.register<INetInfoState>(STORE_NAME, (state = DEFAULT_STATE, action): INetInfoState => {
    switch (action.type) {
    case SET_NETWORK_INFO:
        return assign(state, {
            isOnline: action.isOnline,
            networkType: action.networkType,
            cellularGeneration: action.cellularGeneration,
            details: action.details
        });
    case _STORE_NETWORK_INFO_CLEANUP:
        return assign(state, {
            _cleanup: action.cleanup
        });
    default:
        return state;
    }
});


################################################################################

## File: .\jitsi-meet\react\features\base\net-info\selectors.ts

import { IReduxState } from '../../app/types';

import { STORE_NAME } from './constants';

/**
 * A selector for the internet online status.
 *
 * @param {IReduxState} state - The redux state.
 * @returns {boolean}
 */
export function isOnline(state: IReduxState) {
    return state[STORE_NAME].isOnline;
}


################################################################################

## File: .\jitsi-meet\react\features\base\net-info\types.ts

import { NetInfoCellularGeneration, NetInfoStateType } from '@react-native-community/netinfo';

/**
 * Describes the structure which is used by jitsi-meet to store information about the current network type and
 * conditions.
 */
export type NetworkInfo = {

    /**
     * Any extra info provided by the OS. Should be JSON and is OS specific. Reported only by iOS and Android and
     * the format is whatever comes out of the 'react-native-netinfo' library which is network type dependent.
     */
    details?: {

        /**
         * If {@link networkType} is {@link NetInfoStateType.cellular} then it may provide the info about the type of
         * cellular network.
         */
        cellularGeneration?: NetInfoCellularGeneration | null;

        /**
         * Indicates whether or not the connection is expensive.
         */
        isConnectionExpensive?: boolean;
    } | null;

    /**
     * Tells whether or not the internet is reachable.
     */
    isOnline: boolean;

    /**
     * The network type. Currently reported only on Android/iOS. Can be one of the constants defined by
     * the 'react-native-netinfo' library.
     */
    networkType?: NetInfoStateType;
};


################################################################################

## File: .\jitsi-meet\react\features\base\participants\actions.ts

import { IStore } from '../../app/types';
import { showNotification } from '../../notifications/actions';
import { NOTIFICATION_TIMEOUT_TYPE } from '../../notifications/constants';
import { IJitsiConference } from '../conference/reducer';
import { set } from '../redux/functions';

import {
    DOMINANT_SPEAKER_CHANGED,
    GRANT_MODERATOR,
    KICK_PARTICIPANT,
    LOCAL_PARTICIPANT_AUDIO_LEVEL_CHANGED,
    LOCAL_PARTICIPANT_RAISE_HAND,
    MUTE_REMOTE_PARTICIPANT,
    OVERWRITE_PARTICIPANTS_NAMES,
    OVERWRITE_PARTICIPANT_NAME,
    PARTICIPANT_ID_CHANGED,
    PARTICIPANT_JOINED,
    PARTICIPANT_KICKED,
    PARTICIPANT_LEFT,
    PARTICIPANT_SOURCES_UPDATED,
    PARTICIPANT_UPDATED,
    PIN_PARTICIPANT,
    RAISE_HAND_CLEAR,
    RAISE_HAND_UPDATED,
    SCREENSHARE_PARTICIPANT_NAME_CHANGED,
    SET_LOADABLE_AVATAR_URL,
    SET_LOCAL_PARTICIPANT_RECORDING_STATUS
} from './actionTypes';
import {
    DISCO_REMOTE_CONTROL_FEATURE
} from './constants';
import {
    getLocalParticipant,
    getNormalizedDisplayName,
    getParticipantById,
    getParticipantDisplayName,
    getVirtualScreenshareParticipantOwnerId
} from './functions';
import logger from './logger';
import { FakeParticipant, IJitsiParticipant, IParticipant } from './types';

/**
 * Create an action for when dominant speaker changes.
 *
 * @param {string} dominantSpeaker - Participant ID of the dominant speaker.
 * @param {Array<string>} previousSpeakers - Participant IDs of the previous speakers.
 * @param {boolean} silence - Whether the dominant speaker is silent or not.
 * @param {JitsiConference} conference - The {@code JitsiConference} associated
 * with the participant identified by the specified {@code id}. Only the local
 * participant is allowed to not specify an associated {@code JitsiConference}
 * instance.
 * @returns {{
 *     type: DOMINANT_SPEAKER_CHANGED,
 *     participant: {
 *         conference: JitsiConference,
 *         id: string,
 *         previousSpeakers: Array<string>,
 *         silence: boolean
 *     }
 * }}
 */
export function dominantSpeakerChanged(
        dominantSpeaker: string, previousSpeakers: string[], silence: boolean, conference: IJitsiConference) {
    return {
        type: DOMINANT_SPEAKER_CHANGED,
        participant: {
            conference,
            id: dominantSpeaker,
            previousSpeakers,
            silence
        }
    };
}

/**
 * Create an action for granting moderator to a participant.
 *
 * @param {string} id - Participant's ID.
 * @returns {{
 *     type: GRANT_MODERATOR,
 *     id: string
 * }}
 */
export function grantModerator(id: string) {
    return {
        type: GRANT_MODERATOR,
        id
    };
}

/**
 * Create an action for removing a participant from the conference.
 *
 * @param {string} id - Participant's ID.
 * @returns {{
 *     type: KICK_PARTICIPANT,
 *     id: string
 * }}
 */
export function kickParticipant(id: string) {
    return {
        type: KICK_PARTICIPANT,
        id
    };
}

/**
 * Action to signal that the ID of local participant has changed. It happens
 * when the local participant joins a new conference or leaves an existing
 * conference.
 *
 * @param {string} id - New ID for local participant.
 * @returns {Function}
 */
export function localParticipantIdChanged(id: string) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const participant = getLocalParticipant(getState);

        if (participant) {
            return dispatch({
                type: PARTICIPANT_ID_CHANGED,

                // XXX A participant is identified by an id-conference pair.
                // Only the local participant is with an undefined conference.
                conference: undefined,
                newValue: id,
                oldValue: participant.id
            });
        }
    };
}

/**
 * Action to signal that a local participant has joined.
 *
 * @param {IParticipant} participant={} - Information about participant.
 * @returns {{
 *     type: PARTICIPANT_JOINED,
 *     participant: IParticipant
 * }}
 */
export function localParticipantJoined(participant: IParticipant = { id: '' }) {
    return participantJoined(set(participant, 'local', true));
}

/**
 * Action to remove a local participant.
 *
 * @returns {Function}
 */
export function localParticipantLeft() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const participant = getLocalParticipant(getState);

        if (participant) {
            return (
                dispatch(
                    participantLeft(
                        participant.id,

                        // XXX Only the local participant is allowed to leave
                        // without stating the JitsiConference instance because
                        // the local participant is uniquely identified by the
                        // very fact that there is only one local participant
                        // (and the fact that the local participant "joins" at
                        // the beginning of the app and "leaves" at the end of
                        // the app).
                        undefined)));
        }
    };
}

/**
 * Action to signal the role of the local participant has changed. It can happen
 * when the participant has joined a conference, even before a non-default local
 * id has been set, or after a moderator leaves.
 *
 * @param {string} role - The new role of the local participant.
 * @returns {Function}
 */
export function localParticipantRoleChanged(role: string) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const participant = getLocalParticipant(getState);

        if (participant) {
            return dispatch(participantRoleChanged(participant.id, role));
        }
    };
}

/**
 * Create an action for muting another participant in the conference.
 *
 * @param {string} id - Participant's ID.
 * @param {MEDIA_TYPE} mediaType - The media to mute.
 * @returns {{
 *     type: MUTE_REMOTE_PARTICIPANT,
 *     id: string,
 *     mediaType: MEDIA_TYPE
 * }}
 */
export function muteRemoteParticipant(id: string, mediaType: string) {
    return {
        type: MUTE_REMOTE_PARTICIPANT,
        id,
        mediaType
    };
}

/**
 * Action to signal that a participant has joined.
 *
 * @param {IParticipant} participant - Information about participant.
 * @returns {{
 *     type: PARTICIPANT_JOINED,
 *     participant: IParticipant
 * }}
 */
export function participantJoined(participant: IParticipant) {
    // Only the local participant is not identified with an id-conference pair.
    if (participant.local) {
        return {
            type: PARTICIPANT_JOINED,
            participant
        };
    }

    // In other words, a remote participant is identified with an id-conference
    // pair.
    const { conference } = participant;

    if (!conference) {
        throw Error(
            'A remote participant must be associated with a JitsiConference!');
    }

    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        // A remote participant is only expected to join in a joined or joining
        // conference. The following check is really necessary because a
        // JitsiConference may have moved into leaving but may still manage to
        // sneak a PARTICIPANT_JOINED in if its leave is delayed for any purpose
        // (which is not outragous given that leaving involves network
        // requests.)
        const stateFeaturesBaseConference
            = getState()['features/base/conference'];

        if (conference === stateFeaturesBaseConference.conference
                || conference === stateFeaturesBaseConference.joining) {
            return dispatch({
                type: PARTICIPANT_JOINED,
                participant
            });
        }
    };
}

/**
 * Updates the sources of a remote participant.
 *
 * @param {IJitsiParticipant} jitsiParticipant - The IJitsiParticipant instance.
 * @returns {{
 *      type: PARTICIPANT_SOURCES_UPDATED,
 *      participant: IParticipant
 * }}
 */
export function participantSourcesUpdated(jitsiParticipant: IJitsiParticipant) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const id = jitsiParticipant.getId();
        const participant = getParticipantById(getState(), id);

        if (participant?.local) {
            return;
        }
        const sources = jitsiParticipant.getSources();

        if (!sources?.size) {
            return;
        }

        return dispatch({
            type: PARTICIPANT_SOURCES_UPDATED,
            participant: {
                id,
                sources
            }
        });
    };
}

/**
 * Updates the features of a remote participant.
 *
 * @param {JitsiParticipant} jitsiParticipant - The ID of the participant.
 * @returns {{
*     type: PARTICIPANT_UPDATED,
*     participant: IParticipant
* }}
*/
export function updateRemoteParticipantFeatures(jitsiParticipant: any) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        if (!jitsiParticipant) {
            return;
        }

        const id = jitsiParticipant.getId();

        jitsiParticipant.getFeatures()
            .then((features: Map<string, string>) => {
                const supportsRemoteControl = features.has(DISCO_REMOTE_CONTROL_FEATURE);
                const participant = getParticipantById(getState(), id);

                if (!participant || participant.local) {
                    return;
                }

                if (participant?.supportsRemoteControl !== supportsRemoteControl) {
                    return dispatch({
                        type: PARTICIPANT_UPDATED,
                        participant: {
                            id,
                            supportsRemoteControl
                        }
                    });
                }
            })
            .catch((error: any) => {
                logger.error(`Failed to get participant features for ${id}!`, error);
            });
    };
}

/**
 * Action to signal that a participant has left.
 *
 * @param {string} id - Participant's ID.
 * @param {JitsiConference} conference - The {@code JitsiConference} associated
 * with the participant identified by the specified {@code id}. Only the local
 * participant is allowed to not specify an associated {@code JitsiConference}
 * instance.
 * @param {Object} participantLeftProps - Other participant properties.
 * @typedef {Object} participantLeftProps
 * @param {FakeParticipant|undefined} participantLeftProps.fakeParticipant - The type of fake participant.
 * @param {boolean} participantLeftProps.isReplaced - Whether the participant is to be replaced in the meeting.
 *
 * @returns {{
 *     type: PARTICIPANT_LEFT,
 *     participant: {
 *         conference: JitsiConference,
 *         id: string
 *     }
 * }}
 */
export function participantLeft(id: string, conference?: IJitsiConference, participantLeftProps: {
    fakeParticipant?: string; isReplaced?: boolean;
} = {}) {
    return {
        type: PARTICIPANT_LEFT,
        participant: {
            conference,
            fakeParticipant: participantLeftProps.fakeParticipant,
            id,
            isReplaced: participantLeftProps.isReplaced
        }
    };
}

/**
 * Action to signal that a participant's presence status has changed.
 *
 * @param {string} id - Participant's ID.
 * @param {string} presence - Participant's new presence status.
 * @returns {{
 *     type: PARTICIPANT_UPDATED,
 *     participant: {
 *         id: string,
 *         presence: string
 *     }
 * }}
 */
export function participantPresenceChanged(id: string, presence: string) {
    return participantUpdated({
        id,
        presence
    });
}

/**
 * Action to signal that a participant's role has changed.
 *
 * @param {string} id - Participant's ID.
 * @param {PARTICIPANT_ROLE} role - Participant's new role.
 * @returns {{
 *     type: PARTICIPANT_UPDATED,
 *     participant: {
 *         id: string,
 *         role: PARTICIPANT_ROLE
 *     }
 * }}
 */
export function participantRoleChanged(id: string, role: string) {
    return participantUpdated({
        id,
        role
    });
}

/**
 * Action to signal that a participant's display name has changed.
 *
 * @param {string} id - Screenshare participant's ID.
 * @param {name} name - The new display name of the screenshare participant's owner.
 * @returns {{
 *     type: SCREENSHARE_PARTICIPANT_NAME_CHANGED,
 *     id: string,
 *     name: string
 * }}
 */
export function screenshareParticipantDisplayNameChanged(id: string, name: string) {
    return {
        type: SCREENSHARE_PARTICIPANT_NAME_CHANGED,
        id,
        name
    };
}

/**
 * Action to signal that some of participant properties has been changed.
 *
 * @param {IParticipant} participant={} - Information about participant. To
 * identify the participant the object should contain either property id with
 * value the id of the participant or property local with value true (if the
 * local participant hasn't joined the conference yet).
 * @returns {{
 *     type: PARTICIPANT_UPDATED,
 *     participant: IParticipant
 * }}
 */
export function participantUpdated(participant: IParticipant = { id: '' }) {
    const participantToUpdate = {
        ...participant
    };

    if (participant.name) {
        participantToUpdate.name = getNormalizedDisplayName(participant.name);
    }

    return {
        type: PARTICIPANT_UPDATED,
        participant: participantToUpdate
    };
}

/**
 * Action to signal that a participant has muted us.
 *
 * @param {JitsiParticipant} participant - Information about participant.
 * @param {JitsiLocalTrack} track - Information about the track that has been muted.
 * @returns {Promise}
 */
export function participantMutedUs(participant: any, track: any) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        if (!participant) {
            return;
        }

        const isAudio = track.isAudioTrack();

        dispatch(showNotification({
            titleKey: isAudio ? 'notify.mutedRemotelyTitle' : 'notify.videoMutedRemotelyTitle',
            titleArguments: {
                participantDisplayName: getParticipantDisplayName(getState, participant.getId())
            }
        }, NOTIFICATION_TIMEOUT_TYPE.MEDIUM));
    };
}

/**
 * Action to create a virtual screenshare participant.
 *
 * @param {(string)} sourceName - The source name of the JitsiTrack instance.
 * @param {(boolean)} local - Whether it's a local or remote participant.
 * @param {JitsiConference} conference - The conference instance for which the participant is to be created.
 * @returns {Function}
 */
export function createVirtualScreenshareParticipant(sourceName: string, local: boolean, conference?: IJitsiConference) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const ownerId = getVirtualScreenshareParticipantOwnerId(sourceName);
        const ownerName = getParticipantDisplayName(state, ownerId);

        dispatch(participantJoined({
            conference,
            fakeParticipant: local ? FakeParticipant.LocalScreenShare : FakeParticipant.RemoteScreenShare,
            id: sourceName,
            name: ownerName
        }));
    };
}

/**
 * Action to signal that a participant had been kicked.
 *
 * @param {JitsiParticipant} kicker - Information about participant performing the kick.
 * @param {JitsiParticipant} kicked - Information about participant that was kicked.
 * @returns {Promise}
 */
export function participantKicked(kicker: any, kicked: any) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const localParticipant = getLocalParticipant(state);
        const kickedId = kicked.getId();
        const kickerId = kicker?.getId();

        dispatch({
            type: PARTICIPANT_KICKED,
            kicked: kickedId,
            kicker: kickerId
        });

        if (kicked.isReplaced?.() || !kickerId || kickerId === localParticipant?.id) {
            return;
        }

        dispatch(showNotification({
            titleArguments: {
                kicked:
                    getParticipantDisplayName(state, kickedId),
                kicker:
                    getParticipantDisplayName(state, kickerId)
            },
            titleKey: 'notify.kickParticipant'
        }, NOTIFICATION_TIMEOUT_TYPE.MEDIUM));
    };
}

/**
 * Create an action which pins a conference participant.
 *
 * @param {string|null} id - The ID of the conference participant to pin or null
 * if none of the conference's participants are to be pinned.
 * @returns {{
 *     type: PIN_PARTICIPANT,
 *     participant: {
 *         id: string
 *     }
 * }}
 */
export function pinParticipant(id?: string | null) {
    return {
        type: PIN_PARTICIPANT,
        participant: {
            id
        }
    };
}

/**
 * Creates an action which notifies the app that the loadable URL of the avatar of a participant got updated.
 *
 * @param {string} participantId - The ID of the participant.
 * @param {string} url - The new URL.
 * @param {boolean} useCORS - Indicates whether we need to use CORS for this URL.
 * @returns {{
 *     type: SET_LOADABLE_AVATAR_URL,
 *     participant: {
 *         id: string,
 *         loadableAvatarUrl: string,
 *         loadableAvatarUrlUseCORS: boolean
 *     }
 * }}
*/
export function setLoadableAvatarUrl(participantId: string, url: string, useCORS: boolean) {
    return {
        type: SET_LOADABLE_AVATAR_URL,
        participant: {
            id: participantId,
            loadableAvatarUrl: url,
            loadableAvatarUrlUseCORS: useCORS
        }
    };
}

/**
 * Raise hand for the local participant.
 *
 * @param {boolean} enabled - Raise or lower hand.
 * @returns {{
 *     type: LOCAL_PARTICIPANT_RAISE_HAND,
 *     raisedHandTimestamp: number
 * }}
 */
export function raiseHand(enabled: boolean) {
    return {
        type: LOCAL_PARTICIPANT_RAISE_HAND,
        raisedHandTimestamp: enabled ? Date.now() : 0
    };
}

/**
 * Clear the raise hand queue.
 *
 * @returns {{
*     type: RAISE_HAND_CLEAR
* }}
*/
export function raiseHandClear() {
    return {
        type: RAISE_HAND_CLEAR
    };
}

/**
 * Update raise hand queue of participants.
 *
 * @param {Object} participant - Participant that updated raised hand.
 * @returns {{
 *      type: RAISE_HAND_UPDATED,
 *      participant: Object
 * }}
 */
export function raiseHandUpdateQueue(participant: IParticipant) {
    return {
        type: RAISE_HAND_UPDATED,
        participant
    };
}

/**
 * Notifies if the local participant audio level has changed.
 *
 * @param {number} level - The audio level.
 * @returns {{
 *      type: LOCAL_PARTICIPANT_AUDIO_LEVEL_CHANGED,
 *      level: number
 * }}
 */
export function localParticipantAudioLevelChanged(level: number) {
    return {
        type: LOCAL_PARTICIPANT_AUDIO_LEVEL_CHANGED,
        level
    };
}

/**
 * Overwrites the name of the participant with the given id.
 *
 * @param {string} id - Participant id;.
 * @param {string} name - New participant name.
 * @returns {Object}
 */
export function overwriteParticipantName(id: string, name: string) {
    return {
        type: OVERWRITE_PARTICIPANT_NAME,
        id,
        name
    };
}

/**
 * Overwrites the names of the given participants.
 *
 * @param {Array<Object>} participantList - The list of participants to overwrite.
 * @returns {Object}
 */
export function overwriteParticipantsNames(participantList: IParticipant[]) {
    return {
        type: OVERWRITE_PARTICIPANTS_NAMES,
        participantList
    };
}

/**
 * Local video recording status for the local participant.
 *
 * @param {boolean} recording - If local recording is ongoing.
 * @param {boolean} onlySelf - If recording only local streams.
 * @returns {{
 *     type: SET_LOCAL_PARTICIPANT_RECORDING_STATUS,
 *     recording: boolean
 * }}
 */
export function updateLocalRecordingStatus(recording: boolean, onlySelf?: boolean) {
    return {
        type: SET_LOCAL_PARTICIPANT_RECORDING_STATUS,
        recording,
        onlySelf
    };
}


################################################################################

## File: .\jitsi-meet\react\features\base\participants\actionTypes.ts

/**
 * Create an action to mark the participant as notified to speak next.
 *
 * {
 *     type: NOTIFIED_TO_SPEAK
 * }
 */
export const NOTIFIED_TO_SPEAK = 'NOTIFIED_TO_SPEAK';

/**
 * Create an action for when dominant speaker changes.
 *
 * {
 *     type: DOMINANT_SPEAKER_CHANGED,
 *     participant: {
 *         conference: JitsiConference,
 *         id: string,
 *         previousSpeakers: Array<string>,
 *         silence: boolean
 *     }
 * }
 */
export const DOMINANT_SPEAKER_CHANGED = 'DOMINANT_SPEAKER_CHANGED';

/**
 * Create an action for granting moderator to a participant.
 *
 * {
 *     type: GRANT_MODERATOR,
 *     id: string
 * }
 */
export const GRANT_MODERATOR = 'GRANT_MODERATOR';

/**
 * Create an action for removing a participant from the conference.
 *
 * {
 *     type: KICK_PARTICIPANT,
 *     id: string
 * }
 */
export const KICK_PARTICIPANT = 'KICK_PARTICIPANT';

/**
 * Create an action for muting a remote participant.
 *
 * {
 *     type: MUTE_REMOTE_PARTICIPANT,
 *     id: string
 * }
 */
export const MUTE_REMOTE_PARTICIPANT = 'MUTE_REMOTE_PARTICIPANT';

/**
 * Action to signal that ID of participant has changed. This happens when
 * local participant joins a new conference or quits one.
 *
 * {
 *     type: PARTICIPANT_ID_CHANGED,
 *     conference: JitsiConference
 *     newValue: string,
 *     oldValue: string
 * }
 */
export const PARTICIPANT_ID_CHANGED = 'PARTICIPANT_ID_CHANGED';

/**
 * Action to signal that participant role has changed. e.
 *
 * {
 *     type: PARTICIPANT_ROLE_CHANGED,
 *     participant: {
 *         id: string
 *     }
 *     role: string
 * }
 */
export const PARTICIPANT_ROLE_CHANGED = 'PARTICIPANT_ROLE_CHANGED';

/**
 * Action to signal that a participant has joined.
 *
 * {
 *     type: PARTICIPANT_JOINED,
 *     participant: Participant
 * }
 */
export const PARTICIPANT_JOINED = 'PARTICIPANT_JOINED';

/**
 * Action to signal that a participant has been removed from a conference by
 * another participant.
 *
 * {
 *     type: PARTICIPANT_KICKED,
 *     kicked: Object,
 *     kicker: Object
 * }
 */
export const PARTICIPANT_KICKED = 'PARTICIPANT_KICKED';

/**
 * Action to handle case when participant lefts.
 *
 * {
 *     type: PARTICIPANT_LEFT,
 *     participant: {
 *         id: string
 *     }
 * }
 */
export const PARTICIPANT_LEFT = 'PARTICIPANT_LEFT';

/**
 * Action to handle case when the sources attached to a participant are updated.
 *
 * {
 *      type: PARTICIPANT_SOURCES_UPDATED,
 *      participant: {
 *          id: string
 *      }
 * }
 */
export const PARTICIPANT_SOURCES_UPDATED = 'PARTICIPANT_SOURCES_UPDATED';

/**
 * Action to handle case when info about participant changes.
 *
 * {
 *     type: PARTICIPANT_UPDATED,
 *     participant: Participant
 * }
 */
export const PARTICIPANT_UPDATED = 'PARTICIPANT_UPDATED';

/**
 * The type of the Redux action which pins a conference participant.
 *
 * {
 *     type: PIN_PARTICIPANT,
 *     participant: {
 *         id: string
 *     }
 * }
 */
export const PIN_PARTICIPANT = 'PIN_PARTICIPANT';

/**
 * The type of Redux action which notifies the app that the loadable avatar URL has changed.
 *
 * {
 *     type: SET_LOADABLE_AVATAR_URL,
 *     participant: {
 *         id: string,
           loadableAvatarUrl: string
 *     }
 * }
 */
export const SET_LOADABLE_AVATAR_URL = 'SET_LOADABLE_AVATAR_URL';

/**
 * The type of Redux action which notifies that the screenshare participant's display name has changed.
 *
 * {
 *     type: SCREENSHARE_PARTICIPANT_NAME_CHANGED,
 *     id: string,
 *     name: string
 * }
 */
 export const SCREENSHARE_PARTICIPANT_NAME_CHANGED = 'SCREENSHARE_PARTICIPANT_NAME_CHANGED';

/**
 * Raises hand for the local participant.
 * {
 *     type: LOCAL_PARTICIPANT_RAISE_HAND
 * }
 */
export const LOCAL_PARTICIPANT_RAISE_HAND = 'LOCAL_PARTICIPANT_RAISE_HAND';

/**
 * Clear the raise hand queue.
 * {
 *     type: RAISE_HAND_CLEAR
 * }
 */
export const RAISE_HAND_CLEAR = 'RAISE_HAND_CLEAR';

/**
 * Updates participant in raise hand queue.
 * {
 *     type: RAISE_HAND_UPDATED,
 *     participant: {
 *         id: string,
 *         raiseHand: boolean
 *     }
 * }
 */
export const RAISE_HAND_UPDATED = 'RAISE_HAND_UPDATED';

/**
 * The type of Redux action which notifies that the local participant has changed the audio levels.
 * {
 *     type: LOCAL_PARTICIPANT_AUDIO_LEVEL_CHANGED
 *     level: number
 * }
 */
export const LOCAL_PARTICIPANT_AUDIO_LEVEL_CHANGED = 'LOCAL_PARTICIPANT_AUDIO_LEVEL_CHANGED'

/**
 * The type of Redux action which overwrites the name of a participant.
 * {
 *     type: OVERWRITE_PARTICIPANT_NAME,
 *     id: string,
 *     name: string
 * }
 */
export const OVERWRITE_PARTICIPANT_NAME = 'OVERWRITE_PARTICIPANT_NAME';

/**
 * The type of Redux action which overwrites the names of multiple participants.
 * {
 *     type: OVERWRITE_PARTICIPANTS_NAMES,
 *     participantsList: Array<Object>,
 * }
 */
export const OVERWRITE_PARTICIPANTS_NAMES = 'OVERWRITE_PARTICIPANTS_NAMES';

/**
 * Updates participants local recording status.
 * {
 *     type: SET_LOCAL_PARTICIPANT_RECORDING_STATUS,
 *     recording: boolean,
 *     onlySelf: boolean
 * }
 */
export const SET_LOCAL_PARTICIPANT_RECORDING_STATUS = 'SET_LOCAL_PARTICIPANT_RECORDING_STATUS';


################################################################################

## File: .\jitsi-meet\react\features\base\participants\constants.ts

import { IconPhoneRinging, IconWhiteboard } from '../icons/svg';

/**
 * The relative path to the default/stock avatar (image) file used on both
 * Web/React and mobile/React Native (for the purposes of consistency).
 *
 * XXX (1) Web/React utilizes relativity on the Jitsi Meet deployment.
 * (2) Mobile/React Native utilizes relativity on the local file system at build
 * time. Unfortunately, the packager of React Native cannot deal with the
 * {@code const} early enough for {@code require} to succeed at runtime.
 * Anyway, be sure to synchronize the relative path on Web and mobile for the
 * purposes of consistency.
 *
 * @type {string}
 */
export const DEFAULT_AVATAR_RELATIVE_PATH = 'images/avatar.png';

/**
 * The value for the "var" attribute of feature tag in disco-info packets.
 */
export const DISCO_REMOTE_CONTROL_FEATURE = 'http://jitsi.org/meet/remotecontrol';

/**
 * Icon URL for jigasi participants.
 *
 * @type {string}
 */
export const JIGASI_PARTICIPANT_ICON = IconPhoneRinging;

/**
 * The local participant might not have real ID until she joins a conference,
 * so use 'local' as her default ID.
 *
 * @type {string}
 */
export const LOCAL_PARTICIPANT_DEFAULT_ID = 'local';

/**
 * Max length of the display names.
 *
 * @type {string}
 */
export const MAX_DISPLAY_NAME_LENGTH = 50;

/**
 * The identifier of the sound to be played when new remote participant joins
 * the room.
 *
 * @type {string}
 */
export const PARTICIPANT_JOINED_SOUND_ID = 'PARTICIPANT_JOINED_SOUND';

/**
 * The identifier of the sound to be played when remote participant leaves
 * the room.
 *
 * @type {string}
 */
export const PARTICIPANT_LEFT_SOUND_ID = 'PARTICIPANT_LEFT_SOUND';

/**
 * The set of possible XMPP MUC roles for conference participants.
 *
 * @enum {string}
 */
export const PARTICIPANT_ROLE = {
    MODERATOR: 'moderator',
    NONE: 'none',
    PARTICIPANT: 'participant'
};

/**
 * The audio level at which the hand will be lowered if raised.
 *
 * @type {string}
 */
export const LOWER_HAND_AUDIO_LEVEL = 0.2;

/**
 * Icon URL for the whiteboard participant.
 */
export const WHITEBOARD_PARTICIPANT_ICON = IconWhiteboard;


################################################################################

## File: .\jitsi-meet\react\features\base\participants\functions.ts

// @ts-expect-error
import { getGravatarURL } from '@jitsi/js-utils/avatar';

import { IReduxState, IStore } from '../../app/types';
import { isStageFilmstripAvailable } from '../../filmstrip/functions';
import { isAddPeopleEnabled, isDialOutEnabled } from '../../invite/functions';
import { toggleShareDialog } from '../../share-room/actions';
import { IStateful } from '../app/types';
import { GRAVATAR_BASE_URL } from '../avatar/constants';
import { isCORSAvatarURL } from '../avatar/functions';
import { getCurrentConference } from '../conference/functions';
import { ADD_PEOPLE_ENABLED } from '../flags/constants';
import { getFeatureFlag } from '../flags/functions';
import i18next from '../i18n/i18next';
import { MEDIA_TYPE, MediaType, VIDEO_TYPE } from '../media/constants';
import { toState } from '../redux/functions';
import { getScreenShareTrack, isLocalTrackMuted } from '../tracks/functions.any';
import { createDeferred } from '../util/helpers';

import {
    JIGASI_PARTICIPANT_ICON,
    MAX_DISPLAY_NAME_LENGTH,
    PARTICIPANT_ROLE,
    WHITEBOARD_PARTICIPANT_ICON
} from './constants';
import { preloadImage } from './preloadImage';
import { FakeParticipant, IJitsiParticipant, IParticipant, ISourceInfo } from './types';


/**
 * Temp structures for avatar urls to be checked/preloaded.
 */
const AVATAR_QUEUE: Object[] = [];
const AVATAR_CHECKED_URLS = new Map();
/* eslint-disable arrow-body-style */
const AVATAR_CHECKER_FUNCTIONS = [
    (participant: IParticipant) => {
        return participant?.isJigasi ? JIGASI_PARTICIPANT_ICON : null;
    },
    (participant: IParticipant) => {
        return isWhiteboardParticipant(participant) ? WHITEBOARD_PARTICIPANT_ICON : null;
    },
    (participant: IParticipant) => {
        return participant?.avatarURL ? participant.avatarURL : null;
    },
    (participant: IParticipant, store: IStore) => {
        const config = store.getState()['features/base/config'];
        const isGravatarDisabled = config.gravatar?.disabled;

        if (participant?.email && !isGravatarDisabled) {
            const gravatarBaseURL = config.gravatar?.baseUrl
                || config.gravatarBaseURL
                || GRAVATAR_BASE_URL;

            return getGravatarURL(participant.email, gravatarBaseURL);
        }

        return null;
    }
];
/* eslint-enable arrow-body-style */

/**
 * Returns the list of active speakers that should be moved to the top of the sorted list of participants so that the
 * dominant speaker is visible always on the vertical filmstrip in stage layout.
 *
 * @param {Function | Object} stateful - The (whole) redux state, or redux's {@code getState} function to be used to
 * retrieve the state.
 * @returns {Array<string>}
 */
export function getActiveSpeakersToBeDisplayed(stateful: IStateful) {
    const state = toState(stateful);
    const {
        dominantSpeaker,
        fakeParticipants,
        sortedRemoteVirtualScreenshareParticipants,
        speakersList
    } = state['features/base/participants'];
    const { visibleRemoteParticipants } = state['features/filmstrip'];
    let activeSpeakers = new Map(speakersList);

    // Do not re-sort the active speakers if dominant speaker is currently visible.
    if (dominantSpeaker && visibleRemoteParticipants.has(dominantSpeaker)) {
        return activeSpeakers;
    }
    let availableSlotsForActiveSpeakers = visibleRemoteParticipants.size;

    if (activeSpeakers.has(dominantSpeaker ?? '')) {
        activeSpeakers.delete(dominantSpeaker ?? '');
    }

    // Add dominant speaker to the beginning of the list (not including self) since the active speaker list is always
    // alphabetically sorted.
    if (dominantSpeaker && dominantSpeaker !== getLocalParticipant(state)?.id) {
        const updatedSpeakers = Array.from(activeSpeakers);

        updatedSpeakers.splice(0, 0, [ dominantSpeaker, getParticipantById(state, dominantSpeaker)?.name ?? '' ]);
        activeSpeakers = new Map(updatedSpeakers);
    }

    // Remove screenshares from the count.
    if (sortedRemoteVirtualScreenshareParticipants) {
        availableSlotsForActiveSpeakers -= sortedRemoteVirtualScreenshareParticipants.size * 2;
        for (const screenshare of Array.from(sortedRemoteVirtualScreenshareParticipants.keys())) {
            const ownerId = getVirtualScreenshareParticipantOwnerId(screenshare as string);

            activeSpeakers.delete(ownerId);
        }
    }

    // Remove fake participants from the count.
    if (fakeParticipants) {
        availableSlotsForActiveSpeakers -= fakeParticipants.size;
    }
    const truncatedSpeakersList = Array.from(activeSpeakers).slice(0, availableSlotsForActiveSpeakers);

    truncatedSpeakersList.sort((a: any, b: any) => a[1].localeCompare(b[1]));

    return new Map(truncatedSpeakersList);
}

/**
 * Resolves the first loadable avatar URL for a participant.
 *
 * @param {Object} participant - The participant to resolve avatars for.
 * @param {Store} store - Redux store.
 * @returns {Promise}
 */
export function getFirstLoadableAvatarUrl(participant: IParticipant, store: IStore) {
    const deferred: any = createDeferred();
    const fullPromise = deferred.promise
        .then(() => _getFirstLoadableAvatarUrl(participant, store))
        .then((result: any) => {

            if (AVATAR_QUEUE.length) {
                const next: any = AVATAR_QUEUE.shift();

                next.resolve();
            }

            return result;
        });

    if (AVATAR_QUEUE.length) {
        AVATAR_QUEUE.push(deferred);
    } else {
        deferred.resolve();
    }

    return fullPromise;
}

/**
 * Returns local participant from Redux state.
 *
 * @param {(Function|Object)} stateful - The (whole) redux state, or redux's
 * {@code getState} function to be used to retrieve the state
 * features/base/participants.
 * @returns {(IParticipant|undefined)}
 */
export function getLocalParticipant(stateful: IStateful) {
    const state = toState(stateful)['features/base/participants'];

    return state.local;
}

/**
 * Returns local screen share participant from Redux state.
 *
 * @param {(Function|Object)} stateful - The (whole) redux state, or redux's
 * {@code getState} function to be used to retrieve the state features/base/participants.
 * @returns {(IParticipant|undefined)}
 */
export function getLocalScreenShareParticipant(stateful: IStateful) {
    const state = toState(stateful)['features/base/participants'];

    return state.localScreenShare;
}

/**
 * Returns screenshare participant.
 *
 * @param {(Function|Object)} stateful - The (whole) redux state, or redux's {@code getState} function to be used to
 * retrieve the state features/base/participants.
 * @param {string} id - The owner ID of the screenshare participant to retrieve.
 * @returns {(IParticipant|undefined)}
 */
export function getVirtualScreenshareParticipantByOwnerId(stateful: IStateful, id: string) {
    const state = toState(stateful);
    const track = getScreenShareTrack(state['features/base/tracks'], id);

    return getParticipantById(stateful, track?.jitsiTrack.getSourceName());
}

/**
 * Normalizes a display name so then no invalid values (padding, length...etc)
 * can be set.
 *
 * @param {string} name - The display name to set.
 * @returns {string}
 */
export function getNormalizedDisplayName(name: string) {
    if (!name?.trim()) {
        return undefined;
    }

    return name.trim().substring(0, MAX_DISPLAY_NAME_LENGTH);
}

/**
 * Returns participant by ID from Redux state.
 *
 * @param {(Function|Object)} stateful - The (whole) redux state, or redux's
 * {@code getState} function to be used to retrieve the state
 * features/base/participants.
 * @param {string} id - The ID of the participant to retrieve.
 * @private
 * @returns {(IParticipant|undefined)}
 */
export function getParticipantById(stateful: IStateful, id: string): IParticipant | undefined {
    const state = toState(stateful)['features/base/participants'];
    const { local, localScreenShare, remote } = state;

    return remote.get(id)
        || (local?.id === id ? local : undefined)
        || (localScreenShare?.id === id ? localScreenShare : undefined);
}

/**
 * Returns the participant with the ID matching the passed ID or the local participant if the ID is
 * undefined.
 *
 * @param {(Function|Object)} stateful - The (whole) redux state, or redux's
 * {@code getState} function to be used to retrieve the state
 * features/base/participants.
 * @param {string|undefined} [participantID] - An optional partipantID argument.
 * @returns {IParticipant|undefined}
 */
export function getParticipantByIdOrUndefined(stateful: IStateful, participantID?: string) {
    return participantID ? getParticipantById(stateful, participantID) : getLocalParticipant(stateful);
}

/**
 * Returns a count of the known participants in the passed in redux state,
 * excluding any fake participants.
 *
 * @param {(Function|Object)} stateful - The (whole) redux state, or redux's
 * {@code getState} function to be used to retrieve the state
 * features/base/participants.
 * @returns {number}
 */
export function getParticipantCount(stateful: IStateful) {
    const state = toState(stateful);
    const {
        local,
        remote,
        fakeParticipants,
        sortedRemoteVirtualScreenshareParticipants
    } = state['features/base/participants'];

    return remote.size - fakeParticipants.size - sortedRemoteVirtualScreenshareParticipants.size + (local ? 1 : 0);
}

/**
 * Returns participant ID of the owner of a virtual screenshare participant.
 *
 * @param {string} id - The ID of the virtual screenshare participant.
 * @private
 * @returns {(string|undefined)}
 */
export function getVirtualScreenshareParticipantOwnerId(id: string) {
    return id.split('-')[0];
}

/**
 * Returns the Map with fake participants.
 *
 * @param {(Function|Object)} stateful - The (whole) redux state, or redux's
 * {@code getState} function to be used to retrieve the state
 * features/base/participants.
 * @returns {Map<string, IParticipant>} - The Map with fake participants.
 */
export function getFakeParticipants(stateful: IStateful) {
    return toState(stateful)['features/base/participants'].fakeParticipants;
}

/**
 * Returns whether the fake participant is a local screenshare.
 *
 * @param {IParticipant|undefined} participant - The participant entity.
 * @returns {boolean} - True if it's a local screenshare participant.
 */
export function isLocalScreenshareParticipant(participant?: IParticipant): boolean {
    return participant?.fakeParticipant === FakeParticipant.LocalScreenShare;
}

/**
 * Returns whether the fake participant is a remote screenshare.
 *
 * @param {IParticipant|undefined} participant - The participant entity.
 * @returns {boolean} - True if it's a remote screenshare participant.
 */
export function isRemoteScreenshareParticipant(participant?: IParticipant): boolean {
    return participant?.fakeParticipant === FakeParticipant.RemoteScreenShare;
}

/**
 * Returns whether the fake participant is of local or virtual screenshare type.
 *
 * @param {IReduxState} state - The (whole) redux state, or redux's.
 * @param {string|undefined} participantId - The participant id.
 * @returns {boolean} - True if it's one of the two.
 */
export function isScreenShareParticipantById(state: IReduxState, participantId?: string): boolean {
    const participant = getParticipantByIdOrUndefined(state, participantId);

    return isScreenShareParticipant(participant);
}

/**
 * Returns whether the fake participant is of local or virtual screenshare type.
 *
 * @param {IParticipant|undefined} participant - The participant entity.
 * @returns {boolean} - True if it's one of the two.
 */
export function isScreenShareParticipant(participant?: IParticipant): boolean {
    return isLocalScreenshareParticipant(participant) || isRemoteScreenshareParticipant(participant);
}

/**
 * Returns whether the (fake) participant is a shared video.
 *
 * @param {IParticipant|undefined} participant - The participant entity.
 * @returns {boolean} - True if it's a shared video participant.
 */
export function isSharedVideoParticipant(participant?: IParticipant): boolean {
    return participant?.fakeParticipant === FakeParticipant.SharedVideo;
}

/**
 * Returns whether the fake participant is a whiteboard.
 *
 * @param {IParticipant|undefined} participant - The participant entity.
 * @returns {boolean} - True if it's a whiteboard participant.
 */
export function isWhiteboardParticipant(participant?: IParticipant): boolean {
    return participant?.fakeParticipant === FakeParticipant.Whiteboard;
}

/**
 * Returns a count of the known remote participants in the passed in redux state.
 *
 * @param {(Function|Object)} stateful - The (whole) redux state, or redux's
 * {@code getState} function to be used to retrieve the state
 * features/base/participants.
 * @returns {number}
 */
export function getRemoteParticipantCountWithFake(stateful: IStateful) {
    const state = toState(stateful);
    const participantsState = state['features/base/participants'];

    return participantsState.remote.size;
}

/**
 * Returns the muted state of the given media source for a given participant.
 *
 * @param {(Function|Object)} stateful - The (whole) redux state, or redux's.
 * @param {IParticipant} participant - The participant entity.
 * @param {MediaType} mediaType - The media type.
 * @returns {boolean} - True its muted, false otherwise.
 */
export function getMutedStateByParticipantAndMediaType(
        stateful: IStateful,
        participant: IParticipant,
        mediaType: MediaType): boolean {
    const type = mediaType === MEDIA_TYPE.SCREENSHARE ? 'video' : mediaType;

    if (participant.local) {
        const state = toState(stateful);
        const tracks = state['features/base/tracks'];

        return isLocalTrackMuted(tracks, mediaType);
    }

    const sources = participant.sources?.get(type);

    if (!sources) {
        return true;
    }

    if (mediaType === MEDIA_TYPE.AUDIO) {
        return Array.from(sources.values())[0].muted;
    }
    const videoType = mediaType === MEDIA_TYPE.VIDEO ? VIDEO_TYPE.CAMERA : VIDEO_TYPE.SCREENSHARE;
    const source = Array.from(sources.values()).find(src => src.videoType === videoType);

    return source?.muted ?? true;
}

/**
 * Returns a count of the known participants in the passed in redux state,
 * including fake participants.
 *
 * @param {(Function|Object)} stateful - The (whole) redux state, or redux's
 * {@code getState} function to be used to retrieve the state
 * features/base/participants.
 * @returns {number}
 */
export function getParticipantCountWithFake(stateful: IStateful) {
    const state = toState(stateful);
    const { local, localScreenShare, remote } = state['features/base/participants'];

    return remote.size + (local ? 1 : 0) + (localScreenShare ? 1 : 0);
}

/**
 * Returns participant's display name.
 *
 * @param {(Function|Object)} stateful - The (whole) redux state, or redux's {@code getState} function to be used to
 * retrieve the state.
 * @param {string} id - The ID of the participant's display name to retrieve.
 * @returns {string}
 */
export function getParticipantDisplayName(stateful: IStateful, id: string): string {
    const state = toState(stateful);
    const participant = getParticipantById(state, id);
    const {
        defaultLocalDisplayName,
        defaultRemoteDisplayName
    } = state['features/base/config'];

    if (participant) {
        if (isScreenShareParticipant(participant)) {
            return getScreenshareParticipantDisplayName(state, id);
        }

        if (participant.name) {
            return participant.name;
        }

        if (participant.local) {
            return defaultLocalDisplayName ?? '';
        }
    }

    return defaultRemoteDisplayName ?? '';
}

/**
 * Returns the source names of the screenshare sources in the conference based on the presence shared by the remote
 * endpoints. This should be only used for creating/removing virtual screenshare participant tiles when ssrc-rewriting
 * is enabled. Once the tile is created, the source-name gets added to the receiver constraints based on which the
 * JVB will add the source to the video sources map and signal it to the local endpoint. Only then, a remote track is
 * created/remapped and the tracks in redux will be updated. Once the track is updated in redux, the client will
 * will continue to use the other track based getter functions for other operations related to screenshare.
 *
 * @param {(Function|Object)} stateful - The (whole) redux state, or redux's {@code getState} function to be used to
 * retrieve the state.
 * @returns {string[]}
 */
export function getRemoteScreensharesBasedOnPresence(stateful: IStateful): string[] {
    const conference = getCurrentConference(stateful);

    return conference?.getParticipants()?.reduce((screenshares: string[], participant: IJitsiParticipant) => {
        const sources: Map<string, Map<string, ISourceInfo>> = participant.getSources();
        const videoSources = sources.get(MEDIA_TYPE.VIDEO);
        const screenshareSources = Array.from(videoSources ?? new Map())
            .filter(source => source[1].videoType === VIDEO_TYPE.DESKTOP && !source[1].muted)
            .map(source => source[0]);

        // eslint-disable-next-line no-param-reassign
        screenshares = [ ...screenshares, ...screenshareSources ];

        return screenshares;
    }, []);
}

/**
 * Returns screenshare participant's display name.
 *
 * @param {(Function|Object)} stateful - The (whole) redux state, or redux's {@code getState} function to be used to
 * retrieve the state.
 * @param {string} id - The ID of the screenshare participant's display name to retrieve.
 * @returns {string}
 */
export function getScreenshareParticipantDisplayName(stateful: IStateful, id: string) {
    const ownerDisplayName = getParticipantDisplayName(stateful, getVirtualScreenshareParticipantOwnerId(id));

    return i18next.t('screenshareDisplayName', { name: ownerDisplayName });
}

/**
 * Returns a list of IDs of the participants that are currently screensharing.
 *
 * @param {(Function|Object)} stateful - The (whole) redux state, or redux's {@code getState} function to be used to
 * retrieve the state.
 * @returns {Array<string>}
 */
export function getScreenshareParticipantIds(stateful: IStateful): Array<string> {
    return toState(stateful)['features/base/tracks']
        .filter(track => track.videoType === VIDEO_TYPE.DESKTOP && !track.muted)
        .map(t => t.participantId);
}

/**
 * Returns a list of source names associated with a given remote participant and for the given media type.
 *
 * @param {(Function|Object)} stateful - The (whole) redux state, or redux's {@code getState} function to be used to
 * retrieve the state.
 * @param {string} id - The id of the participant whose source names are to be retrieved.
 * @param {string} mediaType - The type of source, audio or video.
 * @returns {Array<string>}
 */
export function getSourceNamesByMediaTypeAndParticipant(
        stateful: IStateful,
        id: string,
        mediaType: string): Array<string> {
    const participant: IParticipant | undefined = getParticipantById(stateful, id);

    if (!participant) {
        return [];
    }

    const sources = participant.sources;

    if (!sources) {
        return [];
    }

    return Array.from(sources.get(mediaType) ?? new Map())
        .filter(source => source[1].videoType !== VIDEO_TYPE.DESKTOP || !source[1].muted)
        .map(s => s[0]);
}

/**
 * Returns a list of source names associated with a given remote participant and for the given video type (only for
 * video sources).
 *
 * @param {(Function|Object)} stateful - The (whole) redux state, or redux's {@code getState} function to be used to
 * retrieve the state.
 * @param {string} id - The id of the participant whose source names are to be retrieved.
 * @param {string} videoType - The type of video, camera or desktop.
 * @returns {Array<string>}
 */
export function getSourceNamesByVideoTypeAndParticipant(
        stateful: IStateful,
        id: string,
        videoType: string): Array<string> {
    const participant: IParticipant | undefined = getParticipantById(stateful, id);

    if (!participant) {
        return [];
    }

    const sources = participant.sources;

    if (!sources) {
        return [];
    }

    return Array.from(sources.get(MEDIA_TYPE.VIDEO) ?? new Map())
        .filter(source => source[1].videoType === videoType && (videoType === VIDEO_TYPE.CAMERA || !source[1].muted))
        .map(s => s[0]);
}

/**
 * Returns the presence status of a participant associated with the passed id.
 *
 * @param {(Function|Object)} stateful - The (whole) redux state, or redux's
 * {@code getState} function to be used to retrieve the state.
 * @param {string} id - The id of the participant.
 * @returns {string} - The presence status.
 */
export function getParticipantPresenceStatus(stateful: IStateful, id: string) {
    if (!id) {
        return undefined;
    }
    const participantById = getParticipantById(stateful, id);

    if (!participantById) {
        return undefined;
    }

    return participantById.presence;
}

/**
 * Selectors for getting all remote participants.
 *
 * @param {(Function|Object)} stateful - The (whole) redux state, or redux's
 * {@code getState} function to be used to retrieve the state
 * features/base/participants.
 * @returns {Map<string, Object>}
 */
export function getRemoteParticipants(stateful: IStateful): Map<string, IParticipant> {
    return toState(stateful)['features/base/participants'].remote;
}

/**
 * Selectors for the getting the remote participants in the order that they are displayed in the filmstrip.
 *
@param {(Function|Object)} stateful - The (whole) redux state, or redux's {@code getState} function to be used to
 * retrieve the state features/filmstrip.
 * @returns {Array<string>}
 */
export function getRemoteParticipantsSorted(stateful: IStateful) {
    return toState(stateful)['features/filmstrip'].remoteParticipants;
}

/**
 * Returns the participant which has its pinned state set to truthy.
 *
 * @param {(Function|Object)} stateful - The (whole) redux state, or redux's
 * {@code getState} function to be used to retrieve the state
 * features/base/participants.
 * @returns {(IParticipant|undefined)}
 */
export function getPinnedParticipant(stateful: IStateful) {
    const state = toState(stateful);
    const { pinnedParticipant } = state['features/base/participants'];
    const stageFilmstrip = isStageFilmstripAvailable(state);

    if (stageFilmstrip) {
        const { activeParticipants } = state['features/filmstrip'];
        const id = activeParticipants.find(p => p.pinned)?.participantId;

        return id ? getParticipantById(stateful, id) : undefined;
    }

    if (!pinnedParticipant) {
        return undefined;
    }

    return getParticipantById(stateful, pinnedParticipant);
}

/**
 * Returns true if the participant is a moderator.
 *
 * @param {string} participant - Participant object.
 * @returns {boolean}
 */
export function isParticipantModerator(participant?: IParticipant) {
    return participant?.role === PARTICIPANT_ROLE.MODERATOR;
}

/**
 * Returns the dominant speaker participant.
 *
 * @param {(Function|Object)} stateful - The (whole) redux state or redux's
 * {@code getState} function to be used to retrieve the state features/base/participants.
 * @returns {IParticipant} - The participant from the redux store.
 */
export function getDominantSpeakerParticipant(stateful: IStateful) {
    const state = toState(stateful)['features/base/participants'];
    const { dominantSpeaker } = state;

    if (!dominantSpeaker) {
        return undefined;
    }

    return getParticipantById(stateful, dominantSpeaker);
}

/**
 * Returns true if all of the meeting participants are moderators.
 *
 * @param {Object|Function} stateful -Object or function that can be resolved
 * to the Redux state.
 * @returns {boolean}
 */
export function isEveryoneModerator(stateful: IStateful) {
    const state = toState(stateful)['features/base/participants'];

    return state.numberOfNonModeratorParticipants === 0;
}

/**
 * Checks a value and returns true if it's a preloaded icon object.
 *
 * @param {?string | ?Object} icon - The icon to check.
 * @returns {boolean}
 */
export function isIconUrl(icon?: string | Object) {
    return Boolean(icon) && (typeof icon === 'object' || typeof icon === 'function');
}

/**
 * Returns true if the current local participant is a moderator in the
 * conference.
 *
 * @param {Object|Function} stateful - Object or function that can be resolved
 * to the Redux state.
 * @returns {boolean}
 */
export function isLocalParticipantModerator(stateful: IStateful) {
    const state = toState(stateful)['features/base/participants'];

    const { local } = state;

    if (!local) {
        return false;
    }

    return isParticipantModerator(local);
}

/**
 * Resolves the first loadable avatar URL for a participant.
 *
 * @param {Object} participant - The participant to resolve avatars for.
 * @param {Store} store - Redux store.
 * @returns {?string}
 */
async function _getFirstLoadableAvatarUrl(participant: IParticipant, store: IStore) {
    for (let i = 0; i < AVATAR_CHECKER_FUNCTIONS.length; i++) {
        const url = AVATAR_CHECKER_FUNCTIONS[i](participant, store);

        if (url !== null) {
            if (AVATAR_CHECKED_URLS.has(url)) {
                const { isLoadable, isUsingCORS } = AVATAR_CHECKED_URLS.get(url) || {};

                if (isLoadable) {
                    return {
                        isUsingCORS,
                        src: url
                    };
                }
            } else {
                try {
                    const { corsAvatarURLs } = store.getState()['features/base/config'];
                    const useCORS = isIconUrl(url) ? false : isCORSAvatarURL(url, corsAvatarURLs);
                    const { isUsingCORS, src } = await preloadImage(url, useCORS);

                    AVATAR_CHECKED_URLS.set(src, {
                        isLoadable: true,
                        isUsingCORS
                    });

                    return {
                        isUsingCORS,
                        src
                    };
                } catch (e) {
                    AVATAR_CHECKED_URLS.set(url, {
                        isLoadable: false,
                        isUsingCORS: false
                    });
                }
            }
        }
    }

    return undefined;
}

/**
 * Get the participants queue with raised hands.
 *
 * @param {(Function|Object)} stateful - The (whole) redux state, or redux's
 * {@code getState} function to be used to retrieve the state
 * features/base/participants.
 * @returns {Array<Object>}
 */
export function getRaiseHandsQueue(stateful: IStateful): Array<{ id: string; raisedHandTimestamp: number; }> {
    const { raisedHandsQueue } = toState(stateful)['features/base/participants'];

    return raisedHandsQueue;
}

/**
 * Returns whether the given participant has his hand raised or not.
 *
 * @param {Object} participant - The participant.
 * @returns {boolean} - Whether participant has raise hand or not.
 */
export function hasRaisedHand(participant?: IParticipant): boolean {
    return Boolean(participant?.raisedHandTimestamp);
}

/**
 * Add people feature enabling/disabling.
 *
 * @param {Object|Function} stateful - Object or function that can be resolved
 * to the Redux state.
 * @returns {boolean}
 */
export const addPeopleFeatureControl = (stateful: IStateful) => {
    const state = toState(stateful);

    return getFeatureFlag(state, ADD_PEOPLE_ENABLED, true)
    && (isAddPeopleEnabled(state) || isDialOutEnabled(state));
};

/**
 * Controls share dialog visibility.
 *
 * @param {boolean} addPeopleFeatureEnabled - Checks if add people functionality is enabled.
 * @param {Function} dispatch - The Redux dispatch function.
 * @returns {Function}
 */
export const setShareDialogVisiblity = (addPeopleFeatureEnabled: boolean, dispatch: IStore['dispatch']) => {
    if (addPeopleFeatureEnabled) {
        dispatch(toggleShareDialog(false));
    } else {
        dispatch(toggleShareDialog(true));
    }
};


################################################################################

## File: .\jitsi-meet\react\features\base\participants\logger.ts

import { getLogger } from '../logging/functions';

export default getLogger('features/base/participants');


################################################################################

## File: .\jitsi-meet\react\features\base\participants\middleware.ts

import i18n from 'i18next';
import { batch } from 'react-redux';
import { AnyAction } from 'redux';

import { IStore } from '../../app/types';
import { approveParticipant } from '../../av-moderation/actions';
import { UPDATE_BREAKOUT_ROOMS } from '../../breakout-rooms/actionTypes';
import { getBreakoutRooms } from '../../breakout-rooms/functions';
import { toggleE2EE } from '../../e2ee/actions';
import { MAX_MODE } from '../../e2ee/constants';
import { showNotification } from '../../notifications/actions';
import {
    LOCAL_RECORDING_NOTIFICATION_ID,
    NOTIFICATION_TIMEOUT_TYPE,
    RAISE_HAND_NOTIFICATION_ID
} from '../../notifications/constants';
import { open as openParticipantsPane } from '../../participants-pane/actions';
import { isForceMuted } from '../../participants-pane/functions';
import { CALLING, INVITED } from '../../presence-status/constants';
import { RAISE_HAND_SOUND_ID } from '../../reactions/constants';
import { RECORDING_OFF_SOUND_ID, RECORDING_ON_SOUND_ID } from '../../recording/constants';
import { APP_WILL_MOUNT, APP_WILL_UNMOUNT } from '../app/actionTypes';
import { CONFERENCE_JOINED, CONFERENCE_WILL_JOIN } from '../conference/actionTypes';
import { forEachConference, getCurrentConference } from '../conference/functions';
import { IJitsiConference } from '../conference/reducer';
import { SET_CONFIG } from '../config/actionTypes';
import { getDisableRemoveRaisedHandOnFocus } from '../config/functions.any';
import { JitsiConferenceEvents } from '../lib-jitsi-meet';
import { MEDIA_TYPE } from '../media/constants';
import MiddlewareRegistry from '../redux/MiddlewareRegistry';
import StateListenerRegistry from '../redux/StateListenerRegistry';
import { playSound, registerSound, unregisterSound } from '../sounds/actions';

import {
    DOMINANT_SPEAKER_CHANGED,
    GRANT_MODERATOR,
    KICK_PARTICIPANT,
    LOCAL_PARTICIPANT_AUDIO_LEVEL_CHANGED,
    LOCAL_PARTICIPANT_RAISE_HAND,
    MUTE_REMOTE_PARTICIPANT,
    OVERWRITE_PARTICIPANTS_NAMES,
    OVERWRITE_PARTICIPANT_NAME,
    PARTICIPANT_JOINED,
    PARTICIPANT_LEFT,
    PARTICIPANT_UPDATED,
    RAISE_HAND_UPDATED,
    SET_LOCAL_PARTICIPANT_RECORDING_STATUS
} from './actionTypes';
import {
    localParticipantIdChanged,
    localParticipantJoined,
    localParticipantLeft,
    overwriteParticipantName,
    participantLeft,
    participantUpdated,
    raiseHand,
    raiseHandUpdateQueue,
    setLoadableAvatarUrl
} from './actions';
import {
    LOCAL_PARTICIPANT_DEFAULT_ID,
    LOWER_HAND_AUDIO_LEVEL,
    PARTICIPANT_JOINED_SOUND_ID,
    PARTICIPANT_LEFT_SOUND_ID
} from './constants';
import {
    getDominantSpeakerParticipant,
    getFirstLoadableAvatarUrl,
    getLocalParticipant,
    getParticipantById,
    getParticipantCount,
    getParticipantDisplayName,
    getRaiseHandsQueue,
    getRemoteParticipants,
    hasRaisedHand,
    isLocalParticipantModerator,
    isScreenShareParticipant,
    isWhiteboardParticipant
} from './functions';
import logger from './logger';
import { PARTICIPANT_JOINED_FILE, PARTICIPANT_LEFT_FILE } from './sounds';
import { IJitsiParticipant } from './types';

import './subscriber';

/**
 * Middleware that captures CONFERENCE_JOINED and CONFERENCE_LEFT actions and
 * updates respectively ID of local participant.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {
    switch (action.type) {
    case APP_WILL_MOUNT:
        _registerSounds(store);

        return _localParticipantJoined(store, next, action);

    case APP_WILL_UNMOUNT:
        _unregisterSounds(store);

        return _localParticipantLeft(store, next, action);

    case CONFERENCE_WILL_JOIN:
        store.dispatch(localParticipantIdChanged(action.conference.myUserId()));
        break;

    case DOMINANT_SPEAKER_CHANGED: {
        // Lower hand through xmpp when local participant becomes dominant speaker.
        const { id } = action.participant;
        const state = store.getState();
        const participant = getLocalParticipant(state);
        const dominantSpeaker = getDominantSpeakerParticipant(state);
        const isLocal = participant && participant.id === id;

        if (isLocal && dominantSpeaker?.id !== id
                && hasRaisedHand(participant)
                && !getDisableRemoveRaisedHandOnFocus(state)) {
            store.dispatch(raiseHand(false));
        }

        break;
    }

    case LOCAL_PARTICIPANT_AUDIO_LEVEL_CHANGED: {
        const state = store.getState();
        const participant = getDominantSpeakerParticipant(state);

        if (
            participant?.local
            && hasRaisedHand(participant)
            && action.level > LOWER_HAND_AUDIO_LEVEL
            && !getDisableRemoveRaisedHandOnFocus(state)
        ) {
            store.dispatch(raiseHand(false));
        }
        break;
    }

    case GRANT_MODERATOR: {
        const { conference } = store.getState()['features/base/conference'];

        conference?.grantOwner(action.id);
        break;
    }

    case KICK_PARTICIPANT: {
        const { conference } = store.getState()['features/base/conference'];

        conference?.kickParticipant(action.id);
        break;
    }

    case LOCAL_PARTICIPANT_RAISE_HAND: {
        const { raisedHandTimestamp } = action;
        const localId = getLocalParticipant(store.getState())?.id;

        store.dispatch(participantUpdated({
            // XXX Only the local participant is allowed to update without
            // stating the JitsiConference instance (i.e. participant property
            // `conference` for a remote participant) because the local
            // participant is uniquely identified by the very fact that there is
            // only one local participant.

            id: localId ?? '',
            local: true,
            raisedHandTimestamp
        }));

        store.dispatch(raiseHandUpdateQueue({
            id: localId ?? '',
            raisedHandTimestamp
        }));

        if (typeof APP !== 'undefined') {
            APP.API.notifyRaiseHandUpdated(localId, raisedHandTimestamp);
        }

        break;
    }

    case SET_CONFIG: {
        const result = next(action);

        const state = store.getState();
        const { deploymentInfo } = state['features/base/config'];

        // if there userRegion set let's use it for the local participant
        if (deploymentInfo?.userRegion) {
            const localId = getLocalParticipant(state)?.id;

            if (localId) {
                store.dispatch(participantUpdated({
                    id: localId,
                    local: true,
                    region: deploymentInfo.userRegion
                }));
            }
        }

        return result;
    }

    case CONFERENCE_JOINED: {
        const result = next(action);

        const state = store.getState();
        const { startSilent } = state['features/base/config'];

        if (startSilent) {
            const localId = getLocalParticipant(store.getState())?.id;

            if (localId) {
                store.dispatch(participantUpdated({
                    id: localId,
                    local: true,
                    isSilent: startSilent
                }));
            }
        }

        return result;
    }


    case SET_LOCAL_PARTICIPANT_RECORDING_STATUS: {
        const state = store.getState();
        const { recording, onlySelf } = action;
        const localId = getLocalParticipant(state)?.id;
        const { localRecording } = state['features/base/config'];

        if (localRecording?.notifyAllParticipants && !onlySelf && localId) {
            store.dispatch(participantUpdated({
                // XXX Only the local participant is allowed to update without
                // stating the JitsiConference instance (i.e. participant property
                // `conference` for a remote participant) because the local
                // participant is uniquely identified by the very fact that there is
                // only one local participant.

                id: localId,
                local: true,
                localRecording: recording
            }));
        }

        break;
    }

    case MUTE_REMOTE_PARTICIPANT: {
        const { conference } = store.getState()['features/base/conference'];

        conference?.muteParticipant(action.id, action.mediaType);
        break;
    }

    case RAISE_HAND_UPDATED: {
        const { participant } = action;
        let queue = getRaiseHandsQueue(store.getState());

        if (participant.raisedHandTimestamp) {
            queue = [ ...queue, { id: participant.id,
                raisedHandTimestamp: participant.raisedHandTimestamp } ];

            // sort the queue before adding to store.
            queue = queue.sort(({ raisedHandTimestamp: a }, { raisedHandTimestamp: b }) => a - b);
        } else {
            // no need to sort on remove value.
            queue = queue.filter(({ id }) => id !== participant.id);
        }

        action.queue = queue;
        break;
    }

    case PARTICIPANT_JOINED: {
        // Do not play sounds when a screenshare or whiteboard participant tile is created for screenshare.
        (!isScreenShareParticipant(action.participant)
            && !isWhiteboardParticipant(action.participant)
        ) && _maybePlaySounds(store, action);

        return _participantJoinedOrUpdated(store, next, action);
    }

    case PARTICIPANT_LEFT: {
        // Do not play sounds when a tile for screenshare or whiteboard is removed.
        (!isScreenShareParticipant(action.participant)
            && !isWhiteboardParticipant(action.participant)
        ) && _maybePlaySounds(store, action);

        break;
    }

    case PARTICIPANT_UPDATED:
        return _participantJoinedOrUpdated(store, next, action);

    case OVERWRITE_PARTICIPANTS_NAMES: {
        const { participantList } = action;

        if (!Array.isArray(participantList)) {
            logger.error('Overwrite names failed. Argument is not an array.');

            return;
        }
        batch(() => {
            participantList.forEach(p => {
                store.dispatch(overwriteParticipantName(p.id, p.name));
            });
        });
        break;
    }

    case OVERWRITE_PARTICIPANT_NAME: {
        const { dispatch, getState } = store;
        const state = getState();
        const { id, name } = action;

        let breakoutRoom = false, identifier = id;

        if (id.indexOf('@') !== -1) {
            identifier = id.slice(id.indexOf('/') + 1);
            breakoutRoom = true;
            action.id = identifier;
        }

        if (breakoutRoom) {
            const rooms = getBreakoutRooms(state);
            const roomCounter = state['features/breakout-rooms'].roomCounter;
            const newRooms: any = {};

            Object.entries(rooms).forEach(([ key, r ]) => {
                const participants = r?.participants || {};
                const jid = Object.keys(participants).find(p =>
                    p.slice(p.indexOf('/') + 1) === identifier);

                if (jid) {
                    newRooms[key] = {
                        ...r,
                        participants: {
                            ...participants,
                            [jid]: {
                                ...participants[jid],
                                displayName: name
                            }
                        }
                    };
                } else {
                    newRooms[key] = r;
                }
            });
            dispatch({
                type: UPDATE_BREAKOUT_ROOMS,
                rooms,
                roomCounter,
                updatedNames: true
            });
        } else {
            dispatch(participantUpdated({
                id: identifier,
                name
            }));
        }
        break;
    }
    }

    return next(action);
});

/**
 * Syncs the redux state features/base/participants up with the redux state
 * features/base/conference by ensuring that the former does not contain remote
 * participants no longer relevant to the latter. Introduced to address an issue
 * with multiplying thumbnails in the filmstrip.
 */
StateListenerRegistry.register(
    /* selector */ state => getCurrentConference(state),
    /* listener */ (conference, { dispatch, getState }) => {
        batch(() => {
            for (const [ id, p ] of getRemoteParticipants(getState())) {
                (!conference || p.conference !== conference)
                    && dispatch(participantLeft(id, p.conference, {
                        isReplaced: p.isReplaced
                    }));
            }
        });
    });

/**
 * Reset the ID of the local participant to
 * {@link LOCAL_PARTICIPANT_DEFAULT_ID}. Such a reset is deemed possible only if
 * the local participant and, respectively, her ID is not involved in a
 * conference which is still of interest to the user and, consequently, the app.
 * For example, a conference which is in the process of leaving is no longer of
 * interest the user, is unrecoverable from the perspective of the user and,
 * consequently, the app.
 */
StateListenerRegistry.register(
    /* selector */ state => state['features/base/conference'],
    /* listener */ ({ leaving }, { dispatch, getState }) => {
        const state = getState();
        const localParticipant = getLocalParticipant(state);
        let id: string;

        if (!localParticipant
                || (id = localParticipant.id)
                    === LOCAL_PARTICIPANT_DEFAULT_ID) {
            // The ID of the local participant has been reset already.
            return;
        }

        // The ID of the local may be reset only if it is not in use.
        const dispatchLocalParticipantIdChanged
            = forEachConference(
                state,
                conference =>
                    conference === leaving || conference.myUserId() !== id);

        dispatchLocalParticipantIdChanged
            && dispatch(
                localParticipantIdChanged(LOCAL_PARTICIPANT_DEFAULT_ID));
    });

/**
 * Registers listeners for participant change events.
 */
StateListenerRegistry.register(
    state => state['features/base/conference'].conference,
    (conference, store) => {
        if (conference) {
            const propertyHandlers: {
                [key: string]: Function;
            } = {
                'e2ee.enabled': (participant: IJitsiParticipant, value: string) =>
                    _e2eeUpdated(store, conference, participant.getId(), value),
                'features_e2ee': (participant: IJitsiParticipant, value: boolean) =>
                    getParticipantById(store.getState(), participant.getId())?.e2eeSupported !== value
                        && store.dispatch(participantUpdated({
                            conference,
                            id: participant.getId(),
                            e2eeSupported: value
                        })),
                'features_jigasi': (participant: IJitsiParticipant, value: boolean) =>
                    store.dispatch(participantUpdated({
                        conference,
                        id: participant.getId(),
                        isJigasi: value
                    })),
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                'features_screen-sharing': (participant: IJitsiParticipant, value: string) =>
                    store.dispatch(participantUpdated({
                        conference,
                        id: participant.getId(),
                        features: { 'screen-sharing': true }
                    })),
                'localRecording': (participant: IJitsiParticipant, value: string) =>
                    _localRecordingUpdated(store, conference, participant.getId(), value),
                'raisedHand': (participant: IJitsiParticipant, value: string) =>
                    _raiseHandUpdated(store, conference, participant.getId(), value),
                'region': (participant: IJitsiParticipant, value: string) =>
                    store.dispatch(participantUpdated({
                        conference,
                        id: participant.getId(),
                        region: value
                    })),
                'remoteControlSessionStatus': (participant: IJitsiParticipant, value: boolean) =>
                    store.dispatch(participantUpdated({
                        conference,
                        id: participant.getId(),
                        remoteControlSessionStatus: value
                    }))
            };

            // update properties for the participants that are already in the conference
            conference.getParticipants().forEach((participant: any) => {
                Object.keys(propertyHandlers).forEach(propertyName => {
                    const value = participant.getProperty(propertyName);

                    if (value !== undefined) {
                        propertyHandlers[propertyName as keyof typeof propertyHandlers](participant, value);
                    }
                });
            });

            // We joined a conference
            conference.on(
                JitsiConferenceEvents.PARTICIPANT_PROPERTY_CHANGED,
                (participant: IJitsiParticipant, propertyName: string, oldValue: string, newValue: string) => {
                    if (propertyHandlers.hasOwnProperty(propertyName)) {
                        propertyHandlers[propertyName](participant, newValue);
                    }
                });
        } else {
            const localParticipantId = getLocalParticipant(store.getState)?.id;

            // We left the conference, the local participant must be updated.
            _e2eeUpdated(store, conference, localParticipantId ?? '', false);
            _raiseHandUpdated(store, conference, localParticipantId ?? '', 0);
        }
    }
);

/**
 * Handles a E2EE enabled status update.
 *
 * @param {Store} store - The redux store.
 * @param {Object} conference - The conference for which we got an update.
 * @param {string} participantId - The ID of the participant from which we got an update.
 * @param {boolean} newValue - The new value of the E2EE enabled status.
 * @returns {void}
 */
function _e2eeUpdated({ getState, dispatch }: IStore, conference: IJitsiConference,
        participantId: string, newValue: string | boolean) {
    const e2eeEnabled = newValue === 'true';
    const state = getState();
    const { e2ee = {} } = state['features/base/config'];

    if (e2eeEnabled === getParticipantById(state, participantId)?.e2eeEnabled) {
        return;
    }

    dispatch(participantUpdated({
        conference,
        id: participantId,
        e2eeEnabled
    }));

    if (e2ee.externallyManagedKey) {
        return;
    }

    const { maxMode } = getState()['features/e2ee'] || {};

    if (maxMode !== MAX_MODE.THRESHOLD_EXCEEDED || !e2eeEnabled) {
        dispatch(toggleE2EE(e2eeEnabled));
    }
}

/**
 * Initializes the local participant and signals that it joined.
 *
 * @private
 * @param {Store} store - The redux store.
 * @param {Dispatch} next - The redux dispatch function to dispatch the
 * specified action to the specified store.
 * @param {Action} action - The redux action which is being dispatched
 * in the specified store.
 * @private
 * @returns {Object} The value returned by {@code next(action)}.
 */
function _localParticipantJoined({ getState, dispatch }: IStore, next: Function, action: AnyAction) {
    const result = next(action);

    const settings = getState()['features/base/settings'];

    dispatch(localParticipantJoined({
        avatarURL: settings.avatarURL,
        email: settings.email,
        name: settings.displayName,
        id: ''
    }));

    return result;
}

/**
 * Signals that the local participant has left.
 *
 * @param {Store} store - The redux store.
 * @param {Dispatch} next - The redux {@code dispatch} function to dispatch the
 * specified {@code action} into the specified {@code store}.
 * @param {Action} action - The redux action which is being dispatched in the
 * specified {@code store}.
 * @private
 * @returns {Object} The value returned by {@code next(action)}.
 */
function _localParticipantLeft({ dispatch }: IStore, next: Function, action: AnyAction) {
    const result = next(action);

    dispatch(localParticipantLeft());

    return result;
}

/**
 * Plays sounds when participants join/leave conference.
 *
 * @param {Store} store - The redux store.
 * @param {Action} action - The redux action. Should be either
 * {@link PARTICIPANT_JOINED} or {@link PARTICIPANT_LEFT}.
 * @private
 * @returns {void}
 */
function _maybePlaySounds({ getState, dispatch }: IStore, action: AnyAction) {
    const state = getState();
    const { startAudioMuted } = state['features/base/config'];
    const { soundsParticipantJoined: joinSound, soundsParticipantLeft: leftSound } = state['features/base/settings'];

    // We're not playing sounds for local participant
    // nor when the user is joining past the "startAudioMuted" limit.
    // The intention there was to not play user joined notification in big
    // conferences where 100th person is joining.
    if (!action.participant.local
            && (!startAudioMuted
                || getParticipantCount(state) < startAudioMuted)) {
        const { isReplacing, isReplaced } = action.participant;

        if (action.type === PARTICIPANT_JOINED) {
            if (!joinSound) {
                return;
            }
            const { presence } = action.participant;

            // The sounds for the poltergeist are handled by features/invite.
            if (presence !== INVITED && presence !== CALLING && !isReplacing) {
                dispatch(playSound(PARTICIPANT_JOINED_SOUND_ID));
            }
        } else if (action.type === PARTICIPANT_LEFT && !isReplaced && leftSound) {
            dispatch(playSound(PARTICIPANT_LEFT_SOUND_ID));
        }
    }
}

/**
 * Notifies the feature base/participants that the action
 * {@code PARTICIPANT_JOINED} or {@code PARTICIPANT_UPDATED} is being dispatched
 * within a specific redux store.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @param {Dispatch} next - The redux {@code dispatch} function to dispatch the
 * specified {@code action} in the specified {@code store}.
 * @param {Action} action - The redux action {@code PARTICIPANT_JOINED} or
 * {@code PARTICIPANT_UPDATED} which is being dispatched in the specified
 * {@code store}.
 * @private
 * @returns {Object} The value returned by {@code next(action)}.
 */
function _participantJoinedOrUpdated(store: IStore, next: Function, action: AnyAction) {
    const { dispatch, getState } = store;
    const { overwrittenNameList } = store.getState()['features/base/participants'];
    const { participant: {
        avatarURL,
        email,
        id,
        local,
        localRecording,
        name,
        raisedHandTimestamp
    } } = action;

    // Send an external update of the local participant's raised hand state
    // if a new raised hand state is defined in the action.
    if (typeof raisedHandTimestamp !== 'undefined') {
        if (local) {
            const { conference } = getState()['features/base/conference'];
            const rHand = parseInt(raisedHandTimestamp, 10);

            // Send raisedHand signalling only if there is a change
            if (conference && rHand !== getLocalParticipant(getState())?.raisedHandTimestamp) {
                conference.setLocalParticipantProperty('raisedHand', rHand);
            }
        }
    }

    if (overwrittenNameList[id]) {
        action.participant.name = overwrittenNameList[id];
    }

    // Send an external update of the local participant's local recording state
    // if a new local recording state is defined in the action.
    if (typeof localRecording !== 'undefined') {
        if (local) {
            const conference = getCurrentConference(getState);

            // Send localRecording signalling only if there is a change
            if (conference
                && localRecording !== getLocalParticipant(getState())?.localRecording) {
                conference.setLocalParticipantProperty('localRecording', localRecording);
            }
        }
    }

    // Allow the redux update to go through and compare the old avatar
    // to the new avatar and emit out change events if necessary.
    const result = next(action);

    // Only run this if the config is populated, otherwise we preload external resources
    // even if disableThirdPartyRequests is set to true in config
    if (getState()['features/base/config']?.hosts) {
        const { disableThirdPartyRequests } = getState()['features/base/config'];

        if (!disableThirdPartyRequests && (avatarURL || email || id || name)) {
            const participantId = !id && local ? getLocalParticipant(getState())?.id : id;
            const updatedParticipant = getParticipantById(getState(), participantId);

            getFirstLoadableAvatarUrl(updatedParticipant ?? { id: '' }, store)
                .then((urlData?: { isUsingCORS: boolean; src: string; }) => {
                    dispatch(setLoadableAvatarUrl(participantId, urlData?.src ?? '', Boolean(urlData?.isUsingCORS)));
                });
        }
    }

    return result;
}

/**
 * Handles a local recording status update.
 *
 * @param {Function} dispatch - The Redux dispatch function.
 * @param {Object} conference - The conference for which we got an update.
 * @param {string} participantId - The ID of the participant from which we got an update.
 * @param {boolean} newValue - The new value of the local recording status.
 * @returns {void}
 */
function _localRecordingUpdated({ dispatch, getState }: IStore, conference: IJitsiConference,
        participantId: string, newValue: string) {
    const state = getState();

    dispatch(participantUpdated({
        conference,
        id: participantId,
        localRecording: newValue
    }));
    const participantName = getParticipantDisplayName(state, participantId);

    dispatch(showNotification({
        titleKey: 'notify.somebody',
        title: participantName,
        descriptionKey: newValue ? 'notify.localRecordingStarted' : 'notify.localRecordingStopped',
        uid: LOCAL_RECORDING_NOTIFICATION_ID
    }, NOTIFICATION_TIMEOUT_TYPE.MEDIUM));
    dispatch(playSound(newValue ? RECORDING_ON_SOUND_ID : RECORDING_OFF_SOUND_ID));
}


/**
 * Handles a raise hand status update.
 *
 * @param {Function} dispatch - The Redux dispatch function.
 * @param {Object} conference - The conference for which we got an update.
 * @param {string} participantId - The ID of the participant from which we got an update.
 * @param {boolean} newValue - The new value of the raise hand status.
 * @returns {void}
 */
function _raiseHandUpdated({ dispatch, getState }: IStore, conference: IJitsiConference,
        participantId: string, newValue: string | number) {
    let raisedHandTimestamp;

    switch (newValue) {
    case undefined:
    case 'false':
        raisedHandTimestamp = 0;
        break;
    case 'true':
        raisedHandTimestamp = Date.now();
        break;
    default:
        raisedHandTimestamp = parseInt(`${newValue}`, 10);
    }
    const state = getState();

    dispatch(participantUpdated({
        conference,
        id: participantId,
        raisedHandTimestamp
    }));

    dispatch(raiseHandUpdateQueue({
        id: participantId,
        raisedHandTimestamp
    }));

    if (typeof APP !== 'undefined') {
        APP.API.notifyRaiseHandUpdated(participantId, raisedHandTimestamp);
    }

    const isModerator = isLocalParticipantModerator(state);
    const participant = getParticipantById(state, participantId);
    let shouldDisplayAllowAction = false;

    if (isModerator) {
        shouldDisplayAllowAction = isForceMuted(participant, MEDIA_TYPE.AUDIO, state)
            || isForceMuted(participant, MEDIA_TYPE.VIDEO, state);
    }

    let action;

    if (shouldDisplayAllowAction) {
        action = {
            customActionNameKey: [ 'notify.allowAction' ],
            customActionHandler: [ () => dispatch(approveParticipant(participantId)) ]
        };
    } else {
        action = {
            customActionNameKey: [ 'notify.viewParticipants' ],
            customActionHandler: [ () => dispatch(openParticipantsPane()) ]
        };
    }

    if (raisedHandTimestamp) {
        let notificationTitle;
        const participantName = getParticipantDisplayName(state, participantId);
        const { raisedHandsQueue } = state['features/base/participants'];

        if (raisedHandsQueue.length > 1) {
            const raisedHands = raisedHandsQueue.length - 1;

            notificationTitle = i18n.t('notify.raisedHands', {
                participantName,
                raisedHands
            });
        } else {
            notificationTitle = participantName;
        }
        dispatch(showNotification({
            titleKey: 'notify.somebody',
            title: notificationTitle,
            descriptionKey: 'notify.raisedHand',
            concatText: true,
            uid: RAISE_HAND_NOTIFICATION_ID,
            ...action
        }, NOTIFICATION_TIMEOUT_TYPE.MEDIUM));
        dispatch(playSound(RAISE_HAND_SOUND_ID));
    }
}

/**
 * Registers sounds related with the participants feature.
 *
 * @param {Store} store - The redux store.
 * @private
 * @returns {void}
 */
function _registerSounds({ dispatch }: IStore) {
    dispatch(
        registerSound(PARTICIPANT_JOINED_SOUND_ID, PARTICIPANT_JOINED_FILE));
    dispatch(registerSound(PARTICIPANT_LEFT_SOUND_ID, PARTICIPANT_LEFT_FILE));
}

/**
 * Unregisters sounds related with the participants feature.
 *
 * @param {Store} store - The redux store.
 * @private
 * @returns {void}
 */
function _unregisterSounds({ dispatch }: IStore) {
    dispatch(unregisterSound(PARTICIPANT_JOINED_SOUND_ID));
    dispatch(unregisterSound(PARTICIPANT_LEFT_SOUND_ID));
}


################################################################################

## File: .\jitsi-meet\react\features\base\participants\preloadImage.native.ts

import { Image } from 'react-native';

import { isIconUrl } from './functions';

/**
 * Tries to preload an image.
 *
 * @param {string | Object} src - Source of the avatar.
 * @param {boolean} _isUsingCORS - Used on web.
 * @returns {Promise}
 */
export function preloadImage(src: string | Object, _isUsingCORS: boolean): Promise<any> {
    if (isIconUrl(src)) {
        return Promise.resolve(src);
    }

    return new Promise((resolve, reject) => {
        // @ts-ignore
        Image.prefetch(src).then(
            () => resolve({
                src,
                isUsingCORS: false
            }),
            reject);
    });
}


################################################################################

## File: .\jitsi-meet\react\features\base\participants\preloadImage.web.ts


import { isIconUrl } from './functions';

/**
 * Tries to preload an image.
 *
 * @param {string | Object} src - Source of the avatar.
 * @param {boolean} useCORS - Whether to use CORS or not.
 * @param {boolean} tryOnce - If true we try to load the image only using the specified CORS mode. Otherwise both modes
 * (CORS and no CORS) will be used to load the image if the first attempt fails.
 * @returns {Promise}
 */
export function preloadImage(
        src: string,
        useCORS = false,
        tryOnce = false
): Promise<{ isUsingCORS?: boolean; src: string | Object; }> {
    if (isIconUrl(src)) {
        return Promise.resolve({ src });
    }

    return new Promise((resolve, reject) => {
        const image = document.createElement('img');

        if (useCORS) {
            image.setAttribute('crossOrigin', '');
        }
        image.onload = () => resolve({
            src,
            isUsingCORS: useCORS
        });
        image.onerror = error => {
            if (tryOnce) {
                reject(error);
            } else {
                preloadImage(src, !useCORS, true)
                    .then(resolve)
                    .catch(reject);
            }
        };

        image.referrerPolicy = 'no-referrer';

        image.src = src;
    });
}


################################################################################

## File: .\jitsi-meet\react\features\base\participants\reducer.ts

import { AnyAction } from 'redux';

import { MEDIA_TYPE } from '../media/constants';
import ReducerRegistry from '../redux/ReducerRegistry';
import { set } from '../redux/functions';

import {
    DOMINANT_SPEAKER_CHANGED,
    NOTIFIED_TO_SPEAK,
    OVERWRITE_PARTICIPANT_NAME,
    PARTICIPANT_ID_CHANGED,
    PARTICIPANT_JOINED,
    PARTICIPANT_LEFT,
    PARTICIPANT_SOURCES_UPDATED,
    PARTICIPANT_UPDATED,
    PIN_PARTICIPANT,
    RAISE_HAND_CLEAR,
    RAISE_HAND_UPDATED,
    SCREENSHARE_PARTICIPANT_NAME_CHANGED,
    SET_LOADABLE_AVATAR_URL
} from './actionTypes';
import { LOCAL_PARTICIPANT_DEFAULT_ID, PARTICIPANT_ROLE } from './constants';
import {
    isLocalScreenshareParticipant,
    isParticipantModerator,
    isRemoteScreenshareParticipant,
    isScreenShareParticipant
} from './functions';
import { FakeParticipant, ILocalParticipant, IParticipant, ISourceInfo } from './types';

/**
 * Participant object.
 *
 * @typedef {Object} Participant
 * @property {string} id - Participant ID.
 * @property {string} name - Participant name.
 * @property {string} avatar - Path to participant avatar if any.
 * @property {string} role - Participant role.
 * @property {boolean} local - If true, participant is local.
 * @property {boolean} pinned - If true, participant is currently a
 * "PINNED_ENDPOINT".
 * @property {boolean} dominantSpeaker - If this participant is the dominant
 * speaker in the (associated) conference, {@code true}; otherwise,
 * {@code false}.
 * @property {string} email - Participant email.
 */

/**
 * The participant properties which cannot be updated through
 * {@link PARTICIPANT_UPDATED}. They either identify the participant or can only
 * be modified through property-dedicated actions.
 *
 * @type {string[]}
 */
const PARTICIPANT_PROPS_TO_OMIT_WHEN_UPDATE = [

    // The following properties identify the participant:
    'conference',
    'id',
    'local',

    // The following properties can only be modified through property-dedicated
    // actions:
    'dominantSpeaker',
    'pinned'
];

const DEFAULT_STATE = {
    dominantSpeaker: undefined,
    fakeParticipants: new Map(),
    local: undefined,
    localScreenShare: undefined,
    numberOfNonModeratorParticipants: 0,
    numberOfParticipantsDisabledE2EE: 0,
    numberOfParticipantsNotSupportingE2EE: 0,
    overwrittenNameList: {},
    pinnedParticipant: undefined,
    raisedHandsQueue: [],
    remote: new Map(),
    remoteVideoSources: new Set<string>(),
    sortedRemoteVirtualScreenshareParticipants: new Map(),
    sortedRemoteParticipants: new Map(),
    speakersList: new Map()
};

export interface IParticipantsState {
    dominantSpeaker?: string;
    fakeParticipants: Map<string, IParticipant>;
    local?: ILocalParticipant;
    localScreenShare?: IParticipant;
    numberOfNonModeratorParticipants: number;
    numberOfParticipantsDisabledE2EE: number;
    numberOfParticipantsNotSupportingE2EE: number;
    overwrittenNameList: { [id: string]: string; };
    pinnedParticipant?: string;
    raisedHandsQueue: Array<{ hasBeenNotified?: boolean; id: string; raisedHandTimestamp: number; }>;
    remote: Map<string, IParticipant>;
    remoteVideoSources: Set<string>;
    sortedRemoteParticipants: Map<string, string>;
    sortedRemoteVirtualScreenshareParticipants: Map<string, string>;
    speakersList: Map<string, string>;
}

/**
 * Listen for actions which add, remove, or update the set of participants in
 * the conference.
 *
 * @param {IParticipant[]} state - List of participants to be modified.
 * @param {Object} action - Action object.
 * @param {string} action.type - Type of action.
 * @param {IParticipant} action.participant - Information about participant to be
 * added/removed/modified.
 * @returns {IParticipant[]}
 */
ReducerRegistry.register<IParticipantsState>('features/base/participants',
(state = DEFAULT_STATE, action): IParticipantsState => {
    switch (action.type) {
    case NOTIFIED_TO_SPEAK: {
        return {
            ...state,
            raisedHandsQueue: state.raisedHandsQueue.map((item, index) => {
                if (index === 0) {

                    return {
                        ...item,
                        hasBeenNotified: true
                    };
                }

                return item;
            })
        };
    }

    case PARTICIPANT_ID_CHANGED: {
        const { local } = state;

        if (local) {
            if (action.newValue === 'local' && state.raisedHandsQueue.find(pid => pid.id === local.id)) {
                state.raisedHandsQueue = state.raisedHandsQueue.filter(pid => pid.id !== local.id);
            }
            state.local = {
                ...local,
                id: action.newValue
            };

            return {
                ...state
            };
        }

        return state;
    }
    case DOMINANT_SPEAKER_CHANGED: {
        const { participant } = action;
        const { id, previousSpeakers = [] } = participant;
        const { dominantSpeaker, local } = state;
        const newSpeakers = [ id, ...previousSpeakers ];
        const sortedSpeakersList: Array<Array<string>> = [];

        for (const speaker of newSpeakers) {
            if (speaker !== local?.id) {
                const remoteParticipant = state.remote.get(speaker);

                remoteParticipant
                && sortedSpeakersList.push(
                    [ speaker, _getDisplayName(state, remoteParticipant?.name) ]
                );
            }
        }

        // Keep the remote speaker list sorted alphabetically.
        sortedSpeakersList.sort((a, b) => a[1].localeCompare(b[1]));

        // Only one dominant speaker is allowed.
        if (dominantSpeaker) {
            _updateParticipantProperty(state, dominantSpeaker, 'dominantSpeaker', false);
        }

        if (_updateParticipantProperty(state, id, 'dominantSpeaker', true)) {
            return {
                ...state,
                dominantSpeaker: id, // @ts-ignore
                speakersList: new Map(sortedSpeakersList)
            };
        }

        delete state.dominantSpeaker;

        return {
            ...state
        };
    }
    case PIN_PARTICIPANT: {
        const { participant } = action;
        const { id } = participant;
        const { pinnedParticipant } = state;

        // Only one pinned participant is allowed.
        if (pinnedParticipant) {
            _updateParticipantProperty(state, pinnedParticipant, 'pinned', false);
        }

        if (id && _updateParticipantProperty(state, id, 'pinned', true)) {
            return {
                ...state,
                pinnedParticipant: id
            };
        }

        delete state.pinnedParticipant;

        return {
            ...state
        };
    }
    case SET_LOADABLE_AVATAR_URL:
    case PARTICIPANT_UPDATED: {
        const { participant } = action;
        let { id } = participant;
        const { local } = participant;

        if (!id && local) {
            id = LOCAL_PARTICIPANT_DEFAULT_ID;
        }

        let newParticipant: IParticipant | null = null;
        const oldParticipant = local || state.local?.id === id ? state.local : state.remote.get(id);

        if (state.remote.has(id)) {
            newParticipant = _participant(oldParticipant, action);
            state.remote.set(id, newParticipant);
        } else if (id === state.local?.id) {
            newParticipant = state.local = _participant(state.local, action);
        }

        if (oldParticipant && newParticipant && !newParticipant.fakeParticipant) {
            const isModerator = isParticipantModerator(newParticipant);

            if (isParticipantModerator(oldParticipant) !== isModerator) {
                state.numberOfNonModeratorParticipants += isModerator ? -1 : 1;
            }

            const e2eeEnabled = Boolean(newParticipant.e2eeEnabled);
            const e2eeSupported = Boolean(newParticipant.e2eeSupported);

            if (Boolean(oldParticipant.e2eeEnabled) !== e2eeEnabled) {
                state.numberOfParticipantsDisabledE2EE += e2eeEnabled ? -1 : 1;
            }
            if (!local && Boolean(oldParticipant.e2eeSupported) !== e2eeSupported) {
                state.numberOfParticipantsNotSupportingE2EE += e2eeSupported ? -1 : 1;
            }
        }

        return {
            ...state
        };
    }
    case SCREENSHARE_PARTICIPANT_NAME_CHANGED: {
        const { id, name } = action;

        if (state.sortedRemoteVirtualScreenshareParticipants.has(id)) {
            state.sortedRemoteVirtualScreenshareParticipants.delete(id);

            const sortedRemoteVirtualScreenshareParticipants = [ ...state.sortedRemoteVirtualScreenshareParticipants ];

            sortedRemoteVirtualScreenshareParticipants.push([ id, name ]);
            sortedRemoteVirtualScreenshareParticipants.sort((a, b) => a[1].localeCompare(b[1]));

            state.sortedRemoteVirtualScreenshareParticipants = new Map(sortedRemoteVirtualScreenshareParticipants);
        }

        return { ...state };
    }

    case PARTICIPANT_JOINED: {
        const participant = _participantJoined(action);
        const {
            fakeParticipant,
            id,
            name,
            pinned,
            sources
        } = participant;
        const { pinnedParticipant, dominantSpeaker } = state;

        if (pinned) {
            if (pinnedParticipant) {
                _updateParticipantProperty(state, pinnedParticipant, 'pinned', false);
            }

            state.pinnedParticipant = id;
        }

        if (participant.dominantSpeaker) {
            if (dominantSpeaker) {
                _updateParticipantProperty(state, dominantSpeaker, 'dominantSpeaker', false);
            }
            state.dominantSpeaker = id;
        }

        if (!fakeParticipant) {
            const isModerator = isParticipantModerator(participant);

            if (!isModerator) {
                state.numberOfNonModeratorParticipants += 1;
            }

            const { e2eeEnabled, e2eeSupported } = participant as IParticipant;

            if (!e2eeEnabled) {
                state.numberOfParticipantsDisabledE2EE += 1;
            }

            if (!participant.local && !e2eeSupported) {
                state.numberOfParticipantsNotSupportingE2EE += 1;
            }
        }

        if (participant.local) {
            return {
                ...state,
                local: participant
            };
        }

        if (isLocalScreenshareParticipant(participant)) {
            return {
                ...state,
                localScreenShare: participant
            };
        }

        state.remote.set(id, participant);

        if (sources?.size) {
            const videoSources: Map<string, ISourceInfo> | undefined = sources.get(MEDIA_TYPE.VIDEO);

            if (videoSources?.size) {
                const newRemoteVideoSources = new Set(state.remoteVideoSources);

                for (const source of videoSources.keys()) {
                    newRemoteVideoSources.add(source);
                }
                state.remoteVideoSources = newRemoteVideoSources;
            }
        }

        // Insert the new participant.
        const displayName = _getDisplayName(state, name);
        const sortedRemoteParticipants = Array.from(state.sortedRemoteParticipants);

        sortedRemoteParticipants.push([ id, displayName ]);
        sortedRemoteParticipants.sort((a, b) => a[1].localeCompare(b[1]));

        // The sort order of participants is preserved since Map remembers the original insertion order of the keys.
        state.sortedRemoteParticipants = new Map(sortedRemoteParticipants);

        if (isRemoteScreenshareParticipant(participant)) {
            const sortedRemoteVirtualScreenshareParticipants = [ ...state.sortedRemoteVirtualScreenshareParticipants ];

            sortedRemoteVirtualScreenshareParticipants.push([ id, name ?? '' ]);
            sortedRemoteVirtualScreenshareParticipants.sort((a, b) => a[1].localeCompare(b[1]));

            state.sortedRemoteVirtualScreenshareParticipants = new Map(sortedRemoteVirtualScreenshareParticipants);
        }

        // Exclude the screenshare participant from the fake participant count to avoid duplicates.
        if (fakeParticipant && !isScreenShareParticipant(participant)) {
            state.fakeParticipants.set(id, participant);
        }

        return { ...state };

    }
    case PARTICIPANT_LEFT: {
        // XXX A remote participant is uniquely identified by their id in a
        // specific JitsiConference instance. The local participant is uniquely
        // identified by the very fact that there is only one local participant
        // (and the fact that the local participant "joins" at the beginning of
        // the app and "leaves" at the end of the app).
        const { conference, id } = action.participant;
        const {
            fakeParticipants,
            sortedRemoteVirtualScreenshareParticipants,
            remote,
            local,
            localScreenShare,
            dominantSpeaker,
            pinnedParticipant
        } = state;
        let oldParticipant = remote.get(id);
        let isLocalScreenShare = false;

        if (oldParticipant && oldParticipant.conference === conference) {
            remote.delete(id);
        } else if (local?.id === id) {
            oldParticipant = state.local;
            delete state.local;
        } else if (localScreenShare?.id === id) {
            isLocalScreenShare = true;
            oldParticipant = state.local;
            delete state.localScreenShare;
        } else {
            // no participant found
            return state;
        }

        if (oldParticipant?.sources?.size) {
            const videoSources: Map<string, ISourceInfo> | undefined = oldParticipant.sources.get(MEDIA_TYPE.VIDEO);

            if (videoSources?.size) {
                const newRemoteVideoSources = new Set(state.remoteVideoSources);

                for (const source of videoSources.keys()) {
                    newRemoteVideoSources.delete(source);
                }

                state.remoteVideoSources = newRemoteVideoSources;
            }
        } else if (oldParticipant?.fakeParticipant === FakeParticipant.RemoteScreenShare) {
            const newRemoteVideoSources = new Set(state.remoteVideoSources);

            if (newRemoteVideoSources.delete(id)) {
                state.remoteVideoSources = newRemoteVideoSources;
            }
        }

        state.sortedRemoteParticipants.delete(id);
        state.raisedHandsQueue = state.raisedHandsQueue.filter(pid => pid.id !== id);

        if (dominantSpeaker === id) {
            state.dominantSpeaker = undefined;
        }

        // Remove the participant from the list of speakers.
        state.speakersList.has(id) && state.speakersList.delete(id);

        if (pinnedParticipant === id) {
            state.pinnedParticipant = undefined;
        }

        if (fakeParticipants.has(id)) {
            fakeParticipants.delete(id);
        }

        if (sortedRemoteVirtualScreenshareParticipants.has(id)) {
            sortedRemoteVirtualScreenshareParticipants.delete(id);
            state.sortedRemoteVirtualScreenshareParticipants = new Map(sortedRemoteVirtualScreenshareParticipants);
        }

        if (oldParticipant && !oldParticipant.fakeParticipant && !isLocalScreenShare) {
            const { e2eeEnabled, e2eeSupported } = oldParticipant;

            if (!isParticipantModerator(oldParticipant)) {
                state.numberOfNonModeratorParticipants -= 1;
            }

            if (!e2eeEnabled) {
                state.numberOfParticipantsDisabledE2EE -= 1;
            }

            if (!oldParticipant.local && !e2eeSupported) {
                state.numberOfParticipantsNotSupportingE2EE -= 1;
            }
        }

        return { ...state };
    }
    case PARTICIPANT_SOURCES_UPDATED: {
        const { id, sources } = action.participant;
        const participant = state.remote.get(id);

        if (participant) {
            participant.sources = sources;
            const videoSources: Map<string, ISourceInfo> = sources.get(MEDIA_TYPE.VIDEO);

            if (videoSources?.size) {
                const newRemoteVideoSources = new Set(state.remoteVideoSources);

                for (const source of videoSources.keys()) {
                    newRemoteVideoSources.add(source);
                }
                state.remoteVideoSources = newRemoteVideoSources;
            }
        }

        return { ...state };
    }
    case RAISE_HAND_CLEAR: {
        return {
            ...state,
            raisedHandsQueue: []
        };
    }
    case RAISE_HAND_UPDATED: {
        return {
            ...state,
            raisedHandsQueue: action.queue
        };
    }
    case OVERWRITE_PARTICIPANT_NAME: {
        const { id, name } = action;

        return {
            ...state,
            overwrittenNameList: {
                ...state.overwrittenNameList,
                [id]: name
            }
        };
    }
    }

    return state;
});

/**
 * Returns the participant's display name, default string if display name is not set on the participant.
 *
 * @param {Object} state - The local participant redux state.
 * @param {string} name - The display name of the participant.
 * @returns {string}
 */
function _getDisplayName(state: Object, name?: string): string {
    // @ts-ignore
    const config = state['features/base/config'];

    return name ?? (config?.defaultRemoteDisplayName || 'Fellow Jitster');
}

/**
 * Reducer function for a single participant.
 *
 * @param {IParticipant|undefined} state - Participant to be modified.
 * @param {Object} action - Action object.
 * @param {string} action.type - Type of action.
 * @param {IParticipant} action.participant - Information about participant to be
 * added/modified.
 * @param {JitsiConference} action.conference - Conference instance.
 * @private
 * @returns {IParticipant}
 */
function _participant(state: IParticipant | ILocalParticipant = { id: '' },
        action: AnyAction): IParticipant | ILocalParticipant {
    switch (action.type) {
    case SET_LOADABLE_AVATAR_URL:
    case PARTICIPANT_UPDATED: {
        const { participant } = action; // eslint-disable-line no-shadow

        const newState = { ...state };

        for (const key in participant) {
            if (participant.hasOwnProperty(key)
                    && PARTICIPANT_PROPS_TO_OMIT_WHEN_UPDATE.indexOf(key)
                        === -1) {
                // @ts-ignore
                newState[key] = participant[key];
            }
        }

        return newState;
    }
    }

    return state;
}

/**
 * Reduces a specific redux action of type {@link PARTICIPANT_JOINED} in the
 * feature base/participants.
 *
 * @param {Action} action - The redux action of type {@code PARTICIPANT_JOINED}
 * to reduce.
 * @private
 * @returns {Object} The new participant derived from the payload of the
 * specified {@code action} to be added into the redux state of the feature
 * base/participants after the reduction of the specified
 * {@code action}.
 */
function _participantJoined({ participant }: { participant: IParticipant; }) {
    const {
        avatarURL,
        botType,
        dominantSpeaker,
        email,
        fakeParticipant,
        isReplacing,
        loadableAvatarUrl,
        local,
        name,
        pinned,
        presence,
        role,
        sources
    } = participant;
    let { conference, id } = participant;

    if (local) {
        // conference
        //
        // XXX The local participant is not identified in association with a
        // JitsiConference because it is identified by the very fact that it is
        // the local participant.
        conference = undefined;

        // id
        id || (id = LOCAL_PARTICIPANT_DEFAULT_ID);
    }

    return {
        avatarURL,
        botType,
        conference,
        dominantSpeaker: dominantSpeaker || false,
        email,
        fakeParticipant,
        id,
        isReplacing,
        loadableAvatarUrl,
        local: local || false,
        name,
        pinned: pinned || false,
        presence,
        role: role || PARTICIPANT_ROLE.NONE,
        sources
    };
}

/**
 * Updates a specific property for a participant.
 *
 * @param {State} state - The redux state.
 * @param {string} id - The ID of the participant.
 * @param {string} property - The property to update.
 * @param {*} value - The new value.
 * @returns {boolean} - True if a participant was updated and false otherwise.
 */
function _updateParticipantProperty(state: IParticipantsState, id: string, property: string, value: boolean) {
    const { remote, local, localScreenShare } = state;

    if (remote.has(id)) {
        remote.set(id, set(remote.get(id) ?? {
            id: '',
            name: ''
        }, property as keyof IParticipant, value));

        return true;
    } else if (local?.id === id || local?.id === 'local') {
        // The local participant's ID can chance from something to "local" when
        // not in a conference.
        state.local = set(local, property as keyof ILocalParticipant, value);

        return true;

    } else if (localScreenShare?.id === id) {
        state.localScreenShare = set(localScreenShare, property as keyof IParticipant, value);

        return true;
    }

    return false;
}


################################################################################

## File: .\jitsi-meet\react\features\base\participants\sounds.ts

/**
 * The name of the bundled sound file which will be played when new participant
 * joins the conference.
 */
export const PARTICIPANT_JOINED_FILE = 'joined.mp3';

/**
 * The name of the bundled sound file which will be played when any participant
 * leaves the conference.
 */
export const PARTICIPANT_LEFT_FILE = 'left.mp3';


################################################################################

## File: .\jitsi-meet\react\features\base\participants\subscriber.ts


import { difference } from 'lodash-es';
import { batch } from 'react-redux';

import { IStore } from '../../app/types';
import { hideNotification, showNotification } from '../../notifications/actions';
import { NOTIFICATION_TIMEOUT_TYPE, RAISE_HAND_NOTIFICATION_ID } from '../../notifications/constants';
import { getCurrentConference } from '../conference/functions';
import {
    getDisableNextSpeakerNotification,
    getSsrcRewritingFeatureFlag,
    hasBeenNotified,
    isNextToSpeak } from '../config/functions.any';
import { VIDEO_TYPE } from '../media/constants';
import StateListenerRegistry from '../redux/StateListenerRegistry';

import { NOTIFIED_TO_SPEAK } from './actionTypes';
import { createVirtualScreenshareParticipant, participantLeft } from './actions';
import {
    getParticipantById,
    getRemoteScreensharesBasedOnPresence,
    getVirtualScreenshareParticipantOwnerId
} from './functions';
import { FakeParticipant } from './types';

StateListenerRegistry.register(
    /* selector */ state => state['features/base/tracks'],
    /* listener */(tracks, store) => _updateScreenshareParticipants(store)
);

StateListenerRegistry.register(
    /* selector */ state => state['features/base/participants'].remoteVideoSources,
    /* listener */(remoteVideoSources, store) => getSsrcRewritingFeatureFlag(store.getState())
        && _updateScreenshareParticipantsBasedOnPresence(store)
);

StateListenerRegistry.register(
    /* selector */ state => state['features/base/participants'].raisedHandsQueue,
    /* listener */ (raisedHandsQueue, store) => {
        if (raisedHandsQueue.length
            && isNextToSpeak(store.getState())
            && !hasBeenNotified(store.getState())
            && !getDisableNextSpeakerNotification(store.getState())
            && !store.getState()['features/visitors'].iAmVisitor) { // visitors raise hand to be promoted
            _notifyNextSpeakerInRaisedHandQueue(store);
        }
        if (!raisedHandsQueue[0]) {
            store.dispatch(hideNotification(RAISE_HAND_NOTIFICATION_ID));
        }
    }
);

/**
 * Compares the old and new screenshare lists provided and creates/removes the virtual screenshare participant
 * tiles accodingly.
 *
 * @param {Array<string>} oldScreenshareSourceNames - List of old screenshare source names.
 * @param {Array<string>} newScreenshareSourceNames - Current list of screenshare source names.
 * @param {Object} store - The redux store.
 * @returns {void}
 */
function _createOrRemoveVirtualParticipants(
        oldScreenshareSourceNames: string[],
        newScreenshareSourceNames: string[],
        store: IStore): void {
    const { dispatch, getState } = store;
    const conference = getCurrentConference(getState());
    const removedScreenshareSourceNames = difference(oldScreenshareSourceNames, newScreenshareSourceNames);
    const addedScreenshareSourceNames = difference(newScreenshareSourceNames, oldScreenshareSourceNames);

    if (removedScreenshareSourceNames.length) {
        removedScreenshareSourceNames.forEach(id => dispatch(participantLeft(id, conference, {
            fakeParticipant: FakeParticipant.RemoteScreenShare
        })));
    }

    if (addedScreenshareSourceNames.length) {
        addedScreenshareSourceNames.forEach(id => dispatch(
            createVirtualScreenshareParticipant(id, false, conference)));
    }
}

/**
 * Handles creating and removing virtual screenshare participants.
 *
 * @param {*} store - The redux store.
 * @returns {void}
 */
function _updateScreenshareParticipants(store: IStore): void {
    const { dispatch, getState } = store;
    const state = getState();
    const conference = getCurrentConference(state);
    const tracks = state['features/base/tracks'];
    const { sortedRemoteVirtualScreenshareParticipants, localScreenShare } = state['features/base/participants'];
    const previousScreenshareSourceNames = [ ...sortedRemoteVirtualScreenshareParticipants.keys() ];

    let newLocalSceenshareSourceName;

    const currentScreenshareSourceNames = tracks.reduce((acc: string[], track) => {
        if (track.videoType === VIDEO_TYPE.DESKTOP && !track.jitsiTrack.isMuted()) {
            const sourceName: string = track.jitsiTrack.getSourceName();

            // Ignore orphan tracks in ssrc-rewriting mode.
            if (!sourceName && getSsrcRewritingFeatureFlag(state)) {
                return acc;
            }
            if (track.local) {
                newLocalSceenshareSourceName = sourceName;
            } else if (getParticipantById(state, getVirtualScreenshareParticipantOwnerId(sourceName))) {
                acc.push(sourceName);
            }
        }

        return acc;
    }, []);

    if (!localScreenShare && newLocalSceenshareSourceName) {
        dispatch(createVirtualScreenshareParticipant(newLocalSceenshareSourceName, true, conference));
    }

    if (localScreenShare && !newLocalSceenshareSourceName) {
        dispatch(participantLeft(localScreenShare.id, conference, {
            fakeParticipant: FakeParticipant.LocalScreenShare
        }));
    }

    if (getSsrcRewritingFeatureFlag(state)) {
        return;
    }

    _createOrRemoveVirtualParticipants(previousScreenshareSourceNames, currentScreenshareSourceNames, store);
}

/**
 * Handles the creation and removal of remote virtual screenshare participants when ssrc-rewriting is enabled.
 *
 * @param {Object} store - The redux store.
 * @returns {void}
 */
function _updateScreenshareParticipantsBasedOnPresence(store: IStore): void {
    const { getState } = store;
    const state = getState();
    const { sortedRemoteVirtualScreenshareParticipants } = state['features/base/participants'];
    const previousScreenshareSourceNames = [ ...sortedRemoteVirtualScreenshareParticipants.keys() ];
    const currentScreenshareSourceNames = getRemoteScreensharesBasedOnPresence(state);

    _createOrRemoveVirtualParticipants(previousScreenshareSourceNames, currentScreenshareSourceNames, store);
}

/**
 * Handles notifying the next speaker in the raised hand queue.
 *
 * @param {*} store - The redux store.
 * @returns {void}
 */
function _notifyNextSpeakerInRaisedHandQueue(store: IStore): void {
    const { dispatch } = store;

    batch(() => {
        dispatch(showNotification({
            titleKey: 'notify.nextToSpeak',
            maxLines: 2
        }, NOTIFICATION_TIMEOUT_TYPE.MEDIUM));
        dispatch({
            type: NOTIFIED_TO_SPEAK
        });
    });
}


################################################################################

## File: .\jitsi-meet\react\features\base\participants\types.ts

import { IJitsiConference } from '../conference/reducer';

export enum FakeParticipant {
    LocalScreenShare = 'LocalScreenShare',
    RemoteScreenShare = 'RemoteScreenShare',
    SharedVideo = 'SharedVideo',
    Whiteboard = 'Whiteboard'
}

export interface IParticipant {
    avatarURL?: string;
    botType?: string;
    conference?: IJitsiConference;
    displayName?: string;
    dominantSpeaker?: boolean;
    e2eeEnabled?: boolean;
    e2eeSupported?: boolean;
    e2eeVerificationAvailable?: boolean;
    e2eeVerified?: boolean;
    email?: string;
    fakeParticipant?: FakeParticipant;
    features?: IParticipantFeatures;
    getId?: Function;
    id: string;
    isJigasi?: boolean;
    isReplaced?: boolean;
    isReplacing?: number;
    isSilent?: boolean;
    jwtId?: string;
    loadableAvatarUrl?: string;
    loadableAvatarUrlUseCORS?: boolean;
    local?: boolean;
    localRecording?: string;
    name?: string;
    pinned?: boolean;
    presence?: string;
    raisedHandTimestamp?: number;
    region?: string;
    remoteControlSessionStatus?: boolean;
    role?: string;
    sources?: Map<string, Map<string, ISourceInfo>>;
    supportsRemoteControl?: boolean;
}

export interface ILocalParticipant extends IParticipant {
    audioOutputDeviceId?: string;
    cameraDeviceId?: string;
    jwtId?: string;
    micDeviceId?: string;
    startWithAudioMuted?: boolean;
    startWithVideoMuted?: boolean;
    userSelectedMicDeviceId?: string;
    userSelectedMicDeviceLabel?: string;
}

export interface IParticipantFeatures {
    'branding'?: boolean | string;
    'calendar'?: boolean | string;
    'flip'?: boolean | string;
    'inbound-call'?: boolean | string;
    'livestreaming'?: boolean | string;
    'lobby'?: boolean | string;
    'moderation'?: boolean | string;
    'outbound-call'?: boolean | string;
    'recording'?: boolean | string;
    'room'?: boolean | string;
    'screen-sharing'?: boolean | string;
    'sip-inbound-call'?: boolean | string;
    'sip-outbound-call'?: boolean | string;
    'transcription'?: boolean | string;
}

export interface ISourceInfo {
    muted: boolean;
    videoType: string;
}

export interface IJitsiParticipant {
    getDisplayName: () => string;
    getId: () => string;
    getJid: () => string;
    getRole: () => string;
    getSources: () => Map<string, Map<string, ISourceInfo>>;
    isHidden: () => boolean;
}


################################################################################

## File: .\jitsi-meet\react\features\base\participants\components\styles.ts

import { BoxModel } from '../../styles/components/styles/BoxModel';
import { ColorPalette } from '../../styles/components/styles/ColorPalette';

/**
 * The styles of the feature base/participants.
 */
export default {
    /**
     * Container for the avatar in the view.
     */
    avatarContainer: {
        alignItems: 'center',
        justifyContent: 'center'
    },

    /**
     * Style for the text rendered when there is a connectivity problem.
     */
    connectionInfoText: {
        color: ColorPalette.white,
        fontSize: 12,
        marginVertical: BoxModel.margin,
        marginHorizontal: BoxModel.margin,
        textAlign: 'center'
    },

    /**
     * Style for the container of the text rendered when there is a
     * connectivity problem.
     */
    connectionInfoContainer: {
        alignSelf: 'center',
        backgroundColor: ColorPalette.darkGrey,
        borderRadius: 20,
        marginTop: BoxModel.margin
    },

    /**
     * {@code ParticipantView} Style.
     */
    participantView: {
        alignItems: 'stretch',
        flex: 1,
        justifyContent: 'center'
    }
};


################################################################################

## File: .\jitsi-meet\react\features\base\popover\functions.web.ts

const getLeftAlignedStyle = (bounds: DOMRect) => {
    return {
        position: 'fixed',
        right: `${window.innerWidth - bounds.x}px`
    };
};

const getRightAlignedStyle = (bounds: DOMRect) => {
    return {
        position: 'fixed',
        left: `${bounds.x + bounds.width}px`
    };
};

const getTopAlignedStyle = (bounds: DOMRect) => {
    return {
        position: 'fixed',
        bottom: `${window.innerHeight - bounds.y}px`
    };
};

const getBottomAlignedStyle = (bounds: DOMRect) => {
    return {
        position: 'fixed',
        top: `${bounds.y + bounds.height}px`
    };
};

const getLeftRightStartAlign = (bounds: DOMRect, size: DOMRectReadOnly) => {
    return {
        top: `${Math.min(bounds.y, window.innerHeight - size.height - 20)}px`
    };
};

const getLeftRightMidAlign = (bounds: DOMRect, size: DOMRectReadOnly) => {
    return {
        bottom: `${window.innerHeight - bounds.y - (bounds.height / 2) - (size.height / 2)}px`
    };
};

const getLeftRightEndAlign = (bounds: DOMRect, size: DOMRectReadOnly) => {
    return {
        bottom: `${Math.min(window.innerHeight - bounds.y - bounds.height, window.innerHeight - size.height)}px`
    };
};

const getTopBotStartAlign = (bounds: DOMRect) => {
    return {
        right: `${window.innerWidth - bounds.x - 6}px`
    };
};

const getTopBotMidAlign = (bounds: DOMRect, size: DOMRectReadOnly) => {
    return {
        right: `${window.innerWidth - bounds.x - (bounds.width / 2) - (size.width / 2)}px`
    };
};

const getTopBotEndAlign = (bounds: DOMRect) => {
    return {
        left: `${bounds.x + bounds.width - 6}px`
    };
};

/**
 * Gets the trigger element's and the context menu's bounds/size info and
 * computes the style to apply to the context menu to positioning it correctly
 * in regards to the given position info.
 *
 * @param {DOMRect} triggerBounds -The bounds info of the trigger html element.
 * @param {DOMRectReadOnly} dialogSize - The size info of the context menu.
 * @param {string} position - The position of the context menu in regards to the trigger element.
 *
 * @returns {Object} = The style to apply to context menu for positioning it correctly.
 */
export const getContextMenuStyle = (triggerBounds: DOMRect,
        dialogSize: DOMRectReadOnly,
        position: string) => {
    const parsed = position.split('-');

    switch (parsed[0]) {
    case 'top': {
        let alignmentStyle = {};

        if (parsed[1]) {
            alignmentStyle = parsed[1] === 'start'
                ? getTopBotStartAlign(triggerBounds)
                : getTopBotEndAlign(triggerBounds);
        } else {
            alignmentStyle = getTopBotMidAlign(triggerBounds, dialogSize);
        }

        return {
            ...getTopAlignedStyle(triggerBounds),
            ...alignmentStyle
        };
    }
    case 'bottom': {
        let alignmentStyle = {};

        if (parsed[1]) {
            alignmentStyle = parsed[1] === 'start'
                ? getTopBotStartAlign(triggerBounds)
                : getTopBotEndAlign(triggerBounds);
        } else {
            alignmentStyle = getTopBotMidAlign(triggerBounds, dialogSize);
        }

        return {
            ...getBottomAlignedStyle(triggerBounds),
            ...alignmentStyle
        };
    }
    case 'left': {
        let alignmentStyle = {};

        if (parsed[1]) {
            alignmentStyle = parsed[1] === 'start'
                ? getLeftRightStartAlign(triggerBounds, dialogSize)
                : getLeftRightEndAlign(triggerBounds, dialogSize);
        } else {
            alignmentStyle = getLeftRightMidAlign(triggerBounds, dialogSize);
        }

        return {
            ...getLeftAlignedStyle(triggerBounds),
            ...alignmentStyle
        };
    }
    case 'right': {
        let alignmentStyle = {};

        if (parsed[1]) {
            alignmentStyle = parsed[1] === 'start'
                ? getLeftRightStartAlign(triggerBounds, dialogSize)
                : getLeftRightEndAlign(triggerBounds, dialogSize);
        } else {
            alignmentStyle = getLeftRightMidAlign(triggerBounds, dialogSize);
        }

        return {
            ...getRightAlignedStyle(triggerBounds),
            ...alignmentStyle
        };
    }
    default: {
        return {
            ...getLeftAlignedStyle(triggerBounds),
            ...getLeftRightEndAlign(triggerBounds, dialogSize)
        };
    }
    }
};


################################################################################

## File: .\jitsi-meet\react\features\base\popover\components\Popover.native.ts



################################################################################

## File: .\jitsi-meet\react\features\base\premeeting\actions.web.ts

import { SET_UNSAFE_ROOM_CONSENT } from './actionTypes';

/**
 * Sets the consent of the user for joining the unsafe room.
 *
 * @param {boolean} consent - The user's consent.
 * @returns {{
 *      type: SET_UNSAFE_ROOM_CONSENT,
*       consent: boolean
* }}
 */
export function setUnsafeRoomConsent(consent: boolean) {
    return {
        type: SET_UNSAFE_ROOM_CONSENT,
        consent
    };
}


################################################################################

## File: .\jitsi-meet\react\features\base\premeeting\actionTypes.ts

/**
 * Type for setting the user's consent for unsafe room joining.
 *
 * {
 *     type: SET_UNSAFE_ROOM_CONSENT,
 *     consent: boolean
 * }
 */
export const SET_UNSAFE_ROOM_CONSENT = 'SET_UNSAFE_ROOM_CONSENT'

################################################################################

## File: .\jitsi-meet\react\features\base\premeeting\constants.ts

export const CONNECTION_TYPE = {
    GOOD: 'good',
    NON_OPTIMAL: 'nonOptimal',
    NONE: 'none',
    POOR: 'poor'
};


################################################################################

## File: .\jitsi-meet\react\features\base\premeeting\functions.ts

import { CONNECTION_TYPE } from './constants';


/**
 * The avatar size to container size ration.
 */
const ratio = 1 / 3;

/**
 * The max avatar size.
 */
const maxSize = 190;

/**
 * The window limit height over which the avatar should have the default dimension.
 */
const upperHeightLimit = 760;

/**
 * The window limit height under which the avatar should not be resized anymore.
 */
const lowerHeightLimit = 460;

/**
 * The default top margin of the avatar.
 */
const defaultMarginTop = '10%';

/**
 * The top margin of the avatar when its dimension is small.
 */
const smallMarginTop = '5%';

/**
 * Calculates avatar dimensions based on window height and position.
 *
 * @param {number} height - The window height.
 * @returns {{
 *   marginTop: string,
 *   size: number
 * }}
 */
export function calculateAvatarDimensions(height: number) {
    if (height > upperHeightLimit) {
        return {
            size: maxSize,
            marginTop: defaultMarginTop
        };
    }

    if (height > lowerHeightLimit) {
        const diff = height - lowerHeightLimit;
        const percent = diff * ratio;
        const size = Math.floor(maxSize * percent / 100);
        let marginTop = defaultMarginTop;

        if (height < 600) {
            marginTop = smallMarginTop;
        }

        return {
            size,
            marginTop
        };
    }

    return {
        size: 0,
        marginTop: '0'
    };
}

/**
 * Selector for determining the connection type & details.
 *
 * @returns {{
 *   connectionType: string,
 *   connectionDetails: string[]
 * }}
 */
export function getConnectionData() {
    return {
        connectionType: CONNECTION_TYPE.NONE,
        connectionDetails: []
    };
}


################################################################################

## File: .\jitsi-meet\react\features\base\premeeting\logger.ts

import { getLogger } from '../logging/functions';

export default getLogger('features/base/premeeting');


################################################################################

## File: .\jitsi-meet\react\features\base\premeeting\reducer.web.ts

import ReducerRegistry from '../redux/ReducerRegistry';

import { SET_UNSAFE_ROOM_CONSENT } from './actionTypes';
import { IPreMeetingState } from './types';


const DEFAULT_STATE: IPreMeetingState = {
    unsafeRoomConsent: false
};

/**
 * Listen for actions which changes the state of known and used devices.
 *
 * @param {IDevicesState} state - The Redux state of the feature features/base/devices.
 * @param {Object} action - Action object.
 * @param {string} action.type - Type of action.
 * @returns {IPreMeetingState}
 */
ReducerRegistry.register<IPreMeetingState>(
    'features/base/premeeting',
    (state = DEFAULT_STATE, action): IPreMeetingState => {
        switch (action.type) {
        case SET_UNSAFE_ROOM_CONSENT: {
            return {
                ...state,
                unsafeRoomConsent: action.consent
            };
        }
        default:
            return state;
        }
    });



################################################################################

## File: .\jitsi-meet\react\features\base\premeeting\types.ts

export interface IPreMeetingState {
    unsafeRoomConsent?: boolean;
}


################################################################################

## File: .\jitsi-meet\react\features\base\react\constants.ts

/**
 * Z-index for components that are to be rendered like an overlay, to be over
 * everything, such as modal-type of components, or dialogs.
 */
export const OVERLAY_Z_INDEX = 1000;


################################################################################

## File: .\jitsi-meet\react\features\base\react\functions.ts

import punycode from 'punycode';

/**
 * Returns the field value in a platform generic way.
 *
 * @param {Object | string} fieldParameter - The parameter passed through the change event function.
 * @returns {string}
 */
export function getFieldValue(fieldParameter: { target: { value: string; }; } | string) {
    return typeof fieldParameter === 'string' ? fieldParameter : fieldParameter?.target?.value;
}

/**
 * Formats the URL text for react-linkify.
 *
 * @param {string} text - The URL text.
 * @returns {string} - The formatted text.
 */
export function formatURLText(text = '') {
    let result;

    // In order to prevent homograph attacks we need to use punycode. Reference
    // https://github.com/tasti/react-linkify/issues/84. In the same time it seems PunycodeJS will treat the URL
    // as an email when there is '@' and will erase parts of it. This is problematic if there is a URL like
    // https://example.com/@test@@@123/test@test, punycode will truncate this to https://example.com/@test which
    // is security issue because parts of the URL are actually missing from the text that we display. That's why
    // we use punycode on valid URLs(that don't have '@' as part of the host) only for the host part of the URL.
    try {
        const url = new URL(text);
        const { host } = url;

        if (host) {
            url.host = punycode.toASCII(host);
            result = url.toString();
        }
    } catch (e) {
        // Not a valid URL
    }

    if (!result) {
        // This will be the case for invalid URLs or URLs without a host (emails for example). In this case beacuse
        // of the issue with PunycodeJS that truncates parts of the text when there is '@' we split the text by '@'
        // and use punycode for every separate part to prevent homograph attacks.
        result = text.split('@').map(punycode.toASCII)
            .join('@');
    }

    return result;
}


################################################################################

## File: .\jitsi-meet\react\features\base\react\logger.ts

import { getLogger } from '../logging/functions';

export default getLogger('features/base/react');


################################################################################

## File: .\jitsi-meet\react\features\base\react\Platform.native.ts

// Re-export react-native's Platform because we want to provide a minimal
// equivalent on Web.
import { Platform } from 'react-native';
export default Platform;


################################################################################

## File: .\jitsi-meet\react\features\base\react\Platform.web.ts

// @ts-ignore
const { maxTouchPoints, platform, userAgent } = navigator;

let OS = '',
    isPad = false;

if (userAgent.match(/Android/i)) {
    OS = 'android';
} else if (userAgent.match(/iP(ad|hone|od)/i) || (maxTouchPoints && maxTouchPoints > 2 && /MacIntel/.test(platform))) {
    OS = 'ios';
} else if (userAgent.match(/iP(ad)/i)) {
    OS = 'ios';
    isPad = true;
} else if (userAgent.match(/Mac(intosh| OS X)/i)) {
    OS = 'macos';
} else if (userAgent.match(/Windows/i)) {
    OS = 'windows';
} else if (userAgent.match(/Linux/i)) {
    OS = 'linux';
}

/**
 * Provides a minimal equivalent of react-native's Platform abstraction.
 */
export default {
    /**
     * Returns a boolean which defines if device is an iPad.
     *
     * @type {boolean}
     */
    isPad,

    /**
     * The operating system on which the application is executing.
     *
     * @type {string}
     */
    OS,

    /**
     * The operating system version on which the application is executing.
     * This is intentionally set to undefined so we can tell mobile and mobile web
     * apart easier.
     *
     * @type {number|undefined}
     */
    Version: undefined
};


################################################################################

## File: .\jitsi-meet\react\features\base\react\types.ts

import React from 'react';
import { GestureResponderEvent } from 'react-native';

export interface IIconButtonProps {
    accessibilityLabel?: string;
    color?: string;
    disabled?: boolean;
    id?: string;
    onPress?: (e?: GestureResponderEvent) => void;
    size?: number | string;
    src: Function;
    style?: Object | undefined;
    tapColor?: string;
    type?: string;
}

/**
 * Item data for <tt>NavigateSectionList</tt>.
 */
export type Item = {

    /**
     * The avatar URL or icon name.
     */
    avatar?: string;

    /**
     * The color base of the avatar.
     */
    colorBase: string;

    /**
     * An optional react element to append to the end of the Item.
     */
    elementAfter?: React.ReactNode;

    /**
     * Unique ID of the item.
     */
    id: string;

    key?: string;

    /**
     * Lines[0] - date
     * lines[1] - duration
     * lines[2] - server name.
     */
    lines: Array<string>;

    /**
     * Item title.
     */
    title: string;

    type: string;

    /**
     * Item url.
     */
    url: string;
};

/**
 * Web implementation of section data for NavigateSectionList.
 */
export type Section = {

    /**
     * Optional properties added only to fix some flow errors thrown by React
     * SectionList.
     */
    ItemSeparatorComponent?: React.ComponentType<any>;

    /**
     * Array of items in the section.
     */
    data: ReadonlyArray<Item>;

    /**
     * Unique key for the section.
     */
    key?: string;

    keyExtractor?: (item: Object) => string;

    renderItem?: (info: Object) => null | React.ReactElement<any>;

    /**
     * Section title.
     */
    title: string;

};

/**
 * Native implementation of section data for NavigateSectionList.
 *
 * When react-native's SectionList component parses through an array of sections
 * it passes the section nested within the section property of another object
 * to the renderSection method (on web for our own implementation of SectionList
 * this nesting is not implemented as there is no need for nesting).
 */
export type SectionListSection = {
    section: Section;
};


################################################################################

## File: .\jitsi-meet\react\features\base\react\components\AbstractContainer.ts

import React, { Component, ComponentType, ReactNode } from 'react';

import { StyleType, getFixedPlatformStyle } from '../../styles/functions';

/**
 * {@code AbstractContainer} Component's property types.
 */
export interface IProps {

    /**
     * An optional accessibility label to apply to the container root.
     */
    accessibilityLabel?: string;

    /**
     * Whether or not this element is an accessibility element.
     */
    accessible?: boolean;

    /**
     * React Elements to display within the component.
     */
    children?: ReactNode;

    /**
     * Class names of the component (for web).
     */
    className?: string;

    id?: string;

    /**
     * The event handler/listener to be invoked when this
     * {@code AbstractContainer} is clicked on Web or pressed on React
     * Native. If {@code onClick} is defined and {@link touchFeedback} is
     * undefined, {@code touchFeedback} is considered defined as
     * {@code true}.
     */
    onClick?: Function;

    onKeyDown?: Function;

    onKeyPress?: Function;

    role?: string;

    /**
     * The style (as in stylesheet) to be applied to this
     * {@code AbstractContainer}.
     */
    style?: StyleType | StyleType[];

    tabIndex?: number;

    /**
     * If this instance is to provide visual feedback when touched, then
     * {@code true}; otherwise, {@code false}. If {@code touchFeedback} is
     * undefined and {@link onClick} is defined, {@code touchFeedback} is
     * considered defined as {@code true}.
     */
    touchFeedback?: boolean;

    /**
     * Color to display when clicked.
     */
    underlayColor?: string;

    /**
     * If this {@code AbstractContainer} is to be visible, then {@code true}
     * or {@code false} if this instance is to be hidden or not rendered at
     * all.
     */
    visible?: boolean;
}

/**
 * Abstract (base) class for container of React {@link Component} children with
 * a style.
 *
 * @augments Component
 */
export default class AbstractContainer<P extends IProps> extends Component<P> {
    /**
     * Renders this {@code AbstractContainer} as a React {@code Component} of a
     * specific type.
     *
     * @param {string|ReactClass} type - The type of the React {@code Component}
     * which is to be rendered.
     * @param {Object|undefined} props - The read-only React {@code Component}
     * properties, if any, to render. If undefined, the props of this instance
     * will be rendered.
     * @protected
     * @returns {ReactElement}
     */
    _render(type: string | ComponentType<any>, props?: P) {
        const {
            children,
            style,

            /* eslint-disable @typescript-eslint/no-unused-vars */

            // The following properties are defined for the benefit of
            // AbstractContainer and its extenders so they are to not be
            // propagated.
            touchFeedback,
            visible,

            /* eslint-enable @typescript-eslint/no-unused-vars */

            ...filteredProps
        } = props || this.props;

        const _style = getFixedPlatformStyle(style);

        return React.createElement(type, {
            style: _style,
            ...filteredProps
        }, children);
    }
}


################################################################################

## File: .\jitsi-meet\react\features\base\react\components\AbstractPage.ts

import { Component } from 'react';

/**
 * Abstract component that defines a refreshable page to be rendered by
 * {@code PagedList}.
 */
export default class AbstractPage<P> extends Component<P> {
    /**
     * Method to be overridden by the implementing classes to refresh the data
     * content of the component.
     *
     * Note: It is a static method as the {@code Component} may not be
     * initialized yet when the UI invokes refresh (e.g. Tab change).
     *
     * @param {any} _p1 - Param 1.
     * @param {any} _p2 - Param 2.
     * @returns {void}
     */
    static refresh(_p1?: any, _p2?: any) {
        // No implementation in abstract class.
    }
}


################################################################################

## File: .\jitsi-meet\react\features\base\react\components\index.native.ts

export { default as Container } from './native/Container';
export { default as Text } from './native/Text';


################################################################################

## File: .\jitsi-meet\react\features\base\react\components\index.web.ts

export { default as Container } from './web/Container';
export { default as Text } from './web/Text';


################################################################################

## File: .\jitsi-meet\react\features\base\react\components\native\headerstyles.ts

import { StyleSheet } from 'react-native';

import ColorSchemeRegistry from '../../../color-scheme/ColorSchemeRegistry';
import { schemeColor } from '../../../color-scheme/functions';
import { BoxModel } from '../../../styles/components/styles/BoxModel';

const HEADER_FONT_SIZE = 18;
const HEADER_HEIGHT = 48;
const HEADER_PADDING = BoxModel.padding / 2;

ColorSchemeRegistry.register('Header', {

    /**
     * Style of a disabled button in the header (e.g. Next).
     */
    disabledButtonText: {
        opacity: 0.6
    },

    /**
     * Platform specific header button (e.g. Back, menu, etc).
     */
    headerButtonIcon: {
        alignSelf: 'center',
        color: schemeColor('icon'),
        fontSize: 22,
        marginRight: 12,
        padding: 8
    },

    headerButtonText: {
        color: schemeColor('text'),
        fontSize: HEADER_FONT_SIZE
    },

    /**
     * Style of the header overlay to cover the unsafe areas.
     */
    headerOverlay: {
        backgroundColor: schemeColor('background')
    },

    /**
     * Generic style for a label placed in the header.
     */
    headerText: {
        color: schemeColor('text'),
        fontSize: HEADER_FONT_SIZE
    },

    headerTextWrapper: {
        alignItems: 'center',
        justifyContent: 'center',
        left: 0,
        position: 'absolute',
        right: 0
    },

    /**
     * The top-level element of a page.
     */
    page: {
        ...StyleSheet.absoluteFillObject,
        alignItems: 'stretch',
        flex: 1,
        flexDirection: 'column',
        overflow: 'hidden'
    },

    /**
     * Base style of Header.
     */
    screenHeader: {
        alignItems: 'center',
        backgroundColor: schemeColor('background'),
        flexDirection: 'row',
        height: HEADER_HEIGHT,
        justifyContent: 'space-between',
        paddingHorizontal: BoxModel.padding,
        paddingVertical: HEADER_PADDING
    },

    statusBar: schemeColor('statusBar'),

    statusBarContent: schemeColor('statusBarContent')
});


################################################################################

## File: .\jitsi-meet\react\features\base\react\components\native\indicatorStyles.ts

import { ColorPalette } from '../../../styles/components/styles/ColorPalette';

export default {

    /**
     * Base indicator style.
     */
    indicator: {
        backgroundColor: ColorPalette.transparent,
        padding: 2,
        color: ColorPalette.white,
        fontSize: 16,
        textShadowColor: ColorPalette.black,
        textShadowOffset: {
            height: -1,
            width: 0
        }
    }
};


################################################################################

## File: .\jitsi-meet\react\features\base\react\components\native\slidingviewstyles.ts

import { StyleSheet } from 'react-native';

import { OVERLAY_Z_INDEX } from '../../constants';

export default {
    /**
     * The topmost container of the side bar.
     */
    sliderViewContainer: {
        ...StyleSheet.absoluteFillObject,
        zIndex: OVERLAY_Z_INDEX
    },

    /**
     * The container of the actual content of the side menu.
     */
    sliderViewContent: {
        position: 'absolute'
    },

    /**
     * The opaque area that covers the rest of the screen, when the side bar is
     * open.
     */
    sliderViewShadow: {
        ...StyleSheet.absoluteFillObject,
        backgroundColor: 'rgba(0, 0, 0, 0.5)'
    }
};


################################################################################

## File: .\jitsi-meet\react\features\base\react\components\native\styles.ts

import BaseTheme from '../../../ui/components/BaseTheme.native';

const OVERLAY_FONT_COLOR = 'rgba(255, 255, 255, 0.6)';
const BUTTON_HEIGHT = BaseTheme.spacing[7];
const BUTTON_WIDTH = BaseTheme.spacing[7];

export const AVATAR_SIZE = 65;
export const UNDERLAY_COLOR = 'rgba(255, 255, 255, 0.2)';

const SECTION_LIST_STYLES = {
    /**
     * The style of the avatar container that makes the avatar rounded.
     */
    avatarContainer: {
        alignItems: 'center',
        flexDirection: 'row',
        justifyContent: 'space-around',
        padding: 5
    },

    /**
     * Simple {@code Text} content of the avatar (the actual initials).
     */
    avatarContent: {
        backgroundColor: 'rgba(0, 0, 0, 0)',
        color: OVERLAY_FONT_COLOR,
        fontSize: Math.floor(AVATAR_SIZE / 2),
        fontWeight: '100',
        textAlign: 'center'
    },

    /**
     * The top level container style of the list.
     */
    container: {
        flex: 1,
        width: '100%'
    },

    list: {
        flex: 1,
        flexDirection: 'column'
    },

    listItem: {
        alignItems: 'center',
        flex: 1,
        flexDirection: 'row',
        marginHorizontal: BaseTheme.spacing[3],
        marginVertical: BaseTheme.spacing[2]
    },

    listItemDetails: {
        flex: 1,
        flexDirection: 'column',
        overflow: 'hidden',
        paddingHorizontal: 5
    },

    listItemText: {
        color: OVERLAY_FONT_COLOR,
        fontSize: 14
    },

    listItemTitle: {
        fontWeight: 'bold',
        fontSize: 16
    },

    listSection: {
        alignItems: 'center',
        backgroundColor: BaseTheme.palette.ui02,
        flex: 1,
        flexDirection: 'row',
        paddingVertical: BaseTheme.spacing[1],
        paddingHorizontal: BaseTheme.spacing[2]
    },

    listSectionText: {
        color: OVERLAY_FONT_COLOR,
        fontSize: 14,
        fontWeight: 'normal',
        marginLeft: BaseTheme.spacing[2]
    },

    pullToRefresh: {
        alignItems: 'center',
        flex: 1,
        flexDirection: 'column',
        justifyContent: 'center',
        padding: 20
    },

    pullToRefreshIcon: {
        backgroundColor: 'transparent',
        color: OVERLAY_FONT_COLOR,
        fontSize: 20
    },

    pullToRefreshText: {
        backgroundColor: 'transparent',
        color: OVERLAY_FONT_COLOR
    },

    touchableView: {
        flexDirection: 'row'
    }
};

export const TINTED_VIEW_DEFAULT = {
    backgroundColor: BaseTheme.palette.uiBackground,
    opacity: 0.8
};

export const BASE_INDICATOR = {
    alignItems: 'center',
    justifyContent: 'center'
};

const iconButtonContainer = {
    alignItems: 'center',
    display: 'flex',
    justifyContent: 'center',
    borderRadius: BaseTheme.shape.borderRadius,
    height: BUTTON_HEIGHT,
    width: BUTTON_WIDTH
};

/**
 * The styles of the generic React {@code Component}s implemented by the feature
 * base/react.
 */
export default {
    ...SECTION_LIST_STYLES,

    iconButtonContainer: {
        ...iconButtonContainer
    },

    iconButtonContainerPrimary: {
        ...iconButtonContainer,
        backgroundColor: BaseTheme.palette.action01
    },

    iconButtonContainerSecondary: {
        ...iconButtonContainer,
        backgroundColor: BaseTheme.palette.action02
    },

    iconButtonContainerDisabled: {
        ...iconButtonContainer,
        backgroundColor: BaseTheme.palette.disabled01
    }
};


################################################################################

## File: .\jitsi-meet\react\features\base\react\components\native\Text.ts

export { Text as default } from 'react-native';


################################################################################

## File: .\jitsi-meet\react\features\base\react\components\web\Container.ts

import AbstractContainer, { IProps } from '../AbstractContainer';

/**
 * Represents a container of React/Web {@link Component} children with a style.
 *
 * @augments AbstractContainer
 */
export default class Container<P extends IProps> extends AbstractContainer<P> {
    /**
     * Implements React's {@link Component#render()}.
     *
     * @inheritdoc
     * @returns {ReactElement}
     */
    render() {
        const { visible = true } = this.props;

        return visible ? super._render('div') : null;
    }
}


################################################################################

## File: .\jitsi-meet\react\features\base\react\components\web\Image.ts

import React, { Component } from 'react';

/**
 * Implements a React/Web {@link Component} for displaying image
 * in order to facilitate cross-platform source code.
 *
 * @augments Component
 */
export default class Image extends Component<React.HTMLProps<HTMLImageElement>> {
    /**
     * Implements React's {@link Component#render()}.
     *
     * @inheritdoc
     * @returns {ReactElement}
     */
    render() {
        return React.createElement('img', this.props);
    }
}


################################################################################

## File: .\jitsi-meet\react\features\base\react\components\web\LoadingIndicator.ts

export { default } from '../../../ui/components/web/Spinner';


################################################################################

## File: .\jitsi-meet\react\features\base\react\components\web\NavigateSectionListEmptyComponent.ts



################################################################################

## File: .\jitsi-meet\react\features\base\react\components\web\Text.ts

import React, { Component } from 'react';

import { StyleType, getFixedPlatformStyle } from '../../../styles/functions.web';

/**
 * Implements a React/Web {@link Component} for displaying text similar to React
 * Native's {@code Text} in order to facilitate cross-platform source code.
 *
 * @augments Component
 */
export default class Text extends Component<React.HTMLProps<HTMLSpanElement>> {
    /**
     * Implements React's {@link Component#render()}.
     *
     * @inheritdoc
     * @returns {ReactElement}
     */
    render() {
        // eslint-disable-next-line react/prop-types
        const _style = getFixedPlatformStyle(this.props.style as StyleType);

        return React.createElement('span', {
            ...this.props,
            style: _style
        });
    }
}


################################################################################

## File: .\jitsi-meet\react\features\base\redux\functions.ts

import { isEqual } from 'lodash-es';

import { IReduxState, IStore } from '../../app/types';
import { IStateful } from '../app/types';

/**
 * Sets specific properties of a specific state to specific values and prevents
 * unnecessary state changes.
 *
 * @param {T} target - The state on which the specified properties are to
 * be set.
 * @param {T} source - The map of properties to values which are to be set
 * on the specified target.
 * @returns {T} The specified target if the values of the specified
 * properties equal the specified values; otherwise, a new state constructed
 * from the specified target by setting the specified properties to the
 * specified values.
 */
export function assign<T extends Object>(target: T, source: Partial<T>): T {
    let t = target;

    for (const property in source) { // eslint-disable-line guard-for-in
        t = _set(t, property, source[property], t === target);
    }

    return t;
}

/**
 * Determines whether {@code a} equals {@code b} according to deep comparison
 * (which makes sense for Redux and its state definition).
 *
 * @param {*} a - The value to compare to {@code b}.
 * @param {*} b - The value to compare to {@code a}.
 * @returns {boolean} True if {@code a} equals {@code b} (according to deep
 * comparison); false, otherwise.
 */
export function equals(a: any, b: any) {
    return isEqual(a, b);
}

/**
 * Sets a specific property of a specific state to a specific value. Prevents
 * unnecessary state changes (when the specified {@code value} is equal to the
 * value of the specified {@code property} of the specified {@code state}).
 *
 * @param {T} state - The (Redux) state from which a new state is to be
 * constructed by setting the specified {@code property} to the specified
 * {@code value}.
 * @param {string} property - The property of {@code state} which is to be
 * assigned the specified {@code value} (in the new state).
 * @param {*} value - The value to assign to the specified {@code property}.
 * @returns {T} The specified {@code state} if the value of the specified
 * {@code property} equals the specified <tt>value/tt>; otherwise, a new state
 * constructed from the specified {@code state} by setting the specified
 * {@code property} to the specified {@code value}.
 */
export function set<T extends Object>(state: T, property: keyof T, value: any): T {
    return _set(state, property, value, /* copyOnWrite */ true);
}

/**
 * Sets a specific property of a specific state to a specific value. Prevents
 * unnecessary state changes (when the specified {@code value} is equal to the
 * value of the specified {@code property} of the specified {@code state}).
 *
 * @param {T} state - The (Redux) state from which a state is to be
 * constructed by setting the specified {@code property} to the specified
 * {@code value}.
 * @param {string} property - The property of {@code state} which is to be
 * assigned the specified {@code value}.
 * @param {*} value - The value to assign to the specified {@code property}.
 * @param {boolean} copyOnWrite - If the specified {@code state} is to not be
 * modified, {@code true}; otherwise, {@code false}.
 * @returns {T} The specified {@code state} if the value of the specified
 * {@code property} equals the specified <tt>value/tt> or {@code copyOnWrite}
 * is truthy; otherwise, a new state constructed from the specified
 * {@code state} by setting the specified {@code property} to the specified
 * {@code value}.
 */
function _set<T extends Object>(
        state: T,
        property: keyof T,
        value: any,
        copyOnWrite: boolean): T {
    // Delete state properties that are to be set to undefined. (It is a matter
    // of personal preference, mostly.)
    if (typeof value === 'undefined'
            && Object.prototype.hasOwnProperty.call(state, property)) {
        const newState = copyOnWrite ? { ...state } : state;

        if (delete newState[property]) {
            return newState;
        }
    }

    if (state[property] !== value) {
        if (copyOnWrite) {
            return {
                ...state,
                [property]: value
            };
        }

        state[property] = value;
    }

    return state;
}

/* eslint-enable max-params */

/**
 * Whether or not the entity is of type IStore.
 *
 * @param {IStateful} stateful - The entity to check.
 * @returns {boolean}
 */
function isStore(stateful: IStateful): stateful is IStore {
    return 'getState' in stateful && typeof stateful.getState === 'function';
}

/**
 * Returns redux state from the specified {@code stateful} which is presumed to
 * be related to the redux state (e.g. The redux store, the redux
 * {@code getState} function).
 *
 * @param {Function|IStore} stateful - The entity such as the redux store or the
 * redux {@code getState} function from which the redux state is to be
 * returned.
 * @returns {Object} The redux state.
 */
export function toState(stateful: IStateful): IReduxState {
    if (stateful) {
        if (typeof stateful === 'function') {
            return stateful();
        }

        if (isStore(stateful)) {
            return stateful.getState();
        }
    }

    return stateful;
}


################################################################################

## File: .\jitsi-meet\react\features\base\redux\logger.ts

import { getLogger } from '../logging/functions';

export default getLogger('features/base/redux');


################################################################################

## File: .\jitsi-meet\react\features\base\redux\middleware.ts

import { throttle } from 'lodash-es';

import MiddlewareRegistry from './MiddlewareRegistry';
import PersistenceRegistry from './PersistenceRegistry';
import { toState } from './functions';

/**
 * The delay in milliseconds that passes between the last state change and the
 * persisting of that state in the storage.
 */
const PERSIST_STATE_DELAY = 2000;

/**
 * A throttled function to avoid repetitive state persisting.
 */
const throttledPersistState = throttle(state => PersistenceRegistry.persistState(state), PERSIST_STATE_DELAY);

// Web only code.
// We need the <tt>if</tt> because it appears that on mobile the polyfill is not
// executed yet.
if (typeof window.addEventListener === 'function') {
    window.addEventListener('unload', () => {
        throttledPersistState.flush();
    });
}

/**
 * A master MiddleWare to selectively persist state. Please use the
 * {@link persisterconfig.json} to set which subtrees of the redux state should
 * be persisted.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {
    const oldState = toState(store);
    const result = next(action);
    const newState = toState(store);

    oldState === newState || throttledPersistState(newState);

    return result;
});


################################################################################

## File: .\jitsi-meet\react\features\base\redux\MiddlewareRegistry.ts

import { Middleware, applyMiddleware } from 'redux';

import { IReduxState, IStore } from '../../app/types';

/**
 * A registry for Redux middleware, allowing features to register their
 * middleware without needing to create additional inter-feature dependencies.
 */
class MiddlewareRegistry {
    _elements: Array<Middleware<any, any>>;

    /**
     * Creates a MiddlewareRegistry instance.
     */
    constructor() {
        /**
         * The set of registered middleware.
         *
         * @private
         * @type {Middleware[]}
         */
        this._elements = [];
    }

    /**
     * Applies all registered middleware into a store enhancer.
     * (@link http://redux.js.org/docs/api/applyMiddleware.html).
     *
     * @param {Middleware[]} additional - Any additional middleware that need to
     * be included (such as middleware from third-party modules).
     * @returns {Middleware}
     */
    applyMiddleware(...additional: Array<Middleware<any, any>>) {
        return applyMiddleware(...this._elements, ...additional);
    }

    /**
     * Adds a middleware to the registry.
     *
     * The method is to be invoked only before {@link #applyMiddleware()}.
     *
     * @param {Middleware} middleware - A Redux middleware.
     * @returns {void}
     */
    register(middleware: Middleware<any, IReduxState, IStore['dispatch']>) {
        this._elements.push(middleware);
    }
}

/**
 * The public singleton instance of the MiddlewareRegistry class.
 */
export default new MiddlewareRegistry();


################################################################################

## File: .\jitsi-meet\react\features\base\redux\PersistenceRegistry.ts

// @ts-ignore
import { jitsiLocalStorage } from '@jitsi/js-utils';
// eslint-disable-next-line lines-around-comment
// @ts-ignore
import { safeJsonParse } from '@jitsi/js-utils/json';
import md5 from 'js-md5';

import logger from './logger';

declare let __DEV__: any;

/**
 * Mixed type of the element (subtree) config. If it's a {@code boolean} (and is
 * {@code true}), we persist the entire subtree. If it's an {@code Object}, we
 * perist a filtered subtree based on the properties of the config object.
 */
declare type ElementConfig = boolean | Object;

/**
 * The type of the name-config pairs stored in {@code PersistenceRegistry}.
 */
declare type PersistencyConfigMap = { [name: string]: ElementConfig; };

/**
 * A registry to allow features to register their redux store subtree to be
 * persisted and also handles the persistency calls too.
 */
class PersistenceRegistry {
    _checksum = '';
    _defaultStates: { [name: string ]: Object | undefined; } = {};
    _elements: PersistencyConfigMap = {};

    /**
     * Returns the persisted redux state. Takes the {@link #_elements} into
     * account as we may have persisted something in the past that we don't want
     * to retrieve anymore. The next {@link #persistState} will remove such
     * values.
     *
     * @returns {Object}
     */
    getPersistedState() {
        const filteredPersistedState: any = {};

        // localStorage key per feature
        for (const subtreeName of Object.keys(this._elements)) {
            // Assumes that the persisted value is stored under the same key as
            // the feature's redux state name.
            const persistedSubtree
                = this._getPersistedSubtree(
                    subtreeName,
                    this._elements[subtreeName],
                    this._defaultStates[subtreeName]);

            if (persistedSubtree !== undefined) {
                filteredPersistedState[subtreeName] = persistedSubtree;
            }
        }

        // Initialize the checksum.
        this._checksum = this._calculateChecksum(filteredPersistedState);

        if (typeof __DEV__ !== 'undefined' && __DEV__) {
            logger.info('redux state rehydrated as', filteredPersistedState);
        }

        return filteredPersistedState;
    }

    /**
     * Initiates a persist operation, but its execution will depend on the
     * current checksums (checks changes).
     *
     * @param {Object} state - The redux state.
     * @returns {void}
     */
    persistState(state: Object) {
        const filteredState = this._getFilteredState(state);
        const checksum = this._calculateChecksum(filteredState);

        if (checksum !== this._checksum) {
            for (const subtreeName of Object.keys(filteredState)) {
                try {
                    jitsiLocalStorage.setItem(subtreeName, JSON.stringify(filteredState[subtreeName]));
                } catch (error) {
                    logger.error('Error persisting redux subtree', subtreeName, error);
                }
            }
            logger.info(`redux state persisted. ${this._checksum} -> ${checksum}`);
            this._checksum = checksum;
        }
    }

    /**
     * Registers a new subtree config to be used for the persistency.
     *
     * @param {string} name - The name of the subtree the config belongs to.
     * @param {ElementConfig} config - The config {@code Object}, or
     * {@code boolean} if the entire subtree needs to be persisted.
     * @param {Object} defaultState - The default state of the component. If
     * it's provided, the rehydrated state will be merged with it before it gets
     * pushed into Redux.
     * @returns {void}
     */
    register(
            name: string,
            config: ElementConfig = true,
            defaultState?: Object) {
        this._elements[name] = config;
        this._defaultStates[name] = defaultState;
    }

    /**
     * Calculates the checksum of a specific state.
     *
     * @param {Object} state - The redux state to calculate the checksum of.
     * @private
     * @returns {string} The checksum of the specified {@code state}.
     */
    _calculateChecksum(state: Object) {
        try {
            return md5.hex(JSON.stringify(state) || '');
        } catch (error) {
            logger.error('Error calculating checksum for state', error);

            return '';
        }
    }

    /**
     * Prepares a filtered state from the actual or the persisted redux state,
     * based on this registry.
     *
     * @param {Object} state - The actual or persisted redux state.
     * @private
     * @returns {Object}
     */
    _getFilteredState(state: any): any {
        const filteredState: any = {};

        for (const name of Object.keys(this._elements)) {
            if (state[name]) {
                filteredState[name]
                    = this._getFilteredSubtree(
                        state[name],
                        this._elements[name]);
            }
        }

        return filteredState;
    }

    /**
     * Prepares a filtered subtree based on the config for persisting or for
     * retrieval.
     *
     * @param {Object} subtree - The redux state subtree.
     * @param {ElementConfig} subtreeConfig - The related config.
     * @private
     * @returns {Object}
     */
    _getFilteredSubtree(subtree: any, subtreeConfig: any) {
        let filteredSubtree: any;

        if (typeof subtreeConfig === 'object') {
            // Only a filtered subtree gets persisted as specified by
            // subtreeConfig.
            filteredSubtree = {};
            for (const persistedKey of Object.keys(subtree)) {
                if (subtreeConfig[persistedKey]) {
                    filteredSubtree[persistedKey] = subtree[persistedKey];
                }
            }
        } else if (subtreeConfig) {
            // Persist the entire subtree.
            filteredSubtree = subtree;
        }

        return filteredSubtree;
    }

    /**
     * Retrieves a persisted subtree from the storage.
     *
     * @param {string} subtreeName - The name of the subtree.
     * @param {Object} subtreeConfig - The config of the subtree from
     * {@link #_elements}.
     * @param {Object} subtreeDefaults - The defaults of the persisted subtree.
     * @private
     * @returns {Object}
     */
    _getPersistedSubtree(subtreeName: string, subtreeConfig: Object, subtreeDefaults?: Object) {
        let persistedSubtree = jitsiLocalStorage.getItem(subtreeName);

        if (persistedSubtree) {
            try {
                persistedSubtree = safeJsonParse(persistedSubtree);

                const filteredSubtree
                    = this._getFilteredSubtree(persistedSubtree, subtreeConfig);

                if (filteredSubtree !== undefined) {
                    return this._mergeDefaults(
                        filteredSubtree, subtreeDefaults);
                }
            } catch (error) {
                logger.error(
                    'Error parsing persisted subtree',
                    subtreeName,
                    persistedSubtree,
                    error);
            }
        }

        return undefined;
    }

    /**
     * Merges the persisted subtree with its defaults before rehydrating the
     * values.
     *
     * @private
     * @param {Object} subtree - The Redux subtree.
     * @param {?Object} defaults - The defaults, if any.
     * @returns {Object}
     */
    _mergeDefaults(subtree: Object, defaults?: Object) {
        if (!defaults) {
            return subtree;
        }

        // If the subtree is an array, we don't need to merge it with the
        // defaults, because if it has a value, it will overwrite it, and if
        // it's undefined, it won't be even returned, and Redux will natively
        // use the default values instead.
        if (!Array.isArray(subtree)) {
            return {
                ...defaults,
                ...subtree
            };
        }
    }
}

export default new PersistenceRegistry();


################################################################################

## File: .\jitsi-meet\react\features\base\redux\ReducerRegistry.ts

import { Action, combineReducers } from 'redux';
import type { Reducer } from 'redux';

/**
 * The type of the dictionary/map which associates a reducer (function) with the
 * name of he Redux state property managed by the reducer.
 */
type NameReducerMap<S> = { [name: string]: Reducer<S, Action<any>>; };

/**
 * A registry for Redux reducers, allowing features to register themselves
 * without needing to create additional inter-feature dependencies.
 */
class ReducerRegistry {
    _elements: NameReducerMap<any>;

    /**
     * Creates a ReducerRegistry instance.
     */
    constructor() {
        /**
         * The set of registered reducers, keyed based on the field each reducer
         * will manage.
         *
         * @private
         * @type {NameReducerMap}
         */
        this._elements = {};
    }

    /**
     * Combines all registered reducers into a single reducing function.
     *
     * @param {Object} [additional={}] - Any additional reducers that need to be
     * included (such as reducers from third-party modules).
     * @returns {Function}
     */
    combineReducers(additional: NameReducerMap<any> = {}) {
        return combineReducers({
            ...this._elements,
            ...additional
        });
    }

    /**
     * Adds a reducer to the registry.
     *
     * The method is to be invoked only before {@link #combineReducers()}.
     *
     * @param {string} name - The field in the state object that will be managed
     * by the provided reducer.
     * @param {Reducer} reducer - A Redux reducer.
     * @returns {void}
     */
    register<S>(name: string, reducer: Reducer<S, any>) {
        this._elements[name] = reducer;
    }
}

/**
 * The public singleton instance of the ReducerRegistry class.
 */
export default new ReducerRegistry();


################################################################################

## File: .\jitsi-meet\react\features\base\redux\StateListenerRegistry.ts

import { Store } from 'redux';

import { IReduxState, IStore } from '../../app/types';

import { equals } from './functions';
import logger from './logger';

/**
 * The type listener supported for registration with
 * {@link StateListenerRegistry} in association with a {@link Selector}.
 *
 * @param {any} selection - The value derived from the redux store/state by the
 * associated {@code Selector}. Immutable!
 * @param {Store} store - The redux store. Provided in case the {@code Listener}
 * needs to {@code dispatch} or {@code getState}. The latter is advisable only
 * if the {@code Listener} is not to respond to changes to that state.
 * @param {any} prevSelection - The value previously derived from the redux
 * store/state by the associated {@code Selector}. The {@code Listener} is
 * invoked only if {@code prevSelection} and {@code selection} are different.
 * Immutable!
 */
type Listener
    = (selection: any, store: IStore, prevSelection: any) => void;

/**
 * The type selector supported for registration with
 * {@link StateListenerRegistry} in association with a {@link Listener}.
 *
 * @param {IReduxState} state - The redux state from which the {@code Selector} is to
 * derive data.
 * @param {any} prevSelection - The value previously derived from the redux
 * store/state by the {@code Selector}. Provided in case the {@code Selector}
 * needs to derive the returned value from the specified {@code state} and
 * {@code prevSelection}. Immutable!
 * @returns {any} The value derived from the specified {@code state} and/or
 * {@code prevSelection}. The associated {@code Listener} will only be invoked
 * if the returned value is other than {@code prevSelection}.
 */
type Selector = (state: IReduxState, prevSelection: any) => any;

/**
 * Options that can be passed to the register method.
 */
type RegistrationOptions = {

    /**
     * @property {boolean} [deepEquals=false] - Whether or not a deep equals check should be performed on the selection
     * returned by {@link Selector}.
     */
    deepEquals?: boolean;
};

/**
 * A type of a {@link Selector}-{@link Listener} association in which the
 * {@code Listener} listens to changes in the values derived from a redux
 * store/state by the {@code Selector}.
 */
type SelectorListener = {

    /**
     * The {@code Listener} which listens to changes in the values selected by
     * {@link selector}.
     */
    listener: Listener;

    /**
     * The {@link RegistrationOptions} passed during the registration to be applied on the listener.
     */
    options?: RegistrationOptions;

    /**
     * The {@code Selector} which selects values whose changes are listened to
     * by {@link listener}.
     */
    selector: Selector;
};

/**
 * A registry listeners which listen to changes in a redux store/state.
 */
class StateListenerRegistry {
    /**
     * The {@link Listener}s registered with this {@code StateListenerRegistry}
     * to be notified when the values derived by associated {@link Selector}s
     * from a redux store/state change.
     */
    _selectorListeners: Set<SelectorListener> = new Set();

    /**
     * Invoked by a specific redux store any time an action is dispatched, and
     * some part of the state (tree) may potentially have changed.
     *
     * @param {Object} context - The redux store invoking the listener and the
     * private state of this {@code StateListenerRegistry} associated with the
     * redux store.
     * @returns {void}
     */
    _listener({ prevSelections, store }: {
            prevSelections: Map<SelectorListener, any>;
            store: Store<any, any>;
    }) {
        for (const selectorListener of this._selectorListeners) {
            const prevSelection = prevSelections.get(selectorListener);

            try {
                const selection
                    = selectorListener.selector(
                        store.getState(),
                        prevSelection);
                const useDeepEquals = selectorListener?.options?.deepEquals;

                if ((useDeepEquals && !equals(prevSelection, selection))
                        || (!useDeepEquals && prevSelection !== selection)) {
                    prevSelections.set(selectorListener, selection);
                    selectorListener.listener(selection, store, prevSelection);
                }
            } catch (e) {
                // Don't let one faulty listener prevent other listeners from
                // being notified about their associated changes.
                logger.error(e);
            }
        }
    }

    /**
     * Registers a specific listener to be notified when the value derived by a
     * specific {@code selector} from a redux store/state changes.
     *
     * @param {Function} selector - The pure {@code Function} of the redux
     * store/state (and the previous selection of made by {@code selector})
     * which selects the value listened to by the specified {@code listener}.
     * @param {Function} listener - The listener to register with this
     * {@code StateListenerRegistry} so that it gets invoked when the value
     * returned by the specified {@code selector} changes.
     * @param {RegistrationOptions} [options] - Any options to be applied to the registration.
     * @returns {void}
     */
    register(selector: Selector, listener: Listener, options?: RegistrationOptions) {
        if (typeof selector !== 'function' || typeof listener !== 'function') {
            throw new Error('Invalid selector or listener!');
        }

        this._selectorListeners.add({
            listener,
            selector,
            options
        });
    }

    /**
     * Subscribes to a specific redux store (so that this instance gets notified
     * any time an action is dispatched, and some part of the state (tree) of
     * the specified redux store may potentially have changed).
     *
     * @param {Store} store - The redux store to which this
     * {@code StateListenerRegistry} is to {@code subscribe}.
     * @returns {void}
     */
    subscribe(store: Store<any, any>) {
        // XXX If StateListenerRegistry is not utilized by the app to listen to
        // state changes, do not bother subscribing to the store at all.
        if (this._selectorListeners.size) {
            store.subscribe(
                this._listener.bind(
                    this,
                    {
                        /**
                         * The previous selections of the {@code Selector}s
                         * registered with this {@code StateListenerRegistry}.
                         *
                         * @type Map<any>
                         */
                        prevSelections: new Map(),

                        /**
                         * The redux store.
                         *
                         * @type Store
                         */
                        store
                    }));
        }
    }
}

export default new StateListenerRegistry();


################################################################################

## File: .\jitsi-meet\react\features\base\responsive-ui\actions.ts

import { batch } from 'react-redux';

import { IStore } from '../../app/types';
import { CHAT_SIZE } from '../../chat/constants';
import { getParticipantsPaneOpen } from '../../participants-pane/functions';
import theme from '../components/themes/participantsPaneTheme.json';

import {
    CLIENT_RESIZED,
    SAFE_AREA_INSETS_CHANGED,
    SET_ASPECT_RATIO,
    SET_CONTEXT_MENU_OPEN,
    SET_NARROW_LAYOUT,
    SET_REDUCED_UI
} from './actionTypes';
import { ASPECT_RATIO_NARROW, ASPECT_RATIO_WIDE } from './constants';

/**
 * Size threshold for determining if we are in reduced UI mode or not.
 *
 * FIXME The logic to base {@code reducedUI} on a hardcoded width or height is
 * very brittle because it's completely disconnected from the UI which wants to
 * be rendered and, naturally, it broke on iPad where even the secondary Toolbar
 * didn't fit in the height. We do need to measure the actual UI at runtime and
 * determine whether and how to render it.
 */
const REDUCED_UI_THRESHOLD = 300;

/**
 * Indicates a resize of the window.
 *
 * @param {number} clientWidth - The width of the window.
 * @param {number} clientHeight - The height of the window.
 * @returns {Object}
 */
export function clientResized(clientWidth: number, clientHeight: number) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        if (!clientWidth && !clientHeight) {
            return;
        }

        let availableWidth = clientWidth;

        if (navigator.product !== 'ReactNative') {
            const state = getState();
            const { isOpen: isChatOpen } = state['features/chat'];
            const isParticipantsPaneOpen = getParticipantsPaneOpen(state);

            if (isChatOpen) {
                availableWidth -= CHAT_SIZE;
            }

            if (isParticipantsPaneOpen) {
                availableWidth -= theme.participantsPaneWidth;
            }
        }

        batch(() => {
            dispatch({
                type: CLIENT_RESIZED,
                clientHeight,
                clientWidth: availableWidth
            });
            dispatch(setAspectRatio(clientWidth, clientHeight));
        });
    };
}

/**
 * Sets the aspect ratio of the app's user interface based on specific width and
 * height.
 *
 * @param {number} width - The width of the app's user interface.
 * @param {number} height - The height of the app's user interface.
 * @returns {{
 *     type: SET_ASPECT_RATIO,
 *     aspectRatio: Symbol
 * }}
 */
export function setAspectRatio(width: number, height: number) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        // Don't change the aspect ratio if width and height are the same, that
        // is, if we transition to a 1:1 aspect ratio.
        if (width !== height) {
            const aspectRatio
                = width < height ? ASPECT_RATIO_NARROW : ASPECT_RATIO_WIDE;

            if (aspectRatio
                    !== getState()['features/base/responsive-ui'].aspectRatio) {
                return dispatch({
                    type: SET_ASPECT_RATIO,
                    aspectRatio
                });
            }
        }
    };
}

/**
 * Sets the "reduced UI" property. In reduced UI mode some components will
 * be hidden if there is no space to render them.
 *
 * @param {number} width - Current usable width.
 * @param {number} height - Current usable height.
 * @returns {{
 *     type: SET_REDUCED_UI,
 *     reducedUI: boolean
 * }}
 */
export function setReducedUI(width: number, height: number) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const reducedUI = Math.min(width, height) < REDUCED_UI_THRESHOLD;

        if (reducedUI !== getState()['features/base/responsive-ui'].reducedUI) {
            return dispatch({
                type: SET_REDUCED_UI,
                reducedUI
            });
        }
    };
}

/**
 * Sets whether the local or remote participant context menu is open.
 *
 * @param {boolean} isOpen - Whether local or remote context menu is open.
 * @returns {Object}
 */
export function setParticipantContextMenuOpen(isOpen: boolean) {
    return {
        type: SET_CONTEXT_MENU_OPEN,
        isOpen
    };
}

/**
 * Sets the insets from the SafeAreaProvider.
 *
 * @param {Object} insets - The new insets to be set.
 * @returns {{
 *    type: SAFE_AREA_INSETS_CHANGED,
 *    insets: Object
 * }}
 */
export function setSafeAreaInsets(insets: Object) {
    return {
        type: SAFE_AREA_INSETS_CHANGED,
        insets
    };
}

/**
 * Sets narrow layout.
 *
 * @param {boolean} isNarrow - Whether is narrow layout.
 * @returns {{
*    type: SET_NARROW_LAYOUT,
*    isNarrow: boolean
* }}
 */
export function setNarrowLayout(isNarrow: boolean) {
    return {
        type: SET_NARROW_LAYOUT,
        isNarrow
    };
}


################################################################################

## File: .\jitsi-meet\react\features\base\responsive-ui\actionTypes.ts

/**
 * The type of (redux) action which indicates that the client window has been resized.
 *
 * {
 *     type: CLIENT_RESIZED
 * }
 */
export const CLIENT_RESIZED = 'CLIENT_RESIZED';

/**
 * The type of (redux) action which indicates that the insets from the SafeAreaProvider have changed.
 *
 * {
 *    type: SAFE_AREA_INSETS_CHANGED,
 *    insets: Object
 * }
 */
 export const SAFE_AREA_INSETS_CHANGED = 'SAFE_AREA_INSETS_CHANGED';

/**
 * The type of (redux) action which sets the aspect ratio of the app's user
 * interface.
 *
 * {
 *     type: SET_ASPECT_RATIO,
 *     aspectRatio: Symbol
 * }
 */
export const SET_ASPECT_RATIO = 'SET_ASPECT_RATIO';

/**
 * The type of redux action which signals that the reduces UI mode was enabled
 * or disabled.
 *
 * {
 *     type: SET_REDUCED_UI,
 *     reducedUI: boolean
 * }
 *
 * @public
 */
export const SET_REDUCED_UI = 'SET_REDUCED_UI';

/**
 * The type of (redux) action which tells whether a local or remote participant
 * context menu is open.
 *
 * {
 *     type: SET_CONTEXT_MENU_OPEN,
 *     showConnectionInfo: boolean
 * }
 */
export const SET_CONTEXT_MENU_OPEN = 'SET_CONTEXT_MENU_OPEN';

/**
 * The type of redux action which signals whether we are in narrow layout.
 *
 * {
 *     type: SET_NARROW_LAYOUT,
 *     isNarrow: boolean
 * }
 *
 * @public
 */
export const SET_NARROW_LAYOUT = 'SET_NARROW_LAYOUT';



################################################################################

## File: .\jitsi-meet\react\features\base\responsive-ui\constants.ts

/**
 * The aspect ratio constant which indicates that the width (of whatever the
 * aspect ratio constant is used for) is smaller than the height.
 *
 * @type {Symbol}
 */
export const ASPECT_RATIO_NARROW = Symbol('ASPECT_RATIO_NARROW');

/**
 * The aspect ratio constant which indicates that the width (of whatever the
 * aspect ratio constant is used for) is larger than the height.
 *
 * @type {Symbol}
 */
export const ASPECT_RATIO_WIDE = Symbol('ASPECT_RATIO_WIDE');

/**
 * Smallest supported mobile width.
 */
export const SMALL_MOBILE_WIDTH = '320';


################################################################################

## File: .\jitsi-meet\react\features\base\responsive-ui\middleware.native.ts

import MiddlewareRegistry from '../redux/MiddlewareRegistry';

import { CLIENT_RESIZED } from './actionTypes';
import { setAspectRatio, setReducedUI } from './actions';


/**
 * Middleware that handles widnow dimension changes and updates the aspect ratio and
 * reduced UI modes accordingly.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(({ dispatch }) => next => action => {
    const result = next(action);

    switch (action.type) {
    case CLIENT_RESIZED: {
        const { clientWidth: width, clientHeight: height } = action;

        dispatch(setAspectRatio(width, height));
        dispatch(setReducedUI(width, height));
        break;
    }

    }

    return result;
});


################################################################################

## File: .\jitsi-meet\react\features\base\responsive-ui\middleware.web.ts

import { IStore } from '../../app/types';
import { APP_WILL_MOUNT, APP_WILL_UNMOUNT } from '../app/actionTypes';
import { CONFERENCE_JOINED } from '../conference/actionTypes';
import MiddlewareRegistry from '../redux/MiddlewareRegistry';

import { clientResized } from './actions';

/**
 * Dimensions change handler.
 */
let handler: undefined | ((this: Window, ev: UIEvent) => any);

/**
 * Middleware that handles window dimension changes.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {
    const result = next(action);

    switch (action.type) {
    case APP_WILL_UNMOUNT: {
        _appWillUnmount();
        break;
    }
    case APP_WILL_MOUNT:
        _appWillMount(store);
        break;

    case CONFERENCE_JOINED: {
        const { clientHeight = 0, clientWidth = 0 } = store.getState()['features/base/responsive-ui'];

        if (!clientHeight && !clientWidth) {
            const {
                innerHeight,
                innerWidth
            } = window;

            store.dispatch(clientResized(innerWidth, innerHeight));
        }
        break;
    }
    }

    return result;
});

/**
 * Notifies this feature that the action {@link APP_WILL_MOUNT} is being
 * dispatched within a specific redux {@code store}.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @private
 * @returns {void}
 */
function _appWillMount(store: IStore) {
    handler = () => {
        const {
            innerHeight,
            innerWidth
        } = window;

        store.dispatch(clientResized(innerWidth, innerHeight));
    };

    window.addEventListener('resize', handler);
}

/**
 * Notifies this feature that the action {@link APP_WILL_UNMOUNT} is being
 * dispatched within a specific redux {@code store}.
 *
 * @private
 * @returns {void}
 */
function _appWillUnmount() {
    handler && window.removeEventListener('resize', handler);

    handler = undefined;
}


################################################################################

## File: .\jitsi-meet\react\features\base\responsive-ui\reducer.ts

import ReducerRegistry from '../redux/ReducerRegistry';
import { set } from '../redux/functions';

import {
    CLIENT_RESIZED,
    SAFE_AREA_INSETS_CHANGED,
    SET_ASPECT_RATIO,
    SET_CONTEXT_MENU_OPEN,
    SET_NARROW_LAYOUT,
    SET_REDUCED_UI
} from './actionTypes';
import { ASPECT_RATIO_NARROW } from './constants';

const {
    innerHeight = 0,
    innerWidth = 0
} = window;

/**
 * The default/initial redux state of the feature base/responsive-ui.
 */
const DEFAULT_STATE = {
    aspectRatio: ASPECT_RATIO_NARROW,
    clientHeight: innerHeight,
    clientWidth: innerWidth,
    isNarrowLayout: false,
    reducedUI: false,
    contextMenuOpened: false
};

export interface IResponsiveUIState {
    aspectRatio: Symbol;
    clientHeight: number;
    clientWidth: number;
    contextMenuOpened: boolean;
    isNarrowLayout: boolean;
    reducedUI: boolean;
    safeAreaInsets?: {
        bottom: number;
        left: number;
        right: number;
        top: number;
    };
}

ReducerRegistry.register<IResponsiveUIState>('features/base/responsive-ui',
(state = DEFAULT_STATE, action): IResponsiveUIState => {
    switch (action.type) {
    case CLIENT_RESIZED: {
        return {
            ...state,
            clientWidth: action.clientWidth,
            clientHeight: action.clientHeight
        };
    }

    case SAFE_AREA_INSETS_CHANGED:
        return {
            ...state,
            safeAreaInsets: action.insets
        };

    case SET_ASPECT_RATIO:
        return set(state, 'aspectRatio', action.aspectRatio);

    case SET_REDUCED_UI:
        return set(state, 'reducedUI', action.reducedUI);

    case SET_CONTEXT_MENU_OPEN:
        return set(state, 'contextMenuOpened', action.isOpen);

    case SET_NARROW_LAYOUT:
        return set(state, 'isNarrowLayout', action.isNarrow);
    }

    return state;
});


################################################################################

## File: .\jitsi-meet\react\features\base\responsive-ui\components\DimensionsDetector.web.ts



################################################################################

## File: .\jitsi-meet\react\features\base\settings\actions.ts

import { SETTINGS_UPDATED } from './actionTypes';
import { ISettingsState } from './reducer';

/**
 * Create an action for when the settings are updated.
 *
 * @param {Object} settings - The new (partial) settings properties.
 * @returns {{
 *     type: SETTINGS_UPDATED,
 *     settings: {
 *         audioOutputDeviceId: string,
 *         avatarURL: string,
 *         cameraDeviceId: string,
 *         displayName: string,
 *         email: string,
 *         localFlipX: boolean,
 *         micDeviceId: string,
 *         serverURL: string,
 *         soundsReactions: boolean,
 *         startAudioOnly: boolean,
 *         startWithAudioMuted: boolean,
 *         startWithVideoMuted: boolean,
 *         startWithReactionsMuted: boolean
 *     }
 * }}
 */
export function updateSettings(settings: Partial<ISettingsState>) {
    return {
        type: SETTINGS_UPDATED,
        settings
    };
}


################################################################################

## File: .\jitsi-meet\react\features\base\settings\actionTypes.ts

/**
 * Create an action for when the settings are updated.
 *
 * {
 *     type: SETTINGS_UPDATED,
 *     settings: {
 *         audioOutputDeviceId: string,
 *         avatarURL: string,
 *         cameraDeviceId: string,
 *         displayName: string,
 *         email: string,
 *         localFlipX: boolean,
 *         micDeviceId: string,
 *         serverURL: string,
 *         startAudioOnly: boolean,
 *         startWithAudioMuted: boolean,
 *         startWithVideoMuted: boolean,
 *         startWithReactionsMuted: boolean
 *     }
 * }
 */
export const SETTINGS_UPDATED = 'SETTINGS_UPDATED';


################################################################################

## File: .\jitsi-meet\react\features\base\settings\constants.ts

/**
 * The default server URL to open if no other was specified.
 */
export const DEFAULT_SERVER_URL = 'https://meet.jit.si';


################################################################################

## File: .\jitsi-meet\react\features\base\settings\functions.any.ts

import { IReduxState } from '../../app/types';
import { iAmVisitor } from '../../visitors/functions';
import { IStateful } from '../app/types';
import CONFIG_WHITELIST from '../config/configWhitelist';
import { IConfigState } from '../config/reducer';
import { IJwtState } from '../jwt/reducer';
import { toState } from '../redux/functions';
import { parseURLParams } from '../util/parseURLParams';

import { DEFAULT_SERVER_URL } from './constants';
import { ISettingsState } from './reducer';

/**
 * Returns the effective value of a configuration/preference/setting by applying
 * a precedence among the values specified by JWT, URL, settings,
 * and config.
 *
 * @param {Object|Function} stateful - The redux state object or {@code getState} function.
 * @param {string} propertyName - The name of the
 * configuration/preference/setting (property) to retrieve.
 * @param {Object} sources - Flags indicating the configuration/preference/setting sources to
 * consider/retrieve values from.
 * @param {boolean} sources.config - Config.
 * @param {boolean} jwt - JWT.
 * @param {boolean} settings - Settings.
 * @param {boolean} urlParams - URL parameters.
 * @returns {any}
 */
export function getPropertyValue(
        stateful: IStateful,
        propertyName: string,
        sources?: any
) {
    // Default values don't play nicely with partial objects and we want to make
    // the function easy to use without exhaustively defining all flags:
    sources = { // eslint-disable-line no-param-reassign
        // Defaults:
        config: true,
        jwt: true,
        settings: true,
        urlParams: true,

        ...sources
    };

    // Precedence: jwt -> urlParams -> settings -> config.

    const state = toState(stateful);

    // jwt
    if (sources.jwt) {
        const value = state['features/base/jwt'][propertyName as keyof IJwtState];

        if (typeof value !== 'undefined') {
            return value[propertyName as keyof typeof value];
        }
    }

    // urlParams
    if (sources.urlParams) {
        if (CONFIG_WHITELIST.indexOf(propertyName) !== -1) {
            const urlParams
                = parseURLParams(state['features/base/connection'].locationURL ?? '');
            const value = urlParams[`config.${propertyName}`];

            if (typeof value !== 'undefined') {
                return value;
            }
        }
    }

    // settings
    if (sources.settings) {
        const value = state['features/base/settings'][propertyName as keyof ISettingsState];

        if (typeof value !== 'undefined') {
            return value;
        }
    }

    // config
    if (sources.config) {
        const value = state['features/base/config'][propertyName as keyof IConfigState];

        if (typeof value !== 'undefined') {
            return value;
        }
    }

    return undefined;
}

/**
 * Gets the currently configured server URL.
 *
 * @param {Object|Function} stateful - The redux state object or
 * {@code getState} function.
 * @returns {string} - The currently configured server URL.
 */
export function getServerURL(stateful: IStateful) {
    const state = toState(stateful);

    return state['features/base/settings'].serverURL || DEFAULT_SERVER_URL;
}

/**
 * Should we hide the helper dialog when a user tries to do audio only screen sharing.
 *
 * @param {Object} state - The state of the application.
 * @returns {boolean}
 */
export function shouldHideShareAudioHelper(state: IReduxState): boolean | undefined {

    return state['features/base/settings'].hideShareAudioHelper;
}

/**
 * Gets the disabled self view setting.
 *
 * @param {Object} state - Redux state.
 * @returns {boolean}
 */
export function getHideSelfView(state: IReduxState) {
    return state['features/base/config'].disableSelfView || state['features/base/settings'].disableSelfView
        || iAmVisitor(state);
}


################################################################################

## File: .\jitsi-meet\react\features\base\settings\functions.native.ts

import { NativeModules } from 'react-native';
import DefaultPreference from 'react-native-default-preference';

export * from './functions.any';

const { AudioMode } = NativeModules;

/**
 * Handles changes to the `disableCallIntegration` setting.
 * On Android (where `AudioMode.setUseConnectionService` is defined) we must update
 * the native side too, since audio routing works differently.
 *
 * @param {boolean} disabled - Whether call integration is disabled or not.
 * @returns {void}
 */
export function handleCallIntegrationChange(disabled: boolean) {
    if (AudioMode.setUseConnectionService) {
        AudioMode.setUseConnectionService(!disabled);
    }
}

/**
 * Handles changes to the `disableCrashReporting` setting.
 * Stores the value into platform specific default preference file, so at app
 * start-up time it is retrieved on the native side and the crash reporting
 * is enabled/disabled.
 *
 * @param {boolean} disabled - Whether crash reporting is disabled or not.
 * @returns {void}
 */
export function handleCrashReportingChange(disabled: boolean) {
    DefaultPreference.setName('jitsi-default-preferences').then( // @ts-ignore
        DefaultPreference.set('isCrashReportingDisabled', disabled.toString()));
}


################################################################################

## File: .\jitsi-meet\react\features\base\settings\functions.web.ts

import { IReduxState } from '../../app/types';
import { IStateful } from '../app/types';
import { toState } from '../redux/functions';

export * from './functions.any';

/**
 * Returns the deviceId for the currently used camera.
 *
 * @param {Object} state - The state of the application.
 * @returns {void}
 */
export function getCurrentCameraDeviceId(state: IReduxState) {
    return getDeviceIdByType(state, 'isVideoTrack');
}

/**
 * Returns the deviceId for the currently used microphone.
 *
 * @param {Object} state - The state of the application.
 * @returns {void}
 */
export function getCurrentMicDeviceId(state: IReduxState) {
    return getDeviceIdByType(state, 'isAudioTrack');
}

/**
 * Returns the deviceId for the currently used speaker.
 *
 * @param {Object} state - The state of the application.
 * @returns {void}
 */
export function getCurrentOutputDeviceId(state: IReduxState) {
    return state['features/base/settings'].audioOutputDeviceId;
}

/**
 * Returns the deviceId for the corresponding local track type.
 *
 * @param {Object} state - The state of the application.
 * @param {string} isType - Can be 'isVideoTrack' | 'isAudioTrack'.
 * @returns {string}
 */
function getDeviceIdByType(state: IReduxState, isType: string) {
    const [ deviceId ] = state['features/base/tracks']
        .map(t => t.jitsiTrack)
        .filter(t => t?.isLocal() && t[isType as keyof typeof t]())
        .map(t => t.getDeviceId());

    return deviceId || '';
}

/**
 * Returns the saved display name.
 *
 * @param {Object} state - The state of the application.
 * @returns {string}
 */
export function getDisplayName(state: IReduxState): string {
    return state['features/base/settings'].displayName || '';
}

/**
 * Searches known devices for a matching deviceId and fall back to matching on
 * label. Returns the stored preferred cameraDeviceId if a match is not found.
 *
 * @param {Object|Function} stateful - The redux state object or
 * {@code getState} function.
 * @returns {string}
 */
export function getUserSelectedCameraDeviceId(stateful: IStateful) {
    const state = toState(stateful);
    const {
        userSelectedCameraDeviceId,
        userSelectedCameraDeviceLabel
    } = state['features/base/settings'];
    const { videoInput } = state['features/base/devices'].availableDevices;

    return _getUserSelectedDeviceId({
        availableDevices: videoInput,

        // Operating systems may append " #{number}" somewhere in the label so
        // find and strip that bit.
        matchRegex: /\s#\d*(?!.*\s#\d*)/,
        userSelectedDeviceId: userSelectedCameraDeviceId,
        userSelectedDeviceLabel: userSelectedCameraDeviceLabel,
        replacement: ''
    });
}

/**
 * Searches known devices for a matching deviceId and fall back to matching on
 * label. Returns the stored preferred micDeviceId if a match is not found.
 *
 * @param {Object|Function} stateful - The redux state object or
 * {@code getState} function.
 * @returns {string}
 */
export function getUserSelectedMicDeviceId(stateful: IStateful) {
    const state = toState(stateful);
    const {
        userSelectedMicDeviceId,
        userSelectedMicDeviceLabel
    } = state['features/base/settings'];
    const { audioInput } = state['features/base/devices'].availableDevices;

    return _getUserSelectedDeviceId({
        availableDevices: audioInput,

        // Operating systems may append " ({number}-" somewhere in the label so
        // find and strip that bit.
        matchRegex: /\s\(\d*-\s(?!.*\s\(\d*-\s)/,
        userSelectedDeviceId: userSelectedMicDeviceId,
        userSelectedDeviceLabel: userSelectedMicDeviceLabel,
        replacement: ' ('
    });
}

/**
 * Searches known devices for a matching deviceId and fall back to matching on
 * label. Returns the stored preferred audioOutputDeviceId if a match is not found.
 *
 * @param {Object|Function} stateful - The redux state object or
 * {@code getState} function.
 * @returns {string}
 */
export function getUserSelectedOutputDeviceId(stateful: IStateful) {
    const state = toState(stateful);
    const {
        userSelectedAudioOutputDeviceId,
        userSelectedAudioOutputDeviceLabel
    } = state['features/base/settings'];
    const { audioOutput } = state['features/base/devices'].availableDevices;

    return _getUserSelectedDeviceId({
        availableDevices: audioOutput,
        matchRegex: undefined,
        userSelectedDeviceId: userSelectedAudioOutputDeviceId,
        userSelectedDeviceLabel: userSelectedAudioOutputDeviceLabel,
        replacement: undefined
    });
}

/**
 * A helper function to abstract the logic for choosing which device ID to
 * use. Falls back to fuzzy matching on label if a device ID match is not found.
 *
 * @param {Object} options - The arguments used to match find the preferred
 * device ID from available devices.
 * @param {Array<string>} options.availableDevices - The array of currently
 * available devices to match against.
 * @param {Object} options.matchRegex - The regex to use to find strings
 * appended to the label by the operating system. The matches will be replaced
 * with options.replacement, with the intent of matching the same device that
 * might have a modified label.
 * @param {string} options.userSelectedDeviceId - The device ID the participant
 * prefers to use.
 * @param {string} options.userSelectedDeviceLabel - The label associated with the
 * device ID the participant prefers to use.
 * @param {string} options.replacement - The string to use with
 * options.matchRegex to remove identifies added to the label by the operating
 * system.
 * @private
 * @returns {string} The preferred device ID to use for media.
 */
function _getUserSelectedDeviceId(options: {
    availableDevices: MediaDeviceInfo[] | undefined;
    matchRegex?: RegExp;
    replacement?: string;
    userSelectedDeviceId?: string;
    userSelectedDeviceLabel?: string;
}) {
    const {
        availableDevices,
        matchRegex = '',
        userSelectedDeviceId,
        userSelectedDeviceLabel,
        replacement = ''
    } = options;

    if (userSelectedDeviceId) {
        const foundMatchingBasedonDeviceId = availableDevices?.find(
            candidate => candidate.deviceId === userSelectedDeviceId);

        // Prioritize matching the deviceId
        if (foundMatchingBasedonDeviceId) {
            return userSelectedDeviceId;
        }
    }

    // If there is no label at all, there is no need to fall back to checking
    // the label for a fuzzy match.
    if (!userSelectedDeviceLabel) {
        return;
    }

    const strippedDeviceLabel
        = matchRegex ? userSelectedDeviceLabel.replace(matchRegex, replacement)
            : userSelectedDeviceLabel;
    const foundMatchBasedOnLabel = availableDevices?.find(candidate => {
        const { label } = candidate;

        if (!label) {
            return false;
        } else if (strippedDeviceLabel === label) {
            return true;
        }

        const strippedCandidateLabel
            = label.replace(matchRegex, replacement);

        return strippedDeviceLabel === strippedCandidateLabel;
    });

    return foundMatchBasedOnLabel?.deviceId;
}


################################################################################

## File: .\jitsi-meet\react\features\base\settings\logger.ts

import { getLogger } from '../logging/functions';

export default getLogger('features/base/settings');


################################################################################

## File: .\jitsi-meet\react\features\base\settings\middleware.any.ts

import { escape } from 'lodash-es';
import { AnyAction } from 'redux';

import { IStore } from '../../app/types';
import { SET_LOCATION_URL } from '../connection/actionTypes';
import { participantUpdated } from '../participants/actions';
import { getLocalParticipant } from '../participants/functions';
import MiddlewareRegistry from '../redux/MiddlewareRegistry';
import { parseURLParams } from '../util/parseURLParams';

import { SETTINGS_UPDATED } from './actionTypes';
import { updateSettings } from './actions';

/**
 * The middleware of the feature base/settings. Distributes changes to the state
 * of base/settings to the states of other features computed from the state of
 * base/settings.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {
    const result = next(action);

    switch (action.type) {
    case SETTINGS_UPDATED:
        _updateLocalParticipant(store, action);
        break;
    case SET_LOCATION_URL:
        _updateLocalParticipantFromUrl(store);
        break;
    }

    return result;
});

/**
 * Maps the settings field names to participant names where they don't match.
 * Currently there is only one such field, but may be extended in the future.
 *
 * @private
 * @param {string} settingsField - The name of the settings field to map.
 * @returns {string}
 */
function _mapSettingsFieldToParticipant(settingsField: string) {
    switch (settingsField) {
    case 'displayName':
        return 'name';
    }

    return settingsField;
}

/**
 * Updates the local participant according to settings changes.
 *
 * @param {Store} store - The redux store.
 * @param {Object} action - The dispatched action.
 * @private
 * @returns {void}
 */
function _updateLocalParticipant({ dispatch, getState }: IStore, action: AnyAction) {
    const { settings } = action;
    const localParticipant = getLocalParticipant(getState());
    const newLocalParticipant = {
        ...localParticipant
    };

    for (const key in settings) {
        if (settings.hasOwnProperty(key)) {
            newLocalParticipant[_mapSettingsFieldToParticipant(key) as keyof typeof newLocalParticipant]
                = settings[key];
        }
    }

    dispatch(participantUpdated({
        ...newLocalParticipant,
        id: newLocalParticipant.id ?? ''
    }));
}


/**
 * Returns the userInfo set in the URL.
 *
 * @param {Store} store - The redux store.
 * @private
 * @returns {void}
 */
function _updateLocalParticipantFromUrl({ dispatch, getState }: IStore) {
    const urlParams
        = parseURLParams(getState()['features/base/connection'].locationURL ?? '');
    const urlEmail = urlParams['userInfo.email'];
    const urlDisplayName = urlParams['userInfo.displayName'];

    if (!urlEmail && !urlDisplayName) {
        return;
    }

    const localParticipant = getLocalParticipant(getState());

    if (localParticipant) {
        const displayName = escape(urlDisplayName);
        const email = escape(urlEmail);

        dispatch(participantUpdated({
            ...localParticipant,
            email,
            name: displayName
        }));

        dispatch(updateSettings({
            displayName,
            email
        }));
    }
}


################################################################################

## File: .\jitsi-meet\react\features\base\settings\middleware.native.ts

import { IStore } from '../../app/types';
import { APP_WILL_MOUNT } from '../app/actionTypes';
import { setAudioOnly } from '../audio-only/actions';
import MiddlewareRegistry from '../redux/MiddlewareRegistry';

import { SETTINGS_UPDATED } from './actionTypes';
import { handleCallIntegrationChange, handleCrashReportingChange } from './functions.native';
import { ISettingsState } from './reducer';

import './middleware.any';

/**
 * The middleware of the feature base/settings. Distributes changes to the state
 * of base/settings to the states of other features computed from the state of
 * base/settings.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {
    const result = next(action);

    switch (action.type) {
    case APP_WILL_MOUNT:
        _initializeCallIntegration(store);
        break;
    case SETTINGS_UPDATED:
        _maybeHandleCallIntegrationChange(action);
        _maybeCrashReportingChange(action);
        _maybeSetAudioOnly(store, action);
        break;
    }

    return result;
});

/**
 * Initializes the audio device handler based on the `disableCallIntegration` setting.
 *
 * @param {Store} store - The redux store.
 * @private
 * @returns {void}
 */
function _initializeCallIntegration({ getState }: IStore) {
    const { disableCallIntegration } = getState()['features/base/settings'];

    if (typeof disableCallIntegration === 'boolean') {
        handleCallIntegrationChange(disableCallIntegration);
    }
}

/**
 * Handles a change in the `disableCallIntegration` setting.
 *
 * @param {Object} action - The redux action.
 * @private
 * @returns {void}
 */
function _maybeHandleCallIntegrationChange({ settings: { disableCallIntegration } }: {
    settings: Partial<ISettingsState>;
}) {
    if (typeof disableCallIntegration === 'boolean') {
        handleCallIntegrationChange(disableCallIntegration);
    }
}

/**
 * Handles a change in the `disableCrashReporting` setting.
 *
 * @param {Object} action - The redux action.
 * @private
 * @returns {void}
 */
function _maybeCrashReportingChange({ settings: { disableCrashReporting } }: {
    settings: Partial<ISettingsState>;
}) {
    if (typeof disableCrashReporting === 'boolean') {
        handleCrashReportingChange(disableCrashReporting);
    }
}

/**
 * Updates {@code startAudioOnly} flag if it's updated in the settings.
 *
 * @param {Store} store - The redux store.
 * @param {Object} action - The redux action.
 * @private
 * @returns {void}
 */
function _maybeSetAudioOnly(
        { dispatch }: IStore,
        { settings: { startAudioOnly } }: { settings: Partial<ISettingsState>; }) {
    if (typeof startAudioOnly === 'boolean') {
        dispatch(setAudioOnly(startAudioOnly));
    }
}


################################################################################

## File: .\jitsi-meet\react\features\base\settings\middleware.web.ts

import { IStore } from '../../app/types';
import { PREJOIN_INITIALIZED } from '../../prejoin/actionTypes';
import { setPrejoinPageVisibility } from '../../prejoin/actions';
import { APP_WILL_MOUNT } from '../app/actionTypes';
import { getJwtName } from '../jwt/functions';
import { MEDIA_TYPE } from '../media/constants';
import MiddlewareRegistry from '../redux/MiddlewareRegistry';
import { TRACK_ADDED } from '../tracks/actionTypes';
import { ITrack } from '../tracks/types';

import { updateSettings } from './actions';
import logger from './logger';


import './middleware.any';

/**
 * The middleware of the feature base/settings. Distributes changes to the state
 * of base/settings to the states of other features computed from the state of
 * base/settings.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {
    const result = next(action);

    switch (action.type) {
    case APP_WILL_MOUNT:
        _initializeShowPrejoin(store);
        break;
    case PREJOIN_INITIALIZED:
        _maybeUpdateDisplayName(store);
        break;
    case TRACK_ADDED:
        _maybeUpdateDeviceId(store, action.track);
        break;
    }

    return result;
});

/**
 * Overwrites the showPrejoin flag based on cached used selection for showing prejoin screen.
 *
 * @param {Store} store - The redux store.
 * @private
 * @returns {void}
 */
function _initializeShowPrejoin({ dispatch, getState }: IStore) {
    const { userSelectedSkipPrejoin } = getState()['features/base/settings'];

    if (userSelectedSkipPrejoin) {
        dispatch(setPrejoinPageVisibility(false));
    }
}

/**
 * Updates the display name to the one in JWT if there is one.
 *
 * @param {Store} store - The redux store.
 * @private
 * @returns {void}
 */
function _maybeUpdateDisplayName({ dispatch, getState }: IStore) {
    const state = getState();
    const hasJwt = Boolean(state['features/base/jwt'].jwt);

    if (hasJwt) {
        const displayName = getJwtName(state);

        if (displayName) {
            dispatch(updateSettings({
                displayName
            }));
        }
    }
}

/**
 * Maybe update the camera or mic device id when local track is added or updated.
 *
 * @param {Store} store - The redux store.
 * @param {ITrack} track - The potential local track.
 * @private
 * @returns {void}
 */
function _maybeUpdateDeviceId({ dispatch, getState }: IStore, track: ITrack) {
    if (track.local) {
        const { cameraDeviceId, micDeviceId } = getState()['features/base/settings'];
        const deviceId = track.jitsiTrack.getDeviceId();

        if (track.mediaType === MEDIA_TYPE.VIDEO && track.videoType === 'camera' && cameraDeviceId !== deviceId) {
            dispatch(updateSettings({
                cameraDeviceId: track.jitsiTrack.getDeviceId()
            }));
            logger.info(`switched local video device to: ${deviceId}`);
        } else if (track.mediaType === MEDIA_TYPE.AUDIO && micDeviceId !== deviceId) {
            dispatch(updateSettings({
                micDeviceId: track.jitsiTrack.getDeviceId()
            }));
            logger.info(`switched local audio input device to: ${deviceId}`);
        }
    }
}


################################################################################

## File: .\jitsi-meet\react\features\base\settings\reducer.ts

// @ts-expect-error
import { jitsiLocalStorage } from '@jitsi/js-utils';
import { escape } from 'lodash-es';

import { APP_WILL_MOUNT } from '../app/actionTypes';
import PersistenceRegistry from '../redux/PersistenceRegistry';
import ReducerRegistry from '../redux/ReducerRegistry';
import { assignIfDefined } from '../util/helpers';

import { SETTINGS_UPDATED } from './actionTypes';

/**
 * The default/initial redux state of the feature {@code base/settings}.
 *
 * @type Object
 */
const DEFAULT_STATE: ISettingsState = {
    audioOutputDeviceId: undefined,
    avatarURL: undefined,
    cameraDeviceId: undefined,
    disableCallIntegration: undefined,
    disableCrashReporting: undefined,
    disableP2P: undefined,
    disableSelfView: false,
    displayName: undefined,
    email: undefined,
    localFlipX: true,
    maxStageParticipants: 1,
    micDeviceId: undefined,
    serverURL: undefined,
    hideShareAudioHelper: false,
    soundsIncomingMessage: true,
    soundsParticipantJoined: true,
    soundsParticipantKnocking: true,
    soundsParticipantLeft: true,
    soundsTalkWhileMuted: true,
    soundsReactions: true,
    startAudioOnly: false,
    startCarMode: false,
    startWithAudioMuted: false,
    startWithVideoMuted: false,
    userSelectedAudioOutputDeviceId: undefined,
    userSelectedCameraDeviceId: undefined,
    userSelectedMicDeviceId: undefined,
    userSelectedAudioOutputDeviceLabel: undefined,
    userSelectedCameraDeviceLabel: undefined,
    userSelectedNotifications: {
        'notify.chatMessages': true
    },
    userSelectedMicDeviceLabel: undefined,
    userSelectedSkipPrejoin: undefined
};

export interface ISettingsState {
    audioOutputDeviceId?: string;
    audioSettingsVisible?: boolean;
    avatarURL?: string;
    cameraDeviceId?: string | boolean;
    disableCallIntegration?: boolean;
    disableCrashReporting?: boolean;
    disableP2P?: boolean;
    disableSelfView?: boolean;
    displayName?: string;
    email?: string;
    hideShareAudioHelper?: boolean;
    localFlipX?: boolean;
    maxStageParticipants?: number;
    micDeviceId?: string | boolean;
    serverURL?: string;
    soundsIncomingMessage?: boolean;
    soundsParticipantJoined?: boolean;
    soundsParticipantKnocking?: boolean;
    soundsParticipantLeft?: boolean;
    soundsReactions?: boolean;
    soundsTalkWhileMuted?: boolean;
    startAudioOnly?: boolean;
    startCarMode?: boolean;
    startWithAudioMuted?: boolean;
    startWithVideoMuted?: boolean;
    userSelectedAudioOutputDeviceId?: string;
    userSelectedAudioOutputDeviceLabel?: string;
    userSelectedCameraDeviceId?: string;
    userSelectedCameraDeviceLabel?: string;
    userSelectedMicDeviceId?: string;
    userSelectedMicDeviceLabel?: string;
    userSelectedNotifications?: {
        [key: string]: boolean;
    };
    userSelectedSkipPrejoin?: boolean;
    videoSettingsVisible?: boolean;
    visible?: boolean;
}

const STORE_NAME = 'features/base/settings';

/**
 * Sets up the persistence of the feature {@code base/settings}.
 */
const filterSubtree: ISettingsState = {};

// start with the default state
Object.keys(DEFAULT_STATE).forEach(key => {
    const key1 = key as keyof typeof filterSubtree;

    // @ts-ignore
    filterSubtree[key1] = true;
});

// we want to filter these props, to not be stored as they represent
// what is currently opened/used as devices
// @ts-ignore
filterSubtree.audioOutputDeviceId = false;
filterSubtree.cameraDeviceId = false;
filterSubtree.micDeviceId = false;

PersistenceRegistry.register(STORE_NAME, filterSubtree, DEFAULT_STATE);

ReducerRegistry.register<ISettingsState>(STORE_NAME, (state = DEFAULT_STATE, action): ISettingsState => {
    switch (action.type) {
    case APP_WILL_MOUNT:
        return _initSettings(state);

    case SETTINGS_UPDATED:
        return {
            ...state,
            ...action.settings
        };
    }

    return state;
});

/**
 * Inits the settings object based on what information we have available.
 * Info taken into consideration:
 *   - Old Settings.js style data.
 *
 * @private
 * @param {ISettingsState} featureState - The current state of the feature.
 * @returns {Object}
 */
function _initSettings(featureState: ISettingsState) {
    let settings = featureState;

    // Old Settings.js values
    // FIXME: jibri uses old settings.js local storage values to set its display
    // name and email. Provide another way for jibri to set these values, update
    // jibri, and remove the old settings.js values.
    const savedDisplayName = jitsiLocalStorage.getItem('displayname');
    const savedEmail = jitsiLocalStorage.getItem('email');

    // The helper _.escape will convert null to an empty strings. The empty
    // string will be saved in settings. On app re-load, because an empty string
    // is a defined value, it will override any value found in local storage.
    // The workaround is sidestepping _.escape when the value is not set in
    // local storage.
    const displayName = savedDisplayName === null ? undefined : escape(savedDisplayName);
    const email = savedEmail === null ? undefined : escape(savedEmail);

    settings = assignIfDefined({
        displayName,
        email
    }, settings);

    return settings;
}


################################################################################

## File: .\jitsi-meet\react\features\base\sounds\actions.ts

import { IStore } from '../../app/types';
import { Sounds } from '../config/configType';
import { AudioElement } from '../media/components/AbstractAudio';

import {
    PLAY_SOUND,
    REGISTER_SOUND,
    STOP_SOUND,
    UNREGISTER_SOUND,
    _ADD_AUDIO_ELEMENT,
    _REMOVE_AUDIO_ELEMENT
} from './actionTypes';
import { getSoundsPath } from './functions';
import { getDisabledSounds } from './functions.any';

/**
 * Adds {@link AudioElement} instance to the base/sounds feature state for the
 * {@link Sound} instance identified by the given id. After this action the
 * sound can be played by dispatching the {@link PLAY_SOUND} action.
 *
 * @param {string} soundId - The sound identifier for which the audio element
 * will be stored.
 * @param {AudioElement} audioElement - The audio element which implements the
 * audio playback functionality and which is backed by the sound resource
 * corresponding to the {@link Sound} with the given id.
 * @protected
 * @returns {{
 *     type: PLAY_SOUND,
 *     audioElement: AudioElement,
 *     soundId: string
 * }}
 */
export function _addAudioElement(soundId: string, audioElement: AudioElement) {
    return {
        type: _ADD_AUDIO_ELEMENT,
        audioElement,
        soundId
    };
}

/**
 * The opposite of {@link _addAudioElement} which removes {@link AudioElement}
 * for given sound from base/sounds state. It means that the audio resource has
 * been disposed and the sound can no longer be played.
 *
 * @param {string} soundId - The {@link Sound} instance identifier for which the
 * audio element is being removed.
 * @protected
 * @returns {{
 *     type: _REMOVE_AUDIO_ELEMENT,
 *     soundId: string
 * }}
 */
export function _removeAudioElement(soundId: string) {
    return {
        type: _REMOVE_AUDIO_ELEMENT,
        soundId
    };
}

/**
 * Starts playback of the sound identified by the given sound id. The action
 * will have effect only if the audio resource has been loaded already.
 *
 * @param {string} soundId - The id of the sound to be played (the same one
 * which was used in {@link registerSound} to register the sound).
 * @returns {Function}
 */
export function playSound(soundId: string) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const disabledSounds = getDisabledSounds(getState());

        if (!disabledSounds.includes(soundId as Sounds) && !disabledSounds.find(id => soundId.startsWith(id))) {
            dispatch({
                type: PLAY_SOUND,
                soundId
            });
        }
    };
}

/**
 * Registers a new sound for given id and a source object which can be either a
 * path or a raw object depending on the platform (native vs web). It will make
 * the {@link SoundCollection} render extra HTMLAudioElement which will make it
 * available for playback through the {@link playSound} action.
 *
 * @param {string} soundId - The global identifier which identify the sound
 * created for given source object.
 * @param {string} soundName - The name of bundled audio file that will be
 * associated with the given {@code soundId}.
 * @param {Object} options - Optional parameters.
 * @param {boolean} options.loop - True in order to loop the sound.
 * @returns {{
 *     type: REGISTER_SOUND,
 *     soundId: string,
 *     src: string,
 *     options: {
 *          loop: boolean
 *     }
 * }}
 */
export function registerSound(
        soundId: string, soundName: string, options: Object = {}) {
    return {
        type: REGISTER_SOUND,
        soundId,
        src: `${getSoundsPath()}/${soundName}`,
        options
    };
}

/**
 * Stops playback of the sound identified by the given sound id.
 *
 * @param {string} soundId - The id of the sound to be stopped (the same one
 * which was used in {@link registerSound} to register the sound).
 * @returns {{
 *     type: STOP_SOUND,
 *     soundId: string
 * }}
 */
export function stopSound(soundId: string) {
    return {
        type: STOP_SOUND,
        soundId
    };
}

/**
 * Unregister the sound identified by the given id. It will make the
 * {@link SoundCollection} component stop rendering the corresponding
 * {@code HTMLAudioElement} which then should result in the audio resource
 * disposal.
 *
 * @param {string} soundId - The identifier of the {@link Sound} to be removed.
 * @returns {{
 *     type: UNREGISTER_SOUND,
 *     soundId: string
 * }}
 */
export function unregisterSound(soundId: string) {
    return {
        type: UNREGISTER_SOUND,
        soundId
    };
}


################################################################################

## File: .\jitsi-meet\react\features\base\sounds\actionTypes.ts

/**
 * The type of a feature/internal/protected (redux) action to add an audio
 * element to the sounds collection state.
 *
 * {
 *     type: _ADD_AUDIO_ELEMENT,
 *     ref: AudioElement,
 *     soundId: string
 * }
 */
export const _ADD_AUDIO_ELEMENT = '_ADD_AUDIO_ELEMENT';

/**
 * The type of feature/internal/protected (redux) action to remove an audio
 * element for given sound identifier from the sounds collection state.
 *
 * {
 *     type: _REMOVE_AUDIO_ELEMENT,
 *     soundId: string
 * }
 */
export const _REMOVE_AUDIO_ELEMENT = '_REMOVE_AUDIO_ELEMENT';

/**
 * The type of (redux) action to play a sound from the sounds collection.
 *
 * {
 *     type: PLAY_SOUND,
 *     soundId: string
 * }
 */
export const PLAY_SOUND = 'PLAY_SOUND';

/**
 * The type of (redux) action to register a new sound with the sounds
 * collection.
 *
 * {
 *     type: REGISTER_SOUND,
 *     soundId: string
 * }
 */
export const REGISTER_SOUND = 'REGISTER_SOUND';

/**
 * The type of (redux) action to stop a sound from the sounds collection.
 *
 * {
 *     type: STOP_SOUND,
 *     soundId: string
 * }
 */
export const STOP_SOUND = 'STOP_SOUND';

/**
 * The type of (redux) action to unregister an existing sound from the sounds
 * collection.
 *
 * {
 *     type: UNREGISTER_SOUND,
 *     soundId: string
 * }
 */
export const UNREGISTER_SOUND = 'UNREGISTER_SOUND';


################################################################################

## File: .\jitsi-meet\react\features\base\sounds\functions.android.ts

/**
 * Returns the location of the sounds. On Android sounds files are copied to
 * the 'assets/sounds/' folder of the SDK bundle on build time.
 *
 * @returns {string}
 */
export function getSoundsPath() {
    return 'asset:/sounds';
}


################################################################################

## File: .\jitsi-meet\react\features\base\sounds\functions.any.ts

import { IReduxState } from '../../app/types';

/**
 * Selector for retrieving the disabled sounds array.
 *
 * @param {Object} state - The Redux state.
 * @returns {Array<string>} - The disabled sound id's array.
 */
export function getDisabledSounds(state: IReduxState) {
    return state['features/base/config'].disabledSounds || [];
}


################################################################################

## File: .\jitsi-meet\react\features\base\sounds\functions.ios.ts

import { getSdkBundlePath } from '../../app/functions.native';

/**
 * Returns the location of the sounds. On iOS it's the location of the SDK
 * bundle on the phone. Each sound file must be added to the SDK's XCode project
 * in order to be bundled correctly.
 *
 * @returns {string}
 */
export function getSoundsPath() {
    return getSdkBundlePath();
}


################################################################################

## File: .\jitsi-meet\react\features\base\sounds\functions.web.ts

import { IStore } from '../../app/types';

/**
 * Returns the location of the sounds. On Web it's the relative path to
 * the sounds folder placed in the source root.
 *
 * @returns {string}
 */
export function getSoundsPath() {
    return 'sounds';
}

/**
 * Set new audio output device on the global sound elements.
 *
 * @param {string } deviceId - The new output deviceId.
 * @returns {Function}
 */
export function setNewAudioOutputDevice(deviceId: string) {
    return function(_dispatch: IStore['dispatch'], getState: IStore['getState']) {
        const sounds = getState()['features/base/sounds'];

        for (const [ , sound ] of sounds) {
            sound.audioElement?.setSinkId?.(deviceId);
        }
    };
}


################################################################################

## File: .\jitsi-meet\react\features\base\sounds\logger.ts

import { getLogger } from '../logging/functions';

export default getLogger('features/base/sounds');


################################################################################

## File: .\jitsi-meet\react\features\base\sounds\middleware.any.ts

import i18next from 'i18next';

import { registerE2eeAudioFiles } from '../../../features/e2ee/functions';
import { registerRecordingAudioFiles } from '../../../features/recording/functions';
import { IStore } from '../../app/types';
import { AudioSupportedLanguage } from '../media/constants';
import MiddlewareRegistry from '../redux/MiddlewareRegistry';
import StateListenerRegistry from '../redux/StateListenerRegistry';

import { PLAY_SOUND, STOP_SOUND } from './actionTypes';
import logger from './logger';

/**
 * Implements the entry point of the middleware of the feature base/sounds.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {

    switch (action.type) {
    case PLAY_SOUND:
        _playSound(store, action.soundId);
        break;
    case STOP_SOUND:
        _stopSound(store, action.soundId);
        break;
    }

    return next(action);
});

/**
 * Plays sound from audio element registered in the Redux store.
 *
 * @param {Store} store - The Redux store instance.
 * @param {string} soundId - Audio element identifier.
 * @private
 * @returns {void}
 */
function _playSound({ getState }: IStore, soundId: string) {
    const sounds = getState()['features/base/sounds'];
    const sound = sounds.get(soundId);

    if (sound) {
        if (sound.audioElement) {
            sound.audioElement.play();
        } else {
            logger.warn(`PLAY_SOUND: sound not loaded yet for id: ${soundId}`);
        }
    } else {
        logger.warn(`PLAY_SOUND: no sound found for id: ${soundId}`);
    }
}

/**
 * Stop sound from audio element registered in the Redux store.
 *
 * @param {Store} store - The Redux store instance.
 * @param {string} soundId - Audio element identifier.
 * @private
 * @returns {void}
 */
function _stopSound({ getState }: IStore, soundId: string) {
    const sounds = getState()['features/base/sounds'];
    const sound = sounds.get(soundId);

    if (sound) {
        const { audioElement } = sound;

        if (audioElement) {
            audioElement.stop();
        } else {
            logger.warn(`STOP_SOUND: sound not loaded yet for id: ${soundId}`);
        }
    } else {
        logger.warn(`STOP_SOUND: no sound found for id: ${soundId}`);
    }
}

/**
 * Returns whether the language is supported for audio messages.
 *
 * @param {string} language - The requested language.
 * @returns {boolean}
 */
function isLanguageSupported(language: string): Boolean {
    return Boolean(AudioSupportedLanguage[language as keyof typeof AudioSupportedLanguage]);
}

/**
 * Checking if it's necessary to reload the translated files.
 *
 * @param {string} language - The next language.
 * @param {string} prevLanguage - The previous language.
 * @returns {boolean}
 */
function shouldReloadAudioFiles(language: string, prevLanguage: string): Boolean {
    const isNextLanguageSupported = isLanguageSupported(language);
    const isPrevLanguageSupported = isLanguageSupported(prevLanguage);

    return (

        // From an unsupported language (which defaulted to English) to a supported language (that isn't English).
        isNextLanguageSupported && language !== AudioSupportedLanguage.en && !isPrevLanguageSupported
    ) || (

        // From a supported language (that wasn't English) to English.
        !isNextLanguageSupported && isPrevLanguageSupported && prevLanguage !== AudioSupportedLanguage.en
    ) || (

        // From a supported language to another.
        isNextLanguageSupported && isPrevLanguageSupported
    );
}

/**
 * Set up state change listener for language.
 */
StateListenerRegistry.register(
    () => i18next.language,
    (language, { dispatch }, prevLanguage): void => {

        if (language !== prevLanguage && shouldReloadAudioFiles(language, prevLanguage)) {
            registerE2eeAudioFiles(dispatch, true);
            registerRecordingAudioFiles(dispatch, true);
        }
    }
);


################################################################################

## File: .\jitsi-meet\react\features\base\sounds\middleware.native.ts

import './middleware.any';


################################################################################

## File: .\jitsi-meet\react\features\base\sounds\middleware.web.ts

import { getAudioOutputDeviceId } from '../devices/functions.web';
import MiddlewareRegistry from '../redux/MiddlewareRegistry';

import { _ADD_AUDIO_ELEMENT } from './actionTypes';

import './middleware.any';

/**
 * Implements the entry point of the middleware of the feature base/sounds.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(_store => next => action => {

    switch (action.type) {
    case _ADD_AUDIO_ELEMENT:
        action.audioElement?.setSinkId?.(getAudioOutputDeviceId());
        break;
    }

    return next(action);
});


################################################################################

## File: .\jitsi-meet\react\features\base\sounds\reducer.ts

import { AnyAction } from 'redux';

import { AudioElement } from '../media/components/AbstractAudio';
import ReducerRegistry from '../redux/ReducerRegistry';
import { assign } from '../redux/functions';

import {
    REGISTER_SOUND,
    UNREGISTER_SOUND,
    _ADD_AUDIO_ELEMENT,
    _REMOVE_AUDIO_ELEMENT
} from './actionTypes';

/**
 * The structure use by this reducer to describe a sound.
 */
export type Sound = {

    /**
     * The HTMLAudioElement which implements the audio playback functionality.
     * Becomes available once the sound resource gets loaded and the sound can
     * not be played until that happens.
     */
    audioElement?: AudioElement;

    /**
     * This field is container for all optional parameters related to the sound.
     */
    options?: {
        loop: boolean;
    };

    /**
     * This field describes the source of the audio resource to be played. It
     * can be either a path to the file or an object depending on the platform
     * (native vs web).
     */
    src?: Object | string;
};

/**
 * Initial/default state of the feature {@code base/sounds}. It is a {@code Map}
 * of globally stored sounds.
 *
 * @type {Map<string, Sound>}
 */
const DEFAULT_STATE = new Map();

export type ISoundsState = Map<string, Sound>;

/**
 * The base/sounds feature's reducer.
 */
ReducerRegistry.register<ISoundsState>(
    'features/base/sounds',
    (state = DEFAULT_STATE, action): ISoundsState => {
        switch (action.type) {
        case _ADD_AUDIO_ELEMENT:
        case _REMOVE_AUDIO_ELEMENT:
            return _addOrRemoveAudioElement(state, action);

        case REGISTER_SOUND:
            return _registerSound(state, action);

        case UNREGISTER_SOUND:
            return _unregisterSound(state, action);

        default:
            return state;
        }
    });

/**
 * Adds or removes {@link AudioElement} associated with a {@link Sound}.
 *
 * @param {Map<string, Sound>} state - The current Redux state of this feature.
 * @param {_ADD_AUDIO_ELEMENT | _REMOVE_AUDIO_ELEMENT} action - The action to be
 * handled.
 * @private
 * @returns {Map<string, Sound>}
 */
function _addOrRemoveAudioElement(state: ISoundsState, action: AnyAction) {
    const isAddAction = action.type === _ADD_AUDIO_ELEMENT;
    const nextState = new Map(state);
    const { soundId } = action;

    const sound = nextState.get(soundId);

    if (sound) {
        if (isAddAction) {
            nextState.set(soundId,
                assign(sound, {
                    audioElement: action.audioElement
                }));
        } else {
            nextState.set(soundId,
                assign(sound, {
                    audioElement: undefined
                }));
        }
    }

    return nextState;
}

/**
 * Registers a new {@link Sound} for given id and source. It will make
 * the {@link SoundCollection} component render HTMLAudioElement for given
 * source making it available for playback through the redux actions.
 *
 * @param {Map<string, Sound>} state - The current Redux state of the sounds
 * features.
 * @param {REGISTER_SOUND} action - The register sound action.
 * @private
 * @returns {Map<string, Sound>}
 */
function _registerSound(state: ISoundsState, action: AnyAction) {
    const nextState = new Map(state);

    nextState.set(action.soundId, {
        src: action.src,
        options: action.options
    });

    return nextState;
}

/**
 * Unregisters a {@link Sound} which will make the {@link SoundCollection}
 * component stop rendering the corresponding HTMLAudioElement. This will
 * result further in the audio resource disposal.
 *
 * @param {Map<string, Sound>} state - The current Redux state of this feature.
 * @param {UNREGISTER_SOUND} action - The unregister sound action.
 * @private
 * @returns {Map<string, Sound>}
 */
function _unregisterSound(state: ISoundsState, action: AnyAction) {
    const nextState = new Map(state);

    nextState.delete(action.soundId);

    return nextState;
}


################################################################################

## File: .\jitsi-meet\react\features\base\sounds\components\SoundCollection.ts

import React, { Component } from 'react';
import { connect } from 'react-redux';

import { IReduxState, IStore } from '../../../app/types';
import { AudioElement } from '../../media/components/AbstractAudio';
import { Audio } from '../../media/components/index';
import { _addAudioElement, _removeAudioElement } from '../actions';
import { Sound } from '../reducer';

/**
 * {@link SoundCollection}'s properties.
 */
interface IProps {

    /**
     * Dispatches {@link _ADD_AUDIO_ELEMENT} Redux action which will store the
     * {@link AudioElement} for a sound in the Redux store.
     */
    _addAudioElement: Function;

    /**
     * Dispatches {@link _REMOVE_AUDIO_ELEMENT} Redux action which will remove
     * the sound's {@link AudioElement} from the Redux store.
     */
    _removeAudioElement: Function;

    /**
     * It's the 'base/sounds' reducer's state mapped to a property. It's used to
     * render audio elements for every registered sound.
     */
    _sounds: Map<string, Sound>;
}

/**
 * Collections of all global sounds used by the app for playing audio
 * notifications in response to various events. It renders <code>Audio</code>
 * element for each sound registered in the base/sounds feature. When the audio
 * resource is loaded it will emit add/remove audio element actions which will
 * attach the element to the corresponding {@link Sound} instance in the Redux
 * state. When that happens the sound can be played using the {@link playSound}
 * action.
 */
class SoundCollection extends Component<IProps> {
    /**
     * Implements React's {@link Component#render()}.
     *
     * @inheritdoc
     * @returns {ReactElement}
     */
    render() {
        let key = 0;
        const sounds = [];

        for (const [ soundId, sound ] of this.props._sounds.entries()) {
            const { options, src } = sound;

            sounds.push(
                React.createElement(
                    Audio, {
                        key,
                        setRef: this._setRef.bind(this, soundId),
                        src,
                        loop: options?.loop
                    }));
            key += 1;
        }

        return sounds;
    }

    /**
     * Set the (reference to the) {@link AudioElement} object which implements
     * the audio playback functionality.
     *
     * @param {string} soundId - The sound Id for the audio element for which
     * the callback is being executed.
     * @param {AudioElement} element - The {@link AudioElement} instance
     * which implements the audio playback functionality.
     * @protected
     * @returns {void}
     */
    _setRef(soundId: string, element?: AudioElement) {
        if (element) {
            this.props._addAudioElement(soundId, element);
        } else {
            this.props._removeAudioElement(soundId);
        }
    }
}

/**
 * Maps (parts of) the Redux state to {@code SoundCollection}'s props.
 *
 * @param {Object} state - The redux state.
 * @private
 * @returns {{
 *     _sounds: Map<string, Sound>
 * }}
 */
function _mapStateToProps(state: IReduxState) {
    return {
        _sounds: state['features/base/sounds']
    };
}

/**
 * Maps dispatching of some actions to React component props.
 *
 * @param {Function} dispatch - Redux action dispatcher.
 * @private
 * @returns {{
 *     _addAudioElement: void,
 *     _removeAudioElement: void
 * }}
 */
export function _mapDispatchToProps(dispatch: IStore['dispatch']) {
    return {
        /**
         * Dispatches action to store the {@link AudioElement} for
         * a {@link Sound} identified by given <tt>soundId</tt> in the Redux
         * store, so that the playback can be controlled through the Redux
         * actions.
         *
         * @param {string} soundId - A global identifier which will be used to
         * identify the {@link Sound} instance for which an audio element will
         * be added.
         * @param {AudioElement} audioElement - The {@link AudioElement}
         * instance that will be stored in the Redux state of the base/sounds
         * feature, as part of the {@link Sound} object. At that point the sound
         * will be ready for playback.
         * @private
         * @returns {void}
         */
        _addAudioElement(soundId: string, audioElement: AudioElement) {
            dispatch(_addAudioElement(soundId, audioElement));
        },

        /**
         * Dispatches action to remove {@link AudioElement} from the Redux
         * store for specific {@link Sound}, because it is no longer part of
         * the DOM tree and the audio resource will be released.
         *
         * @param {string} soundId - The id of the {@link Sound} instance for
         * which an {@link AudioElement} will be removed from the Redux store.
         * @private
         * @returns {void}
         */
        _removeAudioElement(soundId: string) {
            dispatch(_removeAudioElement(soundId));
        }
    };
}

export default connect(_mapStateToProps, _mapDispatchToProps)(SoundCollection);


################################################################################

## File: .\jitsi-meet\react\features\base\styles\functions.any.ts

declare type StyleSheet = {
    [key: string]: string | number | { [key: string]: string | number; };
};

export type StyleType = StyleSheet | Array<StyleSheet>;

/**
 * RegExp pattern for long HEX color format.
 */
const HEX_LONG_COLOR_FORMAT
    = /^#([0-9A-F]{2,2})([0-9A-F]{2,2})([0-9A-F]{2,2})$/i;

/**
 * RegExp pattern for short HEX color format.
 */
const HEX_SHORT_COLOR_FORMAT
    = /^#([0-9A-F]{1,1})([0-9A-F]{1,1})([0-9A-F]{1,1})$/i;

/**
 * RegExp pattern for RGB color format.
 */
const RGB_COLOR_FORMAT = /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/i;

/**
 * RegExp pattern for RGBA color format.
 */
const RGBA_COLOR_FORMAT
    = /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*([0-9.]+)\)$/i;

/**
 * The list of the well-known style properties which may not be numbers on Web
 * but must be numbers on React Native.
 *
 * @private
 */
const _WELL_KNOWN_NUMBER_PROPERTIES = [ 'height', 'width' ];

/**
 * Function to convert complex StyleType styles into a single flat object,
 * so then they can be deconstructed for further processing.
 *
 * @param {Styletype} st - The complex style type.
 * @returns {Object}
 */
export function styleTypeToObject(st: StyleType | StyleType[]) {
    if (!st) {
        return {};
    }

    if (Array.isArray(st)) {
        const flatStyle = {};

        for (const styleElement of st) {
            Object.assign(flatStyle, styleTypeToObject(styleElement));
        }

        return flatStyle;
    }

    return st;
}

/**
 * Combines the given 2 styles into a single one.
 *
 * @param {StyleType} a - An object or array of styles.
 * @param {StyleType} b - An object or array of styles.
 * @private
 * @returns {StyleType} - The merged styles.
 */
export function combineStyles(a: StyleType, b: StyleType): StyleType {
    const result: Array<StyleSheet> = [];

    if (a) {
        if (Array.isArray(a)) {
            result.push(...a);
        } else {
            result.push(a);
        }
    }

    if (b) {
        if (Array.isArray(b)) {
            result.push(...b);
        } else {
            result.push(b);
        }
    }

    return result;
}

/**
 * Create a style sheet using the provided style definitions.
 *
 * @param {StyleSheet} styles - A dictionary of named style definitions.
 * @param {StyleSheet} [overrides={}] - Optional set of additional (often
 * platform-dependent/specific) style definitions that will override the base
 * (often platform-independent) styles.
 * @returns {StyleSheet}
 */
export function createStyleSheet(
        styles: StyleSheet, overrides: StyleSheet = {}): StyleSheet {
    const combinedStyles: any = {};

    for (const k of Object.keys(styles)) {
        combinedStyles[k]
            = _shimStyles({
                // @ts-ignore
                ...styles[k],

                // @ts-ignore
                ...overrides[k]
            });
    }

    return combinedStyles;
}

/**
 * Returns an rgba format of the provided color if it's in hex or rgb format.
 *
 * NOTE: The function will return the same color if it's not in one of those
 * two formats (e.g. 'white').
 *
 * @param {string} color - The string representation of the color in rgb or hex
 * format.
 * @param {number} alpha - The alpha value to apply.
 * @returns {string}
 */
export function getRGBAFormat(color: string, alpha: number): string {
    let match = color.match(HEX_LONG_COLOR_FORMAT);

    if (match) {
        return `#${match[1]}${match[2]}${match[3]}${_getAlphaInHex(alpha)}`;
    }

    match = color.match(HEX_SHORT_COLOR_FORMAT);
    if (match) {
        return `#${match[1]}${match[1]}${match[2]}${match[2]}${match[3]}${
            match[3]}${_getAlphaInHex(alpha)}`;
    }

    match = color.match(RGB_COLOR_FORMAT);
    if (match) {
        return `rgba(${match[1]}, ${match[2]}, ${match[3]}, ${alpha})`;
    }

    return color;
}

/**
 * Decides if a color is light or dark based on the ITU-R BT.709 and W3C
 * recommendations.
 *
 * NOTE: Please see https://www.w3.org/TR/WCAG20/#relativeluminancedef.
 *
 * @param {string} color - The color in rgb, rgba or hex format.
 * @returns {boolean}
 */
export function isDarkColor(color: string): boolean {
    const rgb = _getRGBObjectFormat(color);

    return ((_getColorLuminance(rgb.r) * 0.2126)
    + (_getColorLuminance(rgb.g) * 0.7152)
    + (_getColorLuminance(rgb.b) * 0.0722)) <= 0.179;
}

/**
 * Converts an [0..1] alpha value into HEX.
 *
 * @param {number} alpha - The alpha value to convert.
 * @returns {string}
 */
function _getAlphaInHex(alpha: number): string {
    return Number(Math.round(255 * alpha)).toString(16)
        .padStart(2, '0');
}

/**
 * Calculated the color luminance component for an individual color channel.
 *
 * NOTE: Please see https://www.w3.org/TR/WCAG20/#relativeluminancedef.
 *
 * @param {number} c - The color which we need the individual luminance
 * for.
 * @returns {number}
 */
function _getColorLuminance(c: number): number {
    return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
}

/**
 * Parses a color string into an object containing the RGB values as numbers.
 *
 * NOTE: Object properties are not alpha-sorted for sanity.
 *
 * @param {string} color - The color to convert.
 * @returns {{
 *     r: number,
 *     g: number,
 *     b: number
 * }}
 */
function _getRGBObjectFormat(color: string): { b: number; g: number; r: number; } {
    let match = color.match(HEX_LONG_COLOR_FORMAT);

    if (match) {
        return {
            r: parseInt(match[1], 16) / 255.0,
            g: parseInt(match[2], 16) / 255.0,
            b: parseInt(match[3], 16) / 255.0
        };
    }

    match = color.match(HEX_SHORT_COLOR_FORMAT);
    if (match) {
        return {
            r: parseInt(`${match[1]}${match[1]}`, 16) / 255.0,
            g: parseInt(`${match[2]}${match[2]}`, 16) / 255.0,
            b: parseInt(`${match[3]}${match[3]}`, 16) / 255.0
        };
    }

    match = color.match(RGB_COLOR_FORMAT) || color.match(RGBA_COLOR_FORMAT);
    if (match) {
        return {
            r: parseInt(match[1], 10) / 255.0,
            g: parseInt(match[2], 10) / 255.0,
            b: parseInt(match[3], 10) / 255.0
        };
    }

    return {
        r: 0,
        g: 0,
        b: 0
    };
}

/**
 * Shims style properties to work correctly on native. Allows us to minimize the
 * number of style declarations that need to be set or overridden for specific
 * platforms.
 *
 * @param {StyleSheet} styles - An object which represents a stylesheet.
 * @private
 * @returns {StyleSheet}
 */
function _shimStyles<T extends StyleSheet>(styles: T): T {
    // Certain style properties may not be numbers on Web but must be numbers on
    // React Native. For example, height and width may be expressed in percent
    // on Web but React Native will not understand them and we will get errors
    // (at least during development). Convert such well-known properties to
    // numbers if possible; otherwise, remove them to avoid runtime errors.
    for (const k of _WELL_KNOWN_NUMBER_PROPERTIES) {
        const v = styles[k];
        const typeofV = typeof v;

        if (typeofV !== 'undefined' && typeofV !== 'number') {
            const numberV = Number(v);

            if (Number.isNaN(numberV)) {
                delete styles[k];
            } else {
                // @ts-ignore
                styles[k] = numberV;
            }
        }
    }

    return styles;
}


################################################################################

## File: .\jitsi-meet\react\features\base\styles\functions.native.ts

import { StyleType } from './functions.any';

export * from './functions.any';

/**
 * Fixes the style prop that is passed to a platform generic component based on platform specific
 * format requirements.
 *
 * @param {StyleType} style - The passed style prop to the component.
 * @returns {StyleType}
 */
export function getFixedPlatformStyle(style?: StyleType | StyleType[]) {
    // There is nothing to do on mobile - yet.

    return style ?? {};
}


################################################################################

## File: .\jitsi-meet\react\features\base\styles\functions.web.ts

import { StyleType } from './functions.any';

export * from './functions.any';

/**
 * Fixes the style prop that is passed to a platform generic component based on platform specific
 * format requirements.
 *
 * @param {StyleType} style - The passed style prop to the component.
 * @returns {StyleType}
 */
export function getFixedPlatformStyle(style?: StyleType | StyleType[]) {
    if (Array.isArray(style)) {
        const _style = {};

        for (const component of style) {
            Object.assign(_style, component);
        }

        return _style;
    }

    return style;
}

/**
 * Sets the line height of a CSS Object group in pixels.
 * By default lineHeight is unitless in CSS, but not in RN.
 *
 * @param {Object} base - The base object containing the `lineHeight` property.
 * @returns {Object}
 */
export function withPixelLineHeight(base: any) {
    return {
        ...base,
        lineHeight: `${base.lineHeight}px`
    };
}


################################################################################

## File: .\jitsi-meet\react\features\base\styles\components\styles\BoxModel.ts

/**
 * The application's default properties related to the CSS box model such as
 * margins, borders, padding.
 */
export const BoxModel = {
    /**
     * The application's default margin when non-zero margin is necessary.
     */
    margin: 10,

    /**
     * The application's default padding when non-zero padding is necessary.
     */
    padding: 10
};


################################################################################

## File: .\jitsi-meet\react\features\base\styles\components\styles\ColorPalette.ts

/**
 * IMPORTANT: this file is deprecated. All of these colors should be moved to
 * the theme instead.
 */

/**
 * The application's definition of the default color black.
 */
const BLACK = '#111111';

/**
 * The application's color palette.
 */
export const ColorPalette = {
    /**
     * The application's background color.
     */
    appBackground: BLACK,

    /**
     * The application's definition of the default color black. Generally,
     * expected to be kept in sync with the application's background color for
     * the sake of consistency.
     */
    black: BLACK,
    blue: '#17A0DB',
    blueHighlight: '#1081b2',
    darkGrey: '#555555',
    green: '#40b183',
    lightGrey: '#AAAAAA',
    red: '#D00000',
    transparent: 'rgba(0, 0, 0, 0)',
    white: '#FFFFFF'
};


################################################################################

## File: .\jitsi-meet\react\features\base\testing\actions.ts

import { SET_CONNECTION_STATE } from './actionTypes';

// eslint-disable-next-line jsdoc/require-description-complete-sentence
/**
 * Sets the conference connection state of the testing feature.
 *
 * @param {string} connectionState - This is the lib-jitsi-meet event name. Can
 * be one of (with the string values at the time of this writing):
 * <li>{@link JitsiConferenceEvents.CONNECTION_ESTABLISHED}
 * - ("conference.connectionEstablished"</li>
 * <li>{@link JitsiConferenceEvents.CONNECTION_INTERRUPTED}
 * - ("conference.connectionInterrupted")</li>
 * <li>{@link JitsiConferenceEvents.CONNECTION_RESTORED}
 * - ("conference.connectionRestored")</li>
 * In the reducer the value will be an empty string until first event is
 * received.
 *
 * @returns {{
 *     type: SET_CONNECTION_STATE,
 *     connectionState: string
 * }}
 */
export function setConnectionState(connectionState: string) {
    return {
        type: SET_CONNECTION_STATE,
        connectionState
    };
}


################################################################################

## File: .\jitsi-meet\react\features\base\testing\actionTypes.ts

/**
 * The type of redux action which sets the configuration of the feature
 * base/logging.
 *
 * {
 *     type: SET_CONNECTION_STATE
 * }
 */
export const SET_CONNECTION_STATE = 'SET_CONNECTION_STATE';


################################################################################

## File: .\jitsi-meet\react\features\base\testing\functions.ts

import { IReduxState, IStore } from '../../app/types';
import { isTrackStreamingStatusActive } from '../../connection-indicator/functions';
import { VIDEO_CODEC } from '../../video-quality/constants';
import { MEDIA_TYPE, VIDEO_TYPE } from '../media/constants';
import { getParticipantById, isScreenShareParticipant } from '../participants/functions';
import {
    getLocalVideoTrack,
    getTrackByMediaTypeAndParticipant,
    getVideoTrackByParticipant
} from '../tracks/functions';

/**
 * Indicates whether the test mode is enabled. When it's enabled
 * {@link TestHint} and other components from the testing package will be
 * rendered in various places across the app to help with automatic testing.
 *
 * @param {IReduxState} state - The redux store state.
 * @returns {boolean}
 */
export function isTestModeEnabled(state: IReduxState): boolean {
    const testingConfig = state['features/base/config'].testing;

    return Boolean(testingConfig?.testMode);
}

/**
 * Returns the video type of the remote participant's video.
 *
 * @param {IStore} store - The redux store.
 * @param {string} id - The participant ID for the remote video.
 * @returns {VIDEO_TYPE}
 */
export function getRemoteVideoType({ getState }: IStore, id: string) {
    const state = getState();
    const participant = getParticipantById(state, id);

    if (isScreenShareParticipant(participant)) {
        return VIDEO_TYPE.DESKTOP;
    }

    return getTrackByMediaTypeAndParticipant(state['features/base/tracks'], MEDIA_TYPE.VIDEO, id)?.videoType;
}

/**
 * Returns whether the last media event received for large video indicates that the video is playing, if not muted.
 *
 * @param {IStore} store - The redux store.
 * @returns {boolean}
 */
export function isLargeVideoReceived({ getState }: IStore): boolean {
    const state = getState();
    const largeVideoParticipantId = state['features/large-video'].participantId ?? '';
    const largeVideoParticipant = getParticipantById(state, largeVideoParticipantId ?? '');
    const videoTrack = getVideoTrackByParticipant(state, largeVideoParticipant);

    return Boolean(videoTrack && !videoTrack.muted && isTrackStreamingStatusActive(videoTrack));
}

/**
 * Returns whether the local video track is encoded in AV1.
 *
 * @param {IStore} store - The redux store.
 * @returns {boolean}
 */
export function isLocalCameraEncodingAv1({ getState }: IStore): boolean {
    const state = getState();
    const tracks = state['features/base/tracks'];
    const localtrack = getLocalVideoTrack(tracks);

    if (localtrack?.codec?.toLowerCase() === VIDEO_CODEC.AV1) {
        return true;
    }

    return false;
}

/**
 * Returns whether the local video track is encoded in H.264.
 *
 * @param {IStore} store - The redux store.
 * @returns {boolean}
 */
export function isLocalCameraEncodingH264({ getState }: IStore): boolean {
    const state = getState();
    const tracks = state['features/base/tracks'];
    const localtrack = getLocalVideoTrack(tracks);

    if (localtrack?.codec?.toLowerCase() === VIDEO_CODEC.H264) {
        return true;
    }

    return false;
}

/**
 * Returns whether the local video track is encoded in VP8.
 *
 * @param {IStore} store - The redux store.
 * @returns {boolean}
 */
export function isLocalCameraEncodingVp8({ getState }: IStore): boolean {
    const state = getState();
    const tracks = state['features/base/tracks'];
    const localtrack = getLocalVideoTrack(tracks);

    if (localtrack?.codec?.toLowerCase() === VIDEO_CODEC.VP8) {
        return true;
    }

    return false;
}

/**
 * Returns whether the local video track is encoded in VP9.
 *
 * @param {IStore} store - The redux store.
 * @returns {boolean}
 */
export function isLocalCameraEncodingVp9({ getState }: IStore): boolean {
    const state = getState();
    const tracks = state['features/base/tracks'];
    const localtrack = getLocalVideoTrack(tracks);

    if (localtrack?.codec?.toLowerCase() === VIDEO_CODEC.VP9) {
        return true;
    }

    return false;
}

/**
 * Returns whether the last media event received for a remote video indicates that the video is playing, if not muted.
 *
 * @param {IStore} store - The redux store.
 * @param {string} id - The participant ID for the remote video.
 * @returns {boolean}
 */
export function isRemoteVideoReceived({ getState }: IStore, id: string): boolean {
    const state = getState();
    const participant = getParticipantById(state, id);
    const videoTrack = getVideoTrackByParticipant(state, participant);

    return Boolean(videoTrack && !videoTrack.muted && isTrackStreamingStatusActive(videoTrack));
}


################################################################################

## File: .\jitsi-meet\react\features\base\testing\logger.ts

import { getLogger } from '../logging/functions';

export default getLogger('features/base/testing');


################################################################################

## File: .\jitsi-meet\react\features\base\testing\middleware.ts

import { IStore } from '../../app/types';
import { CONFERENCE_JOIN_IN_PROGRESS } from '../conference/actionTypes';
import { IJitsiConference } from '../conference/reducer';
import { SET_CONFIG } from '../config/actionTypes';
import { JitsiConferenceEvents } from '../lib-jitsi-meet';
import MiddlewareRegistry from '../redux/MiddlewareRegistry';
import { getJitsiMeetGlobalNS } from '../util/helpers';

import { setConnectionState } from './actions';
import {
    getRemoteVideoType,
    isLargeVideoReceived,
    isLocalCameraEncodingAv1,
    isLocalCameraEncodingH264,
    isLocalCameraEncodingVp8,
    isLocalCameraEncodingVp9,
    isRemoteVideoReceived,
    isTestModeEnabled
} from './functions';
import logger from './logger';

/**
 * The Redux middleware of the feature testing.
 *
 * @param {Store} store - The Redux store.
 * @returns {Function}
 * @private
 */
MiddlewareRegistry.register(store => next => action => {
    switch (action.type) {
    case CONFERENCE_JOIN_IN_PROGRESS:
        _bindConferenceConnectionListener(action.conference, store);
        break;
    case SET_CONFIG: {
        const result = next(action);

        _bindTortureHelpers(store);

        return result;
    }
    }

    return next(action);
});

/**
 * Binds a handler which will listen for the connection related conference
 * events (in the lib-jitsi-meet internals those are associated with the ICE
 * connection state).
 *
 * @param {JitsiConference} conference - The {@link JitsiConference} for which
 * the conference will join even is dispatched.
 * @param {Store} store - The redux store in which the specified action is being
 * dispatched.
 * @private
 * @returns {void}
 */
function _bindConferenceConnectionListener(conference: IJitsiConference, { dispatch }: IStore) {

    conference.on(
        JitsiConferenceEvents.CONNECTION_ESTABLISHED,
        _onConnectionEvent.bind(
            null, JitsiConferenceEvents.CONNECTION_ESTABLISHED, dispatch));
    conference.on(
        JitsiConferenceEvents.CONNECTION_RESTORED,
        _onConnectionEvent.bind(
            null, JitsiConferenceEvents.CONNECTION_RESTORED, dispatch));
    conference.on(
        JitsiConferenceEvents.CONNECTION_INTERRUPTED,
        _onConnectionEvent.bind(
            null, JitsiConferenceEvents.CONNECTION_INTERRUPTED, dispatch));
}

/**
 * Binds all the helper functions needed by torture.
 *
 * @param {IStore} store - The redux store.
 * @private
 * @returns {void}
 */
function _bindTortureHelpers(store: IStore) {
    const { getState } = store;

    // We bind helpers only if testing mode is enabled
    if (!isTestModeEnabled(getState())) {
        return;
    }

    // All torture helper methods go in here
    getJitsiMeetGlobalNS().testing = {
        getRemoteVideoType: getRemoteVideoType.bind(null, store),
        isLargeVideoReceived: isLargeVideoReceived.bind(null, store),
        isLocalCameraEncodingAv1: isLocalCameraEncodingAv1.bind(null, store),
        isLocalCameraEncodingH264: isLocalCameraEncodingH264.bind(null, store),
        isLocalCameraEncodingVp8: isLocalCameraEncodingVp8.bind(null, store),
        isLocalCameraEncodingVp9: isLocalCameraEncodingVp9.bind(null, store),
        isRemoteVideoReceived: isRemoteVideoReceived.bind(null, store)
    };
}

/**
 * The handler function for conference connection events which will store the
 * latest even name in the Redux store of feature testing.
 *
 * @param {string} event - One of the lib-jitsi-meet JitsiConferenceEvents.
 * @param {Function} dispatch - The dispatch function of the current Redux
 * store.
 * @returns {void}
 * @private
 */
function _onConnectionEvent(event: string, dispatch: IStore['dispatch']) {
    switch (event) {
    case JitsiConferenceEvents.CONNECTION_ESTABLISHED:
    case JitsiConferenceEvents.CONNECTION_INTERRUPTED:
    case JitsiConferenceEvents.CONNECTION_RESTORED:
        dispatch(setConnectionState(event));
        break;
    default:
        logger.error(`onConnectionEvent - unsupported event type: ${event}`);
        break;
    }
}



################################################################################

## File: .\jitsi-meet\react\features\base\testing\reducer.ts

import { AnyAction } from 'redux';

import ReducerRegistry from '../redux/ReducerRegistry';
import { assign } from '../redux/functions';

import { SET_CONNECTION_STATE } from './actionTypes';

/**
 * The initial state of the feature testing.
 *
 * @type {{
 *     connectionState: string
 * }}
 */
const INITIAL_STATE = {
    connectionState: ''
};

export interface ITestingState {
    connectionState: string;
}

ReducerRegistry.register<ITestingState>(
    'features/testing',
    (state = INITIAL_STATE, action): ITestingState => {
        switch (action.type) {
        case SET_CONNECTION_STATE:
            return _setConnectionState(state, action);

        default:
            return state;
        }
    });

/**
 * Reduces a specific Redux action SET_CONNECTION_STATE of the feature
 * testing.
 *
 * @param {Object} state - The Redux state of the feature base/logging.
 * @param {Action} action - The Redux action SET_CONNECTION_STATE to reduce.
 * @private
 * @returns {Object} The new state of the feature testing after the
 * reduction of the specified action.
 */
function _setConnectionState(state: ITestingState, action: AnyAction) {
    return assign(state, { connectionState: action.connectionState });
}


################################################################################

## File: .\jitsi-meet\react\features\base\testing\components\AbstractTestHint.ts

import { GestureResponderEvent } from 'react-native';

import { IReduxState } from '../../../app/types';
import { isTestModeEnabled } from '../functions';

/**
 * Describes the {@link TestHint}'s properties.
 *
 * A test hint is meant to resemble the lack of the ability to execute
 * JavaScript by the mobile torture tests. They are used to expose some of
 * the app's internal state that is not always expressed in a feasible manner by
 * the UI.
 */
export type TestHintProps = {

    /**
     * The indicator which determines whether the test mode is enabled.
     * {@link TestHint} Components are rendered only if this flag is set to
     * {@code true}.
     */
    _testModeEnabled: boolean;

    /**
     * The test hint's identifier string. Must be unique in the app instance
     * scope.
     */
    id: string;

    /**
     * The optional "on press" handler which can be used to bind a click handler
     * to a {@link TestHint}.
     */
    onPress?: (e?: GestureResponderEvent) => void;

    /**
     * The test hint's (text) value which is to be consumed by the tests.
     */
    value: string;
};

/**
 * Maps (parts of) the redux state to {@link TestHint}'s React {@code Component}
 * props.
 *
 * @param {Object} state - The redux store/state.
 * @private
 * @returns {{
 *     _testModeEnabled: boolean
 * }}
 */
export function _mapStateToProps(state: IReduxState) {
    return {

        /**
         * The indicator which determines whether the test mode is enabled.
         *
         * @protected
         * @type {boolean}
         */
        _testModeEnabled: isTestModeEnabled(state)
    };
}


################################################################################

## File: .\jitsi-meet\react\features\base\testing\components\TestHint.web.ts

import { Component } from 'react';

export default Component;


################################################################################

## File: .\jitsi-meet\react\features\base\toolbox\components\AbstractHangupButton.ts

import { IconHangup } from '../../icons/svg';

import AbstractButton, { IProps } from './AbstractButton';

/**
 * An abstract implementation of a button for disconnecting a conference.
 */
export default class AbstractHangupButton<P extends IProps, S=any>
    extends AbstractButton<P, S> {

    icon = IconHangup;

    /**
     * Handles clicking / pressing the button, and disconnects the conference.
     *
     * @protected
     * @returns {void}
     */
    _handleClick() {
        this._doHangup();
    }

    /**
     * Helper function to perform the actual hangup action.
     *
     * @protected
     * @returns {void}
     */
    _doHangup() {
        // To be implemented by subclass.
    }
}


################################################################################

## File: .\jitsi-meet\react\features\base\toolbox\components\BaseAudioMuteButton.ts

import { IconMic, IconMicSlash } from '../../icons/svg';

import AbstractButton, { IProps } from './AbstractButton';

/**
 * An abstract implementation of a button for toggling audio mute.
 */
export default class BaseAudioMuteButton<P extends IProps, S=any>
    extends AbstractButton<P, S> {

    icon = IconMic;
    toggledIcon = IconMicSlash;

    /**
     * Handles clicking / pressing the button, and toggles the audio mute state
     * accordingly.
     *
     * @override
     * @protected
     * @returns {void}
     */
    _handleClick() {
        this._setAudioMuted(!this._isAudioMuted());
    }

    /**
     * Helper function to be implemented by subclasses, which must return a
     * boolean value indicating if audio is muted or not.
     *
     * @protected
     * @returns {boolean}
     */
    _isAudioMuted() {
        // To be implemented by subclass.
        return false;
    }

    /**
     * Indicates whether this button is in toggled state or not.
     *
     * @override
     * @protected
     * @returns {boolean}
     */
    _isToggled() {
        return this._isAudioMuted();
    }

    /**
     * Helper function to perform the actual setting of the audio mute / unmute
     * action.
     *
     * @param {boolean} _audioMuted - Whether audio should be muted or not.
     * @protected
     * @returns {void}
     */
    _setAudioMuted(_audioMuted: boolean) {
        // To be implemented by subclass.
    }
}


################################################################################

## File: .\jitsi-meet\react\features\base\toolbox\components\BaseVideoMuteButton.ts

import { IconVideo, IconVideoOff } from '../../icons/svg';

import AbstractButton, { IProps } from './AbstractButton';

/**
 * An abstract implementation of a button for toggling video mute.
 */
export default class BaseVideoMuteButton<P extends IProps, S=any>
    extends AbstractButton<P, S> {

    icon = IconVideo;
    toggledIcon = IconVideoOff;

    /**
     * Handles clicking / pressing the button, and toggles the video mute state
     * accordingly.
     *
     * @protected
     * @returns {void}
     */
    _handleClick() {
        this._setVideoMuted(!this._isVideoMuted());
    }

    /**
     * Indicates whether this button is in toggled state or not.
     *
     * @override
     * @protected
     * @returns {boolean}
     */
    _isToggled() {
        return this._isVideoMuted();
    }

    /**
     * Helper function to be implemented by subclasses, which must return a
     * {@code boolean} value indicating if video is muted or not.
     *
     * @protected
     * @returns {boolean}
     */
    _isVideoMuted() {
        // To be implemented by subclass.
        return false;
    }

    /**
     * Helper function to perform the actual setting of the video mute / unmute
     * action.
     *
     * @param {boolean} _videoMuted - Whether video should be muted or not.
     * @protected
     * @returns {void}
     */
    _setVideoMuted(_videoMuted: boolean) {
        // To be implemented by subclass.
    }
}


################################################################################

## File: .\jitsi-meet\react\features\base\tooltip\actionTypes.ts

/**
 * The type of the action which signals a tooltip is being displayed.
 *
 * {
 *     type: SHOW_TOOLTIP,
 *     content: string
 * }.
 */
export const SHOW_TOOLTIP = 'SHOW_TOOLTIP';

/**
 * The type of the action which signals a tooltip should be hidden.
 *
 * {
 *     type: SHOW_TOOLTIP,
 *     content: string
 * }.
 */
export const HIDE_TOOLTIP = 'HIDE_TOOLTIP';


################################################################################

## File: .\jitsi-meet\react\features\base\tooltip\reducer.ts

import ReducerRegistry from '../redux/ReducerRegistry';

import { HIDE_TOOLTIP, SHOW_TOOLTIP } from './actionTypes';

export interface ITooltipState {
    content: string;
    previousContent: string;
    visible: boolean;
}

const DEFAULT_STATE = {
    content: '',
    previousContent: '',
    visible: false
};

/**
 * Reduces redux actions which mark the tooltip as displayed or hidden.
 *
 * @param {IDialogState} state - The current redux state.
 * @param {Action} action - The redux action to reduce.
 * @param {string} action.type - The type of the redux action to reduce..
 * @returns {State} The next redux state that is the result of reducing the
 * specified action.
 */
ReducerRegistry.register<ITooltipState>('features/base/tooltip', (state = DEFAULT_STATE, action): ITooltipState => {
    switch (action.type) {
    case SHOW_TOOLTIP:
        return {
            content: action.content,
            previousContent: state.content,
            visible: true
        };
    case HIDE_TOOLTIP: {
        // The tooltip can be marked as hidden only if the hide action
        // is dispatched by the tooltip that is displayed.
        if (action.content === state.content) {
            return {
                content: '',
                previousContent: '',
                visible: false
            };
        }

        return state;
    }
    }

    return state;
});


################################################################################

## File: .\jitsi-meet\react\features\base\tracks\actions.any.ts

import { createTrackMutedEvent } from '../../analytics/AnalyticsEvents';
import { sendAnalytics } from '../../analytics/functions';
import { IStore } from '../../app/types';
import { showErrorNotification, showNotification } from '../../notifications/actions';
import { NOTIFICATION_TIMEOUT, NOTIFICATION_TIMEOUT_TYPE } from '../../notifications/constants';
import { getCurrentConference } from '../conference/functions';
import { IJitsiConference } from '../conference/reducer';
import { JitsiTrackErrors, JitsiTrackEvents } from '../lib-jitsi-meet';
import { createLocalTrack } from '../lib-jitsi-meet/functions.any';
import { setAudioMuted, setScreenshareMuted, setVideoMuted } from '../media/actions';
import {
    CAMERA_FACING_MODE,
    MEDIA_TYPE,
    MediaType,
    VIDEO_MUTISM_AUTHORITY,
    VIDEO_TYPE,
    VideoType
} from '../media/constants';
import { getLocalParticipant } from '../participants/functions';
import { updateSettings } from '../settings/actions';

import {
    SET_NO_SRC_DATA_NOTIFICATION_UID,
    TRACK_ADDED,
    TRACK_CREATE_CANCELED,
    TRACK_CREATE_ERROR,
    TRACK_MUTE_UNMUTE_FAILED,
    TRACK_NO_DATA_FROM_SOURCE,
    TRACK_REMOVED,
    TRACK_STOPPED,
    TRACK_UPDATED,
    TRACK_WILL_CREATE
} from './actionTypes';
import {
    createLocalTracksF,
    getCameraFacingMode,
    getLocalTrack,
    getLocalTracks,
    getLocalVideoTrack,
    getTrackByJitsiTrack
} from './functions';
import logger from './logger';
import { ITrack, ITrackOptions } from './types';

/**
 * Add a given local track to the conference.
 *
 * @param {JitsiLocalTrack} newTrack - The local track to be added to the conference.
 * @returns {Function}
 */
export function addLocalTrack(newTrack: any) {
    return async (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const conference = getCurrentConference(getState());

        if (conference) {
            await conference.addTrack(newTrack);
        }

        const setMuted = newTrack.isVideoTrack()
            ? newTrack.getVideoType() === VIDEO_TYPE.DESKTOP
                ? setScreenshareMuted
                : setVideoMuted
            : setAudioMuted;
        const isMuted = newTrack.isMuted();

        logger.log(`Adding ${newTrack.getType()} track - ${isMuted ? 'muted' : 'unmuted'}`);
        dispatch(setMuted(isMuted));

        return dispatch(_addTracks([ newTrack ]));
    };
}

/**
 * Requests the creating of the desired media type tracks. Desire is expressed
 * by base/media unless the function caller specifies desired media types
 * explicitly and thus override base/media. Dispatches a
 * {@code createLocalTracksA} action for the desired media types for which there
 * are no existing tracks yet.
 *
 * @returns {Function}
 */
export function createDesiredLocalTracks(...desiredTypes: any) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();

        dispatch(destroyLocalDesktopTrackIfExists());

        if (desiredTypes.length === 0) {
            const { video } = state['features/base/media'];

            // XXX: Always create the audio track early, even if it will be muted.
            // This fixes a timing issue when adding the track to the conference which
            // manifests primarily on iOS 15.
            desiredTypes.push(MEDIA_TYPE.AUDIO);

            // XXX When the app is coming into the foreground from the
            // background in order to handle a URL, it may realize the new
            // background state soon after it has tried to create the local
            // tracks requested by the URL. Ignore
            // VIDEO_MUTISM_AUTHORITY.BACKGROUND and create the local video
            // track if no other VIDEO_MUTISM_AUTHORITY has muted it. The local
            // video track will be muted until the app realizes the new
            // background state.

            // eslint-disable-next-line no-bitwise
            (video.muted & ~VIDEO_MUTISM_AUTHORITY.BACKGROUND)
                || desiredTypes.push(MEDIA_TYPE.VIDEO);
        }

        const availableTypes
            = getLocalTracks(
                    state['features/base/tracks'],
                    /* includePending */ true)
                .map(t => t.mediaType);

        // We need to create the desired tracks which are not already available.
        const createTypes
            = desiredTypes.filter((type: MediaType) => availableTypes.indexOf(type) === -1);

        createTypes.length
            && dispatch(createLocalTracksA({ devices: createTypes }));
    };
}

/**
 * Request to start capturing local audio and/or video. By default, the user
 * facing camera will be selected.
 *
 * @param {Object} [options] - For info @see JitsiMeetJS.createLocalTracks.
 * @returns {Function}
 */
export function createLocalTracksA(options: ITrackOptions = {}) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const devices
            = options.devices || [ MEDIA_TYPE.AUDIO, MEDIA_TYPE.VIDEO ];
        const store = {
            dispatch,
            getState
        };
        const promises = [];
        const state = getState();

        // The following executes on React Native only at the time of this
        // writing. The effort to port Web's createInitialLocalTracks
        // is significant and that's where the function createLocalTracksF got
        // born. I started with the idea a porting so that we could inherit the
        // ability to getUserMedia for audio only or video only if getUserMedia
        // for audio and video fails. Eventually though, I realized that on
        // mobile we do not have combined permission prompts implemented anyway
        // (either because there are no such prompts or it does not make sense
        // to implement them) and the right thing to do is to ask for each
        // device separately.
        for (const device of devices) {
            if (getLocalTrack(
                state['features/base/tracks'],
                    device as MediaType,
                    /* includePending */ true)) {
                throw new Error(`Local track for ${device} already exists`);
            }

            const gumProcess: any
                = createLocalTracksF(
                    {
                        cameraDeviceId: options.cameraDeviceId,
                        devices: [ device ],
                        facingMode:
                            options.facingMode || getCameraFacingMode(state),
                        micDeviceId: options.micDeviceId
                    },
                    store)
                .then( // @ts-ignore
                    (localTracks: any[]) => {
                        // Because GUM is called for 1 device (which is actually
                        // a media type 'audio', 'video', 'screen', etc.) we
                        // should not get more than one JitsiTrack.
                        if (localTracks.length !== 1) {
                            throw new Error(
                                `Expected exactly 1 track, but was given ${
                                    localTracks.length} tracks for device: ${
                                    device}.`);
                        }

                        if (gumProcess.canceled) {
                            return _disposeTracks(localTracks)
                                .then(() =>
                                    dispatch(_trackCreateCanceled(device as MediaType)));
                        }

                        return dispatch(trackAdded(localTracks[0]));
                    },
                    (reason: Error) =>
                        dispatch(
                            gumProcess.canceled
                                ? _trackCreateCanceled(device as MediaType)
                                : _onCreateLocalTracksRejected(
                                    reason,
                                    device)));

            promises.push(gumProcess.catch(() => undefined));

            /**
             * Cancels the {@code getUserMedia} process represented by this
             * {@code Promise}.
             *
             * @returns {Promise} This {@code Promise} i.e. {@code gumProcess}.
             */
            gumProcess.cancel = () => {
                gumProcess.canceled = true;

                return gumProcess;
            };

            dispatch({
                type: TRACK_WILL_CREATE,
                track: {
                    gumProcess,
                    local: true,
                    mediaType: device
                }
            });
        }

        return Promise.all(promises);
    };
}

/**
 * Calls JitsiLocalTrack#dispose() on the given track or on all local tracks (if none are passed) ignoring errors if
 * track is already disposed. After that signals tracks to be removed.
 *
 * @param {JitsiLocalTrack|null} [track] - The local track that needs to be destroyed.
 * @returns {Function}
 */
export function destroyLocalTracks(track: any = null) {
    if (track) {
        return (dispatch: IStore['dispatch']) => dispatch(_disposeAndRemoveTracks([ track ]));
    }

    return (dispatch: IStore['dispatch'], getState: IStore['getState']) =>

        // First wait until any getUserMedia in progress is settled and then get
        // rid of all local tracks.
        _cancelGUMProcesses(getState)
            .then(() =>
                dispatch(
                    _disposeAndRemoveTracks(
                        getState()['features/base/tracks']
                            .filter(t => t.local)
                            .map(t => t.jitsiTrack))));
}

/**
 * Signals that the passed JitsiLocalTrack has triggered a no data from source event.
 *
 * @param {JitsiLocalTrack} track - The track.
 * @returns {{
*     type: TRACK_NO_DATA_FROM_SOURCE,
*     track: Track
* }}
*/
export function noDataFromSource(track: any) {
    return {
        type: TRACK_NO_DATA_FROM_SOURCE,
        track
    };
}

/**
 * Displays a no data from source video error if needed.
 *
 * @param {JitsiLocalTrack} jitsiTrack - The track.
 * @returns {Function}
 */
export function showNoDataFromSourceVideoError(jitsiTrack: any) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        let notificationInfo;

        const track = getTrackByJitsiTrack(getState()['features/base/tracks'], jitsiTrack);

        if (!track) {
            return;
        }

        if (track.isReceivingData) {
            notificationInfo = undefined;
        } else {
            const notificationAction = dispatch(showErrorNotification({
                descriptionKey: 'dialog.cameraNotSendingData',
                titleKey: 'dialog.cameraNotSendingDataTitle'
            }, NOTIFICATION_TIMEOUT_TYPE.LONG));

            notificationInfo = {
                uid: notificationAction?.uid
            };
        }
        dispatch(trackNoDataFromSourceNotificationInfoChanged(jitsiTrack, notificationInfo));
    };
}

/**
 * Replaces one track with another for one renegotiation instead of invoking
 * two renegotiations with a separate removeTrack and addTrack. Disposes the
 * removed track as well.
 *
 * @param {JitsiLocalTrack|null} oldTrack - The track to dispose.
 * @param {JitsiLocalTrack|null} newTrack - The track to use instead.
 * @param {JitsiConference} [conference] - The conference from which to remove
 * and add the tracks. If one is not provided, the conference in the redux store
 * will be used.
 * @returns {Function}
 */
export function replaceLocalTrack(oldTrack: any, newTrack: any, conference?: IJitsiConference) {
    return async (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        conference

            // eslint-disable-next-line no-param-reassign
            || (conference = getState()['features/base/conference'].conference);

        if (conference) {
            await conference.replaceTrack(oldTrack, newTrack);
        }

        return dispatch(replaceStoredTracks(oldTrack, newTrack));
    };
}

/**
 * Replaces a stored track with another.
 *
 * @param {JitsiLocalTrack|null} oldTrack - The track to dispose.
 * @param {JitsiLocalTrack|null} newTrack - The track to use instead.
 * @returns {Function}
 */
function replaceStoredTracks(oldTrack: any, newTrack: any) {
    return async (dispatch: IStore['dispatch']) => {
        // We call dispose after doing the replace because dispose will
        // try and do a new o/a after the track removes itself. Doing it
        // after means the JitsiLocalTrack.conference is already
        // cleared, so it won't try and do the o/a.
        if (oldTrack) {
            await dispatch(_disposeAndRemoveTracks([ oldTrack ]));
        }

        if (newTrack) {
            // The mute state of the new track should be reflected in the app's mute state. For example, if the
            // app is currently muted and changing to a new track that is not muted, the app's mute state
            // should be falsey. As such, emit a mute event here to set up the app to reflect the track's mute
            // state. If this is not done, the current mute state of the app will be reflected on the track,
            // not vice-versa.
            const setMuted = newTrack.isVideoTrack()
                ? newTrack.getVideoType() === VIDEO_TYPE.DESKTOP
                    ? setScreenshareMuted
                    : setVideoMuted
                : setAudioMuted;
            const isMuted = newTrack.isMuted();

            sendAnalytics(createTrackMutedEvent(newTrack.getType(), 'track.replaced', isMuted));
            logger.log(`Replace ${newTrack.getType()} track - ${isMuted ? 'muted' : 'unmuted'}`);

            dispatch(setMuted(isMuted));
            await dispatch(_addTracks([ newTrack ]));
        }
    };
}

/**
 * Create an action for when a new track has been signaled to be added to the
 * conference.
 *
 * @param {(JitsiLocalTrack|JitsiRemoteTrack)} track - JitsiTrack instance.
 * @returns {Function}
 */
export function trackAdded(track: any) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        track.on(
            JitsiTrackEvents.TRACK_MUTE_CHANGED,
            () => dispatch(trackMutedChanged(track)));
        track.on(
            JitsiTrackEvents.TRACK_VIDEOTYPE_CHANGED,
            (type: VideoType) => dispatch(trackVideoTypeChanged(track, type)));
        const local = track.isLocal();
        const mediaType = track.getVideoType() === VIDEO_TYPE.DESKTOP
            ? MEDIA_TYPE.SCREENSHARE
            : track.getType();
        let isReceivingData, noDataFromSourceNotificationInfo, participantId;

        if (local) {
            // Reset the no data from src notification state when we change the track, as it's context is set
            // on a per device basis.
            dispatch(setNoSrcDataNotificationUid());
            const participant = getLocalParticipant(getState);

            if (participant) {
                participantId = participant.id;
            }

            isReceivingData = track.isReceivingData();
            track.on(JitsiTrackEvents.NO_DATA_FROM_SOURCE, () => dispatch(noDataFromSource({ jitsiTrack: track })));
            if (!isReceivingData) {
                if (mediaType === MEDIA_TYPE.AUDIO) {
                    const notificationAction = dispatch(showNotification({
                        descriptionKey: 'dialog.micNotSendingData',
                        titleKey: 'dialog.micNotSendingDataTitle'
                    }, NOTIFICATION_TIMEOUT_TYPE.LONG));

                    // Set the notification ID so that other parts of the application know that this was
                    // displayed in the context of the current device.
                    // I.E. The no-audio-signal notification shouldn't be displayed if this was already shown.
                    dispatch(setNoSrcDataNotificationUid(notificationAction?.uid));

                    noDataFromSourceNotificationInfo = { uid: notificationAction?.uid };
                } else {
                    const timeout = setTimeout(() => dispatch(
                        showNoDataFromSourceVideoError(track)),
                        NOTIFICATION_TIMEOUT.MEDIUM);

                    noDataFromSourceNotificationInfo = { timeout };
                }
            }

            track.on(JitsiTrackEvents.LOCAL_TRACK_STOPPED,
                () => dispatch({
                    type: TRACK_STOPPED,
                    track: {
                        jitsiTrack: track
                    }
                }));
        } else {
            participantId = track.getParticipantId();
            isReceivingData = true;
        }

        return dispatch({
            type: TRACK_ADDED,
            track: {
                jitsiTrack: track,
                isReceivingData,
                local,
                mediaType,
                mirror: _shouldMirror(track),
                muted: track.isMuted(),
                noDataFromSourceNotificationInfo,
                participantId,
                videoStarted: false,
                videoType: track.videoType
            }
        });
    };
}

/**
 * Create an action for when a track's codec has been signaled to have been changed.
 *
 * @param {JitsiLocalTrack} track - JitsiLocalTrack instance.
 * @param {string} codec - The video codec.
 * @returns {{
 *     type: TRACK_UPDATED,
 *     track: Track
 * }}
 */
export function trackCodecChanged(track: ITrack, codec: string): {
    track: {
        codec: string;
        jitsiTrack: any;
    };
    type: 'TRACK_UPDATED';
} {
    return {
        type: TRACK_UPDATED,
        track: {
            codec,
            jitsiTrack: track
        }
    };
}

/**
 * Create an action for when a track's muted state has been signaled to be
 * changed.
 *
 * @param {(JitsiLocalTrack|JitsiRemoteTrack)} track - JitsiTrack instance.
 * @returns {{
 *     type: TRACK_UPDATED,
 *     track: Track
 * }}
 */
export function trackMutedChanged(track: any): {
    track: {
        jitsiTrack: any;
        muted: boolean;
    };
    type: 'TRACK_UPDATED';
} {
    return {
        type: TRACK_UPDATED,
        track: {
            jitsiTrack: track,
            muted: track.isMuted()
        }
    };
}

/**
 * Create an action for when a track's muted state change action has failed. This could happen because of
 * {@code getUserMedia} errors during unmute or replace track errors at the peerconnection level.
 *
 * @param {(JitsiLocalTrack|JitsiRemoteTrack)} track - JitsiTrack instance.
 * @param {boolean} wasMuting - If the operation that failed was a mute operation or an unmute operation.
 * @returns {{
 *     type: TRACK_MUTE_UNMUTE_FAILED,
 *     track: Track
 * }}
 */
export function trackMuteUnmuteFailed(track: any, wasMuting: boolean): {
    track: any;
    type: 'TRACK_MUTE_UNMUTE_FAILED';
    wasMuting: boolean;
} {
    return {
        type: TRACK_MUTE_UNMUTE_FAILED,
        track,
        wasMuting
    };
}

/**
 * Create an action for when a track's no data from source notification information changes.
 *
 * @param {JitsiLocalTrack} track - JitsiTrack instance.
 * @param {Object} noDataFromSourceNotificationInfo - Information about no data from source notification.
 * @returns {{
 *     type: TRACK_UPDATED,
 *     track: Track
 * }}
 */
export function trackNoDataFromSourceNotificationInfoChanged(track: any, noDataFromSourceNotificationInfo?: Object) {
    return {
        type: TRACK_UPDATED,
        track: {
            jitsiTrack: track,
            noDataFromSourceNotificationInfo
        }
    };
}

/**
 * Create an action for when a track has been signaled for removal from the
 * conference.
 *
 * @param {(JitsiLocalTrack|JitsiRemoteTrack)} track - JitsiTrack instance.
 * @returns {{
 *     type: TRACK_REMOVED,
 *     track: Track
 * }}
 */
export function trackRemoved(track: any): {
    track: {
        jitsiTrack: any;
    };
    type: 'TRACK_REMOVED';
} {
    track.removeAllListeners(JitsiTrackEvents.TRACK_MUTE_CHANGED);
    track.removeAllListeners(JitsiTrackEvents.TRACK_VIDEOTYPE_CHANGED);
    track.removeAllListeners(JitsiTrackEvents.NO_DATA_FROM_SOURCE);

    return {
        type: TRACK_REMOVED,
        track: {
            jitsiTrack: track
        }
    };
}

/**
 * Signal that track's video started to play.
 *
 * @param {(JitsiLocalTrack|JitsiRemoteTrack)} track - JitsiTrack instance.
 * @returns {{
 *     type: TRACK_UPDATED,
 *     track: Track
 * }}
 */
export function trackVideoStarted(track: any): {
    track: {
        jitsiTrack: any;
        videoStarted: true;
    };
    type: 'TRACK_UPDATED';
} {
    return {
        type: TRACK_UPDATED,
        track: {
            jitsiTrack: track,
            videoStarted: true
        }
    };
}

/**
 * Create an action for when participant video type changes.
 *
 * @param {(JitsiLocalTrack|JitsiRemoteTrack)} track - JitsiTrack instance.
 * @param {VIDEO_TYPE|undefined} videoType - Video type.
 * @returns {{
 *     type: TRACK_UPDATED,
 *     track: Track
 * }}
 */
export function trackVideoTypeChanged(track: any, videoType: VideoType) {
    const mediaType = videoType === VIDEO_TYPE.CAMERA ? MEDIA_TYPE.VIDEO : MEDIA_TYPE.SCREENSHARE;

    return {
        type: TRACK_UPDATED,
        track: {
            jitsiTrack: track,
            videoType,
            mediaType
        }
    };
}

/**
 * Create an action for when track streaming status changes.
 *
 * @param {(JitsiRemoteTrack)} track - JitsiTrack instance.
 * @param {string} streamingStatus - The new streaming status of the track.
 * @returns {{
 *     type: TRACK_UPDATED,
 *     track: Track
 * }}
 */
export function trackStreamingStatusChanged(track: any, streamingStatus: string): {
    track: {
        jitsiTrack: any;
        streamingStatus: string;
    };
    type: 'TRACK_UPDATED';
} {
    return {
        type: TRACK_UPDATED,
        track: {
            jitsiTrack: track,
            streamingStatus
        }
    };
}

/**
 * Signals passed tracks to be added.
 *
 * @param {(JitsiLocalTrack|JitsiRemoteTrack)[]} tracks - List of tracks.
 * @private
 * @returns {Function}
 */
function _addTracks(tracks: any[]) {
    return (dispatch: IStore['dispatch']) => Promise.all(tracks.map(t => dispatch(trackAdded(t))));
}

/**
 * Cancels and waits for any {@code getUserMedia} process/currently in progress
 * to complete/settle.
 *
 * @param {Function} getState - The redux store {@code getState} function used
 * to obtain the state.
 * @private
 * @returns {Promise} - A {@code Promise} resolved once all
 * {@code gumProcess.cancel()} {@code Promise}s are settled because all we care
 * about here is to be sure that the {@code getUserMedia} callbacks have
 * completed (i.e. Returned from the native side).
 */
function _cancelGUMProcesses(getState: IStore['getState']): Promise<any> {
    const logError
        = (error: Error) =>
            logger.error('gumProcess.cancel failed', JSON.stringify(error));

    return Promise.all(
        getState()['features/base/tracks']
            .filter(t => t.local)
            .map(({ gumProcess }: any) =>
                gumProcess?.cancel().catch(logError)));
}

/**
 * Disposes passed tracks and signals them to be removed.
 *
 * @param {(JitsiLocalTrack|JitsiRemoteTrack)[]} tracks - List of tracks.
 * @protected
 * @returns {Function}
 */
export function _disposeAndRemoveTracks(tracks: any[]) {
    return (dispatch: IStore['dispatch']) =>
        _disposeTracks(tracks)
            .then(() =>
                Promise.all(tracks.map(t => dispatch(trackRemoved(t)))));
}

/**
 * Disposes passed tracks.
 *
 * @param {(JitsiLocalTrack|JitsiRemoteTrack)[]} tracks - List of tracks.
 * @private
 * @returns {Promise} - A Promise resolved once {@link JitsiTrack.dispose()} is
 * done for every track from the list.
 */
function _disposeTracks(tracks: any[]): Promise<any> {
    return Promise.all(
        tracks.map(t =>
            t.dispose()
                .catch((err: Error) => {
                    // Track might be already disposed so ignore such an error.
                    // Of course, re-throw any other error(s).
                    if (err.name !== JitsiTrackErrors.TRACK_IS_DISPOSED) {
                        throw err;
                    }
                })));
}

/**
 * Implements the {@code Promise} rejection handler of
 * {@code createLocalTracksA} and {@code createLocalTracksF}.
 *
 * @param {Object} error - The {@code Promise} rejection reason.
 * @param {string} device - The device/{@code MEDIA_TYPE} associated with the
 * rejection.
 * @private
 * @returns {Function}
 */
function _onCreateLocalTracksRejected(error?: Error, device?: string) {
    return (dispatch: IStore['dispatch']) => {
        // If permissions are not allowed, alert the user.
        dispatch({
            type: TRACK_CREATE_ERROR,
            permissionDenied: error?.name === 'SecurityError',
            trackType: device
        });
    };
}

/**
 * Returns true if the provided {@code JitsiTrack} should be rendered as a
 * mirror.
 *
 * We only want to show a video in mirrored mode when:
 * 1) The video source is local, and not remote.
 * 2) The video source is a camera, not a desktop (capture).
 * 3) The camera is capturing the user, not the environment.
 *
 * TODO Similar functionality is part of lib-jitsi-meet. This function should be
 * removed after https://github.com/jitsi/lib-jitsi-meet/pull/187 is merged.
 *
 * @param {(JitsiLocalTrack|JitsiRemoteTrack)} track - JitsiTrack instance.
 * @private
 * @returns {boolean}
 */
function _shouldMirror(track: any): boolean {
    return (
        track?.isLocal()
            && track?.isVideoTrack()

            // XXX The type of the return value of JitsiLocalTrack's
            // getCameraFacingMode happens to be named CAMERA_FACING_MODE as
            // well, it's defined by lib-jitsi-meet. Note though that the type
            // of the value on the right side of the equality check is defined
            // by jitsi-meet. The type definitions are surely compatible today
            // but that may not be the case tomorrow.
            && track?.getCameraFacingMode() === CAMERA_FACING_MODE.USER);
}

/**
 * Signals that track create operation for given media track has been canceled.
 * Will clean up local track stub from the redux state which holds the
 * {@code gumProcess} reference.
 *
 * @param {MEDIA_TYPE} mediaType - The type of the media for which the track was
 * being created.
 * @private
 * @returns {{
 *     type,
 *     trackType: MEDIA_TYPE
 * }}
 */
function _trackCreateCanceled(mediaType: MediaType): {
    trackType: MediaType;
    type: 'TRACK_CREATE_CANCELED';
} {
    return {
        type: TRACK_CREATE_CANCELED,
        trackType: mediaType
    };
}

/**
 * If the local track if of type Desktop, it calls _disposeAndRemoveTracks) on it.
 *
 * @returns {Function}
 */
export function destroyLocalDesktopTrackIfExists() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const videoTrack = getLocalVideoTrack(getState()['features/base/tracks']);
        const isDesktopTrack = videoTrack && videoTrack.videoType === VIDEO_TYPE.DESKTOP;

        if (isDesktopTrack) {
            dispatch(_disposeAndRemoveTracks([ videoTrack.jitsiTrack ]));
        }
    };
}

/**
 * Sets UID of the displayed no data from source notification. Used to track
 * if the notification was previously displayed in this context.
 *
 * @param {number} uid - Notification UID.
 * @returns {{
    *     type: SET_NO_AUDIO_SIGNAL_UID,
    *     uid: string
    * }}
    */
export function setNoSrcDataNotificationUid(uid?: string) {
    return {
        type: SET_NO_SRC_DATA_NOTIFICATION_UID,
        uid
    };
}

/**
 * Toggles the facingMode constraint on the video stream.
 *
 * @returns {Function}
 */
export function toggleCamera() {
    return async (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const tracks = state['features/base/tracks'];
        const localVideoTrack = getLocalVideoTrack(tracks)?.jitsiTrack;
        const currentFacingMode = localVideoTrack.getCameraFacingMode();
        const { localFlipX } = state['features/base/settings'];

        /**
         * FIXME: Ideally, we should be dispatching {@code replaceLocalTrack} here,
         * but it seems to not trigger the re-rendering of the local video on Chrome;
         * could be due to a plan B vs unified plan issue. Therefore, we use the legacy
         * method defined in conference.js that manually takes care of updating the local
         * video as well.
         */
        await APP.conference.useVideoStream(null);

        const targetFacingMode = currentFacingMode === CAMERA_FACING_MODE.USER
            ? CAMERA_FACING_MODE.ENVIRONMENT
            : CAMERA_FACING_MODE.USER;

        // Update the flipX value so the environment facing camera is not flipped, before the new track is created.
        dispatch(updateSettings({ localFlipX: targetFacingMode === CAMERA_FACING_MODE.USER ? localFlipX : false }));

        const newVideoTrack = await createLocalTrack('video', null, null, { facingMode: targetFacingMode });

        // FIXME: See above.
        await APP.conference.useVideoStream(newVideoTrack);
    };
}


################################################################################

## File: .\jitsi-meet\react\features\base\tracks\actions.native.ts

import { IReduxState, IStore } from '../../app/types';
import { setPictureInPictureEnabled } from '../../mobile/picture-in-picture/functions';
import { showNotification } from '../../notifications/actions';
import { NOTIFICATION_TIMEOUT_TYPE } from '../../notifications/constants';
import { PIP_WHILE_SCREEN_SHARING_ENABLED } from '../flags/constants';
import { getFeatureFlag } from '../flags/functions';
import JitsiMeetJS from '../lib-jitsi-meet';
import {
    setScreenshareMuted,
    setVideoMuted
} from '../media/actions';
import { VIDEO_MUTISM_AUTHORITY } from '../media/constants';

import { addLocalTrack, replaceLocalTrack } from './actions.any';
import { getLocalDesktopTrack, getTrackState, isLocalVideoTrackDesktop } from './functions.native';


export * from './actions.any';

/**
 * Signals that the local participant is ending screensharing or beginning the screensharing flow.
 *
 * @param {boolean} enabled - The state to toggle screen sharing to.
 * @param {boolean} _ignore1 - Ignored.
 * @param {any} _ignore2 - Ignored.
 * @returns {Function}
 */
export function toggleScreensharing(enabled: boolean, _ignore1?: boolean, _ignore2?: any) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();

        if (enabled) {
            const isSharing = isLocalVideoTrackDesktop(state);

            if (!isSharing) {
                _startScreenSharing(dispatch, state);
            }
        } else {
            dispatch(setScreenshareMuted(true));
            dispatch(setVideoMuted(false, VIDEO_MUTISM_AUTHORITY.SCREEN_SHARE));
            setPictureInPictureEnabled(true);
        }
    };
}

/**
 * Creates desktop track and replaces the local one.
 *
 * @private
 * @param {Dispatch} dispatch - The redux {@code dispatch} function.
 * @param {Object} state - The redux state.
 * @returns {void}
 */
async function _startScreenSharing(dispatch: IStore['dispatch'], state: IReduxState) {
    const pipWhileScreenSharingEnabled = getFeatureFlag(state, PIP_WHILE_SCREEN_SHARING_ENABLED, false);

    if (!pipWhileScreenSharingEnabled) {
        setPictureInPictureEnabled(false);
    }

    try {
        const tracks: any[] = await JitsiMeetJS.createLocalTracks({ devices: [ 'desktop' ] });
        const track = tracks[0];
        const currentLocalDesktopTrack = getLocalDesktopTrack(getTrackState(state));
        const currentJitsiTrack = currentLocalDesktopTrack?.jitsiTrack;

        // The first time the user shares the screen we add the track and create the transceiver.
        // Afterwards, we just replace the old track, so the transceiver will be reused.
        if (currentJitsiTrack) {
            dispatch(replaceLocalTrack(currentJitsiTrack, track));
        } else {
            dispatch(addLocalTrack(track));
        }

        dispatch(setVideoMuted(true, VIDEO_MUTISM_AUTHORITY.SCREEN_SHARE));

        const { enabled: audioOnly } = state['features/base/audio-only'];

        if (audioOnly) {
            dispatch(showNotification({
                titleKey: 'notify.screenSharingAudioOnlyTitle',
                descriptionKey: 'notify.screenSharingAudioOnlyDescription',
                maxLines: 3
            }, NOTIFICATION_TIMEOUT_TYPE.LONG));
        }
    } catch (error: any) {
        console.log('ERROR creating screen-sharing stream ', error);

        setPictureInPictureEnabled(true);
    }
}


################################################################################

## File: .\jitsi-meet\react\features\base\tracks\actions.web.ts

// @ts-expect-error
import { AUDIO_ONLY_SCREEN_SHARE_NO_TRACK } from '../../../../modules/UI/UIErrors';
import { IReduxState, IStore } from '../../app/types';
import { showModeratedNotification } from '../../av-moderation/actions';
import { shouldShowModeratedNotification } from '../../av-moderation/functions';
import { setNoiseSuppressionEnabled } from '../../noise-suppression/actions';
import { showErrorNotification, showNotification } from '../../notifications/actions';
import { NOTIFICATION_TIMEOUT_TYPE } from '../../notifications/constants';
import { stopReceiver } from '../../remote-control/actions';
import { setScreenAudioShareState, setScreenshareAudioTrack } from '../../screen-share/actions';
import { isAudioOnlySharing, isScreenVideoShared } from '../../screen-share/functions';
import { toggleScreenshotCaptureSummary } from '../../screenshot-capture/actions';
import { isScreenshotCaptureEnabled } from '../../screenshot-capture/functions';
import { AudioMixerEffect } from '../../stream-effects/audio-mixer/AudioMixerEffect';
import { getCurrentConference } from '../conference/functions';
import { notifyCameraError, notifyMicError } from '../devices/actions.web';
import { openDialog } from '../dialog/actions';
import { JitsiTrackErrors, JitsiTrackEvents, browser } from '../lib-jitsi-meet';
import { gumPending, setScreenshareMuted } from '../media/actions';
import { MEDIA_TYPE, MediaType, VIDEO_TYPE } from '../media/constants';
import { IGUMPendingState } from '../media/types';

import {
    addLocalTrack,
    replaceLocalTrack,
    toggleCamera
} from './actions.any';
import AllowToggleCameraDialog from './components/web/AllowToggleCameraDialog';
import {
    createLocalTracksF,
    getLocalDesktopTrack,
    getLocalJitsiAudioTrack,
    getLocalVideoTrack,
    isToggleCameraEnabled
} from './functions';
import logger from './logger';
import { ICreateInitialTracksOptions, IInitialTracksErrors, IShareOptions, IToggleScreenSharingOptions } from './types';

export * from './actions.any';

/**
 * Signals that the local participant is ending screensharing or beginning the screensharing flow.
 *
 * @param {boolean} enabled - The state to toggle screen sharing to.
 * @param {boolean} audioOnly - Only share system audio.
 * @param {Object} shareOptions - The options to be passed for capturing screenshare.
 * @returns {Function}
 */
export function toggleScreensharing(
        enabled?: boolean,
        audioOnly = false,
        shareOptions: IShareOptions = {}) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        // check for A/V Moderation when trying to start screen sharing
        if ((enabled || enabled === undefined) && shouldShowModeratedNotification(MEDIA_TYPE.VIDEO, getState())) {
            dispatch(showModeratedNotification(MEDIA_TYPE.SCREENSHARE));

            return Promise.reject();
        }

        return _toggleScreenSharing({
            enabled,
            audioOnly,
            shareOptions
        }, {
            dispatch,
            getState
        });
    };
}

/**
 * Displays a UI notification for screensharing failure based on the error passed.
 *
 * @private
 * @param {Object} error - The error.
 * @param {Object} store - The redux store.
 * @returns {void}
 */


/**
 * Applies the AudioMixer effect on the local audio track if applicable. If there is no local audio track, the desktop
 * audio track is added to the conference.
 *
 * @private
 * @param {JitsiLocalTrack} desktopAudioTrack - The audio track to be added to the conference.
 * @param {*} state - The redux state.
 * @returns {void}
 */
async function _maybeApplyAudioMixerEffect(desktopAudioTrack: any, state: IReduxState): Promise<void> {
    const localAudio = getLocalJitsiAudioTrack(state);
    const conference = getCurrentConference(state);

    if (localAudio) {
        // If there is a localAudio stream, mix in the desktop audio stream captured by the screen sharing API.
        const mixerEffect = new AudioMixerEffect(desktopAudioTrack);

        await localAudio.setEffect(mixerEffect);
    } else {
        // If no local stream is present ( i.e. no input audio devices) we use the screen share audio
        // stream as we would use a regular stream.
        await conference?.replaceTrack(null, desktopAudioTrack);
    }
}

/**
 * Toggles screen sharing.
 *
 * @private
 * @param {boolean} enabled - The state to toggle screen sharing to.
 * @param {Store} store - The redux store.
 * @returns {void}
 */
async function _toggleScreenSharing(
        {
            enabled,
            audioOnly = false,
            shareOptions = {}
        }: IToggleScreenSharingOptions,
        store: IStore
): Promise<void> {
    const { dispatch, getState } = store;
    const state = getState();
    const audioOnlySharing = isAudioOnlySharing(state);
    const screenSharing = isScreenVideoShared(state);
    const conference = getCurrentConference(state);
    const localAudio = getLocalJitsiAudioTrack(state);
    const localScreenshare = getLocalDesktopTrack(state['features/base/tracks']);

    // Toggle screenshare or audio-only share if the new state is not passed. Happens in the following two cases.
    // 1. ShareAudioDialog passes undefined when the user hits continue in the share audio demo modal.
    // 2. Toggle screenshare called from the external API.
    const enable = audioOnly
        ? enabled ?? !audioOnlySharing
        : enabled ?? !screenSharing;
    const screensharingDetails: { sourceType?: string; } = {};

    if (enable) {
        let tracks;

        // Spot proxy stream.
        if (shareOptions.desktopStream) {
            tracks = [ shareOptions.desktopStream ];
        } else {
            const { _desktopSharingSourceDevice } = state['features/base/config'];

            if (!shareOptions.desktopSharingSources && _desktopSharingSourceDevice) {
                shareOptions.desktopSharingSourceDevice = _desktopSharingSourceDevice;
            }

            const options = {
                devices: [ VIDEO_TYPE.DESKTOP ],
                ...shareOptions
            };

            try {
                tracks = await createLocalTracksF(options) as any[];
            } catch (error) {
                dispatch(handleScreenSharingError(error, NOTIFICATION_TIMEOUT_TYPE.MEDIUM));

                throw error;
            }
        }

        const desktopAudioTrack = tracks.find(track => track.getType() === MEDIA_TYPE.AUDIO);
        const desktopVideoTrack = tracks.find(track => track.getType() === MEDIA_TYPE.VIDEO);

        if (audioOnly) {
            // Dispose the desktop track for audio-only screensharing.
            desktopVideoTrack.dispose();

            if (!desktopAudioTrack) {
                dispatch(handleScreenSharingError(AUDIO_ONLY_SCREEN_SHARE_NO_TRACK, NOTIFICATION_TIMEOUT_TYPE.MEDIUM));

                throw new Error(AUDIO_ONLY_SCREEN_SHARE_NO_TRACK);
            }
        } else if (desktopVideoTrack) {
            if (localScreenshare) {
                await dispatch(replaceLocalTrack(localScreenshare.jitsiTrack, desktopVideoTrack, conference));
            } else {
                await dispatch(addLocalTrack(desktopVideoTrack));
            }
            if (isScreenshotCaptureEnabled(state, false, true)) {
                dispatch(toggleScreenshotCaptureSummary(true));
            }
            screensharingDetails.sourceType = desktopVideoTrack.sourceType;
        }

        // Apply the AudioMixer effect if there is a local audio track, add the desktop track to the conference
        // otherwise without unmuting the microphone.
        if (desktopAudioTrack) {
            // Noise suppression doesn't work with desktop audio because we can't chain track effects yet, disable it
            // first. We need to to wait for the effect to clear first or it might interfere with the audio mixer.
            await dispatch(setNoiseSuppressionEnabled(false));
            _maybeApplyAudioMixerEffect(desktopAudioTrack, state);
            dispatch(setScreenshareAudioTrack(desktopAudioTrack));

            // Handle the case where screen share was stopped from the browsers 'screen share in progress' window.
            if (audioOnly) {
                desktopAudioTrack?.on(
                    JitsiTrackEvents.LOCAL_TRACK_STOPPED,
                    () => dispatch(toggleScreensharing(undefined, true)));
            }
        }

        // Show notification about more bandwidth usage in audio-only mode if the user starts screensharing. This
        // doesn't apply to audio-only screensharing.
        const { enabled: bestPerformanceMode } = state['features/base/audio-only'];

        if (bestPerformanceMode && !audioOnly) {
            dispatch(showNotification({
                titleKey: 'notify.screenSharingAudioOnlyTitle',
                descriptionKey: 'notify.screenSharingAudioOnlyDescription'
            }, NOTIFICATION_TIMEOUT_TYPE.LONG));
        }
    } else {
        const { desktopAudioTrack } = state['features/screen-share'];

        dispatch(stopReceiver());

        dispatch(toggleScreenshotCaptureSummary(false));

        // Mute the desktop track instead of removing it from the conference since we don't want the client to signal
        // a source-remove to the remote peer for the screenshare track. Later when screenshare is enabled again, the
        // same sender will be re-used without the need for signaling a new ssrc through source-add.
        dispatch(setScreenshareMuted(true));
        if (desktopAudioTrack) {
            if (localAudio) {
                localAudio.setEffect(undefined);
            } else {
                await conference?.replaceTrack(desktopAudioTrack, null);
            }
            desktopAudioTrack.dispose();
            dispatch(setScreenshareAudioTrack(null));
        }
    }

    if (audioOnly) {
        dispatch(setScreenAudioShareState(enable));
    } else {
        // Notify the external API.
        APP.API.notifyScreenSharingStatusChanged(enable, screensharingDetails);
    }
}

/**
 * Sets the camera facing mode(environment/user). If facing mode not provided, it will do a toggle.
 *
 * @param {string | undefined} facingMode - The selected facing mode.
 * @returns {void}
 */
export function setCameraFacingMode(facingMode: string | undefined) {
    return async (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();

        if (!isToggleCameraEnabled(state)) {
            return;
        }

        if (!facingMode) {
            dispatch(toggleCamera());

            return;
        }

        const tracks = state['features/base/tracks'];
        const localVideoTrack = getLocalVideoTrack(tracks)?.jitsiTrack;

        if (!tracks || !localVideoTrack) {
            return;
        }

        const currentFacingMode = localVideoTrack.getCameraFacingMode();

        if (currentFacingMode !== facingMode) {
            dispatch(toggleCamera());
        }
    };
}

/**
 * Signals to open the permission dialog for toggling camera remotely.
 *
 * @param {Function} onAllow - Callback to be executed if permission to toggle camera was granted.
 * @param {string} initiatorId - The participant id of the requester.
 * @returns {Object} - The open dialog action.
 */
export function openAllowToggleCameraDialog(onAllow: Function, initiatorId: string) {
    return openDialog(AllowToggleCameraDialog, {
        onAllow,
        initiatorId
    });
}

/**
 * Sets the GUM pending state for the tracks that have failed.
 *
 * NOTE: Some of the track that we will be setting to GUM pending state NONE may not have failed but they may have
 * been requested. This won't be a problem because their current GUM pending state will be NONE anyway.
 *
 * @param {JitsiLocalTrack} tracks - The tracks that have been created.
 * @param {Function} dispatch - The redux dispatch function.
 * @returns {void}
 */
export function setGUMPendingStateOnFailedTracks(tracks: Array<any>, dispatch: IStore['dispatch']) {
    const tracksTypes = tracks.map(track => {
        if (track.getVideoType() === VIDEO_TYPE.DESKTOP) {
            return MEDIA_TYPE.SCREENSHARE;
        }

        return track.getType();
    });
    const nonPendingTracks = [ MEDIA_TYPE.AUDIO, MEDIA_TYPE.VIDEO ].filter(type => !tracksTypes.includes(type));

    dispatch(gumPending(nonPendingTracks, IGUMPendingState.NONE));
}

/**
 * Creates and adds to the conference the initial audio/video tracks.
 *
 * @param {Array<MediaType>} devices - Array with devices (audio/video) that will be used.
 * @returns {Function}
 */
export function createAndAddInitialAVTracks(devices: Array<MediaType>) {
    return async (dispatch: IStore['dispatch']) => {
        dispatch(gumPending(devices, IGUMPendingState.PENDING_UNMUTE));

        const { tracks, errors } = await dispatch(createInitialAVTracks({ devices }));

        setGUMPendingStateOnFailedTracks(tracks, dispatch);
        dispatch(displayErrorsForCreateInitialLocalTracks(errors));

        await Promise.allSettled(tracks.map((track: any) => {
            const legacyConferenceObject = APP.conference;

            if (track.isAudioTrack()) {
                return legacyConferenceObject.useAudioStream(track);
            }
            if (track.isVideoTrack()) {
                return legacyConferenceObject.useVideoStream(track);
            }

            return Promise.resolve();
        }));

        dispatch(gumPending(devices, IGUMPendingState.NONE));
    };
}

/**
 * Creates the initial audio/video tracks.
 *
 * @param {ICreateInitialTracksOptions} options - Options for creating the audio/video tracks.
 * @returns {Function}
 */
export function createInitialAVTracks(options: ICreateInitialTracksOptions) {
    return (dispatch: IStore['dispatch'], _getState: IStore['getState']) => {
        const {
            devices,
            timeout,
            firePermissionPromptIsShownEvent
        } = options;

        dispatch(gumPending(devices, IGUMPendingState.PENDING_UNMUTE));

        return createLocalTracksF(options).then(tracks => {
            return {
                errors: {} as IInitialTracksErrors,
                tracks
            };
        })
        .catch(async error => {
            const errors = {} as IInitialTracksErrors;

            if (error.name === JitsiTrackErrors.TIMEOUT && !browser.isElectron()) {
                if (devices.includes(MEDIA_TYPE.AUDIO)) {
                    errors.audioOnlyError = error;
                }

                if (devices.includes(MEDIA_TYPE.VIDEO)) {
                    errors.videoOnlyError = error;
                }

                if (errors.audioOnlyError && errors.videoOnlyError) {
                    errors.audioAndVideoError = error;
                }

                return {
                    errors,
                    tracks: []
                };
            }

            // Retry with separate gUM calls.
            const gUMPromises = [];
            const tracks: any[] | PromiseLike<any[]> = [];

            if (devices.includes(MEDIA_TYPE.AUDIO)) {
                gUMPromises.push(createLocalTracksF({
                    devices: [ MEDIA_TYPE.AUDIO ],
                    timeout,
                    firePermissionPromptIsShownEvent
                }));
            }

            if (devices.includes(MEDIA_TYPE.VIDEO)) {
                gUMPromises.push(createLocalTracksF({
                    devices: [ MEDIA_TYPE.VIDEO ],
                    timeout,
                    firePermissionPromptIsShownEvent
                }));
            }

            const results = await Promise.allSettled(gUMPromises);
            let errorMsg;

            results.forEach((result, idx) => {
                if (result.status === 'fulfilled') {
                    tracks.push(result.value[0]);
                } else {
                    errorMsg = result.reason;
                    const isAudio = idx === 0;

                    logger.error(`${isAudio ? 'Audio' : 'Video'} track creation failed with error ${errorMsg}`);
                    if (isAudio) {
                        errors.audioOnlyError = errorMsg;
                    } else {
                        errors.videoOnlyError = errorMsg;
                    }
                }
            });

            if (errors.audioOnlyError && errors.videoOnlyError) {
                errors.audioAndVideoError = errorMsg;
            }

            return {
                tracks,
                errors
            };
        });
    };
}

/**
 * Displays error notifications according to the state carried by the passed {@code errors} object.
 *
 * @param {InitialTracksErrors} errors - The errors (if any).
 * @returns {Function}
 * @private
 */
export function displayErrorsForCreateInitialLocalTracks(errors: IInitialTracksErrors) {
    return (dispatch: IStore['dispatch']) => {
        const {
            audioOnlyError,
            screenSharingError,
            videoOnlyError
        } = errors;

        if (screenSharingError) {
            dispatch(handleScreenSharingError(screenSharingError, NOTIFICATION_TIMEOUT_TYPE.LONG));
        }
        if (audioOnlyError || videoOnlyError) {
            if (audioOnlyError) {
                dispatch(notifyMicError(audioOnlyError));
            }

            if (videoOnlyError) {
                dispatch(notifyCameraError(videoOnlyError));
            }
        }
    };
}

/**
 * Displays a UI notification for screensharing failure based on the error passed.
 *
 * @private
 * @param {Error | AUDIO_ONLY_SCREEN_SHARE_NO_TRACK} error - The error.
 * @param {NOTIFICATION_TIMEOUT_TYPE} timeout - The time for showing the notification.
 * @returns {Function}
 */
export function handleScreenSharingError(
        error: Error | AUDIO_ONLY_SCREEN_SHARE_NO_TRACK,
        timeout: NOTIFICATION_TIMEOUT_TYPE) {
    return (dispatch: IStore['dispatch']) => {
        logger.error('failed to share local desktop', error);

        let descriptionKey;
        let titleKey;

        if (error.name === JitsiTrackErrors.PERMISSION_DENIED) {
            descriptionKey = 'dialog.screenSharingPermissionDeniedError';
            titleKey = 'dialog.screenSharingFailedTitle';
        } else if (error.name === JitsiTrackErrors.CONSTRAINT_FAILED) {
            descriptionKey = 'dialog.cameraConstraintFailedError';
            titleKey = 'deviceError.cameraError';
        } else if (error.name === JitsiTrackErrors.SCREENSHARING_GENERIC_ERROR) {
            descriptionKey = 'dialog.screenSharingFailed';
            titleKey = 'dialog.screenSharingFailedTitle';
        } else if (error === AUDIO_ONLY_SCREEN_SHARE_NO_TRACK) {
            descriptionKey = 'notify.screenShareNoAudio';
            titleKey = 'notify.screenShareNoAudioTitle';
        } else { // safeguard for not showing notification with empty text. This will also include
            // error.name === JitsiTrackErrors.SCREENSHARING_USER_CANCELED
            return;
        }

        dispatch(showErrorNotification({
            descriptionKey,
            titleKey
        }, timeout));
    };
}


################################################################################

## File: .\jitsi-meet\react\features\base\tracks\actionTypes.ts

/**
 * The type of Redux action which sets the noSrcDataNotificationUid state representing the UID of the previous
 * no data from source notification. Used to check if such a notification was previously displayed.
 *
 * {
 *     type: SET_NO_SRC_DATA_NOTIFICATION_UID,
 *     uid: ?number
 * }
 */
export const SET_NO_SRC_DATA_NOTIFICATION_UID = 'SET_NO_SRC_DATA_NOTIFICATION_UID';

/**
 * The type of redux action dispatched when a track has been (locally or
 * remotely) added to the conference.
 *
 * {
 *     type: TRACK_ADDED,
 *     track: Track
 * }
 */
export const TRACK_ADDED = 'TRACK_ADDED';

/**
 * The type of redux action dispatched when a canceled {@code getUserMedia}
 * process completes either successfully or with an error (the error is ignored
 * and the track is immediately disposed if it has been created).
 *
 * {
 *     type: TRACK_CREATE_CANCELED,
 *     trackType: MEDIA_TYPE
 * }
 */
export const TRACK_CREATE_CANCELED = 'TRACK_CREATE_CANCELED';

/**
 * The type of redux action dispatched when {@code getUserMedia} fails with an
 * error (such as permission denied).
 *
 * {
 *     type: TRACK_CREATE_ERROR,
 *     permissionDenied: Boolean,
 *     trackType: MEDIA_TYPE
 * }
 */
export const TRACK_CREATE_ERROR = 'TRACK_CREATE_ERROR';

/**
 * The type of redux action dispatched when the track mute/unmute operation fails at the conference level. This could
 * happen because of {@code getUserMedia} errors during unmute or replace track errors at the peerconnection level.
 *
 * {
 *     type: TRACK_MUTE_UNMUTE_FAILED,
 *     track: Track,
 *     wasMuting: Boolean
 * }
 */
export const TRACK_MUTE_UNMUTE_FAILED = 'TRACK_MUTE_UNMUTE_FAILED';

/**
 * The type of redux action dispatched when a track has triggered no data from source event.
 *
 * {
 *     type: TRACK_NO_DATA_FROM_SOURCE,
 *     track: Track
 * }
 */
export const TRACK_NO_DATA_FROM_SOURCE = 'TRACK_NO_DATA_FROM_SOURCE';

/**
 * The type of redux action dispatched when a track has been (locally or
 * remotely) removed from the conference.
 *
 * {
 *     type: TRACK_REMOVED,
 *     track: Track
 * }
 */
export const TRACK_REMOVED = 'TRACK_REMOVED';

/**
 * The type of redux action dispatched when a track has stopped.
 *
 * {
 *      type: TRACK_STOPPED,
 *      track: Track
 * }
 */
export const TRACK_STOPPED = 'TRACK_STOPPED';

/**
 * The type of redux action dispatched when a track's properties were updated.
 *
 * {
 *     type: TRACK_UPDATED,
 *     track: Track
 * }
 */
export const TRACK_UPDATED = 'TRACK_UPDATED';
 
/**
 * The type of redux action dispatched when a local track starts being created
 * via a WebRTC {@code getUserMedia} call. The action's payload includes an
 * extra {@code gumProcess} property which is a {@code Promise} with an extra
 * {@code cancel} method which can be used to cancel the process. Canceling will
 * result in disposing any {@code JitsiLocalTrack} returned by the
 * {@code getUserMedia} callback. There will be a {@code TRACK_CREATE_CANCELED}
 * action instead of a {@code TRACK_ADDED} or {@code TRACK_CREATE_ERROR} action.
 *
 * {
 *     type: TRACK_WILL_CREATE
 *     track: {
 *         gumProcess: Promise with a `cancel` method to cancel the process,
 *         local: true,
 *         mediaType: MEDIA_TYPE
 *     }
 * }
 */
export const TRACK_WILL_CREATE = 'TRACK_WILL_CREATE';


################################################################################

## File: .\jitsi-meet\react\features\base\tracks\constants.ts

/**
 * The payload name for remotely setting the camera facing mode message.
 */
export const CAMERA_FACING_MODE_MESSAGE = 'camera-facing-mode-message';
export const LOWER_HAND_MESSAGE = 'lower-hand-message';


################################################################################

## File: .\jitsi-meet\react\features\base\tracks\functions.any.ts

import { IReduxState, IStore } from '../../app/types';
import { JitsiTrackErrors, browser } from '../lib-jitsi-meet';
import { gumPending } from '../media/actions';
import { CAMERA_FACING_MODE, MEDIA_TYPE, MediaType, VIDEO_TYPE } from '../media/constants';
import { IMediaState } from '../media/reducer';
import { IGUMPendingState } from '../media/types';
import {
    getVirtualScreenshareParticipantOwnerId,
    isScreenShareParticipant
} from '../participants/functions';
import { IParticipant } from '../participants/types';

import logger from './logger';
import { ITrack } from './types';

/**
 * Returns root tracks state.
 *
 * @param {IReduxState} state - Global state.
 * @returns {Object} Tracks state.
 */
export const getTrackState = (state: IReduxState) => state['features/base/tracks'];

/**
 * Checks if the passed media type is muted for the participant.
 *
 * @param {IParticipant} participant - Participant reference.
 * @param {MediaType} mediaType - Media type.
 * @param {IReduxState} state - Global state.
 * @returns {boolean} - Is the media type muted for the participant.
 */
export function isParticipantMediaMuted(participant: IParticipant | undefined,
        mediaType: MediaType, state: IReduxState) {
    if (!participant) {
        return false;
    }

    const tracks = getTrackState(state);

    if (participant?.local) {
        return isLocalTrackMuted(tracks, mediaType);
    } else if (!participant?.fakeParticipant) {
        return isRemoteTrackMuted(tracks, mediaType, participant.id);
    }

    return true;
}

/**
 * Checks if the participant is audio muted.
 *
 * @param {IParticipant} participant - Participant reference.
 * @param {IReduxState} state - Global state.
 * @returns {boolean} - Is audio muted for the participant.
 */
export function isParticipantAudioMuted(participant: IParticipant, state: IReduxState) {
    return isParticipantMediaMuted(participant, MEDIA_TYPE.AUDIO, state);
}

/**
 * Checks if the participant is video muted.
 *
 * @param {IParticipant} participant - Participant reference.
 * @param {IReduxState} state - Global state.
 * @returns {boolean} - Is video muted for the participant.
 */
export function isParticipantVideoMuted(participant: IParticipant | undefined, state: IReduxState) {
    return isParticipantMediaMuted(participant, MEDIA_TYPE.VIDEO, state);
}

/**
 * Returns local audio track.
 *
 * @param {ITrack[]} tracks - List of all tracks.
 * @returns {(Track|undefined)}
 */
export function getLocalAudioTrack(tracks: ITrack[]) {
    return getLocalTrack(tracks, MEDIA_TYPE.AUDIO);
}

/**
 * Returns the local desktop track.
 *
 * @param {Track[]} tracks - List of all tracks.
 * @param {boolean} [includePending] - Indicates whether a local track is to be returned if it is still pending.
 * A local track is pending if {@code getUserMedia} is still executing to create it and, consequently, its
 * {@code jitsiTrack} property is {@code undefined}. By default a pending local track is not returned.
 * @returns {(Track|undefined)}
 */
export function getLocalDesktopTrack(tracks: ITrack[], includePending = false) {
    return (
        getLocalTracks(tracks, includePending)
            .find(t => t.mediaType === MEDIA_TYPE.SCREENSHARE || t.videoType === VIDEO_TYPE.DESKTOP));
}

/**
 * Returns the stored local desktop jitsiLocalTrack.
 *
 * @param {IReduxState} state - The redux state.
 * @returns {JitsiLocalTrack|undefined}
 */
export function getLocalJitsiDesktopTrack(state: IReduxState) {
    const track = getLocalDesktopTrack(getTrackState(state));

    return track?.jitsiTrack;
}

/**
 * Returns local track by media type.
 *
 * @param {ITrack[]} tracks - List of all tracks.
 * @param {MediaType} mediaType - Media type.
 * @param {boolean} [includePending] - Indicates whether a local track is to be
 * returned if it is still pending. A local track is pending if
 * {@code getUserMedia} is still executing to create it and, consequently, its
 * {@code jitsiTrack} property is {@code undefined}. By default a pending local
 * track is not returned.
 * @returns {(Track|undefined)}
 */
export function getLocalTrack(tracks: ITrack[], mediaType: MediaType, includePending = false) {
    return (
        getLocalTracks(tracks, includePending)
            .find(t => t.mediaType === mediaType));
}

/**
 * Returns an array containing the local tracks with or without a (valid)
 * {@code JitsiTrack}.
 *
 * @param {ITrack[]} tracks - An array containing all local tracks.
 * @param {boolean} [includePending] - Indicates whether a local track is to be
 * returned if it is still pending. A local track is pending if
 * {@code getUserMedia} is still executing to create it and, consequently, its
 * {@code jitsiTrack} property is {@code undefined}. By default a pending local
 * track is not returned.
 * @returns {Track[]}
 */
export function getLocalTracks(tracks: ITrack[], includePending = false) {
    // XXX A local track is considered ready only once it has its `jitsiTrack`
    // property set by the `TRACK_ADDED` action. Until then there is a stub
    // added just before the `getUserMedia` call with a cancellable
    // `gumInProgress` property which then can be used to destroy the track that
    // has not yet been added to the redux store. Once GUM is cancelled, it will
    // never make it to the store nor there will be any
    // `TRACK_ADDED`/`TRACK_REMOVED` actions dispatched for it.
    return tracks.filter(t => t.local && (t.jitsiTrack || includePending));
}

/**
 * Returns local video track.
 *
 * @param {ITrack[]} tracks - List of all tracks.
 * @returns {(Track|undefined)}
 */
export function getLocalVideoTrack(tracks: ITrack[]) {
    return getLocalTrack(tracks, MEDIA_TYPE.VIDEO);
}

/**
 * Returns the stored local video track.
 *
 * @param {IReduxState} state - The redux state.
 * @returns {Object}
 */
export function getLocalJitsiVideoTrack(state: IReduxState) {
    const track = getLocalVideoTrack(getTrackState(state));

    return track?.jitsiTrack;
}

/**
 * Returns the stored local audio track.
 *
 * @param {IReduxState} state - The redux state.
 * @returns {Object}
 */
export function getLocalJitsiAudioTrack(state: IReduxState) {
    const track = getLocalAudioTrack(getTrackState(state));

    return track?.jitsiTrack;
}

/**
 * Returns track of specified media type for specified participant.
 *
 * @param {IReduxState} state - The redux state.
 * @param {IParticipant} participant - Participant Object.
 * @returns {(Track|undefined)}
 */
export function getVideoTrackByParticipant(
        state: IReduxState,
        participant?: IParticipant) {

    if (!participant) {
        return;
    }

    const tracks = state['features/base/tracks'];

    if (isScreenShareParticipant(participant)) {
        return getVirtualScreenshareParticipantTrack(tracks, participant.id);
    }

    return getTrackByMediaTypeAndParticipant(tracks, MEDIA_TYPE.VIDEO, participant.id);
}

/**
 * Returns track of specified media type for specified participant id.
 *
 * @param {ITrack[]} tracks - List of all tracks.
 * @param {MediaType} mediaType - Media type.
 * @param {string} participantId - Participant ID.
 * @returns {(Track|undefined)}
 */
export function getTrackByMediaTypeAndParticipant(
        tracks: ITrack[],
        mediaType: MediaType,
        participantId?: string) {
    return tracks.find(
        t => Boolean(t.jitsiTrack) && t.participantId === participantId && t.mediaType === mediaType
    );
}

/**
 * Returns track for specified participant id.
 *
 * @param {ITrack[]} tracks - List of all tracks.
 * @param {string} participantId - Participant ID.
 * @returns {(Track[]|undefined)}
 */
export function getTrackByParticipantId(tracks: ITrack[], participantId: string) {
    return tracks.filter(t => t.participantId === participantId);
}

/**
 * Returns screenshare track of given virtualScreenshareParticipantId.
 *
 * @param {ITrack[]} tracks - List of all tracks.
 * @param {string} virtualScreenshareParticipantId - Virtual Screenshare Participant ID.
 * @returns {(Track|undefined)}
 */
export function getVirtualScreenshareParticipantTrack(tracks: ITrack[], virtualScreenshareParticipantId: string) {
    const ownderId = getVirtualScreenshareParticipantOwnerId(virtualScreenshareParticipantId);

    return getScreenShareTrack(tracks, ownderId);
}

/**
 * Returns screenshare track of given owner ID.
 *
 * @param {Track[]} tracks - List of all tracks.
 * @param {string} ownerId - Screenshare track owner ID.
 * @returns {(Track|undefined)}
 */
export function getScreenShareTrack(tracks: ITrack[], ownerId: string) {
    return tracks.find(
        t => Boolean(t.jitsiTrack)
        && t.participantId === ownerId
        && (t.mediaType === MEDIA_TYPE.SCREENSHARE || t.videoType === VIDEO_TYPE.DESKTOP)
    );
}

/**
 * Returns track source name of specified media type for specified participant id.
 *
 * @param {ITrack[]} tracks - List of all tracks.
 * @param {MediaType} mediaType - Media type.
 * @param {string} participantId - Participant ID.
 * @returns {(string|undefined)}
 */
export function getTrackSourceNameByMediaTypeAndParticipant(
        tracks: ITrack[],
        mediaType: MediaType,
        participantId: string) {
    const track = getTrackByMediaTypeAndParticipant(
        tracks,
        mediaType,
        participantId);

    return track?.jitsiTrack?.getSourceName();
}

/**
 * Returns the track if any which corresponds to a specific instance
 * of JitsiLocalTrack or JitsiRemoteTrack.
 *
 * @param {ITrack[]} tracks - List of all tracks.
 * @param {(JitsiLocalTrack|JitsiRemoteTrack)} jitsiTrack - JitsiTrack instance.
 * @returns {(Track|undefined)}
 */
export function getTrackByJitsiTrack(tracks: ITrack[], jitsiTrack: any) {
    return tracks.find(t => t.jitsiTrack === jitsiTrack);
}

/**
 * Returns tracks of specified media type.
 *
 * @param {ITrack[]} tracks - List of all tracks.
 * @param {MediaType} mediaType - Media type.
 * @returns {Track[]}
 */
export function getTracksByMediaType(tracks: ITrack[], mediaType: MediaType) {
    return tracks.filter(t => t.mediaType === mediaType);
}

/**
 * Checks if the first local track in the given tracks set is muted.
 *
 * @param {ITrack[]} tracks - List of all tracks.
 * @param {MediaType} mediaType - The media type of tracks to be checked.
 * @returns {boolean} True if local track is muted or false if the track is
 * unmuted or if there are no local tracks of the given media type in the given
 * set of tracks.
 */
export function isLocalTrackMuted(tracks: ITrack[], mediaType: MediaType) {
    const track = getLocalTrack(tracks, mediaType);

    return !track || track.muted;
}

/**
 * Checks if the local video track is of type DESKtOP.
 *
 * @param {IReduxState} state - The redux state.
 * @returns {boolean}
 */
export function isLocalVideoTrackDesktop(state: IReduxState) {
    const desktopTrack = getLocalDesktopTrack(getTrackState(state));

    return desktopTrack !== undefined && !desktopTrack.muted;
}


/**
 * Returns true if the remote track of the given media type and the given
 * participant is muted, false otherwise.
 *
 * @param {ITrack[]} tracks - List of all tracks.
 * @param {MediaType} mediaType - The media type of tracks to be checked.
 * @param {string} participantId - Participant ID.
 * @returns {boolean}
 */
export function isRemoteTrackMuted(tracks: ITrack[], mediaType: MediaType, participantId: string) {
    const track = getTrackByMediaTypeAndParticipant(tracks, mediaType, participantId);

    return !track || track.muted;
}

/**
 * Returns whether or not the current environment needs a user interaction with
 * the page before any unmute can occur.
 *
 * @param {IReduxState} state - The redux state.
 * @returns {boolean}
 */
export function isUserInteractionRequiredForUnmute(state: IReduxState) {
    return browser.isUserInteractionRequiredForUnmute()
        && window
        && window.self !== window.top
        && !state['features/base/user-interaction'].interacted;
}

/**
 * Sets the GUM pending state for the passed track operation (mute/unmute) and media type.
 * NOTE: We need this only for web.
 *
 * @param {IGUMPendingState} status - The new GUM pending status.
 * @param {MediaType} mediaType - The media type related to the operation (audio or video).
 * @param {boolean} muted - True if the operation is mute and false for unmute.
 * @param {Function} dispatch - The dispatch method.
 * @returns {void}
 */
export function _setGUMPendingState(
        status: IGUMPendingState,
        mediaType: MediaType,
        muted: boolean,
        dispatch?: IStore['dispatch']) {
    if (!muted && dispatch && typeof APP !== 'undefined') {
        dispatch(gumPending([ mediaType ], status));
    }
}

/**
 * Mutes or unmutes a specific {@code JitsiLocalTrack}. If the muted state of the specified {@code track} is already in
 * accord with the specified {@code muted} value, then does nothing.
 *
 * @param {JitsiLocalTrack} track - The {@code JitsiLocalTrack} to mute or unmute.
 * @param {boolean} muted - If the specified {@code track} is to be muted, then {@code true}; otherwise, {@code false}.
 * @param {Object} state - The redux state.
 * @param {Function} dispatch - The dispatch method.
 * @returns {Promise}
 */
export function setTrackMuted(track: any, muted: boolean, state: IReduxState | IMediaState,
        dispatch?: IStore['dispatch']) {
    muted = Boolean(muted); // eslint-disable-line no-param-reassign

    // Ignore the check for desktop track muted operation. When the screenshare is terminated by clicking on the
    // browser's 'Stop sharing' button, the local stream is stopped before the inactive stream handler is fired.
    // We still need to proceed here and remove the track from the peerconnection.
    if (track.isMuted() === muted && track.getVideoType() !== VIDEO_TYPE.DESKTOP) {
        return Promise.resolve();
    }

    const f = muted ? 'mute' : 'unmute';
    const mediaType = track.getType();

    _setGUMPendingState(IGUMPendingState.PENDING_UNMUTE, mediaType, muted, dispatch);

    return track[f]().then((result: any) => {
        _setGUMPendingState(IGUMPendingState.NONE, mediaType, muted, dispatch);

        return result;
    })
    .catch((error: Error) => {
        _setGUMPendingState(IGUMPendingState.NONE, mediaType, muted, dispatch);

        // Track might be already disposed so ignore such an error.
        if (error.name !== JitsiTrackErrors.TRACK_IS_DISPOSED) {
            logger.error(`set track ${f} failed`, error);

            return Promise.reject(error);
        }
    });
}

/**
 * Logs the current track state for a participant.
 *
 * @param {ITrack[]} tracksState - The tracks from redux.
 * @param {string} participantId - The ID of the participant.
 * @param {string} reason - The reason for the track change.
 * @returns {void}
 */
export function logTracksForParticipant(tracksState: ITrack[], participantId: string, reason?: string) {
    if (!participantId) {
        return;
    }
    const tracks = getTrackByParticipantId(tracksState, participantId);
    const logStringPrefix = `Track state for participant ${participantId} changed`;
    const trackStateStrings = tracks.map(t => `{type: ${t.mediaType}, videoType: ${t.videoType}, muted: ${
        t.muted}, isReceivingData: ${t.isReceivingData}, jitsiTrack: ${t.jitsiTrack?.toString()}}`);
    const tracksLogMsg = trackStateStrings.length > 0 ? `\n${trackStateStrings.join('\n')}` : ' No tracks available!';

    logger.debug(`${logStringPrefix}${reason ? `(reason: ${reason})` : ''}:${tracksLogMsg}`);
}

/**
 * Gets the default camera facing mode.
 *
 * @param {Object} state - The redux state.
 * @returns {string} - The camera facing mode.
 */
export function getCameraFacingMode(state: IReduxState) {
    return state['features/base/config'].cameraFacingMode ?? CAMERA_FACING_MODE.USER;
}


################################################################################

## File: .\jitsi-meet\react\features\base\tracks\functions.native.ts

import { IStore } from '../../app/types';
import JitsiMeetJS from '../lib-jitsi-meet';

import { getCameraFacingMode } from './functions.any';
import { ITrackOptions } from './types';

export * from './functions.any';

/**
 * Create local tracks of specific types.
 *
 * @param {Object} options - The options with which the local tracks are to be
 * created.
 * @param {string|null} [options.cameraDeviceId] - Camera device id or
 * {@code undefined} to use app's settings.
 * @param {string[]} options.devices - Required track types such as 'audio'
 * and/or 'video'.
 * @param {string|null} [options.micDeviceId] - Microphone device id or
 * {@code undefined} to use app's settings.
 * @param {number|undefined} [oprions.timeout] - A timeout for JitsiMeetJS.createLocalTracks used to create the tracks.
 * @param {boolean} [options.firePermissionPromptIsShownEvent] - Whether lib-jitsi-meet
 * should check for a {@code getUserMedia} permission prompt and fire a
 * corresponding event.
 * @param {IStore} store - The redux store in the context of which the function
 * is to execute and from which state such as {@code config} is to be retrieved.
 * @returns {Promise<JitsiLocalTrack[]>}
 */
export function createLocalTracksF(options: ITrackOptions = {}, store: IStore) {
    const { cameraDeviceId, micDeviceId } = options;
    const state = store.getState();
    const {
        resolution
    } = state['features/base/config'];
    const constraints = options.constraints ?? state['features/base/config'].constraints;

    return JitsiMeetJS.createLocalTracks(
        {
            cameraDeviceId,
            constraints,

            // Copy array to avoid mutations inside library.
            devices: options.devices?.slice(0),
            facingMode: options.facingMode || getCameraFacingMode(state),
            micDeviceId,
            resolution
        });
}


################################################################################

## File: .\jitsi-meet\react\features\base\tracks\functions.web.ts

import { IStore } from '../../app/types';
import { IStateful } from '../app/types';
import { isMobileBrowser } from '../environment/utils';
import JitsiMeetJS, { JitsiTrackErrors, browser } from '../lib-jitsi-meet';
import { gumPending, setAudioMuted } from '../media/actions';
import { MEDIA_TYPE } from '../media/constants';
import { getStartWithAudioMuted } from '../media/functions';
import { IGUMPendingState } from '../media/types';
import { toState } from '../redux/functions';
import {
    getUserSelectedCameraDeviceId,
    getUserSelectedMicDeviceId
} from '../settings/functions.web';

import { getCameraFacingMode } from './functions.any';
import loadEffects from './loadEffects';
import logger from './logger';
import { ITrackOptions } from './types';

export * from './functions.any';

/**
 * Create local tracks of specific types.
 *
 * @param {Object} options - The options with which the local tracks are to be
 * created.
 * @param {string|null} [options.cameraDeviceId] - Camera device id or
 * {@code undefined} to use app's settings.
 * @param {string[]} options.devices - Required track types such as 'audio'
 * and/or 'video'.
 * @param {string|null} [options.micDeviceId] - Microphone device id or
 * {@code undefined} to use app's settings.
 * @param {number|undefined} [oprions.timeout] - A timeout for JitsiMeetJS.createLocalTracks used to create the tracks.
 * @param {boolean} [options.firePermissionPromptIsShownEvent] - Whether lib-jitsi-meet
 * should check for a {@code getUserMedia} permission prompt and fire a
 * corresponding event.
 * @param {IStore} store - The redux store in the context of which the function
 * is to execute and from which state such as {@code config} is to be retrieved.
 * @returns {Promise<JitsiLocalTrack[]>}
 */
export function createLocalTracksF(options: ITrackOptions = {}, store?: IStore) {
    let { cameraDeviceId, micDeviceId } = options;
    const {
        desktopSharingSourceDevice,
        desktopSharingSources,
        firePermissionPromptIsShownEvent,
        timeout
    } = options;

    // TODO The app's settings should go in the redux store and then the
    // reliance on the global variable APP will go away.
    store = store || APP.store; // eslint-disable-line no-param-reassign

    const state = store.getState();

    if (typeof cameraDeviceId === 'undefined' || cameraDeviceId === null) {
        cameraDeviceId = getUserSelectedCameraDeviceId(state);
    }
    if (typeof micDeviceId === 'undefined' || micDeviceId === null) {
        micDeviceId = getUserSelectedMicDeviceId(state);
    }

    const {
        desktopSharingFrameRate,
        firefox_fake_device, // eslint-disable-line camelcase
        resolution
    } = state['features/base/config'];
    const constraints = options.constraints ?? state['features/base/config'].constraints;

    return (
        loadEffects(store).then((effectsArray: Object[]) => {
            // Filter any undefined values returned by Promise.resolve().
            const effects = effectsArray.filter(effect => Boolean(effect));

            return JitsiMeetJS.createLocalTracks(
                {
                    cameraDeviceId,
                    constraints,
                    desktopSharingFrameRate,
                    desktopSharingSourceDevice,
                    desktopSharingSources,

                    // Copy array to avoid mutations inside library.
                    devices: options.devices?.slice(0),
                    effects,
                    facingMode: options.facingMode || getCameraFacingMode(state),
                    firefox_fake_device, // eslint-disable-line camelcase
                    firePermissionPromptIsShownEvent,
                    micDeviceId,
                    resolution,
                    timeout
                })
            .catch((err: Error) => {
                logger.error('Failed to create local tracks', options.devices, err);

                return Promise.reject(err);
            });
        }));
}

/**
 * Returns an object containing a promise which resolves with the created tracks and the errors resulting from that
 * process.
 *
 * @returns {Promise<JitsiLocalTrack[]>}
 *
 * @todo Refactor to not use APP.
 */
export function createPrejoinTracks() {
    const errors: any = {};
    const initialDevices = [ MEDIA_TYPE.AUDIO ];
    const requestedAudio = true;
    let requestedVideo = false;
    const { startAudioOnly, startWithVideoMuted } = APP.store.getState()['features/base/settings'];
    const startWithAudioMuted = getStartWithAudioMuted(APP.store.getState());

    // On Electron there is no permission prompt for granting permissions. That's why we don't need to
    // spend much time displaying the overlay screen. If GUM is not resolved within 15 seconds it will
    // probably never resolve.
    const timeout = browser.isElectron() ? 15000 : 60000;

    // Always get a handle on the audio input device so that we have statistics even if the user joins the
    // conference muted. Previous implementation would only acquire the handle when the user first unmuted,
    // which would results in statistics ( such as "No audio input" or "Are you trying to speak?") being available
    // only after that point.
    if (startWithAudioMuted) {
        APP.store.dispatch(setAudioMuted(true));
    }

    if (!startWithVideoMuted && !startAudioOnly) {
        initialDevices.push(MEDIA_TYPE.VIDEO);
        requestedVideo = true;
    }

    let tryCreateLocalTracks: any = Promise.resolve([]);
    const { dispatch } = APP.store;

    dispatch(gumPending(initialDevices, IGUMPendingState.PENDING_UNMUTE));

    if (requestedAudio || requestedVideo) {
        tryCreateLocalTracks = createLocalTracksF({
            devices: initialDevices,
            firePermissionPromptIsShownEvent: true,
            timeout
        }, APP.store)
        .catch(async (err: Error) => {
            if (err.name === JitsiTrackErrors.TIMEOUT && !browser.isElectron()) {
                errors.audioAndVideoError = err;

                return [];
            }

            // Retry with separate gUM calls.
            const gUMPromises: any = [];
            const tracks: any = [];

            if (requestedAudio) {
                gUMPromises.push(createLocalTracksF({
                    devices: [ MEDIA_TYPE.AUDIO ],
                    firePermissionPromptIsShownEvent: true,
                    timeout
                }));
            }

            if (requestedVideo) {
                gUMPromises.push(createLocalTracksF({
                    devices: [ MEDIA_TYPE.VIDEO ],
                    firePermissionPromptIsShownEvent: true,
                    timeout
                }));
            }

            const results = await Promise.allSettled(gUMPromises);
            let errorMsg;

            results.forEach((result, idx) => {
                if (result.status === 'fulfilled') {
                    tracks.push(result.value[0]);
                } else {
                    errorMsg = result.reason;
                    const isAudio = idx === 0;

                    logger.error(`${isAudio ? 'Audio' : 'Video'} track creation failed with error ${errorMsg}`);
                    if (isAudio) {
                        errors.audioOnlyError = errorMsg;
                    } else {
                        errors.videoOnlyError = errorMsg;
                    }
                }
            });

            if (errors.audioOnlyError && errors.videoOnlyError) {
                errors.audioAndVideoError = errorMsg;
            }

            return tracks;
        })
        .finally(() => {
            dispatch(gumPending(initialDevices, IGUMPendingState.NONE));
        });
    }

    return {
        tryCreateLocalTracks,
        errors
    };
}

/**
 * Determines whether toggle camera should be enabled or not.
 *
 * @param {Function|Object} stateful - The redux store or {@code getState} function.
 * @returns {boolean} - Whether toggle camera should be enabled.
 */
export function isToggleCameraEnabled(stateful: IStateful) {
    const state = toState(stateful);
    const { videoInput } = state['features/base/devices'].availableDevices;

    return isMobileBrowser() && Number(videoInput?.length) > 1;
}


################################################################################

## File: .\jitsi-meet\react\features\base\tracks\loadEffects.native.ts

/**
 * Loads the enabled stream effects.
 *
 * @param {Object} _store - The Redux store.
 * @returns {Promise} - A Promise which resolves with an array of the loaded effects.
 */
export default function loadEffects(_store: Object): Promise<Array<any>> {
    return Promise.resolve([]);
}


################################################################################

## File: .\jitsi-meet\react\features\base\tracks\loadEffects.web.ts

import { IStore } from '../../app/types';
import { NoiseSuppressionEffect } from '../../stream-effects/noise-suppression/NoiseSuppressionEffect';
import { createVirtualBackgroundEffect } from '../../stream-effects/virtual-background';

import logger from './logger';

/**
 * Loads the enabled stream effects.
 *
 * @param {Object} store - The Redux store.
 * @returns {Promise} - A Promise which resolves when all effects are created.
 */
export default function loadEffects(store: IStore): Promise<any> {
    const state = store.getState();
    const virtualBackground = state['features/virtual-background'];
    const noiseSuppression = state['features/noise-suppression'];
    const { noiseSuppression: nsOptions } = state['features/base/config'];


    const backgroundPromise = virtualBackground.backgroundEffectEnabled
        ? createVirtualBackgroundEffect(virtualBackground)
            .catch((error: Error) => {
                logger.error('Failed to obtain the background effect instance with error: ', error);

                return Promise.resolve();
            })
        : Promise.resolve();

    const noiseSuppressionPromise = noiseSuppression?.enabled
        ? Promise.resolve(new NoiseSuppressionEffect(nsOptions))
        : Promise.resolve();

    return Promise.all([ backgroundPromise, noiseSuppressionPromise ]);
}


################################################################################

## File: .\jitsi-meet\react\features\base\tracks\logger.ts

import { getLogger } from '../logging/functions';

export default getLogger('features/base/tracks');


################################################################################

## File: .\jitsi-meet\react\features\base\tracks\middleware.any.ts

import { batch } from 'react-redux';

import { IStore } from '../../app/types';
import { _RESET_BREAKOUT_ROOMS } from '../../breakout-rooms/actionTypes';
import { isPrejoinPageVisible } from '../../prejoin/functions';
import { getCurrentConference } from '../conference/functions';
import {
    SET_AUDIO_MUTED,
    SET_CAMERA_FACING_MODE,
    SET_SCREENSHARE_MUTED,
    SET_VIDEO_MUTED,
    TOGGLE_CAMERA_FACING_MODE
} from '../media/actionTypes';
import { gumPending, toggleCameraFacingMode } from '../media/actions';
import {
    CAMERA_FACING_MODE,
    MEDIA_TYPE,
    MediaType
} from '../media/constants';
import { IGUMPendingState } from '../media/types';
import MiddlewareRegistry from '../redux/MiddlewareRegistry';
import StateListenerRegistry from '../redux/StateListenerRegistry';

import {
    TRACK_UPDATED
} from './actionTypes';
import {
    createLocalTracksA,
    destroyLocalTracks,
    trackMuteUnmuteFailed,
    trackRemoved
} from './actions';
import {
    getLocalTrack,
    isUserInteractionRequiredForUnmute,
    setTrackMuted
} from './functions';
import './subscriber';

/**
 * Middleware that captures LIB_DID_DISPOSE and LIB_DID_INIT actions and,
 * respectively, creates/destroys local media tracks. Also listens to
 * media-related actions and performs corresponding operations with tracks.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {
    switch (action.type) {
    case SET_AUDIO_MUTED:
        if (!action.muted
                && isUserInteractionRequiredForUnmute(store.getState())) {
            return;
        }

        _setMuted(store, action, MEDIA_TYPE.AUDIO);
        break;

    case SET_CAMERA_FACING_MODE: {
        // XXX The camera facing mode of a MediaStreamTrack can be specified
        // only at initialization time and then it can only be toggled. So in
        // order to set the camera facing mode, one may destroy the track and
        // then initialize a new instance with the new camera facing mode. But
        // that is inefficient on mobile at least so the following relies on the
        // fact that there are 2 camera facing modes and merely toggles between
        // them to (hopefully) get the camera in the specified state.
        const localTrack = _getLocalTrack(store, MEDIA_TYPE.VIDEO);
        let jitsiTrack;

        if (localTrack
                && (jitsiTrack = localTrack.jitsiTrack)
                && jitsiTrack.getCameraFacingMode()
                    !== action.cameraFacingMode) {
            store.dispatch(toggleCameraFacingMode());
        }
        break;
    }

    case SET_SCREENSHARE_MUTED:
        _setMuted(store, action, MEDIA_TYPE.SCREENSHARE);
        break;

    case SET_VIDEO_MUTED:
        if (!action.muted
                && isUserInteractionRequiredForUnmute(store.getState())) {
            return;
        }

        _setMuted(store, action, MEDIA_TYPE.VIDEO);
        break;

    case TOGGLE_CAMERA_FACING_MODE: {
        const localTrack = _getLocalTrack(store, MEDIA_TYPE.VIDEO);
        let jitsiTrack;

        if (localTrack && (jitsiTrack = localTrack.jitsiTrack)) {
            // XXX MediaStreamTrack._switchCamera is a custom function
            // implemented in react-native-webrtc for video which switches
            // between the cameras via a native WebRTC library implementation
            // without making any changes to the track.
            jitsiTrack._switchCamera();

            // Don't mirror the video of the back/environment-facing camera.
            const mirror
                = jitsiTrack.getCameraFacingMode() === CAMERA_FACING_MODE.USER;

            store.dispatch({
                type: TRACK_UPDATED,
                track: {
                    jitsiTrack,
                    mirror
                }
            });
        }
        break;
    }
    }

    return next(action);
});

/**
 * Set up state change listener to perform maintenance tasks when the conference
 * is left or failed, remove all tracks from the store.
 */
StateListenerRegistry.register(
    state => getCurrentConference(state),
    (conference, { dispatch, getState }, prevConference) => {
        const { authRequired, error } = getState()['features/base/conference'];

        // conference keep flipping while we are authenticating, skip clearing while we are in that process
        if (prevConference && !conference && !authRequired && !error) {

            // Clear all tracks.
            const remoteTracks = getState()['features/base/tracks'].filter(t => !t.local);

            batch(() => {
                dispatch(destroyLocalTracks());
                for (const track of remoteTracks) {
                    dispatch(trackRemoved(track.jitsiTrack));
                }
                dispatch({ type: _RESET_BREAKOUT_ROOMS });
            });
        }
    });

/**
 * Gets the local track associated with a specific {@code MEDIA_TYPE} in a
 * specific redux store.
 *
 * @param {Store} store - The redux store from which the local track associated
 * with the specified {@code mediaType} is to be retrieved.
 * @param {MEDIA_TYPE} mediaType - The {@code MEDIA_TYPE} of the local track to
 * be retrieved from the specified {@code store}.
 * @param {boolean} [includePending] - Indicates whether a local track is to be
 * returned if it is still pending. A local track is pending if
 * {@code getUserMedia} is still executing to create it and, consequently, its
 * {@code jitsiTrack} property is {@code undefined}. By default a pending local
 * track is not returned.
 * @private
 * @returns {Track} The local {@code Track} associated with the specified
 * {@code mediaType} in the specified {@code store}.
 */
function _getLocalTrack(
        { getState }: { getState: IStore['getState']; },
        mediaType: MediaType,
        includePending = false) {
    return (
        getLocalTrack(
            getState()['features/base/tracks'],
            mediaType,
            includePending));
}

/**
 * Mutes or unmutes a local track with a specific media type.
 *
 * @param {Store} store - The redux store in which the specified action is
 * dispatched.
 * @param {Action} action - The redux action dispatched in the specified store.
 * @param {MEDIA_TYPE} mediaType - The {@link MEDIA_TYPE} of the local track
 * which is being muted or unmuted.
 * @private
 * @returns {void}
 */
function _setMuted(store: IStore, { ensureTrack, muted }: {
    ensureTrack: boolean; muted: boolean; }, mediaType: MediaType) {
    const { dispatch, getState } = store;
    const localTrack = _getLocalTrack(store, mediaType, /* includePending */ true);
    const state = getState();

    if (mediaType === MEDIA_TYPE.SCREENSHARE && !muted) {
        return;
    }

    if (localTrack) {
        // The `jitsiTrack` property will have a value only for a localTrack for which `getUserMedia` has already
        // completed. If there's no `jitsiTrack`, then the `muted` state will be applied once the `jitsiTrack` is
        // created.
        const { jitsiTrack } = localTrack;

        if (jitsiTrack) {
            setTrackMuted(jitsiTrack, muted, state, dispatch)
                .catch(() => dispatch(trackMuteUnmuteFailed(localTrack, muted)));
        }
    } else if (!muted && ensureTrack && (typeof APP === 'undefined' || isPrejoinPageVisible(state))) {
        typeof APP !== 'undefined' && dispatch(gumPending([ mediaType ], IGUMPendingState.PENDING_UNMUTE));

        // FIXME: This only runs on mobile now because web has its own way of
        // creating local tracks. Adjust the check once they are unified.
        dispatch(createLocalTracksA({ devices: [ mediaType ] })).then(() => {
            typeof APP !== 'undefined' && dispatch(gumPending([ mediaType ], IGUMPendingState.NONE));
        });
    }
}


################################################################################

## File: .\jitsi-meet\react\features\base\tracks\middleware.native.ts

import {
    MEDIA_TYPE,
    VIDEO_TYPE
} from '../media/constants';
import MiddlewareRegistry from '../redux/MiddlewareRegistry';

import {
    TRACK_UPDATED
} from './actionTypes';
import {
    toggleScreensharing
} from './actions.native';

import './middleware.any';

/**
 * Middleware that captures LIB_DID_DISPOSE and LIB_DID_INIT actions and,
 * respectively, creates/destroys local media tracks. Also listens to
 * media-related actions and performs corresponding operations with tracks.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {
    switch (action.type) {
    case TRACK_UPDATED: {
        const { jitsiTrack, local } = action.track;

        if (local && jitsiTrack.isMuted()
                && jitsiTrack.type === MEDIA_TYPE.VIDEO && jitsiTrack.videoType === VIDEO_TYPE.DESKTOP) {
            store.dispatch(toggleScreensharing(false));
        }
        break;
    }
    }

    return next(action);
});


################################################################################

## File: .\jitsi-meet\react\features\base\tracks\middleware.web.ts

import { AnyAction } from 'redux';

import { IStore } from '../../app/types';
import { hideNotification } from '../../notifications/actions';
import { isPrejoinPageVisible } from '../../prejoin/functions';
import { getAvailableDevices } from '../devices/actions.web';
import { setScreenshareMuted } from '../media/actions';
import {
    MEDIA_TYPE,
    VIDEO_TYPE
} from '../media/constants';
import MiddlewareRegistry from '../redux/MiddlewareRegistry';

import {
    TRACK_ADDED,
    TRACK_MUTE_UNMUTE_FAILED,
    TRACK_NO_DATA_FROM_SOURCE,
    TRACK_REMOVED,
    TRACK_STOPPED,
    TRACK_UPDATED
} from './actionTypes';
import {
    showNoDataFromSourceVideoError,
    toggleScreensharing,
    trackNoDataFromSourceNotificationInfoChanged
} from './actions.web';
import {
    getTrackByJitsiTrack, logTracksForParticipant
} from './functions.web';
import { ITrack } from './types';

import './middleware.any';

/**
 * Middleware that captures LIB_DID_DISPOSE and LIB_DID_INIT actions and,
 * respectively, creates/destroys local media tracks. Also listens to
 * media-related actions and performs corresponding operations with tracks.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {
    switch (action.type) {
    case TRACK_ADDED: {
        const { local } = action.track;

        // The devices list needs to be refreshed when no initial video permissions
        // were granted and a local video track is added by umuting the video.
        if (local) {
            store.dispatch(getAvailableDevices());
            break;
        }

        const result = next(action);
        const participantId = action.track?.participantId;

        if (participantId) {
            logTracksForParticipant(store.getState()['features/base/tracks'], participantId, 'Track added');
        }

        return result;
    }
    case TRACK_NO_DATA_FROM_SOURCE: {
        const result = next(action);

        _handleNoDataFromSourceErrors(store, action);

        return result;
    }

    case TRACK_REMOVED: {
        _removeNoDataFromSourceNotification(store, action.track);

        const result = next(action);
        const participantId = action.track?.jitsiTrack?.getParticipantId();

        if (participantId && !action.track?.jitsiTrack?.isLocal()) {
            logTracksForParticipant(store.getState()['features/base/tracks'], participantId, 'Track removed');
        }

        return result;
    }

    case TRACK_MUTE_UNMUTE_FAILED: {
        const { jitsiTrack } = action.track;
        const muted = action.wasMuted;
        const isVideoTrack = jitsiTrack.getType() !== MEDIA_TYPE.AUDIO;

        if (isVideoTrack && jitsiTrack.getVideoType() === VIDEO_TYPE.DESKTOP) {
            store.dispatch(setScreenshareMuted(!muted));
        } else if (isVideoTrack) {
            APP.conference.setVideoMuteStatus();
        } else {
            APP.conference.updateAudioIconEnabled();
        }

        break;
    }

    case TRACK_STOPPED: {
        const { jitsiTrack } = action.track;

        if (jitsiTrack.getVideoType() === VIDEO_TYPE.DESKTOP) {
            store.dispatch(toggleScreensharing(false));
        }
        break;
    }

    case TRACK_UPDATED: {
        // TODO Remove the following calls to APP.UI once components interested
        // in track mute changes are moved into React and/or redux.

        const result = next(action);
        const state = store.getState();

        if (isPrejoinPageVisible(state)) {
            return result;
        }

        const { jitsiTrack } = action.track;
        const participantID = jitsiTrack.getParticipantId();
        const isVideoTrack = jitsiTrack.type !== MEDIA_TYPE.AUDIO;
        const local = jitsiTrack.isLocal();

        if (isVideoTrack) {
            if (local && !(jitsiTrack.getVideoType() === VIDEO_TYPE.DESKTOP)) {
                APP.conference.setVideoMuteStatus();
            } else if (!local) {
                APP.UI.setVideoMuted(participantID);
            }
        } else if (local) {
            APP.conference.updateAudioIconEnabled();
        }

        if (typeof action.track?.muted !== 'undefined' && participantID && !local) {
            logTracksForParticipant(store.getState()['features/base/tracks'], participantID, 'Track updated');
        }

        return result;
    }

    }

    return next(action);
});

/**
 * Handles no data from source errors.
 *
 * @param {Store} store - The redux store in which the specified action is
 * dispatched.
 * @param {Action} action - The redux action dispatched in the specified store.
 * @private
 * @returns {void}
 */
function _handleNoDataFromSourceErrors(store: IStore, action: AnyAction) {
    const { getState, dispatch } = store;

    const track = getTrackByJitsiTrack(getState()['features/base/tracks'], action.track.jitsiTrack);

    if (!track?.local) {
        return;
    }

    const { jitsiTrack } = track;

    if (track.mediaType === MEDIA_TYPE.AUDIO && track.isReceivingData) {
        _removeNoDataFromSourceNotification(store, action.track);
    }

    if (track.mediaType === MEDIA_TYPE.VIDEO) {
        const { noDataFromSourceNotificationInfo = {} } = track;

        if (track.isReceivingData) {
            if (noDataFromSourceNotificationInfo.timeout) {
                clearTimeout(noDataFromSourceNotificationInfo.timeout);
                dispatch(trackNoDataFromSourceNotificationInfoChanged(jitsiTrack, undefined));
            }

            // try to remove the notification if there is one.
            _removeNoDataFromSourceNotification(store, action.track);
        } else {
            if (noDataFromSourceNotificationInfo.timeout) {
                return;
            }

            const timeout = setTimeout(() => dispatch(showNoDataFromSourceVideoError(jitsiTrack)), 5000);

            dispatch(trackNoDataFromSourceNotificationInfoChanged(jitsiTrack, { timeout }));
        }
    }
}

/**
 * Removes the no data from source notification associated with the JitsiTrack if displayed.
 *
 * @param {Store} store - The redux store.
 * @param {Track} track - The redux action dispatched in the specified store.
 * @returns {void}
 */
function _removeNoDataFromSourceNotification({ getState, dispatch }: IStore, track: ITrack) {
    const t = getTrackByJitsiTrack(getState()['features/base/tracks'], track.jitsiTrack);
    const { jitsiTrack, noDataFromSourceNotificationInfo = {} } = t || {};

    if (noDataFromSourceNotificationInfo?.uid) {
        dispatch(hideNotification(noDataFromSourceNotificationInfo.uid));
        dispatch(trackNoDataFromSourceNotificationInfoChanged(jitsiTrack, undefined));
    }
}


################################################################################

## File: .\jitsi-meet\react\features\base\tracks\reducer.ts

import { AnyAction } from 'redux';

import { PARTICIPANT_ID_CHANGED } from '../participants/actionTypes';
import ReducerRegistry from '../redux/ReducerRegistry';
import { set } from '../redux/functions';

import {
    SET_NO_SRC_DATA_NOTIFICATION_UID,
    TRACK_ADDED,
    TRACK_CREATE_CANCELED,
    TRACK_CREATE_ERROR,
    TRACK_NO_DATA_FROM_SOURCE,
    TRACK_REMOVED,
    TRACK_UPDATED,
    TRACK_WILL_CREATE
} from './actionTypes';
import { ITrack } from './types';

/**
 * Reducer function for a single track.
 *
 * @param {Track|undefined} state - Track to be modified.
 * @param {Object} action - Action object.
 * @param {string} action.type - Type of action.
 * @param {string} action.name - Name of last media event.
 * @param {string} action.newValue - New participant ID value (in this
 * particular case).
 * @param {string} action.oldValue - Old participant ID value (in this
 * particular case).
 * @param {Track} action.track - Information about track to be changed.
 * @param {Participant} action.participant - Information about participant.
 * @returns {Track|undefined}
 */
function track(state: ITrack, action: AnyAction) {
    switch (action.type) {
    case PARTICIPANT_ID_CHANGED:
        if (state.participantId === action.oldValue) {
            return {
                ...state,
                participantId: action.newValue
            };
        }
        break;

    case TRACK_UPDATED: {
        const t = action.track;

        if (state.jitsiTrack === t.jitsiTrack) {
            // Make sure that there's an actual update in order to reduce the
            // risk of unnecessary React Component renders.
            for (const p in t) {
                // @ts-ignore
                if (state[p] !== t[p]) {
                    // There's an actual update.
                    return {
                        ...state,
                        ...t
                    };
                }
            }
        }
        break;
    }

    case TRACK_NO_DATA_FROM_SOURCE: {
        const t = action.track;

        if (state.jitsiTrack === t.jitsiTrack) {
            const isReceivingData = t.jitsiTrack.isReceivingData();

            if (state.isReceivingData !== isReceivingData) {
                return {
                    ...state,
                    isReceivingData
                };
            }
        }
        break;
    }
    }

    return state;
}

export type ITracksState = ITrack[];

/**
 * Listen for actions that mutate (e.g. Add, remove) local and remote tracks.
 */
ReducerRegistry.register<ITracksState>('features/base/tracks', (state = [], action): ITracksState => {
    switch (action.type) {
    case PARTICIPANT_ID_CHANGED:
    case TRACK_NO_DATA_FROM_SOURCE:
    case TRACK_UPDATED:
        return state.map((t: ITrack) => track(t, action));
    case TRACK_ADDED: {
        let withoutTrackStub = state;

        if (action.track.local) {
            withoutTrackStub
                = state.filter(
                    (t: ITrack) => !t.local || t.mediaType !== action.track.mediaType);
        }

        return [ ...withoutTrackStub, action.track ];
    }

    case TRACK_CREATE_CANCELED:
    case TRACK_CREATE_ERROR: {
        return state.filter((t: ITrack) => !t.local || t.mediaType !== action.trackType);
    }

    case TRACK_REMOVED:
        return state.filter((t: ITrack) => t.jitsiTrack !== action.track.jitsiTrack);

    case TRACK_WILL_CREATE:
        return [ ...state, action.track ];

    default:
        return state;
    }
});

export interface INoSrcDataState {
    noSrcDataNotificationUid?: string | number;
}

/**
 * Listen for actions that mutate the no-src-data state, like the current notification id.
 */
ReducerRegistry.register<INoSrcDataState>('features/base/no-src-data', (state = {}, action): INoSrcDataState => {
    switch (action.type) {
    case SET_NO_SRC_DATA_NOTIFICATION_UID:
        return set(state, 'noSrcDataNotificationUid', action.uid);

    default:
        return state;
    }
});



################################################################################

## File: .\jitsi-meet\react\features\base\tracks\subscriber.ts

import { isEqual, sortBy } from 'lodash-es';

import { MEDIA_TYPE } from '../media/constants';
import { getScreenshareParticipantIds } from '../participants/functions';
import StateListenerRegistry from '../redux/StateListenerRegistry';

import { isLocalTrackMuted } from './functions';

/**
 * Notifies when the list of currently sharing participants changes.
 */
StateListenerRegistry.register(
    /* selector */ state => getScreenshareParticipantIds(state),
    /* listener */ (participantIDs, store, previousParticipantIDs) => {
        if (typeof APP !== 'object') {
            return;
        }

        if (!isEqual(sortBy(participantIDs), sortBy(previousParticipantIDs))) {
            APP.API.notifySharingParticipantsChanged(participantIDs);
        }
    }
);


/**
 * Notifies when the local video mute state changes.
 */
StateListenerRegistry.register(
    /* selector */ state => isLocalTrackMuted(state['features/base/tracks'], MEDIA_TYPE.VIDEO),
    /* listener */ (muted, store, previousMuted) => {
        if (typeof APP !== 'object') {
            return;
        }

        if (muted !== previousMuted) {
            APP.API.notifyVideoMutedStatusChanged(muted);
        }
    }
);


################################################################################

## File: .\jitsi-meet\react\features\base\tracks\types.ts

import { MediaType } from '../media/constants';

export interface ITrackOptions {
    cameraDeviceId?: string | null;
    constraints?: {
        video?: {
            height?: {
                ideal?: number;
                max?: number;
                min?: number;
            };
        };
    };
    desktopSharingSourceDevice?: string;
    desktopSharingSources?: string[];
    devices?: string[];
    facingMode?: string;
    firePermissionPromptIsShownEvent?: boolean;
    micDeviceId?: string | null;
    timeout?: number;
}

/**
 * Track type.
 *
 * @typedef {object} Track
 * @property {JitsiLocalTrack|JitsiRemoteTrack} jitsiTrack - The associated
 * {@code JitsiTrack} instance. Optional for local tracks if those are still
 * being created (ie {@code getUserMedia} is still in progress).
 * @property {Promise} [gumProcess] - If a local track is still being created,
 * it will have no {@code JitsiTrack}, but a {@code gumProcess} set to a
 * {@code Promise} with and extra {@code cancel()}.
 * @property {boolean} local=false - If the track is local.
 * @property {MEDIA_TYPE} mediaType=false - The media type of the track.
 * @property {boolean} mirror=false - The indicator which determines whether the
 * display/rendering of the track should be mirrored. It only makes sense in the
 * context of video (at least at the time of this writing).
 * @property {boolean} muted=false - If the track is muted.
 * @property {(string|undefined)} participantId - The ID of the participant whom
 * the track belongs to.
 * @property {boolean} videoStarted=false - If the video track has already
 * started to play.
 * @property {(VIDEO_TYPE|undefined)} videoType - The type of video track if
 * any.
 */
export interface ITrack {
    codec: string;
    getOriginalStream: Function;
    isReceivingData: boolean;
    jitsiTrack: any;
    local: boolean;
    mediaType: MediaType;
    mirror: boolean;
    muted: boolean;
    noDataFromSourceNotificationInfo?: {
        timeout?: number;
        uid?: string;
    };
    participantId: string;
    streamingStatus?: string;
    videoStarted: boolean;
    videoType?: string | null;
}

export interface IToggleScreenSharingOptions {
    audioOnly: boolean;
    enabled?: boolean;
    shareOptions: IShareOptions;
}

export interface IShareOptions {
    desktopSharingSourceDevice?: string;
    desktopSharingSources?: string[];
    desktopStream?: any;
}

export interface ICreateInitialTracksOptions {
    devices: Array<MediaType>;
    firePermissionPromptIsShownEvent?: boolean;
    timeout?: number;
}

export interface IInitialTracksErrors {
    audioAndVideoError?: Error;
    audioOnlyError: Error;
    screenSharingError: Error;
    videoOnlyError: Error;
}


################################################################################

## File: .\jitsi-meet\react\features\base\ui\constants.any.ts

/**
 * The types of the buttons.
 */
export enum BUTTON_TYPES {
    DESTRUCTIVE = 'destructive',
    PRIMARY = 'primary',
    SECONDARY = 'secondary',
    TERTIARY = 'tertiary'
}

/**
 * Behaviour types for showing overflow text content.
 */
export enum TEXT_OVERFLOW_TYPES {
    ELLIPSIS = 'ellipsis',
    SCROLL_ON_HOVER = 'scroll-on-hover'
}

/**
 * The modes of the buttons.
 */
export const BUTTON_MODES: {
    CONTAINED: 'contained';
    TEXT: 'text';
} = {
    CONTAINED: 'contained',
    TEXT: 'text'
};


export type TOOLTIP_POSITION = 'top' | 'bottom' | 'left' | 'right';


################################################################################

## File: .\jitsi-meet\react\features\base\ui\constants.native.ts

export * from './constants.any';


################################################################################

## File: .\jitsi-meet\react\features\base\ui\constants.web.ts

import { Theme } from '@mui/material';

export * from './constants.any';

/**
 * Returns an object containing the declaration of the common, reusable CSS classes.
 *
 * @param {Object} theme -The theme.
 *
 * @returns {Object} - The common styles.
 */
export const commonStyles = (theme: Theme) => {
    return {
        '.empty-list': {
            listStyleType: 'none',
            margin: 0,
            padding: 0
        },

        '.mute-dialog': {
            '& .separator-line': {
                margin: `${theme.spacing(4)} 0 ${theme.spacing(4)} -20px`,
                padding: '0 20px',
                width: '100%',
                height: '1px',
                background: '#5E6D7A'
            },

            '& .control-row': {
                display: 'flex',
                justifyContent: 'space-between',
                marginTop: theme.spacing(3),

                '& label': {
                    fontSize: '14px'
                }
            }
        },

        '.overflow-menu-item': {
            alignItems: 'center',
            color: theme.palette.text01,
            cursor: 'pointer',
            display: 'flex',
            fontSize: 14,
            fontWeight: 400,
            height: 40,
            lineHeight: '24px',
            padding: '8px 16px',
            boxSizing: 'border-box' as const,
            '& > div': {
                display: 'flex',
                alignItems: 'center'
            },

            '&.unclickable': {
                cursor: 'default'
            },

            '&.disabled': {
                cursor: 'initial',
                color: theme.palette.text03,

                '&:hover': {
                    background: 'none'
                },

                '& svg': {
                    fill: theme.palette.text03
                }
            },

            '@media (hover: hover) and (pointer: fine)': {
                '&:hover': {
                    background: theme.palette.action02Hover
                },
                '&.unclickable:hover': {
                    background: 'inherit'
                }
            }
        },

        '.overflow-menu-item-icon': {
            marginRight: '16px',

            '& i': {
                display: 'inline',
                fontSize: 24
            },

            '@media (hover: hover) and (pointer: fine)': {
                '&i:hover': {
                    backgroundColor: 'initial'
                }
            },

            '& img': {
                maxWidth: 24,
                maxHeight: 24
            },

            '& svg': {
                fill: theme.palette.text01,
                height: 20,
                width: 20
            }
        },

        '.prejoin-dialog': {
            backgroundColor: theme.palette.uiBackground,
            boxShadow: '0px 2px 20px rgba(0, 0, 0, 0.5)',
            borderRadius: theme.shape.borderRadius,
            color: '#fff',
            height: '400px',
            width: '375px',

            '.prejoin-dialog--small': {
                height: 300,
                width: 400
            },

            '.prejoin-dialog-label': {
                fontSize: '15px',
                lineHeight: '24px'
            },

            '.prejoin-dialog-label-num': {
                background: '#2b3b4b',
                border: '1px solid #A4B8D1',
                borderRadius: '50%',
                color: '#fff',
                display: 'inline-block',
                height: '24px',
                marginRight: theme.spacing(2),
                width: '24px'
            },

            '.prejoin-dialog-container': {
                alignItems: 'center',
                background: 'rgba(0,0,0,0.6)',
                display: 'flex',
                height: '100dvh',
                justifyContent: 'center',
                left: 0,
                position: 'absolute' as const,
                top: 0,
                width: '100vw',
                zIndex: 3
            },

            '.prejoin-dialog-flag': {
                display: 'inline-block',
                marginRight: theme.spacing(2),
                transform: 'scale(1.2)'
            },

            '.prejoin-dialog-title': {
                display: 'inline-block',
                fontSize: '24px',
                lineHeight: '32px'
            },

            '.prejoin-dialog-icon': {
                cursor: 'pointer'
            },

            '.prejoin-dialog-btn': {
                marginBottom: '8px'
            },

            '.prejoin-dialog-dialin-container': {
                textAlign: 'center' as const
            },

            '.prejoin-dialog-delimiter': {
                background: theme.palette.ui03,
                border: '0',
                height: '1px',
                margin: '0',
                padding: '0',
                width: '100%'
            },

            '.prejoin-dialog-delimiter-container': {
                margin: `${theme.spacing(4)} 0`,
                position: 'relative' as const
            },

            '.prejoin-dialog-delimiter-txt-container': {
                position: 'absolute' as const,
                textAlign: 'center' as const,
                top: '-8px',
                width: '100%'
            },

            '.prejoin-dialog-delimiter-txt': {
                background: theme.palette.uiBackground,
                color: theme.palette.text01,
                fontSize: '11px',
                textTransform: 'uppercase' as const,
                padding: `0 ${theme.spacing(2)}`
            }
        },

        '.prejoin-dialog-btn': {
            '&.primary, &.prejoin-dialog-btn.text': {
                width: '310px'
            }
        },

        '.toolbox-icon': {
            display: 'flex',
            borderRadius: 3,
            flexDirection: 'column' as const,
            fontSize: 24,
            height: 48,
            justifyContent: 'center',
            width: 48,

            '@media (hover: hover) and (pointer: fine)': {
                '&:hover': {
                    backgroundColor: theme.palette.ui04
                },

                '&:active': {
                    backgroundColor: theme.palette.ui03
                }
            },
            [theme.breakpoints.down(320)]: {
                height: 36,
                width: 36
            },

            '&.toggled': {
                backgroundColor: theme.palette.ui03
            },

            '&.disabled': {
                cursor: 'initial !important',
                backgroundColor: `${theme.palette.disabled01} !important`,

                '& svg': {
                    fill: `${theme.palette.text03} !important`
                }
            }
        },

        '.toolbox-button': {
            color: theme.palette.text01,
            cursor: 'pointer',
            display: 'inline-block',
            lineHeight: '48px',
            textAlign: 'center' as const
        },

        '.toolbox-content-items': {
            background: theme.palette.ui01,
            borderRadius: 6,
            margin: '0 auto',
            padding: 6,
            textAlign: 'center' as const,
            pointerEvents: 'all' as const,
            display: 'flex',
            boxShadow: '0px 2px 8px 4px rgba(0, 0, 0, 0.25), 0px 0px 0px 1px rgba(0, 0, 0, 0.15)',

            '& > div': {
                marginRight: theme.spacing(2),

                '&:last-of-type': {
                    marginRight: 0
                }
            }
        }
    };
};


################################################################################

## File: .\jitsi-meet\react\features\base\ui\functions.native.ts

import { DefaultTheme } from 'react-native-paper';

import { createColorTokens } from './utils';

/**
 * Creates a React Native Paper theme based on local UI tokens.
 *
 * @param {Object} arg - The ui tokens.
 * @returns {Object}
 */
export function createNativeTheme({ font, colors, colorMap, shape, spacing, typography }: any): any {
    return {
        ...DefaultTheme,
        palette: createColorTokens(colorMap, colors),
        shape,
        spacing,
        typography: {
            font,
            ...typography
        }
    };
}


################################################################################

## File: .\jitsi-meet\react\features\base\ui\functions.web.ts

/* eslint-disable @typescript-eslint/naming-convention */
import { Theme, adaptV4Theme, createTheme } from '@mui/material/styles';

import { ITypography, IPalette as Palette1 } from '../ui/types';

import { createColorTokens } from './utils';

declare module '@mui/material/styles' {
    // eslint-disable-next-line @typescript-eslint/no-empty-interface
    interface Palette extends Palette1 {}

    // eslint-disable-next-line @typescript-eslint/no-empty-interface
    interface TypographyVariants extends ITypography {}
}

interface ThemeProps {
    breakpoints: Object;
    colorMap: Object;
    colors: Object;
    font: Object;
    shape: Object;
    spacing: Array<number>;
    typography: Object;
}

/**
 * Creates a MUI theme based on local UI tokens.
 *
 * @param {Object} arg - The ui tokens.
 * @returns {Object}
 */
export function createWebTheme({ font, colors, colorMap, shape, spacing, typography, breakpoints }: ThemeProps) {
    return createTheme(adaptV4Theme({
        spacing,
        palette: createColorTokens(colorMap, colors),
        shape,
        typography: {
            // @ts-ignore
            font,
            ...typography
        },
        breakpoints
    }));
}

/**
 * Find the first styled ancestor component of an element.
 *
 * @param {HTMLElement|null} target - Element to look up.
 * @param {string} cssClass - Styled component reference.
 * @returns {HTMLElement|null} Ancestor.
 */
export const findAncestorByClass = (target: HTMLElement | null, cssClass: string): HTMLElement | null => {
    if (!target || target.classList.contains(cssClass)) {
        return target;
    }

    return findAncestorByClass(target.parentElement, cssClass);
};

/**
 * Checks if the passed element is visible in the viewport.
 *
 * @param {Element} element - The element.
 * @returns {boolean}
 */
export function isElementInTheViewport(element?: Element): boolean {
    if (!element) {
        return false;
    }

    if (!document.body.contains(element)) {
        return false;
    }

    const { innerHeight, innerWidth } = window;
    const { bottom, left, right, top } = element.getBoundingClientRect();

    if (bottom <= innerHeight && top >= 0 && left >= 0 && right <= innerWidth) {
        return true;
    }

    return false;
}

const enterKeyElements = [ 'select', 'textarea', 'summary', 'a' ];

/**
 * Informs whether or not the given element does something on its own when pressing the Enter key.
 *
 * This is useful to correctly submit custom made "forms" that are not using the native form element,
 * only when the user is not using an element that needs the enter key to work.
 * Note the implementation is incomplete and should be updated as needed if more complex use cases arise
 * (for example, the Tabs aria pattern is not handled).
 *
 * @param {Element} element - The element.
 * @returns {boolean}
 */
export function operatesWithEnterKey(element: Element): boolean {
    if (enterKeyElements.includes(element.tagName.toLowerCase())) {
        return true;
    }

    if (element.tagName.toLowerCase() === 'button' && element.getAttribute('role') === 'button') {
        return true;
    }

    return false;
}

/**
 * Returns a common spacing from the bottom of the page for floating elements over the video space.
 *
 * @param {Theme} theme - The current theme.
 * @param {boolean} isToolbarVisible - Whether the toolbar is visible or not.
 * @returns {number}
 */
export function getVideospaceFloatingElementsBottomSpacing(theme: Theme, isToolbarVisible: boolean) {
    return parseInt(isToolbarVisible ? theme.spacing(12) : theme.spacing(6), 10);
}


################################################################################

## File: .\jitsi-meet\react\features\base\ui\Tokens.ts

// Default color palette
export const colors = {
    error03: '#7A141F',
    error04: '#A21B29',
    error05: '#CB2233',
    error06: '#D83848',
    error08: '#F24D5F',

    primary01: '#00112D',
    primary02: '#00225A',
    primary03: '#003486',
    primary04: '#0045B3',
    primary05: '#0056E0',
    primary06: '#246FE5',
    primary07: '#4687ED',
    primary08: '#99BBF3',
    primary09: '#CCDDF9',

    surface01: '#040404',
    surface02: '#141414',
    surface03: '#292929',
    surface04: '#3D3D3D',
    surface05: '#525252',
    surface06: '#666',
    surface07: '#858585',
    surface08: '#A3A3A3',
    surface09: '#C2C2C2',
    surface10: '#E0E0E0',
    surface11: '#FFF',

    success04: '#189B55',
    success05: '#1EC26A',

    warning05: '#F8AE1A',
    warning06: '#FFD600',

    support01: '#FF9B42',
    support02: '#F96E57',
    support03: '#DF486F',
    support04: '#B23683',
    support05: '#73348C',
    support06: '#6A50D3',
    support07: '#4380E2',
    support08: '#00A8B3',
    support09: '#2AA076'
};

// Mapping between the token used and the color
export const colorMap = {
    // ----- Surfaces -----

    // Default page background
    uiBackground: 'surface01',

    // Container backgrounds
    ui01: 'surface02',
    ui02: 'surface03',
    ui03: 'surface04',
    ui04: 'surface05',
    ui05: 'surface06',
    ui06: 'surface07',
    ui07: 'surface08',
    ui08: 'surface09',
    ui09: 'surface10',
    ui10: 'surface11',

    // ----- Actions -----

    // Primary
    action01: 'primary06',
    action01Hover: 'primary07',
    action01Active: 'primary04',

    // Secondary
    action02: 'surface10',
    action02Hover: 'surface11',
    action02Active: 'surface09',

    // Destructive
    actionDanger: 'error05',
    actionDangerHover: 'error06',
    actionDangerActive: 'error04',

    // Tertiary
    action03: 'transparent',
    action03Hover: 'surface04',
    action03Active: 'surface03',

    // Disabled
    disabled01: 'surface09',

    // Focus
    focus01: 'primary07',

    // ----- Links -----

    link01: 'primary07',
    link01Hover: 'primary08',
    link01Active: 'primary06',

    // ----- Text -----

    // Primary
    text01: 'surface11',

    // Secondary
    text02: 'surface09',

    // Tertiary
    text03: 'surface07',

    // High-contrast
    text04: 'surface01',

    // Error
    textError: 'error08',

    // ----- Icons -----

    // Primary
    icon01: 'surface11',

    // Secondary
    icon02: 'surface09',

    // Tertiary
    icon03: 'surface07',

    // High-contrast
    icon04: 'surface01',

    // Error
    iconError: 'error06',

    // ----- Forms -----

    field01: 'surface04',

    // ----- Feedback -----

    // Success
    success01: 'success05',
    success02: 'success04',

    // Warning
    warning01: 'warning05',
    warning02: 'warning06',

    // ----- Support -----

    support01: 'support01',
    support02: 'support02',
    support03: 'support03',
    support04: 'support04',
    support05: 'support05',
    support06: 'support06',
    support07: 'support07',
    support08: 'support08',
    support09: 'support09'
};


export const font = {
    weightRegular: '400',
    weightSemiBold: '600'
};

export const shape = {
    borderRadius: 6,
    circleRadius: 50,
    boxShadow: 'inset 0px -1px 0px rgba(255, 255, 255, 0.15)'
};

export const spacing
    = [ 0, 4, 8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 96, 104, 112, 120, 128 ];

export const typography = {
    labelRegular: {
        fontSize: 12,
        lineHeight: 16,
        fontWeight: font.weightRegular,
        letterSpacing: 0.16
    },

    labelBold: {
        fontSize: 12,
        lineHeight: 16,
        fontWeight: font.weightSemiBold,
        letterSpacing: 0.16
    },

    bodyShortRegularSmall: {
        fontSize: 10,
        lineHeight: 16,
        fontWeight: font.weightRegular,
        letterSpacing: 0
    },

    bodyShortRegular: {
        fontSize: 14,
        lineHeight: 20,
        fontWeight: font.weightRegular,
        letterSpacing: 0
    },

    bodyShortBold: {
        fontSize: 14,
        lineHeight: 20,
        fontWeight: font.weightSemiBold,
        letterSpacing: 0
    },

    bodyShortRegularLarge: {
        fontSize: 16,
        lineHeight: 22,
        fontWeight: font.weightRegular,
        letterSpacing: 0
    },

    bodyShortBoldLarge: {
        fontSize: 16,
        lineHeight: 22,
        fontWeight: font.weightSemiBold,
        letterSpacing: 0
    },

    bodyLongRegular: {
        fontSize: 14,
        lineHeight: 24,
        fontWeight: font.weightRegular,
        letterSpacing: 0
    },

    bodyLongRegularLarge: {
        fontSize: 16,
        lineHeight: 26,
        fontWeight: font.weightRegular,
        letterSpacing: 0
    },

    bodyLongBold: {
        fontSize: 14,
        lineHeight: 24,
        fontWeight: font.weightSemiBold,
        letterSpacing: 0
    },

    bodyLongBoldLarge: {
        fontSize: 16,
        lineHeight: 26,
        fontWeight: font.weightSemiBold,
        letterSpacing: 0
    },

    heading1: {
        fontSize: 54,
        lineHeight: 64,
        fontWeight: font.weightSemiBold,
        letterSpacing: 0
    },

    heading2: {
        fontSize: 42,
        lineHeight: 50,
        fontWeight: font.weightSemiBold,
        letterSpacing: 0
    },

    heading3: {
        fontSize: 32,
        lineHeight: 40,
        fontWeight: font.weightSemiBold,
        letterSpacing: 0
    },

    heading4: {
        fontSize: 28,
        lineHeight: 36,
        fontWeight: font.weightSemiBold,
        letterSpacing: 0
    },

    heading5: {
        fontSize: 20,
        lineHeight: 28,
        fontWeight: font.weightSemiBold,
        letterSpacing: 0
    },

    heading6: {
        fontSize: 16,
        lineHeight: 26,
        fontWeight: font.weightSemiBold,
        letterSpacing: 0
    }
};

export const breakpoints = {
    values: {
        '0': 0,
        '320': 320,
        '400': 400,
        '480': 480
    }
};


################################################################################

## File: .\jitsi-meet\react\features\base\ui\types.ts

interface ITypographyType {
    fontSize: number;
    fontWeight: string;
    letterSpacing: number;
    lineHeight: number;
}

export interface IPalette {
    action01: string;
    action01Active: string;
    action01Hover: string;
    action02: string;
    action02Active: string;
    action02Hover: string;
    action03: string;
    action03Active: string;
    action03Hover: string;
    actionDanger: string;
    actionDangerActive: string;
    actionDangerHover: string;
    disabled01: string;
    field01: string;
    focus01: string;
    icon01: string;
    icon02: string;
    icon03: string;
    icon04: string;
    iconError: string;
    link01: string;
    link01Active: string;
    link01Hover: string;
    success01: string;
    success02: string;
    support01: string;
    support02: string;
    support03: string;
    support04: string;
    support05: string;
    support06: string;
    support07: string;
    support08: string;
    support09: string;
    text01: string;
    text02: string;
    text03: string;
    text04: string;
    textError: string;
    ui01: string;
    ui02: string;
    ui03: string;
    ui04: string;
    ui05: string;
    ui06: string;
    ui07: string;
    ui08: string;
    ui09: string;
    ui10: string;
    uiBackground: string;
    warning01: string;
    warning02: string;
}

export interface ITypography {
    bodyLongBold: ITypographyType;
    bodyLongBoldLarge: ITypographyType;
    bodyLongRegular: ITypographyType;
    bodyLongRegularLarge: ITypographyType;
    bodyShortBold: ITypographyType;
    bodyShortBoldLarge: ITypographyType;
    bodyShortRegular: ITypographyType;
    bodyShortRegularLarge: ITypographyType;
    bodyShortRegularSmall: ITypographyType;
    heading1: ITypographyType;
    heading2: ITypographyType;
    heading3: ITypographyType;
    heading4: ITypographyType;
    heading5: ITypographyType;
    heading6: ITypographyType;
    labelBold: ITypographyType;
    labelRegular: ITypographyType;
}


################################################################################

## File: .\jitsi-meet\react\features\base\ui\utils.ts

/**
 * Creates the color tokens based on the color theme and the association map.
 * If a key is not found in the association map it defaults to the current value.
 *
 * @param {Object} colorMap - A map between the token name and the actual color value.
 * @param {Object} colors - An object containing all the theme colors.
 * @returns {Object}
 */
export function createColorTokens(colorMap: Object, colors: Object): any {
    return Object.entries(colorMap)
        .reduce((result, [ token, value ]: [any, keyof Object]) =>
            Object.assign(result, { [token]: colors[value] || value }), {});
}


################################################################################

## File: .\jitsi-meet\react\features\base\ui\components\BaseTheme.native.ts

import { colorMap, colors, font, shape, spacing, typography } from '../Tokens';
import { createNativeTheme } from '../functions.native';

import updateTheme from './updateTheme.native';

export default createNativeTheme(updateTheme({
    font,
    colors,
    colorMap,
    spacing,
    shape,
    typography
}));


################################################################################

## File: .\jitsi-meet\react\features\base\ui\components\BaseTheme.web.ts

import { breakpoints, colorMap, colors, font, shape, spacing, typography } from '../Tokens';
import { createWebTheme } from '../functions.web';

export default createWebTheme({
    font,
    colors,
    colorMap,
    spacing,
    shape,
    typography,
    breakpoints
});


################################################################################

## File: .\jitsi-meet\react\features\base\ui\components\types.ts

import { GestureResponderEvent } from 'react-native';

import { BUTTON_TYPES } from '../constants.any';

export interface IButtonProps {

    /**
     * Label used for accessibility.
     */
    accessibilityLabel?: string;

    /**
     * Whether or not the button should automatically focus.
     */
    autoFocus?: boolean;

    /**
     * Whether or not the button is disabled.
     */
    disabled?: boolean;

    /**
     * The icon to be displayed on the button.
     */
    icon?: Function;

    /**
     * The translation key of the text to be displayed on the button.
     */
    labelKey?: string;

    /**
     * Click callback.
     */
    onClick?: (e?: React.MouseEvent<HTMLButtonElement> | GestureResponderEvent) => void;

    /**
     * Key press callback.
     */
    onKeyPress?: (e?: React.KeyboardEvent<HTMLButtonElement>) => void;

    /**
     * The type of button to be displayed.
     */
    type?: BUTTON_TYPES;
}

export interface IInputProps {

    /**
     * Whether the input is be clearable. (show clear button).
     */
    clearable?: boolean;

    /**
     * Whether the input is be disabled.
     */
    disabled?: boolean;

    /**
     * Whether the input is in error state.
     */
    error?: boolean;

    /**
     * The icon to be displayed on the input.
     */
    icon?: Function;

    /**
     * The label of the input.
     */
    label?: string;

    /**
     * Change callback.
     */
    onChange?: (value: string) => void;

    /**
     * The input placeholder text.
     */
    placeholder?: string;

    /**
     * The value of the input.
     */
    value: string | number;
}

export interface ISwitchProps {

    /**
     * Whether or not the toggle is on.
     */
    checked: boolean;

    /**
     * Whether or not the toggle is disabled.
     */
    disabled?: boolean;

    /**
     * Toggle change callback.
     */
    onChange: (on?: boolean) => void;
}

export type MultiSelectItem = {
    content: string;
    description?: string;
    elemBefore?: Element;
    isDisabled?: boolean;
    value: string;
};


################################################################################

## File: .\jitsi-meet\react\features\base\ui\components\updateTheme.native.ts

/**
 * Custom theme for setting client branding.
 *
 * @param {Object} theme - The ui tokens theme object.
 * @returns {Object}
 */
export default function updateTheme(theme: Object) {
    return theme;
}


################################################################################

## File: .\jitsi-meet\react\features\base\ui\components\variables.ts

/**
 * Prejoin / premeeting screen.
 */

// Maps SCSS variable $prejoinDefaultContentWidth
export const PREJOIN_DEFAULT_CONTENT_WIDTH = '336px';


################################################################################

## File: .\jitsi-meet\react\features\base\ui\components\native\buttonStyles.ts

import BaseTheme from '../../../ui/components/BaseTheme.native';

const BUTTON_HEIGHT = BaseTheme.spacing[7];

const button = {
    borderRadius: BaseTheme.shape.borderRadius,
    display: 'flex',
    height: BUTTON_HEIGHT,
    justifyContent: 'center'
};

const buttonLabel = {
    ...BaseTheme.typography.bodyShortBold,
    textTransform: 'capitalize'
};

export default {
    button: {
        ...button
    },

    buttonLabel: {
        ...buttonLabel
    },

    buttonLabelDisabled: {
        ...buttonLabel,
        color: BaseTheme.palette.text03
    },

    buttonContent: {
        height: BUTTON_HEIGHT
    },

    buttonDisabled: {
        ...button,
        backgroundColor: BaseTheme.palette.ui08
    },

    buttonLabelPrimary: {
        ...buttonLabel,
        color: BaseTheme.palette.text01
    },

    buttonLabelPrimaryText: {
        ...buttonLabel,
        color: BaseTheme.palette.action01
    },

    buttonLabelSecondary: {
        ...buttonLabel,
        color: BaseTheme.palette.text04
    },

    buttonLabelDestructive: {
        ...buttonLabel,
        color: BaseTheme.palette.text01
    },

    buttonLabelDestructiveText: {
        ...buttonLabel,
        color: BaseTheme.palette.actionDanger
    },

    buttonLabelTertiary: {
        ...buttonLabel,
        color: BaseTheme.palette.text01,
        marginHorizontal: BaseTheme.spacing[2],
        textAlign: 'center'
    },

    buttonLabelTertiaryDisabled: {
        ...buttonLabel,
        color: BaseTheme.palette.text03,
        textAlign: 'center'
    }
};


################################################################################

## File: .\jitsi-meet\react\features\base\ui\components\native\inputStyles.ts

import BaseTheme from '../../../ui/components/BaseTheme.native';

export default {
    inputContainer: {
        display: 'flex',
        flexDirection: 'column'
    },

    label: {
        ...BaseTheme.typography.bodyShortRegularLarge,
        lineHeight: 0,
        color: BaseTheme.palette.text01,
        marginBottom: BaseTheme.spacing[2]
    },

    fieldContainer: {
        position: 'relative'
    },

    icon: {
        position: 'absolute',
        zIndex: 1,
        top: 14,
        left: 14
    },

    input: {
        ...BaseTheme.typography.bodyShortRegularLarge,
        backgroundColor: BaseTheme.palette.ui03,
        borderColor: BaseTheme.palette.ui03,
        borderRadius: BaseTheme.shape.borderRadius,
        borderWidth: 2,
        color: BaseTheme.palette.text01,
        paddingHorizontal: BaseTheme.spacing[3],
        height: BaseTheme.spacing[7],
        lineHeight: 20
    },

    inputDisabled: {
        color: BaseTheme.palette.text03
    },

    inputFocused: {
        borderColor: BaseTheme.palette.focus01
    },

    inputError: {
        borderColor: BaseTheme.palette.textError
    },

    iconInput: {
        paddingLeft: BaseTheme.spacing[6]
    },

    inputMultiline: {
        height: BaseTheme.spacing[10],
        paddingTop: BaseTheme.spacing[2]
    },

    clearableInput: {
        paddingRight: BaseTheme.spacing[6]
    },

    clearButton: {
        backgroundColor: 'transparent',
        borderWidth: 0,
        position: 'absolute',
        right: 0,
        top: 14,
        width: BaseTheme.spacing[6],
        height: BaseTheme.spacing[7]
    },

    clearIcon: {
        color: BaseTheme.palette.icon01
    },

    bottomLabel: {
        ...BaseTheme.typography.labelRegular,
        color: BaseTheme.palette.text02,
        marginTop: BaseTheme.spacing[2]
    },

    bottomLabelError: {
        color: BaseTheme.palette.textError
    }
};


################################################################################

## File: .\jitsi-meet\react\features\base\ui\components\native\switchStyles.ts

import BaseTheme from '../BaseTheme.native';

export const ENABLED_TRACK_COLOR = BaseTheme.palette.action01;
export const DISABLED_TRACK_COLOR = BaseTheme.palette.ui05;
export const THUMB_COLOR = BaseTheme.palette.icon01;


################################################################################

## File: .\jitsi-meet\react\features\base\ui\hooks\useContextMenu.web.ts

import { useCallback, useRef, useState } from 'react';

import { findAncestorByClass } from '../functions.web';


type RaiseContext<T> = {

    /**
     * The entity for which the menu is context menu is raised.
     */
    entity?: T;

    /**
     * Target elements against which positioning calculations are made.
     */
    offsetTarget?: HTMLElement | null;
};

const initialState = Object.freeze({});

const useContextMenu = <T>(): [(force?: boolean | Object) => void,
    (entity: T, target: HTMLElement | null) => void,
    (entity: T) => (e?: MouseEvent) => void,
    () => void,
    () => void,
    RaiseContext<T>] => {
    const [ raiseContext, setRaiseContext ] = useState < RaiseContext<T> >(initialState);
    const isMouseOverMenu = useRef(false);

    const lowerMenu = useCallback((force: boolean | Object = false) => {
        /**
         * We are tracking mouse movement over the active participant item and
         * the context menu. Due to the order of enter/leave events, we need to
         * defer checking if the mouse is over the context menu with
         * queueMicrotask.
         */
        window.queueMicrotask(() => {
            if (isMouseOverMenu.current && !(force === true)) {
                return;
            }

            if (raiseContext !== initialState || force) {
                setRaiseContext(initialState);
            }
        });
    }, [ raiseContext ]);

    const raiseMenu = useCallback((entity: T, target: HTMLElement | null) => {
        setRaiseContext({
            entity,
            offsetTarget: findAncestorByClass(target, 'list-item-container')
        });
    }, [ raiseContext ]);

    const toggleMenu = useCallback((entity: T) => (e?: MouseEvent) => {
        e?.stopPropagation();
        const { entity: raisedEntity } = raiseContext;

        if (raisedEntity && raisedEntity === entity) {
            lowerMenu();
        } else {
            raiseMenu(entity, e?.target as HTMLElement);
        }
    }, [ raiseContext ]);

    const menuEnter = useCallback(() => {
        isMouseOverMenu.current = true;
    }, []);

    const menuLeave = useCallback(() => {
        isMouseOverMenu.current = false;
    }, [ lowerMenu ]);

    return [ lowerMenu, raiseMenu, toggleMenu, menuEnter, menuLeave, raiseContext ];
};

export default useContextMenu;


################################################################################

## File: .\jitsi-meet\react\features\base\user-interaction\actionTypes.ts

/**
 * The type of (redux) action which signals the user has interacted with the
 * page.
 *
 * {
 *     type: USER_INTERACTION_RECEIVED,
 * }
 */
export const USER_INTERACTION_RECEIVED = 'USER_INTERACTION_RECEIVED';


################################################################################

## File: .\jitsi-meet\react\features\base\user-interaction\middleware.ts

import { IStore } from '../../app/types';
import { APP_WILL_MOUNT, APP_WILL_UNMOUNT } from '../app/actionTypes';
import MiddlewareRegistry from '../redux/MiddlewareRegistry';

import { USER_INTERACTION_RECEIVED } from './actionTypes';

/**
 * Reference to any callback that has been created to be invoked on user
 * interaction.
 *
 * @type {Function|null}
 */
let userInteractionListener: Function | null = null;

/**
 * Implements the entry point of the middleware of the feature base/user-interaction.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {
    switch (action.type) {
    case APP_WILL_MOUNT:
        _startListeningForUserInteraction(store);
        break;

    case APP_WILL_UNMOUNT:
        _stopListeningForUserInteraction();
        break;
    }

    return next(action);
});

/**
 * Callback invoked when the user interacts with the page.
 *
 * @param {Function} dispatch - The redux dispatch function.
 * @param {Object} event - The DOM event for a user interacting with the page.
 * @private
 * @returns {void}
 */
function _onUserInteractionReceived(dispatch: IStore['dispatch'], event: any) {
    if (event.isTrusted) {
        dispatch({
            type: USER_INTERACTION_RECEIVED
        });

        _stopListeningForUserInteraction();
    }
}

/**
 * Registers listeners to notify redux of any user interaction with the page.
 *
 * @param {Object} store - The redux store.
 * @private
 * @returns {void}
 */
function _startListeningForUserInteraction({ dispatch }: { dispatch: IStore['dispatch']; }) {
    _stopListeningForUserInteraction();

    userInteractionListener = _onUserInteractionReceived.bind(null, dispatch);

    // @ts-ignore
    window.addEventListener('mousedown', userInteractionListener);

    // @ts-ignore
    window.addEventListener('keydown', userInteractionListener);
}

/**
 * De-registers listeners for user interaction with the page.
 *
 * @private
 * @returns {void}
 */
function _stopListeningForUserInteraction() {
    // @ts-ignore
    window.removeEventListener('mousedown', userInteractionListener);

    // @ts-ignore
    window.removeEventListener('keydown', userInteractionListener);

    userInteractionListener = null;
}


################################################################################

## File: .\jitsi-meet\react\features\base\user-interaction\reducer.ts

import { APP_WILL_MOUNT, APP_WILL_UNMOUNT } from '../app/actionTypes';
import ReducerRegistry from '../redux/ReducerRegistry';

import { USER_INTERACTION_RECEIVED } from './actionTypes';

export interface IUserInteractionState {
    interacted?: boolean;
}


ReducerRegistry.register<IUserInteractionState>('features/base/user-interaction',
(state = {}, action): IUserInteractionState => {
    switch (action.type) {
    case APP_WILL_MOUNT:
    case APP_WILL_UNMOUNT:
        return {
            ...state,
            interacted: false
        };

    case USER_INTERACTION_RECEIVED:
        return {
            ...state,
            interacted: true
        };
    }

    return state;
});


################################################################################

## File: .\jitsi-meet\react\features\base\util\contants.ts

export const SECURITY_URL = 'https://jitsi.org/security/';


################################################################################

## File: .\jitsi-meet\react\features\base\util\copyText.native.ts

import Clipboard from '@react-native-clipboard/clipboard';

/**
 * Tries to copy a given text to the clipboard.
 * Returns true if the action succeeds.
 *
 * @param {string} textToCopy - Text to be copied.
 * @returns {Promise<boolean>}
 */
export function copyText(textToCopy: string) {
    try {
        Clipboard.setString(textToCopy);

        return true;
    } catch (e) {
        return false;
    }
}


################################################################################

## File: .\jitsi-meet\react\features\base\util\copyText.web.ts

import clipboardCopy from 'clipboard-copy';

/**
 * Tries to copy a given text to the clipboard.
 * Returns true if the action succeeds.
 *
 * @param {string} textToCopy - Text to be copied.
 * @returns {Promise<boolean>}
 */
export async function copyText(textToCopy: string) {
    try {
        await clipboardCopy(textToCopy);

        return true;
    } catch (e) {
        return false;
    }
}


################################################################################

## File: .\jitsi-meet\react\features\base\util\downloadJSON.web.ts

/**
 * Downloads a JSON object.
 *
 * @param {Object} json - The JSON object to download.
 * @param {string} filename - The filename to give to the downloaded file.
 * @returns {void}
 */
export function downloadJSON(json: Object, filename: string) {
    const data = encodeURIComponent(JSON.stringify(json, null, '  '));

    const elem = document.createElement('a');

    elem.download = filename;
    elem.href = `data:application/json;charset=utf-8,\n${data}`;
    elem.dataset.downloadurl = [ 'text/json', elem.download, elem.href ].join(':');
    elem.dispatchEvent(new MouseEvent('click', {
        view: window,
        bubbles: true,
        cancelable: false
    }));
}


################################################################################

## File: .\jitsi-meet\react\features\base\util\getUnsafeRoomText.native.ts

import React from 'react';
import { Text } from 'react-native';


import { IReduxState } from '../../app/types';
import Link from '../react/components/native/Link';
import BaseTheme from '../ui/components/BaseTheme.native';

import { SECURITY_URL } from './contants';

/**
 * Gets the unsafe room text for the given context.
 *
 * @param {IReduxState} state - The redux state.
 * @param {Function} t - The translation function.
 * @param {'meeting'|'prejoin'|'welcome'} context - The given context of the warining.
 * @returns {Text}
 */
export default function getUnsafeRoomText(state: IReduxState, t: Function, context: 'meeting' | 'prejoin' | 'welcome') {
    const securityUrl = state['features/base/config'].legalUrls?.security ?? SECURITY_URL;
    const link = React.createElement(Link, {
        url: securityUrl,
        children: 'here',
        key: 'support-link',
        style: { color: BaseTheme.palette.action01 } });

    const options = {
        recommendAction: t(`security.unsafeRoomActions.${context}`)
    };

    return React.createElement(Text, { children: [ t('security.insecureRoomNameWarningNative', options), link, '.' ] });
}


################################################################################

## File: .\jitsi-meet\react\features\base\util\getUnsafeRoomText.web.ts

import { translateToHTML } from '../i18n/functions';

import { SECURITY_URL } from './contants';

/**
 * Gets the unsafe room text for the given context.
 *
 * @param {Function} t - The translation function.
 * @param {'meeting'|'prejoin'|'welcome'} context - The given context of the warining.
 * @returns {string}
 */
export default function getUnsafeRoomText(t: Function, context: 'meeting' | 'prejoin' | 'welcome') {
    const securityUrl = APP.store.getState()['features/base/config'].legalUrls?.security ?? SECURITY_URL;
    const options = {
        recommendAction: t(`security.unsafeRoomActions.${context}`),
        securityUrl
    };

    return translateToHTML(t, 'security.insecureRoomNameWarningWeb', options);
}


################################################################################

## File: .\jitsi-meet\react\features\base\util\helpers.ts

/**
 * A helper function that behaves similar to Object.assign, but only reassigns a
 * property in target if it's defined in source.
 *
 * @param {Object} target - The target object to assign the values into.
 * @param {Object} source - The source object.
 * @returns {Object}
 */
export function assignIfDefined(target: Object, source: Object) {
    const to = Object(target);

    for (const nextKey in source) {
        if (source.hasOwnProperty(nextKey)) {
            const value = source[nextKey as keyof typeof source];

            if (typeof value !== 'undefined') {
                to[nextKey] = value;
            }
        }
    }

    return to;
}


/**
 * Creates a deferred object.
 *
 * @returns {{promise, resolve, reject}}
 */
export function createDeferred() {
    const deferred: any = {};

    deferred.promise = new Promise((resolve, reject) => {
        deferred.resolve = resolve;
        deferred.reject = reject;
    });

    return deferred;
}

const MATCH_OPERATOR_REGEXP = /[|\\{}()[\]^$+*?.-]/g;

/**
 * Escape RegExp special characters.
 *
 * Based on https://github.com/sindresorhus/escape-string-regexp.
 *
 * @param {string} s - The regexp string to escape.
 * @returns {string}
 */
export function escapeRegexp(s: string) {
    if (typeof s !== 'string') {
        throw new TypeError('Expected a string');
    }

    return s.replace(MATCH_OPERATOR_REGEXP, '\\$&');
}

/**
 * Returns the base URL of the app.
 *
 * @param {Object} w - Window object to use instead of the built in one.
 * @returns {string}
 */
export function getBaseUrl(w: typeof window = window) {
    const doc = w.document;
    const base = doc.querySelector('base');

    if (base?.href) {
        return base.href;
    }

    const { protocol, host } = w.location;

    return `${protocol}//${host}`;
}

/**
 * Returns the namespace for all global variables, functions, etc that we need.
 *
 * @returns {Object} The namespace.
 *
 * NOTE: After React-ifying everything this should be the only global.
 */
export function getJitsiMeetGlobalNS() {
    if (!window.JitsiMeetJS) {
        window.JitsiMeetJS = {};
    }

    if (!window.JitsiMeetJS.app) {
        window.JitsiMeetJS.app = {};
    }

    return window.JitsiMeetJS.app;
}

/**
 * Prints the error and reports it to the global error handler.
 *
 * @param {Error} e - The error object.
 * @param {string} msg - A custom message to print in addition to the error.
 * @returns {void}
 */
export function reportError(e: Error, msg = '') {
    console.error(msg, e);
    window.onerror?.(msg, undefined, undefined, undefined, e);
}

/**
 * Adds alpha to a color css string.
 *
 * @param {string} color - The color string either in rgb... Or #... Format.
 * @param {number} opacity -The opacity(alpha) to apply to the color. Can take a value between 0 and 1, including.
 * @returns {string} - The color with applied alpha.
 */
export function setColorAlpha(color: string, opacity: number) {
    if (!color) {
        return `rgba(0, 0, 0, ${opacity})`;
    }

    let b, g, r;

    try {
        if (color.startsWith('rgb')) {
            [ r, g, b ] = color.split('(')[1].split(')')[0].split(',').map(c => c.trim());
        } else if (color.startsWith('#')) {
            if (color.length === 4) {
                [ r, g, b ] = parseShorthandColor(color);
            } else {
                r = parseInt(color.substring(1, 3), 16);
                g = parseInt(color.substring(3, 5), 16);
                b = parseInt(color.substring(5, 7), 16);
            }
        } else {
            return color;
        }

        return `rgba(${r}, ${g}, ${b}, ${opacity})`;
    } catch {
        return color;
    }
}

/**
 * Gets the hexa rgb values for a shorthand css color.
 *
 * @param {string} color - The shorthand css color.
 * @returns {Array<number>} - Array containing parsed r, g, b values of the color.
 */
function parseShorthandColor(color: string) {
    let b, g, r;

    r = color.substring(1, 2);
    r += r;
    r = parseInt(r, 16);

    g = color.substring(2, 3);
    g += g;
    g = parseInt(g, 16);

    b = color.substring(3, 4);
    b += b;
    b = parseInt(b, 16);

    return [ r, g, b ];
}

/**
 * Sorts an object by a sort function, same functionality as array.sort().
 *
 * @param {Object} object - The data object.
 * @param {Function} callback - The sort function.
 * @returns {void}
 */
export function objectSort(object: Object, callback: Function) {
    return Object.entries(object)
        .sort(([ , a ], [ , b ]) => callback(a, b))
        .reduce((row, [ key, value ]) => {
            return { ...row,
                [key]: value };
        }, {});
}


################################################################################

## File: .\jitsi-meet\react\features\base\util\hooks.ts

import { useSelector } from 'react-redux';

/**
 * Takes a redux selector and binds it to specific values.
 *
 * @param {Function} selector - The selector function.
 * @param {...any} args - The values to bind to.
 * @returns {any}
 */
export function useBoundSelector(selector: Function, ...args: any[]) {
    return useSelector(state => selector(state, ...args));
}


################################################################################

## File: .\jitsi-meet\react\features\base\util\httpUtils.ts

import base64js from 'base64-js';

import { timeoutPromise } from './timeoutPromise';

/**
 * The number of milliseconds before deciding that we need retry a fetch request.
 *
 * @type {number}
 */
const RETRY_TIMEOUT = 3000;

/**
 * Wrapper around fetch GET requests to handle json-ifying the response
 * and logging errors.
 *
 * @param {string} url - The URL to perform a GET against.
 * @param {?boolean} retry - Whether the request will be retried after short timeout.
 * @param {?Object} options - The request options.
 * @returns {Promise<Object>} The response body, in JSON format, will be
 * through the Promise.
 */
export function doGetJSON(url: string, retry?: boolean, options?: Object) {
    const fetchPromise = fetch(url, options)
        .then(response => {
            const jsonify = response.json();

            if (response.ok) {
                return jsonify;
            }

            return jsonify
                .then(result => Promise.reject(result));
        });

    if (retry) {
        return timeoutPromise(fetchPromise, RETRY_TIMEOUT)
            .catch(response => {
                if (response.status >= 400 && response.status < 500) {
                    return Promise.reject(response);
                }

                return timeoutPromise(fetchPromise, RETRY_TIMEOUT);
            });
    }

    return fetchPromise;
}

/**
 * Encodes strings to Base64URL.
 *
 * @param {any} data - The byte array to encode.
 * @returns {string}
 */
export const encodeToBase64URL = (data: string): string => base64js
    .fromByteArray(new window.TextEncoder().encode(data))
    .replace(/=/g, '')
    .replace(/\+/g, '-')
    .replace(/\//g, '_');

/**
 * Decodes strings from Base64URL.
 *
 * @param {string} data - The byte array to decode.
 * @returns {string}
 */
export const decodeFromBase64URL = (data: string): string => {
    let s = data;

    // Convert from Base64URL to Base64.
    if (s.length % 4 === 2) {
        s += '==';
    } else if (s.length % 4 === 3) {
        s += '=';
    }

    s = s.replace(/-/g, '+').replace(/_/g, '/');

    // Convert Base64 to a byte array.
    return new window.TextDecoder().decode(base64js.toByteArray(s));
};


################################################################################

## File: .\jitsi-meet\react\features\base\util\iframeUtils.ts

/**
 * Checks whether we are loaded in iframe.
 *
 * @returns {boolean} Whether the current page is loaded in an iframe.
 */
export function inIframe(): boolean {
    if (navigator.product === 'ReactNative') {
        return false;
    }

    try {
        return window.self !== window.top;
    } catch (e) {
        return true;
    }
}


################################################################################

## File: .\jitsi-meet\react\features\base\util\isInsecureRoomName.ts

import { isEqual } from 'lodash-es';
import { NIL, parse as parseUUID } from 'uuid';
import zxcvbn from 'zxcvbn';

// The null UUID.
const NIL_UUID = parseUUID(NIL);

const _zxcvbnCache = new Map();

/**
 * Checks if the given string is a valid UUID or not.
 *
 * @param {string} str - The string to be checked.
 * @returns {boolean} - Whether the string is a valid UUID or not.
 */
function isValidUUID(str: string) {
    let uuid;

    try {
        uuid = parseUUID(str);
    } catch (e) {
        return false;
    }

    return !isEqual(uuid, NIL_UUID);
}

/**
 * Checks a room name and caches the result.
 *
 * @param {string} roomName - The room name.
 * @returns {Object}
 */
function _checkRoomName(roomName = '') {
    if (_zxcvbnCache.has(roomName)) {
        return _zxcvbnCache.get(roomName);
    }

    const result = zxcvbn(roomName);

    _zxcvbnCache.set(roomName, result);

    return result;
}

/**
 * Returns true if the room name is considered a weak (insecure) one.
 *
 * @param {string} roomName - The room name.
 * @returns {boolean}
 */
export default function isInsecureRoomName(roomName = ''): boolean {

    // room names longer than 200 chars we consider secure
    return !isValidUUID(roomName) && (roomName.length < 200 && _checkRoomName(roomName).score < 3);
}


################################################################################

## File: .\jitsi-meet\react\features\base\util\loadScript.native.ts

/**
 * Default timeout for loading scripts.
 */
const DEFAULT_TIMEOUT = 5000;

/**
 * Loads a script from a specific URL. React Native cannot load a JS
 * file/resource/URL via a <script> HTML element, so the implementation
 * fetches the specified {@code url} as plain text using {@link fetch()} and
 * then evaluates the fetched string as JavaScript code (using {@link eval()}).
 *
 * @param {string} url - The absolute URL from which the script is to be
 * (down)loaded.
 * @param {number} [timeout] - The timeout in millisecnods after which the
 * loading of the specified {@code url} is to be aborted/rejected (if not
 * settled yet).
 * @param {boolean} skipEval - Whether we want to skip evaluating the loaded content or not.
 * @returns {void}
 */
export async function loadScript(
        url: string, timeout: number = DEFAULT_TIMEOUT, skipEval = false): Promise<any> {
    // XXX The implementation of fetch on Android will throw an Exception on
    // the Java side which will break the app if the URL is invalid (which
    // the implementation of fetch on Android calls 'unexpected url'). In
    // order to try to prevent the breakage of the app, try to fail on an
    // invalid URL as soon as possible.
    const { hostname, pathname, protocol } = new URL(url);

    // XXX The standard URL implementation should throw an Error if the
    // specified URL is relative. Unfortunately, the polyfill used on
    // react-native does not.
    if (!hostname || !pathname || !protocol) {
        throw new Error(`unexpected url: ${url}`);
    }

    const controller = new AbortController();
    const signal = controller.signal;

    const timer = setTimeout(() => {
        controller.abort();
    }, timeout);

    const response = await fetch(url, { signal });

    // If the timeout hits the above will raise AbortError.

    clearTimeout(timer);

    switch (response.status) {
    case 200: {
        const txt = await response.text();

        if (skipEval) {
            return txt;
        }

        return eval.call(window, txt); // eslint-disable-line no-eval
    }
    default:
        throw new Error(`loadScript error: ${response.statusText}`);
    }
}


################################################################################

## File: .\jitsi-meet\react\features\base\util\loadScript.web.ts

/**
 * Loads a script from a specific URL. The script will be interpreted upon load.
 *
 * @param {string} url - The url to be loaded.
 * @returns {Promise} Resolved with no arguments when the script is loaded and
 * rejected with the error from JitsiMeetJS.ScriptUtil.loadScript method.
 */
export function loadScript(url: string): Promise<void> {
    return new Promise((resolve, reject) =>
        JitsiMeetJS.util.ScriptUtil.loadScript(
            url,
            /* async */ true,
            /* prepend */ false,
            /* relativeURL */ false,
            /* loadCallback */ resolve,
            /* errorCallback */ reject));
}


################################################################################

## File: .\jitsi-meet\react\features\base\util\logger.ts

import { getLogger } from '../logging/functions';

export default getLogger('features/base/util');


################################################################################

## File: .\jitsi-meet\react\features\base\util\math.ts

/**
 * Compute the greatest common divisor using Euclid's algorithm.
 *
 * @param {number} num1 - First number.
 * @param {number} num2 - Second number.
 * @returns {number}
 */
export function greatestCommonDivisor(num1: number, num2: number) {
    let number1: number = num1;
    let number2: number = num2;

    while (number1 !== number2) {
        if (number1 > number2) {
            number1 = number1 - number2;
        } else {
            number2 = number2 - number1;
        }
    }

    return number2;
}

/**
 * Calculate least common multiple using gcd.
 *
 * @param {number} num1 - First number.
 * @param {number} num2 - Second number.
 * @returns {number}
 */
export function leastCommonMultiple(num1: number, num2: number) {
    const number1: number = num1;
    const number2: number = num2;

    const gcd: number = greatestCommonDivisor(number1, number2);

    return (number1 * number2) / gcd;
}


################################################################################

## File: .\jitsi-meet\react\features\base\util\openURLInBrowser.native.ts

import { Linking } from 'react-native';

import logger from './logger';

/**
 * Opens URL in the browser.
 *
 * @param {string} url - The URL to be opened.
 * @param {boolean} _ignore - Ignored.
 * @returns {void}
 */
export function openURLInBrowser(url: string, _ignore?: boolean) {
    Linking.openURL(url).catch(error => {
        logger.error(`An error occurred while trying to open ${url}`, error);
    });
}


################################################################################

## File: .\jitsi-meet\react\features\base\util\openURLInBrowser.web.ts

/**
 * Opens URL in the browser.
 *
 * @param {string} url - The URL to be opened.
 * @param {boolean} openInNewTab - If the link should be opened in a new tab.
 * @returns {void}
 */
export function openURLInBrowser(url: string, openInNewTab?: boolean) {
    const target = openInNewTab ? '_blank' : '';

    window.open(url, target, 'noopener');
}


################################################################################

## File: .\jitsi-meet\react\features\base\util\parseURLParams.ts

// @ts-ignore
import { safeJsonParse } from '@jitsi/js-utils/json';

import { reportError } from './helpers';

/**
 * A list if keys to ignore when parsing.
 *
 * @type {string[]}
 */
const blacklist = [ '__proto__', 'constructor', 'prototype' ];

/**
 * Parses the query/search or fragment/hash parameters out of a specific URL and
 * returns them as a JS object.
 *
 * @param {URL} url - The URL to parse.
 * @param {boolean} dontParse - If falsy, some transformations (for parsing the
 * value as JSON) will be executed.
 * @param {string} source - If {@code 'search'}, the parameters will parsed out
 * of {@code url.search}; otherwise, out of {@code url.hash}.
 * @returns {Object}
 */
export function parseURLParams(
        url: URL | string,
        dontParse = false,
        source = 'hash') {
    if (!url) {
        return {};
    }

    if (typeof url === 'string') {
        // eslint-disable-next-line no-param-reassign
        url = new URL(url);
    }
    const paramStr = source === 'search' ? url.search : url.hash;
    const params: any = {};
    const paramParts = paramStr?.substr(1).split('&') || [];

    // Detect and ignore hash params for hash routers.
    if (source === 'hash' && paramParts.length === 1) {
        const firstParam = paramParts[0];

        if (firstParam.startsWith('/') && firstParam.split('&').length === 1) {
            return params;
        }
    }

    paramParts.forEach((part: string) => {
        const param = part.split('=');
        const key = param[0];

        if (!key || key.split('.').some((k: string) => blacklist.includes(k))) {
            return;
        }

        let value;

        try {
            value = param[1];

            if (!dontParse) {
                const decoded = decodeURIComponent(value).replace(/\\&/, '&')
                    .replace(/[\u2018\u2019]/g, '\'')
                    .replace(/[\u201C\u201D]/g, '"');

                value = decoded === 'undefined' ? undefined : safeJsonParse(decoded);

            }
        } catch (e: any) {
            reportError(
                e, `Failed to parse URL parameter value: ${String(value)}`);

            return;
        }
        params[key] = value;
    });

    return params;
}


################################################################################

## File: .\jitsi-meet\react\features\base\util\strings.native.ts

import * as unorm from 'unorm';

/**
 * Applies NFKC normalization to the given text.
 * NOTE: Here we use the unorm package because the JSC version in React Native for Android crashes.
 *
 * @param {string} text - The text that needs to be normalized.
 * @returns {string} - The normalized text.
 */
export function normalizeNFKC(text: string) {
    return unorm.nfkc(text);
}

/**
 * Replaces accent characters with english alphabet characters.
 * NOTE: Here we use the unorm package because the JSC version in React Native for Android crashes.
 *
 * @param {string} text - The text that needs to be normalized.
 * @returns {string} - The normalized text.
 */
export function normalizeAccents(text: string) {
    return unorm.nfd(text).replace(/[\u0300-\u036f]/g, '');
}


################################################################################

## File: .\jitsi-meet\react\features\base\util\strings.web.ts

/**
 * Applies NFKC normalization to the given text.
 *
 * @param {string} text - The text that needs to be normalized.
 * @returns {string} - The normalized text.
 */
export function normalizeNFKC(text: string) {
    return text.normalize('NFKC');
}

/**
 * Replaces accent characters with english alphabet characters.
 * NOTE: Here we use the unorm package because the JSC version in React Native for Android crashes.
 *
 * @param {string} text - The text that needs to be normalized.
 * @returns {string} - The normalized text.
 */
export function normalizeAccents(text: string) {
    return text.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
}


################################################################################

## File: .\jitsi-meet\react\features\base\util\timeoutPromise.ts

/**
 * Returns a new {@code Promise} which settles when a specific {@code Promise}
 * settles and is automatically rejected if the specified {@code Promise}
 * doesn't settle within a specific time interval.
 *
 * @param {Promise} promise - The {@code Promise} for which automatic rejecting
 * after the specified timeout is to be implemented.
 * @param {number} timeout - The number of milliseconds to wait the specified
 * {@code promise} to settle before automatically rejecting the returned
 * {@code Promise}.
 * @returns {Promise} - A new {@code Promise} which settles when the specified
 * {@code promise} settles and is automatically rejected after {@code timeout}
 * milliseconds.
 */
export function timeoutPromise<T>(
        promise: Promise<T>,
        timeout: number
): Promise<T> {
    return new Promise((resolve, reject) => {
        const timeoutID
            = setTimeout(() => reject(new Error('timeout')), timeout);

        promise.then(
            /* onFulfilled */ value => {
                resolve(value);
                clearTimeout(timeoutID);
            },
            /* onRejected */ reason => {
                reject(reason);
                clearTimeout(timeoutID);
            }
        );
    });
}


################################################################################

## File: .\jitsi-meet\react\features\base\util\uri.ts

import { sanitizeUrl as _sanitizeUrl } from '@braintree/sanitize-url';

import { parseURLParams } from './parseURLParams';
import { normalizeNFKC } from './strings';

/**
 * Http status codes.
 */
export enum StatusCode {
    PaymentRequired = 402
}

/**
 * The app linking scheme.
 * TODO: This should be read from the manifest files later.
 */
export const APP_LINK_SCHEME = 'org.jitsi.meet:';

/**
 * A list of characters to be excluded/removed from the room component/segment
 * of a conference/meeting URI/URL. The list is based on RFC 3986 and the jxmpp
 * library utilized by jicofo.
 */
const _ROOM_EXCLUDE_PATTERN = '[\\:\\?#\\[\\]@!$&\'()*+,;=></"]';

/**
 * The {@link RegExp} pattern of the authority of a URI.
 *
 * @private
 * @type {string}
 */
const _URI_AUTHORITY_PATTERN = '(//[^/?#]+)';

/**
 * The {@link RegExp} pattern of the path of a URI.
 *
 * @private
 * @type {string}
 */
const _URI_PATH_PATTERN = '([^?#]*)';

/**
 * The {@link RegExp} pattern of the protocol of a URI.
 *
 * FIXME: The URL class exposed by JavaScript will not include the colon in
 * the protocol field. Also in other places (at the time of this writing:
 * the DeepLinkingMobilePage.js) the APP_LINK_SCHEME does not include
 * the double dots, so things are inconsistent.
 *
 * @type {string}
 */
export const URI_PROTOCOL_PATTERN = '^([a-z][a-z0-9\\.\\+-]*:)';

/**
 * Excludes/removes certain characters from a specific path part which are
 * incompatible with Jitsi Meet on the client and/or server sides. The main
 * use case for this method is to clean up the room name and the tenant.
 *
 * @param {?string} pathPart - The path part to fix.
 * @private
 * @returns {?string}
 */
function _fixPathPart(pathPart?: string) {
    return pathPart
        ? pathPart.replace(new RegExp(_ROOM_EXCLUDE_PATTERN, 'g'), '')
        : pathPart;
}

/**
 * Fixes the scheme part of a specific URI (string) so that it contains a
 * well-known scheme such as HTTP(S). For example, the mobile app implements an
 * app-specific URI scheme in addition to Universal Links. The app-specific
 * scheme may precede or replace the well-known scheme. In such a case, dealing
 * with the app-specific scheme only complicates the logic and it is simpler to
 * get rid of it (by translating the app-specific scheme into a well-known
 * scheme).
 *
 * @param {string} uri - The URI (string) to fix the scheme of.
 * @private
 * @returns {string}
 */
function _fixURIStringScheme(uri: string) {
    const regex = new RegExp(`${URI_PROTOCOL_PATTERN}+`, 'gi');
    const match: Array<string> | null = regex.exec(uri);

    if (match) {
        // As an implementation convenience, pick up the last scheme and make
        // sure that it is a well-known one.
        let protocol = match[match.length - 1].toLowerCase();

        if (protocol !== 'http:' && protocol !== 'https:') {
            protocol = 'https:';
        }

        /* eslint-disable no-param-reassign */

        uri = uri.substring(regex.lastIndex);
        if (uri.startsWith('//')) {
            // The specified URL was not a room name only, it contained an
            // authority.
            uri = protocol + uri;
        }

        /* eslint-enable no-param-reassign */
    }

    return uri;
}

/**
 * Converts a path to a backend-safe format, by splitting the path '/' processing each part.
 * Properly lowercased and url encoded.
 *
 * @param {string?} path - The path to convert.
 * @returns {string?}
 */
export function getBackendSafePath(path?: string): string | undefined {
    if (!path) {
        return path;
    }

    return path
        .split('/')
        .map(getBackendSafeRoomName)
        .join('/');
}

/**
 * Converts a room name to a backend-safe format. Properly lowercased and url encoded.
 *
 * @param {string?} room - The room name to convert.
 * @returns {string?}
 */
export function getBackendSafeRoomName(room?: string): string | undefined {
    if (!room) {
        return room;
    }

    /* eslint-disable no-param-reassign */
    try {
        // We do not know if we get an already encoded string at this point
        // as different platforms do it differently, but we need a decoded one
        // for sure. However since decoding a non-encoded string is a noop, we're safe
        // doing it here.
        room = decodeURIComponent(room);
    } catch (e) {
        // This can happen though if we get an unencoded string and it contains
        // some characters that look like an encoded entity, but it's not.
        // But in this case we're fine going on...
    }

    // Normalize the character set.
    room = normalizeNFKC(room);

    // Only decoded and normalized strings can be lowercased properly.
    room = room?.toLowerCase();

    // But we still need to (re)encode it.
    room = encodeURIComponent(room ?? '');
    /* eslint-enable no-param-reassign */

    // Unfortunately we still need to lowercase it, because encoding a string will
    // add some uppercase characters, but some backend services
    // expect it to be full lowercase. However lowercasing an encoded string
    // doesn't change the string value.
    return room.toLowerCase();
}

/**
 * Gets the (Web application) context root defined by a specific location (URI).
 *
 * @param {Object} location - The location (URI) which defines the (Web
 * application) context root.
 * @public
 * @returns {string} - The (Web application) context root defined by the
 * specified {@code location} (URI).
 */
export function getLocationContextRoot({ pathname }: { pathname: string; }) {
    const contextRootEndIndex = pathname.lastIndexOf('/');

    return (
        contextRootEndIndex === -1
            ? '/'
            : pathname.substring(0, contextRootEndIndex + 1));
}

/**
 * Constructs a new {@code Array} with URL parameter {@code String}s out of a
 * specific {@code Object}.
 *
 * @param {Object} obj - The {@code Object} to turn into URL parameter
 * {@code String}s.
 * @returns {Array<string>} The {@code Array} with URL parameter {@code String}s
 * constructed out of the specified {@code obj}.
 */
function _objectToURLParamsArray(obj = {}) {
    const params = [];

    for (const key in obj) { // eslint-disable-line guard-for-in
        try {
            params.push(
                `${key}=${encodeURIComponent(JSON.stringify(obj[key as keyof typeof obj]))}`);
        } catch (e) {
            console.warn(`Error encoding ${key}: ${e}`);
        }
    }

    return params;
}

/**
 * Parses a specific URI string into an object with the well-known properties of
 * the {@link Location} and/or {@link URL} interfaces implemented by Web
 * browsers. The parsing attempts to be in accord with IETF's RFC 3986.
 *
 * @param {string} str - The URI string to parse.
 * @public
 * @returns {{
 *     hash: string,
 *     host: (string|undefined),
 *     hostname: (string|undefined),
 *     pathname: string,
 *     port: (string|undefined),
 *     protocol: (string|undefined),
 *     search: string
 * }}
 */
export function parseStandardURIString(str: string) {
    /* eslint-disable no-param-reassign */

    const obj: { [key: string]: any; } = {
        toString: _standardURIToString
    };

    let regex;
    let match: Array<string> | null;

    // XXX A URI string as defined by RFC 3986 does not contain any whitespace.
    // Usually, a browser will have already encoded any whitespace. In order to
    // avoid potential later problems related to whitespace in URI, strip any
    // whitespace. Anyway, the Jitsi Meet app is not known to utilize unencoded
    // whitespace so the stripping is deemed safe.
    str = str.replace(/\s/g, '');

    // protocol
    regex = new RegExp(URI_PROTOCOL_PATTERN, 'gi');
    match = regex.exec(str);
    if (match) {
        obj.protocol = match[1].toLowerCase();
        str = str.substring(regex.lastIndex);
    }

    // authority
    regex = new RegExp(`^${_URI_AUTHORITY_PATTERN}`, 'gi');
    match = regex.exec(str);
    if (match) {
        let authority: string = match[1].substring(/* // */ 2);

        str = str.substring(regex.lastIndex);

        // userinfo
        const userinfoEndIndex = authority.indexOf('@');

        if (userinfoEndIndex !== -1) {
            authority = authority.substring(userinfoEndIndex + 1);
        }

        obj.host = authority;

        // port
        const portBeginIndex = authority.lastIndexOf(':');

        if (portBeginIndex !== -1) {
            obj.port = authority.substring(portBeginIndex + 1);
            authority = authority.substring(0, portBeginIndex);
        }

        // hostname
        obj.hostname = authority;
    }

    // pathname
    regex = new RegExp(`^${_URI_PATH_PATTERN}`, 'gi');
    match = regex.exec(str);

    let pathname: string | undefined;

    if (match) {
        pathname = match[1];
        str = str.substring(regex.lastIndex);
    }
    if (pathname) {
        pathname.startsWith('/') || (pathname = `/${pathname}`);
    } else {
        pathname = '/';
    }
    obj.pathname = pathname;

    // query
    if (str.startsWith('?')) {
        let hashBeginIndex = str.indexOf('#', 1);

        if (hashBeginIndex === -1) {
            hashBeginIndex = str.length;
        }
        obj.search = str.substring(0, hashBeginIndex);
        str = str.substring(hashBeginIndex);
    } else {
        obj.search = ''; // Google Chrome
    }

    // fragment
    obj.hash = str.startsWith('#') ? str : '';

    /* eslint-enable no-param-reassign */

    return obj;
}

/**
 * Parses a specific URI which (supposedly) references a Jitsi Meet resource
 * (location).
 *
 * @param {(string|undefined)} uri - The URI to parse which (supposedly)
 * references a Jitsi Meet resource (location).
 * @public
 * @returns {{
 *     contextRoot: string,
 *     hash: string,
 *     host: string,
 *     hostname: string,
 *     pathname: string,
 *     port: string,
 *     protocol: string,
 *     room: (string|undefined),
 *     search: string
 * }}
 */
export function parseURIString(uri?: string): any {
    if (typeof uri !== 'string') {
        return undefined;
    }

    const obj = parseStandardURIString(_fixURIStringScheme(uri));

    // XXX While the components/segments of pathname are URI encoded, Jitsi Meet
    // on the client and/or server sides still don't support certain characters.
    obj.pathname = obj.pathname.split('/').map((pathPart: any) => _fixPathPart(pathPart))
        .join('/');

    // Add the properties that are specific to a Jitsi Meet resource (location)
    // such as contextRoot, room:

    // contextRoot
    // @ts-ignore
    obj.contextRoot = getLocationContextRoot(obj);

    // The room (name) is the last component/segment of pathname.
    const { pathname } = obj;

    const contextRootEndIndex = pathname.lastIndexOf('/');

    obj.room = pathname.substring(contextRootEndIndex + 1) || undefined;

    if (contextRootEndIndex > 1) {
        // The part of the pathname from the beginning to the room name is the tenant.
        obj.tenant = pathname.substring(1, contextRootEndIndex);
    }

    return obj;
}

/**
 * Implements {@code href} and {@code toString} for the {@code Object} returned
 * by {@link #parseStandardURIString}.
 *
 * @param {Object} [thiz] - An {@code Object} returned by
 * {@code #parseStandardURIString} if any; otherwise, it is presumed that the
 * function is invoked on such an instance.
 * @returns {string}
 */
function _standardURIToString(thiz?: Object) {
    // @ts-ignore
    // eslint-disable-next-line @typescript-eslint/no-invalid-this
    const { hash, host, pathname, protocol, search } = thiz || this;
    let str = '';

    protocol && (str += protocol);

    // TODO userinfo

    host && (str += `//${host}`);
    str += pathname || '/';
    search && (str += search);
    hash && (str += hash);

    return str;
}

/**
 * Sometimes we receive strings that we don't know if already percent-encoded, or not, due to the
 * various sources we get URLs or room names. This function encapsulates the decoding in a safe way.
 *
 * @param {string} text - The text to decode.
 * @returns {string}
 */
export function safeDecodeURIComponent(text: string) {
    try {
        return decodeURIComponent(text);
    } catch (e) {
        // The text wasn't encoded.
    }

    return text;
}

/**
 * Attempts to return a {@code String} representation of a specific
 * {@code Object} which is supposed to represent a URL. Obviously, if a
 * {@code String} is specified, it is returned. If a {@code URL} is specified,
 * its {@code URL#href} is returned. Additionally, an {@code Object} similar to
 * the one accepted by the constructor of Web's ExternalAPI is supported on both
 * mobile/React Native and Web/React.
 *
 * @param {Object|string} obj - The URL to return a {@code String}
 * representation of.
 * @returns {string} - A {@code String} representation of the specified
 * {@code obj} which is supposed to represent a URL.
 */
export function toURLString(obj?: (Object | string)) {
    let str;

    switch (typeof obj) {
    case 'object':
        if (obj) {
            if (obj instanceof URL) {
                str = obj.href;
            } else {
                str = urlObjectToString(obj);
            }
        }
        break;

    case 'string':
        str = String(obj);
        break;
    }

    return str;
}

/**
 * Attempts to return a {@code String} representation of a specific
 * {@code Object} similar to the one accepted by the constructor
 * of Web's ExternalAPI.
 *
 * @param {Object} o - The URL to return a {@code String} representation of.
 * @returns {string} - A {@code String} representation of the specified
 * {@code Object}.
 */
export function urlObjectToString(o: { [key: string]: any; }): string | undefined {
    // First normalize the given url. It come as o.url or split into o.serverURL
    // and o.room.
    let tmp;

    if (o.serverURL && o.room) {
        tmp = new URL(o.room, o.serverURL).toString();
    } else if (o.room) {
        tmp = o.room;
    } else {
        tmp = o.url || '';
    }

    const url = parseStandardURIString(_fixURIStringScheme(tmp));

    // protocol
    if (!url.protocol) {
        let protocol: string | undefined = o.protocol || o.scheme;

        if (protocol) {
            // Protocol is supposed to be the scheme and the final ':'. Anyway,
            // do not make a fuss if the final ':' is not there.
            protocol.endsWith(':') || (protocol += ':');
            url.protocol = protocol;
        }
    }

    // authority & pathname
    let { pathname } = url;

    if (!url.host) {
        // Web's ExternalAPI domain
        //
        // It may be host/hostname and pathname with the latter denoting the
        // tenant.
        const domain: string | undefined = o.domain || o.host || o.hostname;

        if (domain) {
            const { host, hostname, pathname: contextRoot, port }
                = parseStandardURIString(

                    // XXX The value of domain in supposed to be host/hostname
                    // and, optionally, pathname. Make sure it is not taken for
                    // a pathname only.
                    _fixURIStringScheme(`${APP_LINK_SCHEME}//${domain}`));

            // authority
            if (host) {
                url.host = host;
                url.hostname = hostname;
                url.port = port;
            }

            // pathname
            pathname === '/' && contextRoot !== '/' && (pathname = contextRoot);
        }
    }

    // pathname

    // Web's ExternalAPI roomName
    const room = o.roomName || o.room;

    if (room
            && (url.pathname.endsWith('/')
                || !url.pathname.endsWith(`/${room}`))) {
        pathname.endsWith('/') || (pathname += '/');
        pathname += room;
    }

    url.pathname = pathname;

    // query/search

    // Web's ExternalAPI jwt and lang
    const { jwt, lang, release } = o;

    const search = new URLSearchParams(url.search);

    // TODO: once all available versions are updated to support the jwt in the hash, remove this
    if (jwt) {
        search.set('jwt', jwt);
    }

    const { defaultLanguage } = o.configOverwrite || {};

    if (lang || defaultLanguage) {
        search.set('lang', lang || defaultLanguage);
    }

    if (release) {
        search.set('release', release);
    }

    const searchString = search.toString();

    if (searchString) {
        url.search = `?${searchString}`;
    }

    // fragment/hash

    let { hash } = url;

    if (jwt) {
        if (hash.length) {
            hash = `${hash}&jwt=${JSON.stringify(jwt)}`;
        } else {
            hash = `#jwt=${JSON.stringify(jwt)}`;
        }
    }

    for (const urlPrefix of [ 'config', 'iceServers', 'interfaceConfig', 'devices', 'userInfo', 'appData' ]) {
        const urlParamsArray
            = _objectToURLParamsArray(
                o[`${urlPrefix}Overwrite`]
                    || o[urlPrefix]
                    || o[`${urlPrefix}Override`]);

        if (urlParamsArray.length) {
            let urlParamsString
                = `${urlPrefix}.${urlParamsArray.join(`&${urlPrefix}.`)}`;

            if (hash.length) {
                urlParamsString = `&${urlParamsString}`;
            } else {
                hash = '#';
            }
            hash += urlParamsString;
        }
    }

    url.hash = hash;

    return url.toString() || undefined;
}

/**
 * Adds hash params to URL.
 *
 * @param {URL} url - The URL.
 * @param {Object} hashParamsToAdd - A map with the parameters to be set.
 * @returns {URL} - The new URL.
 */
export function addHashParamsToURL(url: URL, hashParamsToAdd: Object = {}) {
    const params = parseURLParams(url);
    const urlParamsArray = _objectToURLParamsArray({
        ...params,
        ...hashParamsToAdd
    });

    if (urlParamsArray.length) {
        url.hash = `#${urlParamsArray.join('&')}`;
    }

    return url;
}

/**
 * Returns the decoded URI.
 *
 * @param {string} uri - The URI to decode.
 * @returns {string}
 */
export function getDecodedURI(uri: string) {
    return decodeURI(uri.replace(/^https?:\/\//i, ''));
}

/**
 * Adds new param to a url string. Checks whether to use '?' or '&' as a separator (checks for already existing params).
 *
 * @param {string} url - The url to modify.
 * @param {string} name - The param name to add.
 * @param {string} value - The value for the param.
 *
 * @returns {string} - The modified url.
 */
export function appendURLParam(url: string, name: string, value: string) {
    const newUrl = new URL(url);

    newUrl.searchParams.append(name, value);

    return newUrl.toString();
}

/**
 * Adds new hash param to a url string.
 * Checks whether to use '?' or '&' as a separator (checks for already existing params).
 *
 * @param {string} url - The url to modify.
 * @param {string} name - The param name to add.
 * @param {string} value - The value for the param.
 *
 * @returns {string} - The modified url.
 */
export function appendURLHashParam(url: string, name: string, value: string) {
    const newUrl = new URL(url);
    const dummyUrl = new URL('https://example.com');

    // Copy current hash-parameters without the '#' as search-parameters.
    dummyUrl.search = newUrl.hash.substring(1);

    // Set or update value with the searchParams-API.
    dummyUrl.searchParams.append(name, value);

    // Write back as hash parameters.
    newUrl.hash = dummyUrl.searchParams.toString();

    return newUrl.toString();
}

/**
 * Sanitizes the given URL so that it's safe to use. If it's unsafe, null is returned.
 *
 * @param {string|URL} url - The URL that needs to be sanitized.
 *
 * @returns {URL?} - The sanitized URL, or null otherwise.
 */
export function sanitizeUrl(url?: string | URL): URL | null {
    if (!url) {
        return null;
    }

    const urlStr = url.toString();
    const result = _sanitizeUrl(urlStr);

    if (result === 'about:blank') {
        return null;
    }

    return new URL(result);
}


################################################################################

## File: .\jitsi-meet\react\features\breakout-rooms\actions.ts

import i18next from 'i18next';
import { chunk, filter, shuffle } from 'lodash-es';

import { createBreakoutRoomsEvent } from '../analytics/AnalyticsEvents';
import { sendAnalytics } from '../analytics/functions';
import { IStore } from '../app/types';
import {
    conferenceLeft,
    conferenceWillLeave,
    createConference
} from '../base/conference/actions';
import { CONFERENCE_LEAVE_REASONS } from '../base/conference/constants';
import { getCurrentConference } from '../base/conference/functions';
import { setAudioMuted, setVideoMuted } from '../base/media/actions';
import { MEDIA_TYPE } from '../base/media/constants';
import { getRemoteParticipants } from '../base/participants/functions';
import { createDesiredLocalTracks } from '../base/tracks/actions';
import {
    getLocalTracks,
    isLocalTrackMuted
} from '../base/tracks/functions';
import { clearNotifications, showNotification } from '../notifications/actions';
import { NOTIFICATION_TIMEOUT_TYPE } from '../notifications/constants';

import { _RESET_BREAKOUT_ROOMS, _UPDATE_ROOM_COUNTER } from './actionTypes';
import { FEATURE_KEY } from './constants';
import {
    getBreakoutRooms,
    getMainRoom,
    getRoomByJid
} from './functions';
import logger from './logger';

/**
 * Action to create a breakout room.
 *
 * @param {string} name - Name / subject for the breakout room.
 * @returns {Function}
 */
export function createBreakoutRoom(name?: string) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        let { roomCounter } = state[FEATURE_KEY];
        const subject = name || i18next.t('breakoutRooms.defaultName', { index: ++roomCounter });

        sendAnalytics(createBreakoutRoomsEvent('create'));

        dispatch({
            type: _UPDATE_ROOM_COUNTER,
            roomCounter
        });

        getCurrentConference(state)?.getBreakoutRooms()
            ?.createBreakoutRoom(subject);
    };
}

/**
 * Action to close a room and send participants to the main room.
 *
 * @param {string} roomId - The id of the room to close.
 * @returns {Function}
 */
export function closeBreakoutRoom(roomId: string) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const rooms = getBreakoutRooms(getState);
        const room = rooms[roomId];
        const mainRoom = getMainRoom(getState);

        sendAnalytics(createBreakoutRoomsEvent('close'));

        if (room && mainRoom) {
            Object.values(room.participants).forEach(p => {
                dispatch(sendParticipantToRoom(p.jid, mainRoom.id));
            });
        }
    };
}

/**
 * Action to rename a breakout room.
 *
 * @param {string} breakoutRoomJid - The jid of the breakout room to rename.
 * @param {string} name - New name / subject for the breakout room.
 * @returns {Function}
 */
export function renameBreakoutRoom(breakoutRoomJid: string, name = '') {
    return (_dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const trimmedName = name.trim();

        if (trimmedName.length !== 0) {
            sendAnalytics(createBreakoutRoomsEvent('rename'));
            getCurrentConference(getState)?.getBreakoutRooms()
                ?.renameBreakoutRoom(breakoutRoomJid, trimmedName);
        }
    };
}

/**
 * Action to remove a breakout room.
 *
 * @param {string} breakoutRoomJid - The jid of the breakout room to remove.
 * @returns {Function}
 */
export function removeBreakoutRoom(breakoutRoomJid: string) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        sendAnalytics(createBreakoutRoomsEvent('remove'));
        const room = getRoomByJid(getState, breakoutRoomJid);

        if (!room) {
            logger.error('The room to remove was not found.');

            return;
        }

        if (Object.keys(room.participants).length > 0) {
            dispatch(closeBreakoutRoom(room.id));
        }
        getCurrentConference(getState)?.getBreakoutRooms()
            ?.removeBreakoutRoom(breakoutRoomJid);
    };
}

/**
 * Action to auto-assign the participants to breakout rooms.
 *
 * @returns {Function}
 */
export function autoAssignToBreakoutRooms() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const rooms = getBreakoutRooms(getState);
        const breakoutRooms = filter(rooms, room => !room.isMainRoom);

        if (breakoutRooms) {
            sendAnalytics(createBreakoutRoomsEvent('auto.assign'));
            const participantIds = Array.from(getRemoteParticipants(getState).keys());
            const length = Math.ceil(participantIds.length / breakoutRooms.length);

            chunk(shuffle(participantIds), length).forEach((group, index) =>
                group.forEach(participantId => {
                    dispatch(sendParticipantToRoom(participantId, breakoutRooms[index].id));
                })
            );
        }
    };
}

/**
 * Action to send a participant to a room.
 *
 * @param {string} participantId - The participant id.
 * @param {string} roomId - The room id.
 * @returns {Function}
 */
export function sendParticipantToRoom(participantId: string, roomId: string) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const rooms = getBreakoutRooms(getState);
        const room = rooms[roomId];

        if (!room) {
            logger.warn(`Invalid room: ${roomId}`);

            return;
        }

        // Get the full JID of the participant. We could be getting the endpoint ID or
        // a participant JID. We want to find the connection JID.
        const participantJid = _findParticipantJid(getState, participantId);

        if (!participantJid) {
            logger.warn(`Could not find participant ${participantId}`);

            return;
        }

        getCurrentConference(getState)?.getBreakoutRooms()
            ?.sendParticipantToRoom(participantJid, room.jid);
    };
}

/**
 * Action to move to a room.
 *
 * @param {string} roomId - The room id to move to. If omitted move to the main room.
 * @returns {Function}
 */
export function moveToRoom(roomId?: string) {
    return async (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const mainRoomId = getMainRoom(getState)?.id;
        let _roomId: string | undefined | String = roomId || mainRoomId;

        // Check if we got a full JID.
        if (_roomId && _roomId?.indexOf('@') !== -1) {
            const [ id, ...domainParts ] = _roomId.split('@');

            // On mobile we first store the room and the connection is created
            // later, so let's attach the domain to the room String object as
            // a little hack.

            // eslint-disable-next-line no-new-wrappers
            _roomId = new String(id);

            // @ts-ignore
            _roomId.domain = domainParts.join('@');
        }

        const roomIdStr = _roomId?.toString();
        const goToMainRoom = roomIdStr === mainRoomId;
        const rooms = getBreakoutRooms(getState);
        const targetRoom = rooms[roomIdStr ?? ''];

        if (!targetRoom) {
            logger.warn(`Unknown room: ${targetRoom}`);

            return;
        }

        dispatch({
            type: _RESET_BREAKOUT_ROOMS
        });

        if (navigator.product === 'ReactNative') {
            const conference = getCurrentConference(getState);
            const { audio, video } = getState()['features/base/media'];

            dispatch(conferenceWillLeave(conference));

            try {
                await conference?.leave(CONFERENCE_LEAVE_REASONS.SWITCH_ROOM);
            } catch (error) {
                logger.warn('JitsiConference.leave() rejected with:', error);

                dispatch(conferenceLeft(conference));
            }

            dispatch(clearNotifications());
            dispatch(createConference(_roomId));
            dispatch(setAudioMuted(audio.muted));
            dispatch(setVideoMuted(Boolean(video.muted)));
            dispatch(createDesiredLocalTracks());
        } else {
            const localTracks = getLocalTracks(getState()['features/base/tracks']);
            const isAudioMuted = isLocalTrackMuted(localTracks, MEDIA_TYPE.AUDIO);
            const isVideoMuted = isLocalTrackMuted(localTracks, MEDIA_TYPE.VIDEO);

            try {
                // all places we fire notifyConferenceLeft we pass the room name from APP.conference
                await APP.conference.leaveRoom(false /* doDisconnect */, CONFERENCE_LEAVE_REASONS.SWITCH_ROOM).then(
                    () => APP.API.notifyConferenceLeft(APP.conference.roomName));
            } catch (error) {
                logger.warn('APP.conference.leaveRoom() rejected with:', error);

                // TODO: revisit why we don't dispatch CONFERENCE_LEFT here.
            }

            APP.conference.joinRoom(_roomId, {
                startWithAudioMuted: isAudioMuted,
                startWithVideoMuted: isVideoMuted
            });
        }

        if (goToMainRoom) {
            dispatch(showNotification({
                titleKey: 'breakoutRooms.notifications.joinedTitle',
                descriptionKey: 'breakoutRooms.notifications.joinedMainRoom',
                concatText: true,
                maxLines: 2
            }, NOTIFICATION_TIMEOUT_TYPE.MEDIUM));
        } else {
            dispatch(showNotification({
                titleKey: 'breakoutRooms.notifications.joinedTitle',
                descriptionKey: 'breakoutRooms.notifications.joined',
                descriptionArguments: { name: targetRoom.name },
                concatText: true,
                maxLines: 2
            }, NOTIFICATION_TIMEOUT_TYPE.MEDIUM));
        }
    };
}

/**
 * Finds a participant's connection JID given its ID.
 *
 * @param {Function} getState - The redux store state getter.
 * @param {string} participantId - ID of the given participant.
 * @returns {string|undefined} - The participant connection JID if found.
 */
function _findParticipantJid(getState: IStore['getState'], participantId: string) {
    const conference = getCurrentConference(getState);

    if (!conference) {
        return;
    }

    // Get the full JID of the participant. We could be getting the endpoint ID or
    // a participant JID. We want to find the connection JID.
    let _participantId = participantId;
    let participantJid;

    if (!participantId.includes('@')) {
        const p = conference.getParticipantById(participantId);

        _participantId = p?.getJid(); // This will be the room JID.
    }

    if (_participantId) {
        const rooms = getBreakoutRooms(getState);

        for (const room of Object.values(rooms)) {
            const participants = room.participants || {};
            const p = participants[_participantId]
                || Object.values(participants).find(item => item.jid === _participantId);

            if (p) {
                participantJid = p.jid;
                break;
            }
        }
    }

    return participantJid;
}


################################################################################

## File: .\jitsi-meet\react\features\breakout-rooms\actionTypes.ts

/**
 * The type of (redux) action to reset the breakout rooms data.
 */
export const _RESET_BREAKOUT_ROOMS = '_RESET_BREAKOUT_ROOMS';

/**
 * The type of (redux) action to update the room counter locally.
 */
export const _UPDATE_ROOM_COUNTER = '_UPDATE_ROOM_COUNTER';

/**
  * The type of (redux) action to update the breakout room data.
  *
  */
export const UPDATE_BREAKOUT_ROOMS = 'UPDATE_BREAKOUT_ROOMS';


################################################################################

## File: .\jitsi-meet\react\features\breakout-rooms\constants.ts

/**
 * Key for this feature.
 */
export const FEATURE_KEY = 'features/breakout-rooms';

/**
 * Feature to rename breakout rooms.
 */
export const BREAKOUT_ROOMS_RENAME_FEATURE = 'rename';


################################################################################

## File: .\jitsi-meet\react\features\breakout-rooms\functions.ts

import { find } from 'lodash-es';

import { IStateful } from '../base/app/types';
import { getCurrentConference } from '../base/conference/functions';
import {
    getLocalParticipant,
    getParticipantById,
    getParticipantCount,
    isLocalParticipantModerator
} from '../base/participants/functions';
import { IJitsiParticipant } from '../base/participants/types';
import { toState } from '../base/redux/functions';

import { FEATURE_KEY } from './constants';
import { IRoom, IRoomInfo, IRoomInfoParticipant, IRooms, IRoomsInfo } from './types';

/**
 * Returns the rooms object for breakout rooms.
 *
 * @param {IStateful} stateful - The redux store, the redux
 * {@code getState} function, or the redux state itself.
 * @returns {Object} Object of rooms.
 */
export const getBreakoutRooms = (stateful: IStateful): IRooms => toState(stateful)[FEATURE_KEY].rooms;

/**
 * Returns the main room.
 *
 * @param {IStateful} stateful - The redux store, the redux
 * {@code getState} function, or the redux state itself.
 * @returns {IRoom|undefined} The main room object, or undefined.
 */
export const getMainRoom = (stateful: IStateful) => {
    const rooms = getBreakoutRooms(stateful);

    return find(rooms, room => Boolean(room.isMainRoom));
};

/**
 * Returns the rooms info.
 *
 * @param {IStateful} stateful - The redux store, the redux.

* @returns {IRoomsInfo} The rooms info.
 */
export const getRoomsInfo = (stateful: IStateful) => {
    const breakoutRooms = getBreakoutRooms(stateful);
    const conference = getCurrentConference(stateful);

    const initialRoomsInfo = {
        rooms: []
    };

    // only main roomn
    if (!breakoutRooms || Object.keys(breakoutRooms).length === 0) {
        // filter out hidden participants
        const conferenceParticipants = conference?.getParticipants()
            .filter((participant: IJitsiParticipant) => !participant.isHidden());

        const localParticipant = getLocalParticipant(stateful);
        let localParticipantInfo;

        if (localParticipant) {
            localParticipantInfo = {
                role: localParticipant.role,
                displayName: localParticipant.name,
                avatarUrl: localParticipant.loadableAvatarUrl,
                id: localParticipant.id
            };
        }

        return {
            ...initialRoomsInfo,
            rooms: [ {
                isMainRoom: true,
                id: conference?.room?.roomjid,
                jid: conference?.room?.myroomjid,
                participants: conferenceParticipants?.length > 0
                    ? [
                        localParticipantInfo,
                        ...conferenceParticipants.map((participantItem: IJitsiParticipant) => {
                            const storeParticipant = getParticipantById(stateful, participantItem.getId());

                            return {
                                jid: participantItem.getJid(),
                                role: participantItem.getRole(),
                                displayName: participantItem.getDisplayName(),
                                avatarUrl: storeParticipant?.loadableAvatarUrl,
                                id: participantItem.getId()
                            } as IRoomInfoParticipant;
                        }) ]
                    : [ localParticipantInfo ]
            } as IRoomInfo ]
        } as IRoomsInfo;
    }

    return {
        ...initialRoomsInfo,
        rooms: Object.keys(breakoutRooms).map(breakoutRoomKey => {
            const breakoutRoomItem = breakoutRooms[breakoutRoomKey];

            return {
                isMainRoom: Boolean(breakoutRoomItem.isMainRoom),
                id: breakoutRoomItem.id,
                jid: breakoutRoomItem.jid,
                participants: breakoutRoomItem.participants && Object.keys(breakoutRoomItem.participants).length
                    ? Object.keys(breakoutRoomItem.participants).map(participantLongId => {
                        const participantItem = breakoutRoomItem.participants[participantLongId];
                        const ids = participantLongId.split('/');
                        const storeParticipant = getParticipantById(stateful,
                            ids.length > 1 ? ids[1] : participantItem.jid);

                        return {
                            jid: participantItem?.jid,
                            role: participantItem?.role,
                            displayName: participantItem?.displayName,
                            avatarUrl: storeParticipant?.loadableAvatarUrl,
                            id: storeParticipant ? storeParticipant.id
                                : participantLongId
                        } as IRoomInfoParticipant;
                    }) : []
            } as IRoomInfo;
        })
    } as IRoomsInfo;
};

/**
 * Returns the room by Jid.
 *
 * @param {IStateful} stateful - The redux store, the redux
 * {@code getState} function, or the redux state itself.
 * @param {string} roomJid - The jid of the room.
 * @returns {IRoom|undefined} The main room object, or undefined.
 */
export const getRoomByJid = (stateful: IStateful, roomJid: string) => {
    const rooms = getBreakoutRooms(stateful);

    return find(rooms, (room: IRoom) => room.jid === roomJid);
};

/**
 * Returns the id of the current room.
 *
 * @param {IStateful} stateful - The redux store, the redux
 * {@code getState} function, or the redux state itself.
 * @returns {string} Room id or undefined.
 */
export const getCurrentRoomId = (stateful: IStateful) => {
    const conference = getCurrentConference(stateful);

    return conference?.getName();
};

/**
 * Determines whether the local participant is in a breakout room.
 *
 * @param {IStateful} stateful - The redux store, the redux
 * {@code getState} function, or the redux state itself.
 * @returns {boolean}
 */
export const isInBreakoutRoom = (stateful: IStateful) => {
    const conference = getCurrentConference(stateful);

    return conference?.getBreakoutRooms()?.isBreakoutRoom();
};

/**
 * Returns the breakout rooms config.
 *
 * @param {IStateful} stateful - The redux store, the redux
 * {@code getState} function, or the redux state itself.
 * @returns {Object}
 */
export const getBreakoutRoomsConfig = (stateful: IStateful) => {
    const state = toState(stateful);
    const { breakoutRooms = {} } = state['features/base/config'];

    return breakoutRooms;
};

/**
 * Returns whether the add breakout room button is visible.
 *
 * @param {IStateful} stateful - Global state.
 * @returns {boolean}
 */
export const isAddBreakoutRoomButtonVisible = (stateful: IStateful) => {
    const state = toState(stateful);
    const isLocalModerator = isLocalParticipantModerator(state);
    const { conference } = state['features/base/conference'];
    const isBreakoutRoomsSupported = conference?.getBreakoutRooms()?.isSupported();
    const { hideAddRoomButton } = getBreakoutRoomsConfig(state);

    return isLocalModerator && isBreakoutRoomsSupported && !hideAddRoomButton;
};

/**
 * Returns whether the auto assign participants to breakout rooms button is visible.
 *
 * @param {IStateful} stateful - Global state.
 * @returns {boolean}
 */
export const isAutoAssignParticipantsVisible = (stateful: IStateful) => {
    const state = toState(stateful);
    const rooms = getBreakoutRooms(state);
    const inBreakoutRoom = isInBreakoutRoom(state);
    const isLocalModerator = isLocalParticipantModerator(state);
    const participantsCount = getParticipantCount(state);
    const { hideAutoAssignButton } = getBreakoutRoomsConfig(state);

    return !inBreakoutRoom
        && isLocalModerator
        && participantsCount > 2
        && Object.keys(rooms).length > 1
        && !hideAutoAssignButton;
};


################################################################################

## File: .\jitsi-meet\react\features\breakout-rooms\logger.ts

import { getLogger } from '../base/logging/functions';

import { FEATURE_KEY } from './constants';

export default getLogger(FEATURE_KEY);


################################################################################

## File: .\jitsi-meet\react\features\breakout-rooms\middleware.ts

import { JitsiConferenceEvents } from '../base/lib-jitsi-meet';
import { getParticipantById } from '../base/participants/functions';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import StateListenerRegistry from '../base/redux/StateListenerRegistry';
import { editMessage } from '../chat/actions.any';
import { MESSAGE_TYPE_REMOTE } from '../chat/constants';

import { UPDATE_BREAKOUT_ROOMS } from './actionTypes';
import { moveToRoom } from './actions';
import logger from './logger';
import { IRooms } from './types';

/**
 * Registers a change handler for state['features/base/conference'].conference to
 * set the event listeners needed for the breakout rooms feature to operate.
 */
StateListenerRegistry.register(
    state => state['features/base/conference'].conference,
    (conference, { dispatch }, previousConference) => {
        if (conference && !previousConference) {
            conference.on(JitsiConferenceEvents.BREAKOUT_ROOMS_MOVE_TO_ROOM, (roomId: string) => {
                logger.debug(`Moving to room: ${roomId}`);
                dispatch(moveToRoom(roomId));
            });

            conference.on(JitsiConferenceEvents.BREAKOUT_ROOMS_UPDATED, ({ rooms, roomCounter }: {
                roomCounter: number; rooms: IRooms;
            }) => {
                logger.debug('Room list updated');
                if (typeof APP !== 'undefined') {
                    APP.API.notifyBreakoutRoomsUpdated(rooms);
                }
                dispatch({
                    type: UPDATE_BREAKOUT_ROOMS,
                    rooms,
                    roomCounter
                });
            });
        }
    });

MiddlewareRegistry.register(({ dispatch, getState }) => next => action => {
    const { type } = action;

    switch (type) {
    case UPDATE_BREAKOUT_ROOMS: {
        // edit name if it was overwritten
        if (!action.updatedNames) {
            const { overwrittenNameList } = getState()['features/base/participants'];

            if (Object.keys(overwrittenNameList).length > 0) {
                const newRooms: IRooms = {};

                Object.entries(action.rooms as IRooms).forEach(([ key, r ]) => {
                    let participants = r?.participants || {};
                    let jid;

                    for (const id of Object.keys(overwrittenNameList)) {
                        jid = Object.keys(participants).find(p => p.slice(p.indexOf('/') + 1) === id);

                        if (jid) {
                            participants = {
                                ...participants,
                                [jid]: {
                                    ...participants[jid],
                                    displayName: overwrittenNameList[id as keyof typeof overwrittenNameList]
                                }
                            };
                        }
                    }

                    newRooms[key] = {
                        ...r,
                        participants
                    };
                });

                action.rooms = newRooms;
            }
        }

        // edit the chat history to match names for participants in breakout rooms
        const { messages } = getState()['features/chat'];

        messages?.forEach(m => {
            if (m.messageType === MESSAGE_TYPE_REMOTE && !getParticipantById(getState(), m.participantId)) {
                const rooms: IRooms = action.rooms;

                for (const room of Object.values(rooms)) {
                    const participants = room.participants || {};
                    const matchedJid = Object.keys(participants).find(jid => jid.endsWith(m.participantId));

                    if (matchedJid) {
                        m.displayName = participants[matchedJid].displayName;

                        dispatch(editMessage(m));
                    }
                }
            }
        });

        break;
    }
    }

    return next(action);
});


################################################################################

## File: .\jitsi-meet\react\features\breakout-rooms\reducer.ts

import ReducerRegistry from '../base/redux/ReducerRegistry';

import {
    UPDATE_BREAKOUT_ROOMS,
    _RESET_BREAKOUT_ROOMS,
    _UPDATE_ROOM_COUNTER
} from './actionTypes';
import { FEATURE_KEY } from './constants';
import { IRooms } from './types';

const DEFAULT_STATE = {
    rooms: {},
    roomCounter: 0
};

export interface IBreakoutRoomsState {
    roomCounter: number;
    rooms: IRooms;
}

/**
 * Listen for actions for the breakout-rooms feature.
 */
ReducerRegistry.register<IBreakoutRoomsState>(FEATURE_KEY, (state = DEFAULT_STATE, action): IBreakoutRoomsState => {
    switch (action.type) {
    case _UPDATE_ROOM_COUNTER:
        return {
            ...state,
            roomCounter: action.roomCounter
        };
    case UPDATE_BREAKOUT_ROOMS: {
        const { roomCounter, rooms } = action;

        return {
            ...state,
            roomCounter,
            rooms
        };
    }
    case _RESET_BREAKOUT_ROOMS: {
        return DEFAULT_STATE;
    }
    }

    return state;
});


################################################################################

## File: .\jitsi-meet\react\features\breakout-rooms\types.ts

export interface IRoom {
    id: string;
    isMainRoom?: boolean;
    jid: string;
    name: string;
    participants: {
        [jid: string]: {
            displayName: string;
            jid: string;
            role: string;
        };
    };
}

export interface IRooms {
    [jid: string]: IRoom;
}

export interface IRoomInfo {
    id: string;
    isMainRoom: boolean;
    jid: string;
    participants: IRoomInfoParticipant[];
}

export interface IRoomsInfo {
    rooms: IRoomInfo[];
}

export interface IRoomInfoParticipant {
    avatarUrl: string;
    displayName: string;
    id: string;
    jid: string;
    role: string;
}


################################################################################

## File: .\jitsi-meet\react\features\breakout-rooms\components\native\styles.ts

import BaseTheme from '../../../base/ui/components/BaseTheme.native';


/**
 * The styles of the native components of the feature {@code breakout rooms}.
 */
export default {

    button: {
        marginBottom: BaseTheme.spacing[4],
        marginHorizontal: BaseTheme.spacing[2]
    },

    collapsibleList: {
        alignItems: 'center',
        borderRadius: BaseTheme.shape.borderRadius,
        display: 'flex',
        flexDirection: 'row',
        height: BaseTheme.spacing[7],
        marginHorizontal: BaseTheme.spacing[2],
        marginTop: BaseTheme.spacing[3]
    },

    arrowIcon: {
        backgroundColor: BaseTheme.palette.ui03,
        height: BaseTheme.spacing[5],
        width: BaseTheme.spacing[5],
        borderRadius: 6,
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center'
    },

    roomName: {
        fontSize: 15,
        color: BaseTheme.palette.text01,
        fontWeight: 'bold',
        marginLeft: BaseTheme.spacing[2]
    },

    listTile: {
        fontSize: 15,
        color: BaseTheme.palette.text01,
        fontWeight: 'bold',
        marginLeft: BaseTheme.spacing[2]
    },

    autoAssignLabel: {
        color: BaseTheme.palette.link01
    },

    autoAssignButton: {
        alignSelf: 'center',
        justifyContent: 'center',
        marginTop: BaseTheme.spacing[3]
    },

    breakoutRoomsContainer: {
        backgroundColor: BaseTheme.palette.ui01,
        flex: 1,
        flexDirection: 'column',
        height: 'auto',
        paddingHorizontal: BaseTheme.spacing[3]
    },

    inputContainer: {
        marginLeft: BaseTheme.spacing[2],
        marginRight: BaseTheme.spacing[2],
        marginTop: BaseTheme.spacing[4]
    },

    centerInput: {
        paddingRight: BaseTheme.spacing[3],
        textAlign: 'center'
    }
};


################################################################################

## File: .\jitsi-meet\react\features\calendar-sync\actions.any.ts

import {
    REFRESH_CALENDAR,
    SET_CALENDAR_AUTHORIZATION,
    SET_CALENDAR_EVENTS
} from './actionTypes';

/**
 * Sends an action to refresh the entry list (fetches new data).
 *
 * @param {boolean} forcePermission - Whether to force to re-ask for
 * the permission or not.
 * @param {boolean} isInteractive - If true this refresh was caused by
 * direct user interaction, false otherwise.
 * @returns {{
 *     type: REFRESH_CALENDAR,
 *     forcePermission: boolean,
 *     isInteractive: boolean
 * }}
 */
export function refreshCalendar(forcePermission = false, isInteractive = true) {
    return {
        type: REFRESH_CALENDAR,
        forcePermission,
        isInteractive
    };
}

/**
 * Sends an action to signal that a calendar access has been requested. For more
 * info, see {@link SET_CALENDAR_AUTHORIZATION}.
 *
 * @param {string | undefined} authorization - The result of the last calendar
 * authorization request.
 * @returns {{
 *     type: SET_CALENDAR_AUTHORIZATION,
 *     authorization: ?string
 * }}
 */
export function setCalendarAuthorization(authorization?: string) {
    return {
        type: SET_CALENDAR_AUTHORIZATION,
        authorization
    };
}

/**
 * Sends an action to update the current calendar list in redux.
 *
 * @param {Array<Object>} events - The new list.
 * @returns {{
 *     type: SET_CALENDAR_EVENTS,
 *     events: Array<Object>
 * }}
 */
export function setCalendarEvents(events: Array<Object>) {
    return {
        type: SET_CALENDAR_EVENTS,
        events
    };
}


################################################################################

## File: .\jitsi-meet\react\features\calendar-sync\actions.native.ts

// @ts-expect-error
import { generateRoomWithoutSeparator } from '@jitsi/js-utils/random';

import { getDefaultURL } from '../app/functions';
import { IStore } from '../app/types';
import { openDialog } from '../base/dialog/actions';

import { refreshCalendar } from './actions';
import UpdateCalendarEventDialog from './components/UpdateCalendarEventDialog.native';
import { addLinkToCalendarEntry } from './functions.native';

export * from './actions.any';

/**
 * Asks confirmation from the user to add a Jitsi link to the calendar event.
 *
 * @param {string} eventId - The event id.
 * @returns {{
 *     type: OPEN_DIALOG,
 *     component: React.Component,
 *     componentProps: (Object | undefined)
 * }}
 */
export function openUpdateCalendarEventDialog(eventId: string) {
    return openDialog(UpdateCalendarEventDialog, { eventId });
}

/**
 * Updates calendar event by generating new invite URL and editing the event
 * adding some descriptive text and location.
 *
 * @param {string} eventId - The event id.
 * @returns {Function}
 */
export function updateCalendarEvent(eventId: string) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const defaultUrl = getDefaultURL(getState);
        const roomName = generateRoomWithoutSeparator();

        addLinkToCalendarEntry(getState(), eventId, `${defaultUrl}/${roomName}`)
        .finally(() => {
            dispatch(refreshCalendar(false, false));
        });
    };
}


################################################################################

## File: .\jitsi-meet\react\features\calendar-sync\actions.web.ts

// @ts-expect-error
import { generateRoomWithoutSeparator } from '@jitsi/js-utils/random';

import { createCalendarConnectedEvent } from '../analytics/AnalyticsEvents';
import { sendAnalytics } from '../analytics/functions';
import { IStore } from '../app/types';
import { loadGoogleAPI } from '../google-api/actions';

import {
    CLEAR_CALENDAR_INTEGRATION,
    SET_CALENDAR_AUTH_STATE,
    SET_CALENDAR_ERROR,
    SET_CALENDAR_INTEGRATION,
    SET_CALENDAR_PROFILE_EMAIL,
    SET_LOADING_CALENDAR_EVENTS
} from './actionTypes';
import { refreshCalendar, setCalendarEvents } from './actions.web';
import { _getCalendarIntegration, isCalendarEnabled } from './functions.web';
import logger from './logger';

export * from './actions.any';

/**
 * Sets the initial state of calendar integration by loading third party APIs
 * and filling out any data that needs to be fetched.
 *
 * @returns {Function}
 */
export function bootstrapCalendarIntegration() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();

        if (!isCalendarEnabled(state)) {
            return Promise.reject();
        }

        const {
            googleApiApplicationClientID
        } = state['features/base/config'];
        const {
            integrationReady,
            integrationType
        } = state['features/calendar-sync'];

        return Promise.resolve()
            .then(() => {
                if (googleApiApplicationClientID) {
                    return dispatch(loadGoogleAPI());
                }
            })
            .then(() => {
                if (!integrationType || integrationReady) {
                    return;
                }

                const integrationToLoad
                    = _getCalendarIntegration(integrationType);

                if (!integrationToLoad) {
                    dispatch(clearCalendarIntegration());

                    return;
                }

                return dispatch(integrationToLoad._isSignedIn())
                    .then((signedIn: boolean) => {
                        if (signedIn) {
                            dispatch(setIntegrationReady(integrationType));
                            dispatch(updateProfile(integrationType));
                        } else {
                            dispatch(clearCalendarIntegration());
                        }
                    });
            });
    };
}

/**
 * Resets the state of calendar integration so stored events and selected
 * calendar type are cleared.
 *
 * @returns {{
 *     type: CLEAR_CALENDAR_INTEGRATION
 * }}
 */
export function clearCalendarIntegration() {
    return {
        type: CLEAR_CALENDAR_INTEGRATION
    };
}

/**
 * Asks confirmation from the user to add a Jitsi link to the calendar event.
 *
 * NOTE: Currently there is no confirmation prompted on web, so this is just
 * a relaying method to avoid flow problems.
 *
 * @param {string} eventId - The event id.
 * @param {string} calendarId - The calendar id.
 * @returns {Function}
 */
export function openUpdateCalendarEventDialog(
        eventId: string, calendarId: string) {
    return updateCalendarEvent(eventId, calendarId);
}

/**
 * Sends an action to update the current calendar api auth state in redux.
 * This is used only for microsoft implementation to store it auth state.
 *
 * @param {number} newState - The new state.
 * @returns {{
 *     type: SET_CALENDAR_AUTH_STATE,
 *     msAuthState: Object
 * }}
 */
export function setCalendarAPIAuthState(newState?: Object) {
    return {
        type: SET_CALENDAR_AUTH_STATE,
        msAuthState: newState
    };
}

/**
 * Sends an action to update the calendar error state in redux.
 *
 * @param {Object} error - An object with error details.
 * @returns {{
 *     type: SET_CALENDAR_ERROR,
 *     error: Object
 * }}
 */
export function setCalendarError(error?: Object) {
    return {
        type: SET_CALENDAR_ERROR,
        error
    };
}

/**
 * Sends an action to update the current calendar profile email state in redux.
 *
 * @param {number} newEmail - The new email.
 * @returns {{
 *     type: SET_CALENDAR_PROFILE_EMAIL,
 *     email: string
 * }}
 */
export function setCalendarProfileEmail(newEmail?: string) {
    return {
        type: SET_CALENDAR_PROFILE_EMAIL,
        email: newEmail
    };
}

/**
 * Sends an to denote a request in is flight to get calendar events.
 *
 * @param {boolean} isLoadingEvents - Whether or not calendar events are being
 * fetched.
 * @returns {{
 *     type: SET_LOADING_CALENDAR_EVENTS,
 *     isLoadingEvents: boolean
 * }}
 */
export function setLoadingCalendarEvents(isLoadingEvents: boolean) {
    return {
        type: SET_LOADING_CALENDAR_EVENTS,
        isLoadingEvents
    };
}

/**
 * Sets the calendar integration type to be used by web and signals that the
 * integration is ready to be used.
 *
 * @param {string|undefined} integrationType - The calendar type.
 * @returns {{
 *      type: SET_CALENDAR_INTEGRATION,
 *      integrationReady: boolean,
 *      integrationType: string
 * }}
 */
export function setIntegrationReady(integrationType: string) {
    return {
        type: SET_CALENDAR_INTEGRATION,
        integrationReady: true,
        integrationType
    };
}

/**
 * Signals signing in to the specified calendar integration.
 *
 * @param {string} calendarType - The calendar integration which should be
 * signed into.
 * @returns {Function}
 */
export function signIn(calendarType: string) {
    return (dispatch: IStore['dispatch']) => {
        const integration = _getCalendarIntegration(calendarType);

        if (!integration) {
            return Promise.reject('No supported integration found');
        }

        return dispatch(integration.load())
            .then(() => dispatch(integration.signIn()))
            .then(() => dispatch(setIntegrationReady(calendarType)))
            .then(() => dispatch(updateProfile(calendarType)))
            .then(() => dispatch(refreshCalendar()))
            .then(() => sendAnalytics(createCalendarConnectedEvent()))
            .catch((error: any) => {
                logger.error(
                    'Error occurred while signing into calendar integration',
                    error);

                return Promise.reject(error);
            });
    };
}

/**
 * Updates calendar event by generating new invite URL and editing the event
 * adding some descriptive text and location.
 *
 * @param {string} id - The event id.
 * @param {string} calendarId - The id of the calendar to use.
 * @returns {Function}
 */
export function updateCalendarEvent(id: string, calendarId: string) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {

        const { integrationType = '' } = getState()['features/calendar-sync'];
        const integration = _getCalendarIntegration(integrationType);

        if (!integration) {
            return Promise.reject('No integration found');
        }

        const { locationURL } = getState()['features/base/connection'];
        const newRoomName = generateRoomWithoutSeparator();
        let href = locationURL?.href ?? '';

        href.endsWith('/') || (href += '/');

        const roomURL = `${href}${newRoomName}`;

        return dispatch(integration.updateCalendarEvent(
                id, calendarId, roomURL))
            .then(() => {
                // make a copy of the array
                const events
                    = getState()['features/calendar-sync'].events.slice(0);

                const eventIx = events.findIndex(
                    e => e.id === id && e.calendarId === calendarId);

                // clone the event we will modify
                const newEvent = Object.assign({}, events[eventIx]);

                newEvent.url = roomURL;
                events[eventIx] = newEvent;

                return dispatch(setCalendarEvents(events));
            });
    };
}

/**
 * Signals to get current profile data linked to the current calendar
 * integration that is in use.
 *
 * @param {string} calendarType - The calendar integration to which the profile
 * should be updated.
 * @returns {Function}
 */
export function updateProfile(calendarType: string) {
    return (dispatch: IStore['dispatch']) => {
        const integration = _getCalendarIntegration(calendarType);

        if (!integration) {
            return Promise.reject('No integration found');
        }

        // @ts-ignore
        return dispatch(integration.getCurrentEmail())
            .then((email: string) => {
                dispatch(setCalendarProfileEmail(email));
            });
    };
}


################################################################################

## File: .\jitsi-meet\react\features\calendar-sync\actionTypes.ts

/**
 * Resets the state of calendar integration so stored events and selected
 * calendar type are cleared.
 *
 * {
 *     type: CLEAR_CALENDAR_INTEGRATION
 * }
 */
export const CLEAR_CALENDAR_INTEGRATION = 'CLEAR_CALENDAR_INTEGRATION';

/**
 * Action to refresh (re-fetch) the entry list.
 *
 * {
 *     type: REFRESH_CALENDAR,
 *     forcePermission: boolean,
 *     isInteractive: boolean
 * }
 */
export const REFRESH_CALENDAR = 'REFRESH_CALENDAR';

/**
 * Action to signal that calendar access has already been requested since the
 * app started, so no new request should be done unless the user explicitly
 * tries to refresh the calendar view.
 *
 * {
 *     type: SET_CALENDAR_AUTHORIZATION,
 *     authorization: ?string
 * }
 */
export const SET_CALENDAR_AUTHORIZATION = 'SET_CALENDAR_AUTHORIZATION';

/**
 * Action to update the last error that occurred while trying to authenticate
 * with or fetch data from the calendar integration.
 *
 * {
 *     type: SET_CALENDAR_ERROR,
 *     error: ?Object
 * }
 */
export const SET_CALENDAR_ERROR = 'SET_CALENDAR_ERROR';

/**
 * Action to update the current calendar entry list in the store.
 *
 * {
 *     type: SET_CALENDAR_EVENTS,
 *     events: Array<Object>
 * }
 */
export const SET_CALENDAR_EVENTS = 'SET_CALENDAR_EVENTS';

/**
 * Action to update calendar type to be used for web.
 *
 * {
 *     type: SET_CALENDAR_INTEGRATION,
 *     integrationReady: boolean,
 *     integrationType: string
 * }
 */
export const SET_CALENDAR_INTEGRATION = 'SET_CALENDAR_INTEGRATION';

/**
 * The type of Redux action which changes Calendar API auth state.
 *
 * {
 *     type: SET_CALENDAR_AUTH_STATE
 * }
 * @public
 */
export const SET_CALENDAR_AUTH_STATE = 'SET_CALENDAR_AUTH_STATE';

/**
 * The type of Redux action which changes Calendar Profile email state.
 *
 * {
 *     type: SET_CALENDAR_PROFILE_EMAIL,
 *     email: string
 * }
 * @public
 */
export const SET_CALENDAR_PROFILE_EMAIL = 'SET_CALENDAR_PROFILE_EMAIL';

/**
 * The type of Redux action which denotes whether a request is in flight to get
 * updated calendar events.
 *
 * {
 *     type: SET_LOADING_CALENDAR_EVENTS,
 *     isLoadingEvents: string
 * }
 * @public
 */
export const SET_LOADING_CALENDAR_EVENTS
    = 'SET_LOADING_CALENDAR_EVENTS';


################################################################################

## File: .\jitsi-meet\react\features\calendar-sync\constants.ts

/**
 * An enumeration of support calendar integration types.
 *
 * @enum {string}
 */
export const CALENDAR_TYPE = {
    GOOGLE: 'google',
    MICROSOFT: 'microsoft'
};

/**
 * An enumeration of known errors that can occur while interacting with the
 * calendar integration.
 *
 * @enum {string}
 */
export const ERRORS = {
    AUTH_FAILED: 'sign_in_failed',
    GOOGLE_APP_MISCONFIGURED: 'idpiframe_initialization_failed'
};

/**
 * The number of days to fetch.
 */
export const FETCH_END_DAYS = 10;

/**
 * The number of days to go back when fetching.
 */
export const FETCH_START_DAYS = -1;

/**
 * The max number of events to fetch from the calendar.
 */
export const MAX_LIST_LENGTH = 10;


################################################################################

## File: .\jitsi-meet\react\features\calendar-sync\functions.any.ts

import md5 from 'js-md5';

import { APP_LINK_SCHEME, parseURIString } from '../base/util/uri';

import { setCalendarEvents } from './actions';
import { MAX_LIST_LENGTH } from './constants';

const ALLDAY_EVENT_LENGTH = 23 * 60 * 60 * 1000;

/**
 * Returns true of the calendar entry is to be displayed in the app, false
 * otherwise.
 *
 * @param {Object} entry - The calendar entry.
 * @returns {boolean}
 */
function _isDisplayableCalendarEntry(entry: { allDay: boolean; attendees: Object[];
    endDate: number; startDate: number; }) {
    // Entries are displayable if:
    //   - Ends in the future (future or ongoing events)
    //   - Is not an all day event and there is only one attendee (these events
    //     are usually placeholder events that don't need to be shown.)
    return entry.endDate > Date.now()
        && !((entry.allDay
                || entry.endDate - entry.startDate > ALLDAY_EVENT_LENGTH)
                    && (!entry.attendees || entry.attendees.length < 2));
}

/**
 * Updates the calendar entries in redux when new list is received. The feature
 * calendar-sync doesn't display all calendar events, it displays unique
 * title, URL, and start time tuples, and it doesn't display subsequent
 * occurrences of recurring events, and the repetitions of events coming from
 * multiple calendars.
 *
 * XXX The function's {@code this} is the redux store.
 *
 * @param {Array<CalendarEntry>} events - The new event list.
 * @private
 * @returns {void}
 */
export function _updateCalendarEntries(events: Array<Object>) {
    if (!events?.length) {
        return;
    }

    // @ts-ignore
    // eslint-disable-next-line @typescript-eslint/no-invalid-this
    const { dispatch, getState } = this;
    const knownDomains = getState()['features/base/known-domains'];
    const entryMap = new Map();

    for (const event of events) {
        const entry = _parseCalendarEntry(event, knownDomains);

        if (entry && _isDisplayableCalendarEntry(entry)) {
            // As was stated above, we don't display subsequent occurrences of
            // recurring events, and the repetitions of events coming from
            // multiple calendars.
            const key = md5.hex(JSON.stringify([

                // Obviously, we want to display different conference/meetings
                // URLs. URLs are the very reason why we implemented the feature
                // calendar-sync in the first place.
                entry.url,

                // We probably want to display one and the same URL to people if
                // they have it under different titles in their Calendar.
                // Because maybe they remember the title of the meeting, not the
                // URL so they expect to see the title without realizing that
                // they have the same URL already under a different title.
                entry.title,

                // XXX Eventually, given that the URL and the title are the
                // same, what sets one event apart from another is the start
                // time of the day (note the use of toTimeString() below)! The
                // day itself is not important because we don't want multiple
                // occurrences of a recurring event or repetitions of an even
                // from multiple calendars.
                new Date(entry.startDate).toTimeString()
            ]));
            const existingEntry = entryMap.get(key);

            // We want only the earliest occurrence (which hasn't ended in the
            // past, that is) of a recurring event.
            if (!existingEntry || existingEntry.startDate > entry.startDate) {
                entryMap.set(key, entry);
            }
        }
    }

    dispatch(
        setCalendarEvents(
            Array.from(entryMap.values())
                .sort((a, b) => a.startDate - b.startDate)
                .slice(0, MAX_LIST_LENGTH)));
}

/**
 * Checks a string against a positive pattern and a negative pattern. Returns
 * the string if it matches the positive pattern and doesn't provide any match
 * against the negative pattern. Null otherwise.
 *
 * @param {string} str - The string to check.
 * @param {string} positivePattern - The positive pattern.
 * @param {string} negativePattern - The negative pattern.
 * @returns {string}
 */
function _checkPattern(str: string, positivePattern: string, negativePattern: string) {
    const positiveRegExp = new RegExp(positivePattern, 'gi');
    let positiveMatch = positiveRegExp.exec(str);

    while (positiveMatch !== null) {
        const url = positiveMatch[0];

        if (!new RegExp(negativePattern, 'gi').exec(url)) {
            return url;
        }

        positiveMatch = positiveRegExp.exec(str);
    }
}

/**
 * Updates the calendar entries in Redux when new list is received.
 *
 * @param {Object} event - An event returned from the native calendar.
 * @param {Array<string>} knownDomains - The known domain list.
 * @private
 * @returns {CalendarEntry}
 */
function _parseCalendarEntry(event: any, knownDomains: string[]) {
    if (event) {
        const url = _getURLFromEvent(event, knownDomains);
        const startDate = Date.parse(event.startDate);
        const endDate = Date.parse(event.endDate);

        // we want to hide all events that
        // - has no start or end date
        // - for web, if there is no url and we cannot edit the event (has
        // no calendarId)
        if (isNaN(startDate)
            || isNaN(endDate)
            || (navigator.product !== 'ReactNative'
                    && !url
                    && !event.calendarId)) {
            // Ignore the event.
        } else {
            return {
                allDay: event.allDay,
                attendees: event.attendees,
                calendarId: event.calendarId,
                endDate,
                id: event.id,
                startDate,
                title: event.title,
                url
            };
        }
    }

    return null;
}

/**
 * Retrieves a Jitsi Meet URL from an event if present.
 *
 * @param {Object} event - The event to parse.
 * @param {Array<string>} knownDomains - The known domain names.
 * @private
 * @returns {string}
 */
function _getURLFromEvent(event: { description: string; location: string; notes: string; title: string;
    url: string; }, knownDomains: string[]) {
    const linkTerminatorPattern = '[^\\s<>$]';
    const urlRegExp
        = `http(s)?://(${knownDomains.join('|')})/${linkTerminatorPattern}+`;
    const schemeRegExp = `${APP_LINK_SCHEME}${linkTerminatorPattern}+`;
    const excludePattern = '/static/';
    const fieldsToSearch = [
        event.title,
        event.url,
        event.location,
        event.notes,
        event.description
    ];

    for (const field of fieldsToSearch) {
        if (typeof field === 'string') {
            const match
                = _checkPattern(field, urlRegExp, excludePattern)
                || _checkPattern(field, schemeRegExp, excludePattern);

            if (match) {
                const url = parseURIString(match);

                if (url) {
                    return url.toString();
                }
            }
        }
    }

    return null;
}


################################################################################

## File: .\jitsi-meet\react\features\calendar-sync\functions.native.ts

import { NativeModules, Platform } from 'react-native';
import RNCalendarEvents from 'react-native-calendar-events';

import { IReduxState, IStore } from '../app/types';
import { IStateful } from '../base/app/types';
import { CALENDAR_ENABLED } from '../base/flags/constants';
import { getFeatureFlag } from '../base/flags/functions';
import { getShareInfoText } from '../invite/functions';

import { setCalendarAuthorization } from './actions.native';
import { FETCH_END_DAYS, FETCH_START_DAYS } from './constants';
import { _updateCalendarEntries } from './functions.native';
import logger from './logger';

export * from './functions.any';

/**
 * Adds a Jitsi link to a calendar entry.
 *
 * @param {Object} state - The Redux state.
 * @param {string} id - The ID of the calendar entry.
 * @param {string} link - The link to add info with.
 * @returns {Promise<*>}
 */
export function addLinkToCalendarEntry(
        state: IReduxState, id: string, link: string): Promise<any> {
    return new Promise((resolve, reject) => {
        getShareInfoText(state, link, true).then((shareInfoText: string) => {
            RNCalendarEvents.findEventById(id).then((event: any) => {
                const updateText
                    = event.description
                        ? `${event.description}\n\n${shareInfoText}`
                        : shareInfoText;
                const updateObject = {
                    id: event.id,
                    ...Platform.select({
                        ios: {
                            notes: updateText
                        },
                        android: {
                            description: updateText
                        }
                    })
                };

                // @ts-ignore
                RNCalendarEvents.saveEvent(event.title, updateObject)
                .then(resolve, reject);
            }, reject);
        }, reject);
    });
}

/**
 * Determines whether the calendar feature is enabled by the app. For
 * example, Apple through its App Store requires
 * {@code NSCalendarsUsageDescription} in the app's Info.plist or App Store
 * rejects the app. It could also be disabled with a feature flag.
 *
 * @param {Function|Object} stateful - The redux store or {@code getState}
 * function.
 * @returns {boolean} If the app has enabled the calendar feature, {@code true};
 * otherwise, {@code false}.
 */
export function isCalendarEnabled(stateful: IStateful) {
    const flag = getFeatureFlag(stateful, CALENDAR_ENABLED);

    if (typeof flag !== 'undefined') {
        return flag;
    }

    const { calendarEnabled = true } = NativeModules.AppInfo;

    return calendarEnabled;
}

/**
 * Reads the user's calendar and updates the stored entries if need be.
 *
 * @param {Object} store - The redux store.
 * @param {boolean} maybePromptForPermission - Flag to tell the app if it should
 * prompt for a calendar permission if it wasn't granted yet.
 * @param {boolean|undefined} forcePermission - Whether to force to re-ask for
 * the permission or not.
 * @private
 * @returns {void}
 */
export function _fetchCalendarEntries(
        store: IStore,
        maybePromptForPermission: boolean,
        forcePermission?: boolean) {
    const { dispatch, getState } = store;
    const promptForPermission
        = (maybePromptForPermission
        && !getState()['features/calendar-sync'].authorization)
        || forcePermission;

    _ensureCalendarAccess(promptForPermission, dispatch)
        .then(accessGranted => {
            if (accessGranted) {
                const startDate = new Date();
                const endDate = new Date();

                startDate.setDate(startDate.getDate() + FETCH_START_DAYS);
                endDate.setDate(endDate.getDate() + FETCH_END_DAYS);

                RNCalendarEvents.fetchAllEvents(

                    // @ts-ignore
                    startDate.getTime(),
                    endDate.getTime(),
                    [])
                    .then(_updateCalendarEntries.bind(store))
                    .catch(error =>
                        logger.error('Error fetching calendar.', error));
            } else {
                logger.warn('Calendar access not granted.');
            }
        })
        .catch(reason => logger.error('Error accessing calendar.', reason));
}

/**
 * Ensures calendar access if possible and resolves the promise if it's granted.
 *
 * @param {boolean} promptForPermission - Flag to tell the app if it should
 * prompt for a calendar permission if it wasn't granted yet.
 * @param {Function} dispatch - The Redux dispatch function.
 * @private
 * @returns {Promise}
 */
function _ensureCalendarAccess(promptForPermission: boolean | undefined, dispatch: IStore['dispatch']) {
    return new Promise((resolve, reject) => {
        RNCalendarEvents.checkPermissions()
            .then(status => {
                if (status === 'authorized') {
                    resolve(true);
                } else if (promptForPermission) {
                    RNCalendarEvents.requestPermissions()
                        .then(result => {
                            dispatch(setCalendarAuthorization(result));
                            resolve(result === 'authorized');
                        })
                        .catch(reject);
                } else {
                    resolve(false);
                }
            })
            .catch(reject);
    });
}


################################################################################

## File: .\jitsi-meet\react\features\calendar-sync\functions.web.ts

import { IStore } from '../app/types';
import { IStateful } from '../base/app/types';
import { toState } from '../base/redux/functions';

import {
    clearCalendarIntegration,
    setCalendarError,
    setLoadingCalendarEvents
} from './actions.web';
export * from './functions.any';
import {
    CALENDAR_TYPE,
    ERRORS,
    FETCH_END_DAYS,
    FETCH_START_DAYS
} from './constants';
import { _updateCalendarEntries } from './functions.web';
import logger from './logger';
import { googleCalendarApi } from './web/googleCalendar';
import { microsoftCalendarApi } from './web/microsoftCalendar';

/**
 * Determines whether the calendar feature is enabled by the web.
 *
 * @param {Function|Object} stateful - The redux store or {@code getState}
 * function.
 * @returns {boolean} If the app has enabled the calendar feature, {@code true};
 * otherwise, {@code false}.
 */
export function isCalendarEnabled(stateful: IStateful) {
    const {
        enableCalendarIntegration,
        googleApiApplicationClientID,
        microsoftApiApplicationClientID
    } = toState(stateful)['features/base/config'] || {};

    return Boolean(enableCalendarIntegration && (googleApiApplicationClientID || microsoftApiApplicationClientID));
}

/**
 * Reads the user's calendar and updates the stored entries if need be.
 *
 * @param {Object} store - The redux store.
 * @param {boolean} _maybePromptForPermission - Flag to tell the app if it should
 * prompt for a calendar permission if it wasn't granted yet.
 * @param {boolean|undefined} _forcePermission - Whether to force to re-ask for
 * the permission or not.
 * @private
 * @returns {void}
 */
export function _fetchCalendarEntries(
        store: IStore,
        _maybePromptForPermission: boolean,
        _forcePermission?: boolean) {
    const { dispatch, getState } = store;

    const { integrationType = '' } = getState()['features/calendar-sync'];
    const integration = _getCalendarIntegration(integrationType);

    if (!integration) {
        logger.debug('No calendar type available');

        return;
    }

    dispatch(setLoadingCalendarEvents(true));

    dispatch(integration.load())
        .then(() => dispatch(integration._isSignedIn()))
        .then((signedIn: boolean) => {
            if (signedIn) {
                return Promise.resolve();
            }

            return Promise.reject({
                error: ERRORS.AUTH_FAILED
            });
        })
        .then(() => dispatch(integration.getCalendarEntries(
            FETCH_START_DAYS, FETCH_END_DAYS)))
        .then((events: Object[]) => _updateCalendarEntries.call({
            dispatch,
            getState
        }, events))
        .then(() => {
            dispatch(setCalendarError());
        }, (error: any) => {
            logger.error('Error fetching calendar.', error);

            if (error.error === ERRORS.AUTH_FAILED) {
                dispatch(clearCalendarIntegration());
            }

            dispatch(setCalendarError(error));
        })
        .then(() => dispatch(setLoadingCalendarEvents(false)));
}

/**
 * Returns the calendar API implementation by specified type.
 *
 * @param {string} calendarType - The calendar type API as defined in
 * the constant {@link CALENDAR_TYPE}.
 * @private
 * @returns {Object|undefined}
 */
export function _getCalendarIntegration(calendarType: string) {
    switch (calendarType) {
    case CALENDAR_TYPE.GOOGLE:
        return googleCalendarApi;
    case CALENDAR_TYPE.MICROSOFT:
        return microsoftCalendarApi;
    }
}


################################################################################

## File: .\jitsi-meet\react\features\calendar-sync\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/calendar-sync');


################################################################################

## File: .\jitsi-meet\react\features\calendar-sync\middleware.ts

import { IStore } from '../app/types';
import { SET_CONFIG } from '../base/config/actionTypes';
import { ADD_KNOWN_DOMAINS } from '../base/known-domains/actionTypes';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import { equals } from '../base/redux/functions';
import { APP_STATE_CHANGED } from '../mobile/background/actionTypes';

import { REFRESH_CALENDAR } from './actionTypes';
import { setCalendarAuthorization } from './actions';
import { _fetchCalendarEntries, isCalendarEnabled } from './functions';

MiddlewareRegistry.register(store => next => action => {
    const { getState } = store;

    if (!isCalendarEnabled(getState)) {
        return next(action);
    }

    switch (action.type) {
    case ADD_KNOWN_DOMAINS: {
        // XXX Fetch new calendar entries only when an actual domain has
        // become known.
        const oldValue = getState()['features/base/known-domains'];
        const result = next(action);
        const newValue = getState()['features/base/known-domains'];

        equals(oldValue, newValue)
            || _fetchCalendarEntries(store, false, false);

        return result;
    }

    case APP_STATE_CHANGED: {
        const result = next(action);

        _maybeClearAccessStatus(store, action);

        return result;
    }

    case SET_CONFIG: {
        const result = next(action);

        _fetchCalendarEntries(store, false, false);

        return result;
    }

    case REFRESH_CALENDAR: {
        const result = next(action);

        _fetchCalendarEntries(
            store, action.isInteractive, action.forcePermission);

        return result;
    }
    }

    return next(action);
});

/**
 * Clears the calendar access status when the app comes back from the
 * background. This is needed as some users may never quit the app, but puts it
 * into the background and we need to try to request for a permission as often
 * as possible, but not annoyingly often.
 *
 * @param {Object} store - The redux store.
 * @param {Object} action - The Redux action.
 * @private
 * @returns {void}
 */
function _maybeClearAccessStatus(store: IStore, { appState }: { appState: string; }) {
    appState === 'background'
        && store.dispatch(setCalendarAuthorization(undefined));
}


################################################################################

## File: .\jitsi-meet\react\features\calendar-sync\components\AddMeetingUrlButton.native.ts

import { Component } from 'react';

/**
 * A React Component for adding a meeting URL to an existing calendar meeting.
 *
 * @augments Component
 */
class AddMeetingUrlButton extends Component<void> {
    /**
     * Implements React's {@link Component#render}.
     *
     * @inheritdoc
     */
    render() {
        // Not yet implemented.

        return null;
    }
}

export default AddMeetingUrlButton;


################################################################################

## File: .\jitsi-meet\react\features\calendar-sync\components\JoinButton.native.ts

import { Component } from 'react';

/**
 * A React Component for joining an existing calendar meeting.
 *
 * @augments Component
 */
class JoinButton extends Component<void> {
    /**
     * Implements React's {@link Component#render}.
     *
     * @inheritdoc
     */
    render() {
        // Not yet implemented.

        return null;
    }
}

export default JoinButton;


################################################################################

## File: .\jitsi-meet\react\features\calendar-sync\components\MicrosoftSignInButton.native.ts



################################################################################

## File: .\jitsi-meet\react\features\calendar-sync\components\styles.ts

import { ColorPalette } from '../../base/styles/components/styles/ColorPalette';
import { createStyleSheet } from '../../base/styles/functions.any';
import BaseTheme from '../../base/ui/components/BaseTheme';

const NOTIFICATION_SIZE = 55;

/**
 * The styles of the React {@code Component}s of the feature meeting-list i.e.
 * {@code CalendarList}.
 */
export default createStyleSheet({

    /**
     * Button style of the open settings button.
     */
    noPermissionMessageButton: {
        backgroundColor: ColorPalette.blue,
        borderColor: ColorPalette.blue,
        borderRadius: 4,
        borderWidth: 1,
        height: 30,
        justifyContent: 'center',
        margin: 15,
        paddingHorizontal: 20
    },

    /**
     * Text style of the open settings button.
     */
    noPermissionMessageButtonText: {
        color: ColorPalette.white
    },

    /**
     * Text style of the no permission message.
     */
    noPermissionMessageText: {
        backgroundColor: 'transparent',
        color: 'rgba(255, 255, 255, 0.6)',
        textAlign: 'center'
    },

    /**
     * Top level view of the no permission message.
     */
    noPermissionMessageView: {
        alignItems: 'center',
        flex: 1,
        flexDirection: 'column',
        justifyContent: 'center',
        padding: 20
    },

    /**
     * The top level container of the notification.
     */
    notificationContainer: {
        alignSelf: 'flex-start',
        flexDirection: 'row',
        justifyContent: 'center',
        overflow: 'hidden',
        position: 'absolute'
    },

    /**
     * Additional style for the container when the notification is displayed
     * on the side (narrow view).
     */
    notificationContainerSide: {
        top: 100
    },

    /**
     * Additional style for the container when the notification is displayed
     * on the top (wide view).
     */
    notificationContainerTop: {
        justifyContent: 'center',
        left: 0,
        right: 0,
        top: 0
    },

    /**
     * The top level container of the notification.
     */
    notificationContent: {
        alignSelf: 'flex-start',
        flexDirection: 'row',
        height: NOTIFICATION_SIZE,
        justifyContent: 'center',
        paddingHorizontal: 10
    },

    /**
     * Color for upcoming meeting notification.
     */
    notificationContentNext: {
        backgroundColor: '#eeb231'
    },

    /**
     * Color for already ongoing meeting notifications.
     */
    notificationContentPast: {
        backgroundColor: 'red'
    },

    /**
     * Additional style for the content when the notification is displayed
     * on the side (narrow view).
     */
    notificationContentSide: {
        borderBottomRightRadius: NOTIFICATION_SIZE,
        borderTopRightRadius: NOTIFICATION_SIZE
    },

    /**
     * Additional style for the content when the notification is displayed
     * on the top (wide view).
     */
    notificationContentTop: {
        borderBottomLeftRadius: NOTIFICATION_SIZE / 2,
        borderBottomRightRadius: NOTIFICATION_SIZE / 2,
        paddingHorizontal: 20
    },

    /**
     * The icon of the notification.
     */
    notificationIcon: {
        color: 'white',
        fontSize: 25
    },

    /**
     * The container that contains the icon.
     */
    notificationIconContainer: {
        alignItems: 'center',
        flexDirection: 'row',
        height: NOTIFICATION_SIZE,
        justifyContent: 'center'
    },

    /**
     * A single line of text of the notification.
     */
    notificationText: {
        color: 'white',
        fontSize: 13
    },

    /**
     * The container for all the lines if the norification.
     */
    notificationTextContainer: {
        flexDirection: 'column',
        height: NOTIFICATION_SIZE,
        justifyContent: 'center'
    },

    /**
     * The touchable component.
     */
    touchableView: {
        flexDirection: 'row'
    },

    calendarSync: {
        backgroundColor: BaseTheme.palette.uiBackground,
        flex: 1,
        overflow: 'hidden'
    },

    calendarSyncDisabled: {
        backgroundColor: BaseTheme.palette.uiBackground,
        flex: 1,
        opacity: 0.8,
        overflow: 'hidden'
    }
});


################################################################################

## File: .\jitsi-meet\react\features\calendar-sync\components\UpdateCalendarEventDialog.web.ts



################################################################################

## File: .\jitsi-meet\react\features\calendar-sync\web\googleCalendar.ts

import { IStore } from '../../app/types';
import {
    getCalendarEntries,
    loadGoogleAPI,
    signIn,
    updateCalendarEvent,
    updateProfile
} from '../../google-api/actions'; // @ts-ignore
import googleApi from '../../google-api/googleApi.web';

/**
 * A stateless collection of action creators that implements the expected
 * interface for interacting with the Google API in order to get calendar data.
 *
 * @type {Object}
 */
export const googleCalendarApi = {
    /**
     * Retrieves the current calendar events.
     *
     * @param {number} fetchStartDays - The number of days to go back
     * when fetching.
     * @param {number} fetchEndDays - The number of days to fetch.
     * @returns {function(): Promise<CalendarEntries>}
     */
    getCalendarEntries,

    /**
     * Returns the email address for the currently logged in user.
     *
     * @returns {function(Dispatch<any>): Promise<string|never>}
     */
    getCurrentEmail() {
        return updateProfile();
    },

    /**
     * Initializes the google api if needed.
     *
     * @returns {function(Dispatch<any>, Function): Promise<void>}
     */
    load() {
        return (dispatch: IStore['dispatch']) => dispatch(loadGoogleAPI());
    },

    /**
     * Prompts the participant to sign in to the Google API Client Library.
     *
     * @returns {function(Dispatch<any>): Promise<string|never>}
     */
    signIn,

    /**
     * Returns whether or not the user is currently signed in.
     *
     * @returns {function(): Promise<boolean>}
     */
    _isSignedIn() {
        return () => googleApi.isSignedIn();
    },

    /**
     * Updates calendar event by generating new invite URL and editing the event
     * adding some descriptive text and location.
     *
     * @param {string} id - The event id.
     * @param {string} calendarId - The id of the calendar to use.
     * @param {string} location - The location to save to the event.
     * @returns {function(Dispatch<any>): Promise<string|never>}
     */
    updateCalendarEvent
};


################################################################################

## File: .\jitsi-meet\react\features\calendar-sync\web\microsoftCalendar.ts

import { Client } from '@microsoft/microsoft-graph-client';
// eslint-disable-next-line lines-around-comment
import base64js from 'base64-js';
import { v4 as uuidV4 } from 'uuid';
import { findWindows } from 'windows-iana';
import { IanaName } from 'windows-iana/dist/enums';

// @ts-expect-error
import { createDeferred } from '../../../../modules/util/helpers';
import { IStore } from '../../app/types';
import { parseURLParams } from '../../base/util/parseURLParams';
import { parseStandardURIString } from '../../base/util/uri';
import { getShareInfoText } from '../../invite/functions';
import { setCalendarAPIAuthState } from '../actions.web';


/**
 * Constants used for interacting with the Microsoft API.
 *
 * @private
 * @type {object}
 */
const MS_API_CONFIGURATION = {
    /**
     * The URL to use when authenticating using Microsoft API.
     *
     * @type {string}
     */
    AUTH_ENDPOINT:
        'https://login.microsoftonline.com/common/oauth2/v2.0/authorize?',

    CALENDAR_ENDPOINT: '/me/calendars',

    /**
     * The Microsoft API scopes to request access for calendar.
     *
     * @type {string}
     */
    MS_API_SCOPES: 'openid profile Calendars.ReadWrite',

    /**
     * See https://docs.microsoft.com/en-us/azure/active-directory/develop/
     * v2-oauth2-implicit-grant-flow#send-the-sign-in-request. This value is
     * needed for passing in the proper domain_hint value when trying to refresh
     * a token silently.
     *
     * @type {string}
     */
    MS_CONSUMER_TENANT: '9188040d-6c67-4c5b-b112-36a304b66dad',

    /**
     * The redirect URL to be used by the Microsoft API on successful
     * authentication.
     *
     * @type {string}
     */
    REDIRECT_URI: `${window.location.origin}/static/msredirect.html`
};

/**
 * Store the window from an auth request. That way it can be reused if a new
 * request comes in and it can be used to indicate a request is in progress.
 *
 * @private
 * @type {Object|null}
 */
let popupAuthWindow: Window | null = null;

/**
 * A stateless collection of action creators that implements the expected
 * interface for interacting with the Microsoft API in order to get calendar
 * data.
 *
 * @type {Object}
 */
export const microsoftCalendarApi = {
    /**
     * Retrieves the current calendar events.
     *
     * @param {number} fetchStartDays - The number of days to go back
     * when fetching.
     * @param {number} fetchEndDays - The number of days to fetch.
     * @returns {function(Dispatch<any>, Function): Promise<CalendarEntries>}
     */
    getCalendarEntries(fetchStartDays?: number, fetchEndDays?: number) {
        return (dispatch: IStore['dispatch'], getState: IStore['getState']): Promise<any> => {
            const state = getState()['features/calendar-sync'] || {};
            const token = state.msAuthState?.accessToken;

            if (!token) {
                return Promise.reject('Not authorized, please sign in!');
            }

            const client = Client.init({
                authProvider: done => done(null, token)
            });

            return client
                .api(MS_API_CONFIGURATION.CALENDAR_ENDPOINT)
                .get()
                .then(response => {
                    const calendarIds = response.value.map((en: any) => en.id);
                    const getEventsPromises = calendarIds.map((id: string) =>
                        requestCalendarEvents(
                            client, id, fetchStartDays, fetchEndDays));

                    return Promise.all(getEventsPromises);
                })

                // get .value of every element from the array of results,
                // which is an array of events and flatten it to one array
                // of events
                .then(result => [].concat(...result))
                .then(entries => entries.map(e => formatCalendarEntry(e)));
        };
    },

    /**
     * Returns the email address for the currently logged in user.
     *
     * @returns {function(Dispatch<*, Function>): Promise<string>}
     */
    getCurrentEmail(): Function {
        return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
            const { msAuthState = {} }
                = getState()['features/calendar-sync'] || {};
            const email = msAuthState.userSigninName || '';

            return Promise.resolve(email);
        };
    },

    /**
     * Sets the application ID to use for interacting with the Microsoft API.
     *
     * @returns {function(): Promise<void>}
     */
    load() {
        return () => Promise.resolve();
    },

    /**
     * Prompts the participant to sign in to the Microsoft API Client Library.
     *
     * @returns {function(Dispatch<any>, Function): Promise<void>}
     */
    signIn() {
        return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
            // Ensure only one popup window at a time.
            if (popupAuthWindow) {
                popupAuthWindow.focus();

                return Promise.reject('Sign in already in progress.');
            }

            const signInDeferred = createDeferred();

            const guids = {
                authState: uuidV4(),
                authNonce: uuidV4()
            };

            dispatch(setCalendarAPIAuthState(guids));

            const { microsoftApiApplicationClientID }
                = getState()['features/base/config'];
            const authUrl = getAuthUrl(
                microsoftApiApplicationClientID ?? '',
                guids.authState,
                guids.authNonce);
            const h = 600;
            const w = 480;

            popupAuthWindow = window.open(
                authUrl,
                'Auth M$',
                `width=${w}, height=${h}, top=${
                    (screen.height / 2) - (h / 2)}, left=${
                    (screen.width / 2) - (w / 2)}`);

            const windowCloseCheck = setInterval(() => {
                if (popupAuthWindow?.closed) {
                    signInDeferred.reject(
                        'Popup closed before completing auth.');
                    popupAuthWindow = null;
                    window.removeEventListener('message', handleAuth);
                    clearInterval(windowCloseCheck);
                } else if (!popupAuthWindow) {
                    // This case probably happened because the user completed
                    // auth.
                    clearInterval(windowCloseCheck);
                }
            }, 500);

            /**
             * Callback with scope access to other variables that are part of
             * the sign in request.
             *
             * @param {Object} event - The event from the post message.
             * @private
             * @returns {void}
             */
            function handleAuth({ data }: any) {
                if (!data || data.type !== 'ms-login') {
                    return;
                }

                window.removeEventListener('message', handleAuth);

                popupAuthWindow?.close();
                popupAuthWindow = null;

                const params = getParamsFromHash(data.url);
                const tokenParts = getValidatedTokenParts(
                    params, guids, microsoftApiApplicationClientID ?? '');

                if (!tokenParts) {
                    signInDeferred.reject('Invalid token received');

                    return;
                }

                dispatch(setCalendarAPIAuthState({
                    authState: undefined,
                    accessToken: tokenParts.accessToken,
                    idToken: tokenParts.idToken,
                    tokenExpires: params.tokenExpires,
                    userDomainType: tokenParts.userDomainType,
                    userSigninName: tokenParts.userSigninName
                }));

                signInDeferred.resolve();
            }

            window.addEventListener('message', handleAuth);

            return signInDeferred.promise;
        };
    },

    /**
     * Returns whether or not the user is currently signed in.
     *
     * @returns {function(Dispatch<any>, Function): Promise<boolean>}
     */
    _isSignedIn() {
        return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
            const now = new Date().getTime();
            const state
                = getState()['features/calendar-sync'].msAuthState || {};
            const tokenExpires = parseInt(state.tokenExpires, 10);
            const isExpired = now > tokenExpires && !isNaN(tokenExpires);

            if (state.accessToken && isExpired) {
                // token expired, let's refresh it
                return dispatch(refreshAuthToken())
                    .then(() => true)
                    .catch(() => false);
            }

            return Promise.resolve(state.accessToken && !isExpired);
        };
    },

    /**
     * Updates calendar event by generating new invite URL and editing the event
     * adding some descriptive text and location.
     *
     * @param {string} id - The event id.
     * @param {string} calendarId - The id of the calendar to use.
     * @param {string} location - The location to save to the event.
     * @returns {function(Dispatch<any>): Promise<string|never>}
     */
    updateCalendarEvent(id: string, calendarId: string, location: string) {
        return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
            const state = getState()['features/calendar-sync'] || {};
            const token = state.msAuthState?.accessToken;

            if (!token) {
                return Promise.reject('Not authorized, please sign in!');
            }

            return getShareInfoText(getState(), location, true/* use html */)
                .then(text => {
                    const client = Client.init({
                        authProvider: done => done(null, token)
                    });

                    return client
                        .api(`/me/events/${id}`)
                        .get()
                        .then(description => {
                            const body = description.body;

                            if (description.bodyPreview) {
                                body.content
                                    = `${description.bodyPreview}<br><br>`;
                            }

                            // replace all new lines from the text with html
                            // <br> to make it pretty
                            body.content += text.split('\n').join('<br>');

                            return client
                                .api(`/me/calendar/events/${id}`)
                                .patch({
                                    body,
                                    location: {
                                        'displayName': location
                                    }
                                });
                        });
                });
        };
    }
};

/**
 * Parses the Microsoft calendar entries to a known format.
 *
 * @param {Object} entry - The Microsoft calendar entry.
 * @private
 * @returns {{
 *     calendarId: string,
 *     description: string,
 *     endDate: string,
 *     id: string,
 *     location: string,
 *     startDate: string,
 *     title: string
 * }}
 */
function formatCalendarEntry(entry: any) {
    return {
        calendarId: entry.calendarId,
        description: entry.body.content,
        endDate: entry.end.dateTime,
        id: entry.id,
        location: entry.location.displayName,
        startDate: entry.start.dateTime,
        title: entry.subject
    };
}

/**
 * Constructs and returns the URL to use for renewing an auth token.
 *
 * @param {string} appId - The Microsoft application id to log into.
 * @param {string} userDomainType - The domain type of the application as
 * provided by Microsoft.
 * @param {string} userSigninName - The email of the user signed into the
 * integration with Microsoft.
 * @private
 * @returns {string} - The auth URL.
 */
function getAuthRefreshUrl(appId: string, userDomainType: string, userSigninName: string) {
    return [
        getAuthUrl(appId, 'undefined', 'undefined'),
        'prompt=none',
        `domain_hint=${userDomainType}`,
        `login_hint=${userSigninName}`
    ].join('&');
}

/**
 * Constructs and returns the auth URL to use for login.
 *
 * @param {string} appId - The Microsoft application id to log into.
 * @param {string} authState - The authState guid to use.
 * @param {string} authNonce - The authNonce guid to use.
 * @private
 * @returns {string} - The auth URL.
 */
function getAuthUrl(appId: string, authState: string, authNonce: string) {
    const authParams = [
        'response_type=id_token+token',
        `client_id=${appId}`,
        `redirect_uri=${MS_API_CONFIGURATION.REDIRECT_URI}`,
        `scope=${MS_API_CONFIGURATION.MS_API_SCOPES}`,
        `state=${authState}`,
        `nonce=${authNonce}`,
        'response_mode=fragment'
    ].join('&');

    return `${MS_API_CONFIGURATION.AUTH_ENDPOINT}${authParams}`;
}

/**
 * Converts a url from an auth redirect into an object of parameters passed
 * into the url.
 *
 * @param {string} url - The string to parse.
 * @private
 * @returns {Object}
 */
function getParamsFromHash(url: string) {
    // @ts-ignore
    const params = parseURLParams(parseStandardURIString(url), true, 'hash');

    // Get the number of seconds the token is valid for, subtract 5 minutes
    // to account for differences in clock settings and convert to ms.
    const expiresIn = (parseInt(params.expires_in, 10) - 300) * 1000;
    const now = new Date();
    const expireDate = new Date(now.getTime() + expiresIn);

    params.tokenExpires = expireDate.getTime().toString();

    return params;
}

/**
 * Converts the parameters from a Microsoft auth redirect into an object of
 * token parts. The value "null" will be returned if the params do not produce
 * a valid token.
 *
 * @param {Object} tokenInfo - The token object.
 * @param {Object} guids - The guids for authState and authNonce that should
 * match in the token.
 * @param {Object} appId - The Microsoft application this token is for.
 * @private
 * @returns {Object|null}
 */
function getValidatedTokenParts(tokenInfo: any, guids: any, appId: string) {
    // Make sure the token matches the request source by matching the GUID.
    if (tokenInfo.state !== guids.authState) {
        return null;
    }

    const idToken = tokenInfo.id_token;

    // A token must exist to be valid.
    if (!idToken) {
        return null;
    }

    const tokenParts = idToken.split('.');

    if (tokenParts.length !== 3) {
        return null;
    }

    let payload;

    try {
        payload = JSON.parse(b64utoutf8(tokenParts[1]));
    } catch (e) {
        return null;
    }

    if (payload.nonce !== guids.authNonce
        || payload.aud !== appId
        || payload.iss
            !== `https://login.microsoftonline.com/${payload.tid}/v2.0`) {
        return null;
    }

    const now = new Date();

    // Adjust by 5 minutes to allow for inconsistencies in system clocks.
    const notBefore = new Date((payload.nbf - 300) * 1000);
    const expires = new Date((payload.exp + 300) * 1000);

    if (now < notBefore || now > expires) {
        return null;
    }

    return {
        accessToken: tokenInfo.access_token,
        idToken,
        userDisplayName: payload.name,
        userDomainType:
            payload.tid === MS_API_CONFIGURATION.MS_CONSUMER_TENANT
                ? 'consumers' : 'organizations',
        userSigninName: payload.preferred_username
    };
}

/**
 * Renews an existing auth token so it can continue to be used.
 *
 * @private
 * @returns {function(Dispatch<any>, Function): Promise<void>}
 */
function refreshAuthToken() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const { microsoftApiApplicationClientID }
            = getState()['features/base/config'];
        const { msAuthState = {} }
            = getState()['features/calendar-sync'] || {};

        const refreshAuthUrl = getAuthRefreshUrl(
            microsoftApiApplicationClientID ?? '',
            msAuthState.userDomainType,
            msAuthState.userSigninName);

        const iframe = document.createElement('iframe');

        iframe.setAttribute('id', 'auth-iframe');
        iframe.setAttribute('name', 'auth-iframe');
        iframe.setAttribute('style', 'display: none');
        iframe.setAttribute('src', refreshAuthUrl);

        const signInPromise = new Promise(resolve => {
            iframe.onload = () => {
                resolve(iframe.contentWindow?.location.hash);
            };
        });

        // The check for body existence is done for flow, which also runs
        // against native where document.body may not be defined.
        if (!document.body) {
            return Promise.reject(
                'Cannot refresh auth token in this environment');
        }

        document.body.appendChild(iframe);

        return signInPromise.then(hash => {
            const params = getParamsFromHash(hash as string);

            dispatch(setCalendarAPIAuthState({
                accessToken: params.access_token,
                idToken: params.id_token,
                tokenExpires: params.tokenExpires
            }));
        });
    };
}

/**
 * Retrieves calendar entries from a specific calendar.
 *
 * @param {Object} client - The Microsoft-graph-client initialized.
 * @param {string} calendarId - The calendar ID to use.
 * @param {number} fetchStartDays - The number of days to go back
 * when fetching.
 * @param {number} fetchEndDays - The number of days to fetch.
 * @returns {Promise<any> | Promise}
 * @private
 */
function requestCalendarEvents( // eslint-disable-line max-params
        client: any,
        calendarId: string,
        fetchStartDays?: number,
        fetchEndDays?: number): Promise<any> {
    const startDate = new Date();
    const endDate = new Date();

    startDate.setDate(startDate.getDate() + Number(fetchStartDays));
    endDate.setDate(endDate.getDate() + Number(fetchEndDays));

    const filter = `Start/DateTime ge '${
        startDate.toISOString()}' and End/DateTime lt '${
        endDate.toISOString()}'`;

    const ianaTimeZone = new Intl.DateTimeFormat().resolvedOptions().timeZone;
    const windowsTimeZone = findWindows(ianaTimeZone as IanaName);

    return client
        .api(`/me/calendars/${calendarId}/events`)
        .filter(filter)
        .header('Prefer', `outlook.timezone="${windowsTimeZone}"`)
        .select('id,subject,start,end,location,body')
        .orderby('createdDateTime DESC')
        .get()
        .then((result: any) => result.value.map((item: Object) => {
            return {
                ...item,
                calendarId
            };
        }));
}

/**
 * Convert a Base64URL encoded string to a UTF-8 encoded string including CJK or Latin.
 *
 * @param {string} str - The string that needs conversion.
 * @private
 * @returns {string} - The converted string.
 */
function b64utoutf8(str: string) {
    let s = str;

    // Convert from Base64URL to Base64.

    if (s.length % 4 === 2) {
        s += '==';
    } else if (s.length % 4 === 3) {
        s += '=';
    }

    s = s.replace(/-/g, '+').replace(/_/g, '/');

    // Convert Base64 to a byte array.

    const bytes = base64js.toByteArray(s);

    // Convert bytes to hex.

    s = bytes.reduce((str_: any, byte: any) => str_ + byte.toString(16).padStart(2, '0'), '');

    // Convert a hexadecimal string to a URLComponent string

    s = s.replace(/(..)/g, '%$1');

    // Decodee the URI component

    return decodeURIComponent(s);
}


################################################################################

## File: .\jitsi-meet\react\features\chat\actions.any.ts

import { IStore } from '../app/types';
import { getCurrentConference } from '../base/conference/functions';
import { getLocalParticipant } from '../base/participants/functions';
import { IParticipant } from '../base/participants/types';
import { LOBBY_CHAT_INITIALIZED } from '../lobby/constants';

import {
    ADD_MESSAGE,
    ADD_MESSAGE_REACTION,
    CLEAR_MESSAGES,
    CLOSE_CHAT,
    EDIT_MESSAGE,
    REMOVE_LOBBY_CHAT_PARTICIPANT,
    SEND_MESSAGE,
    SEND_REACTION,
    SET_IS_POLL_TAB_FOCUSED,
    SET_LOBBY_CHAT_ACTIVE_STATE,
    SET_LOBBY_CHAT_RECIPIENT,
    SET_PRIVATE_MESSAGE_RECIPIENT
} from './actionTypes';

/**
 * Adds a chat message to the collection of messages.
 *
 * @param {Object} messageDetails - The chat message to save.
 * @param {string} messageDetails.displayName - The displayName of the
 * participant that authored the message.
 * @param {boolean} messageDetails.hasRead - Whether or not to immediately mark
 * the message as read.
 * @param {string} messageDetails.message - The received message to display.
 * @param {string} messageDetails.messageType - The kind of message, such as
 * "error" or "local" or "remote".
 * @param {string} messageDetails.timestamp - A timestamp to display for when
 * the message was received.
 * @param {string} messageDetails.isReaction - Whether or not the
 * message is a reaction message.
 * @returns {{
 *     type: ADD_MESSAGE,
 *     displayName: string,
 *     hasRead: boolean,
 *     message: string,
 *     messageType: string,
 *     timestamp: string,
 *     isReaction: boolean
 * }}
 */
export function addMessage(messageDetails: Object) {
    return {
        type: ADD_MESSAGE,
        ...messageDetails
    };
}

/**
 * Adds a reaction to a chat message.
 *
 * @param {Object} reactionDetails - The reaction to add.
 * @param {string} reactionDetails.participantId - The ID of the message to react to.
 * @param {string} reactionDetails.reactionList - The reaction to add.
 * @param {string} reactionDetails.messageId - The receiver ID of the reaction.
 * @returns {{
 *     type: ADD_MESSAGE_REACTION,
 *     participantId: string,
 *     reactionList: string[],
 *     messageId: string
 * }}
 */
export function addMessageReaction(reactionDetails: Object) {
    return {
        type: ADD_MESSAGE_REACTION,
        ...reactionDetails
    };
}

/**
 * Edits an existing chat message.
 *
 * @param {Object} message - The chat message to edit/override. The messages will be matched from the state
 * comparing the messageId.
 * @returns {{
 *     type: EDIT_MESSAGE,
 *     message: Object
 * }}
 */
export function editMessage(message: Object) {
    return {
        type: EDIT_MESSAGE,
        message
    };
}

/**
 * Clears the chat messages in Redux.
 *
 * @returns {{
 *     type: CLEAR_MESSAGES
 * }}
 */
export function clearMessages() {
    return {
        type: CLEAR_MESSAGES
    };
}

/**
 * Action to signal the closing of the chat dialog.
 *
 * @returns {{
 *     type: CLOSE_CHAT
 * }}
 */
export function closeChat() {
    return {
        type: CLOSE_CHAT
    };
}

/**
 * Sends a chat message to everyone in the conference.
 *
 * @param {string} message - The chat message to send out.
 * @param {boolean} ignorePrivacy - True if the privacy notification should be ignored.
 * @returns {{
 *     type: SEND_MESSAGE,
 *     ignorePrivacy: boolean,
 *     message: string
 * }}
 */
export function sendMessage(message: string, ignorePrivacy = false) {
    return {
        type: SEND_MESSAGE,
        ignorePrivacy,
        message
    };
}

/**
 * Sends a reaction to a message.
 *
 * @param {string} reaction - The reaction to send.
 * @param {string} messageId - The message ID to react to.
 * @param {string} receiverId - The receiver ID of the reaction.
 * @returns {Function}
 */
export function sendReaction(reaction: string, messageId: string, receiverId?: string) {

    return {
        type: SEND_REACTION,
        reaction,
        messageId,
        receiverId
    };
}

/**
 * Initiates the sending of a private message to the supplied participant.
 *
 * @param {IParticipant} participant - The participant to set the recipient to.
 * @returns {{
 *     participant: IParticipant,
 *     type: SET_PRIVATE_MESSAGE_RECIPIENT
 * }}
 */
export function setPrivateMessageRecipient(participant?: Object) {
    return {
        participant,
        type: SET_PRIVATE_MESSAGE_RECIPIENT
    };
}

/**
 * Set the value of _isPollsTabFocused.
 *
 * @param {boolean} isPollsTabFocused - The new value for _isPollsTabFocused.
 * @returns {Function}
 */
export function setIsPollsTabFocused(isPollsTabFocused: boolean) {
    return {
        isPollsTabFocused,
        type: SET_IS_POLL_TAB_FOCUSED
    };
}

/**
 * Initiates the sending of messages between a moderator and a lobby attendee.
 *
 * @param {Object} lobbyChatInitializedInfo - The information about the attendee and the moderator
 * that is going to chat.
 *
 * @returns {Function}
 */
export function onLobbyChatInitialized(lobbyChatInitializedInfo: { attendee: IParticipant; moderator: IParticipant; }) {
    return async (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const conference = getCurrentConference(state);

        const lobbyLocalId = conference?.myLobbyUserId();

        if (!lobbyLocalId) {
            return;
        }

        if (lobbyChatInitializedInfo.moderator.id === lobbyLocalId) {
            dispatch({
                type: SET_LOBBY_CHAT_RECIPIENT,
                participant: lobbyChatInitializedInfo.attendee,
                open: true
            });
        }

        if (lobbyChatInitializedInfo.attendee.id === lobbyLocalId) {
            return dispatch({
                type: SET_LOBBY_CHAT_RECIPIENT,
                participant: lobbyChatInitializedInfo.moderator,
                open: false
            });
        }
    };
}

/**
 * Sets the lobby room's chat active state.
 *
 * @param {boolean} value - The active state.
 *
 * @returns {Object}
 */
export function setLobbyChatActiveState(value: boolean) {
    return {
        type: SET_LOBBY_CHAT_ACTIVE_STATE,
        payload: value
    };
}

/**
 * Removes lobby type messages.
 *
 *  @param {boolean} removeLobbyChatMessages - Should remove messages from chat  (works only for accepted users).
 * If not specified, it will delete all lobby messages.
 *
 * @returns {Object}
 */
export function removeLobbyChatParticipant(removeLobbyChatMessages?: boolean) {
    return {
        type: REMOVE_LOBBY_CHAT_PARTICIPANT,
        removeLobbyChatMessages
    };
}

/**
 * Handles initial setup of lobby message between
 * Moderator and participant.
 *
 * @param {string} participantId - The participant id.
 *
 * @returns {Object}
 */
export function handleLobbyChatInitialized(participantId: string) {
    return async (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        if (!participantId) {
            return;
        }
        const state = getState();
        const conference = state['features/base/conference'].conference;
        const { knockingParticipants } = state['features/lobby'];
        const { lobbyMessageRecipient } = state['features/chat'];
        const me = getLocalParticipant(state);
        const lobbyLocalId = conference?.myLobbyUserId();


        if (lobbyMessageRecipient && lobbyMessageRecipient.id === participantId) {
            return dispatch(setLobbyChatActiveState(true));
        }

        const attendee = knockingParticipants.find(p => p.id === participantId);

        if (attendee && attendee.chattingWithModerator === lobbyLocalId) {
            return dispatch({
                type: SET_LOBBY_CHAT_RECIPIENT,
                participant: attendee,
                open: true
            });
        }

        if (!attendee) {
            return;
        }

        const payload = { type: LOBBY_CHAT_INITIALIZED,
            moderator: {
                ...me,
                name: 'Moderator',
                id: lobbyLocalId
            },
            attendee };

        // notify attendee privately.
        conference?.sendLobbyMessage(payload, attendee.id);

        // notify other moderators.
        return conference?.sendLobbyMessage(payload);
    };
}


################################################################################

## File: .\jitsi-meet\react\features\chat\actions.native.ts

import { IParticipant } from '../base/participants/types';
import { navigate }
    from '../mobile/navigation/components/conference/ConferenceNavigationContainerRef';
import { screen } from '../mobile/navigation/routes';

import { OPEN_CHAT } from './actionTypes';

export * from './actions.any';

/**
 * Displays the chat panel.
 *
 * @param {Object} participant - The recipient for the private chat.
 * @param {boolean} disablePolls - Checks if polls are disabled.
 *
 * @returns {{
 *     participant: participant,
 *     type: OPEN_CHAT
 * }}
 */
export function openChat(participant: IParticipant | undefined | Object, disablePolls?: boolean) {
    if (disablePolls) {
        navigate(screen.conference.chat);
    }
    navigate(screen.conference.chatandpolls.main);

    return {
        participant,
        type: OPEN_CHAT
    };
}


################################################################################

## File: .\jitsi-meet\react\features\chat\actions.web.ts

// @ts-expect-error
import VideoLayout from '../../../modules/UI/videolayout/VideoLayout';
import { IStore } from '../app/types';

import { OPEN_CHAT } from './actionTypes';
import { closeChat } from './actions.any';

export * from './actions.any';

/**
 * Displays the chat panel.
 *
 * @param {Object} participant - The recipient for the private chat.
 * @param {Object} _disablePolls - Used on native.
 * @returns {{
 *     participant: Participant,
 *     type: OPEN_CHAT
 * }}
 */
export function openChat(participant?: Object, _disablePolls?: boolean) {
    return function(dispatch: IStore['dispatch']) {
        dispatch({
            participant,
            type: OPEN_CHAT
        });
    };
}

/**
 * Toggles display of the chat panel.
 *
 * @returns {Function}
 */
export function toggleChat() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const isOpen = getState()['features/chat'].isOpen;

        if (isOpen) {
            dispatch(closeChat());
        } else {
            dispatch(openChat());
        }

        // Recompute the large video size whenever we toggle the chat, as it takes chat state into account.
        VideoLayout.onResize();
    };
}


################################################################################

## File: .\jitsi-meet\react\features\chat\actionTypes.ts

/**
 * The type of the action which signals to add a new chat message.
 *
 * {
 *     type: ADD_MESSAGE,
 *     displayName: string
 *     hasRead: boolean,
 *     id: string,
 *     messageType: string,
 *     message: string,
 *     timestamp: string,
 * }
 */
export const ADD_MESSAGE = 'ADD_MESSAGE';

/**
 * The type of the action that adds a reaction to a chat message.
 *
 * {
 *     type: ADD_MESSAGE_REACTION,
 *     reaction: string,
 *     messageID: string,
 *     receiverID: string,
 * }
 */
export const ADD_MESSAGE_REACTION = 'ADD_MESSAGE_REACTION';

/**
 * The type of the action which signals to clear messages in Redux.
 *
 * {
 *     type: CLEAR_MESSAGES
 * }
 */
export const CLEAR_MESSAGES = 'CLEAR_MESSAGES';

/**
 * The type of the action which signals the cancellation the chat panel.
 *
 * {
 *     type: CLOSE_CHAT
 * }
 */
export const CLOSE_CHAT = 'CLOSE_CHAT';

/**
 * The type of the action which signals to edit chat message.
 *
 * {
 *     type: EDIT_MESSAGE,
 *     message: Object
 * }
 */
export const EDIT_MESSAGE = 'EDIT_MESSAGE';

/**
 * The type of the action which signals to display the chat panel.
 *
 * {
 *     type: OPEN_CHAT
 * }
 */
export const OPEN_CHAT = 'OPEN_CHAT';

/**
 * The type of the action which signals a send a chat message to everyone in the
 * conference.
 *
 * {
 *     type: SEND_MESSAGE,
 *     ignorePrivacy: boolean,
 *     message: string
 * }
 */
export const SEND_MESSAGE = 'SEND_MESSAGE';

/**
 * The type of the action which signals a reaction to a message.
 *
 * {
 *     type: SEND_REACTION,
 *     reaction: string,
 *     messageID: string,
 *     receiverID: string
 * }
 */
export const SEND_REACTION = 'SEND_REACTION';

/**
 * The type of action which signals the initiation of sending of as private message to the
 * supplied recipient.
 *
 * {
 *     participant: Participant,
 *     type: SET_PRIVATE_MESSAGE_RECIPIENT
 * }
 */
export const SET_PRIVATE_MESSAGE_RECIPIENT = 'SET_PRIVATE_MESSAGE_RECIPIENT';

/**
 * The type of action which signals the update a _isPollsTabFocused.
 *
 * {
 *     isPollsTabFocused: boolean,
 *     type: SET_PRIVATE_MESSAGE_RECIPIENT
 * }
 */
export const SET_IS_POLL_TAB_FOCUSED = 'SET_IS_POLL_TAB_FOCUSED';

/**
 * The type of action which sets the current recipient for lobby messages.
 *
 * {
 *     participant: Object,
 *     type: SET_LOBBY_CHAT_RECIPIENT
 * }
 */
 export const SET_LOBBY_CHAT_RECIPIENT = 'SET_LOBBY_CHAT_RECIPIENT';

 /**
  * The type of action sets the state of lobby messaging status.
  *
  * {
  *     type: SET_LOBBY_CHAT_ACTIVE_STATE
  *     payload: boolean
  * }
  */
 export const SET_LOBBY_CHAT_ACTIVE_STATE = 'SET_LOBBY_CHAT_ACTIVE_STATE';

 /**
  * The type of action removes the lobby messaging from participant.
  *
  * {
  *     type: REMOVE_LOBBY_CHAT_PARTICIPANT
  * }
  */
 export const REMOVE_LOBBY_CHAT_PARTICIPANT = 'REMOVE_LOBBY_CHAT_PARTICIPANT';


################################################################################

## File: .\jitsi-meet\react\features\chat\constants.ts

/**
 * Maximum number of characters allowed.
 */
export const CHAR_LIMIT = 500;

/**
 * The size of the chat. Equal to $sidebarWidth SCSS variable.
 */
export const CHAT_SIZE = 315;

/**
 * The audio ID of the audio element for which the {@link playAudio} action is
 * triggered when new chat message is received.
 *
 * @type {string}
 */
export const INCOMING_MSG_SOUND_ID = 'INCOMING_MSG_SOUND';

/**
 * The {@code messageType} of error (system) messages.
 */
export const MESSAGE_TYPE_ERROR = 'error';

/**
 * The {@code messageType} of local messages.
 */
export const MESSAGE_TYPE_LOCAL = 'local';

/**
 * The {@code messageType} of remote messages.
 */
export const MESSAGE_TYPE_REMOTE = 'remote';

export const SMALL_WIDTH_THRESHOLD = 580;


/**
 * Lobby message type.
 */
export const LOBBY_CHAT_MESSAGE = 'LOBBY_CHAT_MESSAGE';

export const CHAT_TABS = {
    POLLS: 'polls-tab',
    CHAT: 'chat-tab'
};

/**
 * Formatter string to display the message timestamp.
 */
export const TIMESTAMP_FORMAT = 'H:mm';

/**
 * The namespace for system messages.
 */
export const MESSAGE_TYPE_SYSTEM = 'system_chat_message';


################################################################################

## File: .\jitsi-meet\react\features\chat\functions.ts

// @ts-expect-error
import aliases from 'react-emoji-render/data/aliases';
// eslint-disable-next-line lines-around-comment
// @ts-expect-error
import emojiAsciiAliases from 'react-emoji-render/data/asciiAliases';

import { IReduxState } from '../app/types';
import { getLocalizedDateFormatter } from '../base/i18n/dateUtil';
import i18next from '../base/i18n/i18next';
import { getParticipantById } from '../base/participants/functions';
import { escapeRegexp } from '../base/util/helpers';

import { MESSAGE_TYPE_ERROR, MESSAGE_TYPE_LOCAL, TIMESTAMP_FORMAT } from './constants';
import { IMessage } from './types';

/**
 * An ASCII emoticon regexp array to find and replace old-style ASCII
 * emoticons (such as :O) with the new Unicode representation, so that
 * devices and browsers that support them can render these natively
 * without a 3rd party component.
 *
 * NOTE: this is currently only used on mobile, but it can be used
 * on web too once we drop support for browsers that don't support
 * unicode emoji rendering.
 */
const ASCII_EMOTICON_REGEXP_ARRAY: Array<[RegExp, string]> = [];

/**
 * An emoji regexp array to find and replace alias emoticons
 * (such as :smiley:) with the new Unicode representation, so that
 * devices and browsers that support them can render these natively
 * without a 3rd party component.
 *
 * NOTE: this is currently only used on mobile, but it can be used
 * on web too once we drop support for browsers that don't support
 * unicode emoji rendering.
 */
const SLACK_EMOJI_REGEXP_ARRAY: Array<[RegExp, string]> = [];

(function() {
    for (const [ key, value ] of Object.entries(aliases)) {

        // Add ASCII emoticons
        const asciiEmoticons = emojiAsciiAliases[key];

        if (asciiEmoticons) {
            const asciiEscapedValues = asciiEmoticons.map((v: string) => escapeRegexp(v));

            const asciiRegexp = `(${asciiEscapedValues.join('|')})`;

            // Escape urls
            const formattedAsciiRegexp = key === 'confused'
                ? `(?=(${asciiRegexp}))(:(?!//).)`
                : asciiRegexp;

            ASCII_EMOTICON_REGEXP_ARRAY.push([ new RegExp(formattedAsciiRegexp, 'g'), value as string ]);
        }

        // Add slack-type emojis
        const emojiRegexp = `\\B(${escapeRegexp(`:${key}:`)})\\B`;

        SLACK_EMOJI_REGEXP_ARRAY.push([ new RegExp(emojiRegexp, 'g'), value as string ]);
    }
})();

/**
 * Replaces ASCII and other non-unicode emoticons with unicode emojis to let the emojis be rendered
 * by the platform native renderer.
 *
 * @param {string} message - The message to parse and replace.
 * @returns {string}
 */
export function replaceNonUnicodeEmojis(message: string) {
    let replacedMessage = message;

    for (const [ regexp, replaceValue ] of SLACK_EMOJI_REGEXP_ARRAY) {
        replacedMessage = replacedMessage.replace(regexp, replaceValue);
    }

    for (const [ regexp, replaceValue ] of ASCII_EMOTICON_REGEXP_ARRAY) {
        replacedMessage = replacedMessage.replace(regexp, replaceValue);
    }

    return replacedMessage;
}

/**
 * Selector for calculating the number of unread chat messages.
 *
 * @param {IReduxState} state - The redux state.
 * @returns {number} The number of unread messages.
 */
export function getUnreadCount(state: IReduxState) {
    const { lastReadMessage, messages } = state['features/chat'];
    const messagesCount = messages.length;

    if (!messagesCount) {
        return 0;
    }

    let reactionMessages = 0;
    let lastReadIndex;

    if (navigator.product === 'ReactNative') {
        // React native stores the messages in a reversed order.
        lastReadIndex = messages.indexOf(<IMessage>lastReadMessage);

        for (let i = 0; i < lastReadIndex; i++) {
            if (messages[i].isReaction) {
                reactionMessages++;
            }
        }

        return lastReadIndex - reactionMessages;
    }

    lastReadIndex = messages.lastIndexOf(<IMessage>lastReadMessage);

    for (let i = lastReadIndex + 1; i < messagesCount; i++) {
        if (messages[i].isReaction) {
            reactionMessages++;
        }
    }

    return messagesCount - (lastReadIndex + 1) - reactionMessages;
}

/**
 * Get whether the chat smileys are disabled or not.
 *
 * @param {IReduxState} state - The redux state.
 * @returns {boolean} The disabled flag.
 */
export function areSmileysDisabled(state: IReduxState) {
    const disableChatSmileys = state['features/base/config']?.disableChatSmileys === true;

    return disableChatSmileys;
}

/**
 * Returns the timestamp to display for the message.
 *
 * @param {IMessage} message - The message from which to get the timestamp.
 * @returns {string}
 */
export function getFormattedTimestamp(message: IMessage) {
    return getLocalizedDateFormatter(new Date(message.timestamp))
        .format(TIMESTAMP_FORMAT);
}

/**
 * Generates the message text to be rendered in the component.
 *
 * @param {IMessage} message - The message from which to get the text.
 * @returns {string}
 */
export function getMessageText(message: IMessage) {
    return message.messageType === MESSAGE_TYPE_ERROR
        ? i18next.t('chat.error', {
            error: message.message
        })
        : message.message;
}


/**
 * Returns whether a message can be replied to.
 *
 * @param {IReduxState} state - The redux state.
 * @param {IMessage} message - The message to be checked.
 * @returns {boolean}
 */
export function getCanReplyToMessage(state: IReduxState, message: IMessage) {
    const { knocking } = state['features/lobby'];
    const participant = getParticipantById(state, message.participantId);

    return Boolean(participant)
        && (message.privateMessage || (message.lobbyChat && !knocking))
        && message.messageType !== MESSAGE_TYPE_LOCAL;
}

/**
 * Returns the message that is displayed as a notice for private messages.
 *
 * @param {IMessage} message - The message to be checked.
 * @returns {string}
 */
export function getPrivateNoticeMessage(message: IMessage) {
    return i18next.t('chat.privateNotice', {
        recipient: message.messageType === MESSAGE_TYPE_LOCAL ? message.recipient : i18next.t('chat.you')
    });
}


################################################################################

## File: .\jitsi-meet\react\features\chat\middleware.ts

import { AnyAction } from 'redux';

import { IReduxState, IStore } from '../app/types';
import { APP_WILL_MOUNT, APP_WILL_UNMOUNT } from '../base/app/actionTypes';
import {
    CONFERENCE_JOINED,
    ENDPOINT_MESSAGE_RECEIVED,
    NON_PARTICIPANT_MESSAGE_RECEIVED
} from '../base/conference/actionTypes';
import { getCurrentConference } from '../base/conference/functions';
import { IJitsiConference } from '../base/conference/reducer';
import { openDialog } from '../base/dialog/actions';
import i18next from '../base/i18n/i18next';
import {
    JitsiConferenceErrors,
    JitsiConferenceEvents
} from '../base/lib-jitsi-meet';
import {
    getLocalParticipant,
    getParticipantById,
    getParticipantDisplayName
} from '../base/participants/functions';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import StateListenerRegistry from '../base/redux/StateListenerRegistry';
import { playSound, registerSound, unregisterSound } from '../base/sounds/actions';
import { addGif } from '../gifs/actions';
import { extractGifURL, getGifDisplayMode, isGifEnabled, isGifMessage } from '../gifs/function.any';
import { showMessageNotification } from '../notifications/actions';
import { NOTIFICATION_TIMEOUT_TYPE } from '../notifications/constants';
import { resetNbUnreadPollsMessages } from '../polls/actions';
import { ADD_REACTION_MESSAGE } from '../reactions/actionTypes';
import { pushReactions } from '../reactions/actions.any';
import { ENDPOINT_REACTION_NAME } from '../reactions/constants';
import { getReactionMessageFromBuffer, isReactionsEnabled } from '../reactions/functions.any';
import { showToolbox } from '../toolbox/actions';

import {
    ADD_MESSAGE,
    CLOSE_CHAT,
    OPEN_CHAT,
    SEND_MESSAGE,
    SEND_REACTION,
    SET_IS_POLL_TAB_FOCUSED
} from './actionTypes';
import { addMessage, addMessageReaction, clearMessages, closeChat } from './actions.any';
import { ChatPrivacyDialog } from './components';
import {
    INCOMING_MSG_SOUND_ID,
    LOBBY_CHAT_MESSAGE,
    MESSAGE_TYPE_ERROR,
    MESSAGE_TYPE_LOCAL,
    MESSAGE_TYPE_REMOTE,
    MESSAGE_TYPE_SYSTEM
} from './constants';
import { getUnreadCount } from './functions';
import { INCOMING_MSG_SOUND_FILE } from './sounds';

/**
 * Timeout for when to show the privacy notice after a private message was received.
 *
 * E.g. If this value is 20 secs (20000ms), then we show the privacy notice when sending a non private
 * message after we have received a private message in the last 20 seconds.
 */
const PRIVACY_NOTICE_TIMEOUT = 20 * 1000;

/**
 * Implements the middleware of the chat feature.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {
    const { dispatch, getState } = store;
    const localParticipant = getLocalParticipant(getState());
    let isOpen, unreadCount;

    switch (action.type) {
    case ADD_MESSAGE:
        unreadCount = getUnreadCount(getState());
        if (action.isReaction) {
            action.hasRead = false;
        } else {
            unreadCount = action.hasRead ? 0 : unreadCount + 1;
        }
        isOpen = getState()['features/chat'].isOpen;

        if (typeof APP !== 'undefined') {
            APP.API.notifyChatUpdated(unreadCount, isOpen);
        }
        break;

    case APP_WILL_MOUNT:
        dispatch(
                registerSound(INCOMING_MSG_SOUND_ID, INCOMING_MSG_SOUND_FILE));
        break;

    case APP_WILL_UNMOUNT:
        dispatch(unregisterSound(INCOMING_MSG_SOUND_ID));
        break;

    case CONFERENCE_JOINED:
        _addChatMsgListener(action.conference, store);
        break;

    case CLOSE_CHAT: {
        const isPollTabOpen = getState()['features/chat'].isPollsTabFocused;

        unreadCount = 0;

        if (typeof APP !== 'undefined') {
            APP.API.notifyChatUpdated(unreadCount, false);
        }

        if (isPollTabOpen) {
            dispatch(resetNbUnreadPollsMessages());
        }
        break;
    }

    case ENDPOINT_MESSAGE_RECEIVED: {
        const state = store.getState();

        if (!isReactionsEnabled(state)) {
            return next(action);
        }

        const { participant, data } = action;

        if (data?.name === ENDPOINT_REACTION_NAME) {
            store.dispatch(pushReactions(data.reactions));

            _handleReceivedMessage(store, {
                participantId: participant.getId(),
                message: getReactionMessageFromBuffer(data.reactions),
                privateMessage: false,
                lobbyChat: false,
                timestamp: data.timestamp
            }, false, true);
        }

        break;
    }

    case NON_PARTICIPANT_MESSAGE_RECEIVED: {
        const { participantId, json: data } = action;

        if (data?.type === MESSAGE_TYPE_SYSTEM && data.message) {
            _handleReceivedMessage(store, {
                displayName: data.displayName ?? i18next.t('chat.systemDisplayName'),
                participantId,
                lobbyChat: false,
                message: data.message,
                privateMessage: true,
                timestamp: Date.now()
            });
        }

        break;
    }

    case OPEN_CHAT:
        unreadCount = 0;

        if (typeof APP !== 'undefined') {
            APP.API.notifyChatUpdated(unreadCount, true);
        }
        break;

    case SET_IS_POLL_TAB_FOCUSED: {
        dispatch(resetNbUnreadPollsMessages());
        break;
    }

    case SEND_MESSAGE: {
        const state = store.getState();
        const conference = getCurrentConference(state);

        if (conference) {
            // There may be cases when we intend to send a private message but we forget to set the
            // recipient. This logic tries to mitigate this risk.
            const shouldSendPrivateMessageTo = _shouldSendPrivateMessageTo(state, action);

            const participantExists = shouldSendPrivateMessageTo
                && getParticipantById(state, shouldSendPrivateMessageTo);

            if (shouldSendPrivateMessageTo && participantExists) {
                dispatch(openDialog(ChatPrivacyDialog, {
                    message: action.message,
                    participantID: shouldSendPrivateMessageTo
                }));
            } else {
                // Sending the message if privacy notice doesn't need to be shown.

                const { privateMessageRecipient, isLobbyChatActive, lobbyMessageRecipient }
                    = state['features/chat'];

                if (typeof APP !== 'undefined') {
                    APP.API.notifySendingChatMessage(action.message, Boolean(privateMessageRecipient));
                }

                if (isLobbyChatActive && lobbyMessageRecipient) {
                    conference.sendLobbyMessage({
                        type: LOBBY_CHAT_MESSAGE,
                        message: action.message
                    }, lobbyMessageRecipient.id);
                    _persistSentPrivateMessage(store, lobbyMessageRecipient.id, action.message, true);
                } else if (privateMessageRecipient) {
                    conference.sendPrivateTextMessage(privateMessageRecipient.id, action.message);
                    _persistSentPrivateMessage(store, privateMessageRecipient.id, action.message);
                } else {
                    conference.sendTextMessage(action.message);
                }
            }
        }
        break;
    }

    case SEND_REACTION: {
        const state = store.getState();
        const conference = getCurrentConference(state);

        if (conference) {
            const { reaction, messageId, receiverId } = action;

            conference.sendReaction(reaction, messageId, receiverId);
        }
        break;
    }

    case ADD_REACTION_MESSAGE: {
        if (localParticipant?.id) {
            _handleReceivedMessage(store, {
                participantId: localParticipant.id,
                message: action.message,
                privateMessage: false,
                timestamp: Date.now(),
                lobbyChat: false
            }, false, true);
        }
    }
    }

    return next(action);
});

/**
 * Set up state change listener to perform maintenance tasks when the conference
 * is left or failed, e.g. Clear messages or close the chat modal if it's left
 * open.
 */
StateListenerRegistry.register(
    state => getCurrentConference(state),
    (conference, { dispatch, getState }, previousConference) => {
        if (conference !== previousConference) {
            // conference changed, left or failed...

            if (getState()['features/chat'].isOpen) {
                // Closes the chat if it's left open.
                dispatch(closeChat());
            }

            // Clear chat messages.
            dispatch(clearMessages());
        }
    });

StateListenerRegistry.register(
    state => state['features/chat'].isOpen,
    (isOpen, { dispatch }) => {
        if (typeof APP !== 'undefined' && isOpen) {
            dispatch(showToolbox());
        }
    }
);

/**
 * Registers listener for {@link JitsiConferenceEvents.MESSAGE_RECEIVED} that
 * will perform various chat related activities.
 *
 * @param {JitsiConference} conference - The conference instance on which the
 * new event listener will be registered.
 * @param {Object} store - The redux store object.
 * @private
 * @returns {void}
 */
function _addChatMsgListener(conference: IJitsiConference, store: IStore) {
    if (store.getState()['features/base/config'].iAmRecorder) {
        // We don't register anything on web if we are in iAmRecorder mode
        return;
    }

    conference.on(
        JitsiConferenceEvents.MESSAGE_RECEIVED,
        /* eslint-disable max-params */
        (participantId: string, message: string, timestamp: number,
                displayName: string, isGuest: boolean, messageId: string) => {
        /* eslint-enable max-params */
            _onConferenceMessageReceived(store, {
                // in case of messages coming from visitors we can have unknown id
                participantId: participantId || displayName,
                message,
                timestamp,
                displayName,
                isGuest,
                messageId,
                privateMessage: false });
        }
    );

    conference.on(
        JitsiConferenceEvents.REACTION_RECEIVED,
        (participantId: string, reactionList: string[], messageId: string) => {
            _onReactionReceived(store, {
                participantId,
                reactionList,
                messageId
            });
        }
    );

    conference.on(
        JitsiConferenceEvents.PRIVATE_MESSAGE_RECEIVED,
        (participantId: string, message: string, timestamp: number, messageId: string) => {
            _onConferenceMessageReceived(store, {
                participantId,
                message,
                timestamp,
                messageId,
                privateMessage: true
            });
        }
    );

    conference.on(
        JitsiConferenceEvents.CONFERENCE_ERROR, (errorType: string, error: Error) => {
            errorType === JitsiConferenceErrors.CHAT_ERROR && _handleChatError(store, error);
        });
}

/**
 * Handles a received message.
 *
 * @param {Object} store - Redux store.
 * @param {Object} message - The message object.
 * @returns {void}
 */
function _onConferenceMessageReceived(store: IStore,
        { displayName, isGuest, message, messageId, participantId, privateMessage, timestamp }: {
        displayName?: string; isGuest?: boolean; message: string; messageId?: string;
        participantId: string; privateMessage: boolean; timestamp: number; }
) {

    const isGif = isGifEnabled(store.getState()) && isGifMessage(message);

    if (isGif) {
        _handleGifMessageReceived(store, participantId, message);
        if (getGifDisplayMode(store.getState()) === 'tile') {
            return;
        }
    }
    _handleReceivedMessage(store, {
        displayName,
        isGuest,
        participantId,
        message,
        privateMessage,
        lobbyChat: false,
        timestamp,
        messageId
    }, true, isGif);
}

/**
 * Handles a received reaction.
 *
 * @param {Object} store - Redux store.
 * @param {string} participantId - Id of the participant that sent the message.
 * @param {string} reactionList - The list of received reactions.
 * @param {string} messageId - The id of the message that the reaction is for.
 * @returns {void}
 */
function _onReactionReceived(store: IStore, { participantId, reactionList, messageId }: {
    messageId: string; participantId: string; reactionList: string[]; }) {

    const reactionPayload = {
        participantId,
        reactionList,
        messageId
    };

    store.dispatch(addMessageReaction(reactionPayload));
}

/**
 * Handles a received gif message.
 *
 * @param {Object} store - Redux store.
 * @param {string} participantId - Id of the participant that sent the message.
 * @param {string} message - The message sent.
 * @returns {void}
 */
function _handleGifMessageReceived(store: IStore, participantId: string, message: string) {
    const url = extractGifURL(message);

    store.dispatch(addGif(participantId, url));
}

/**
 * Handles a chat error received from the xmpp server.
 *
 * @param {Store} store - The Redux store.
 * @param  {string} error - The error message.
 * @returns {void}
 */
function _handleChatError({ dispatch }: IStore, error: Error) {
    dispatch(addMessage({
        hasRead: true,
        messageType: MESSAGE_TYPE_ERROR,
        message: error,
        privateMessage: false,
        timestamp: Date.now()
    }));
}

/**
 * Function to handle an incoming chat message from lobby room.
 *
 * @param {string} message - The message received.
 * @param {string} participantId - The participant id.
 * @returns {Function}
 */
export function handleLobbyMessageReceived(message: string, participantId: string) {
    return async (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        _handleReceivedMessage({ dispatch,
            getState }, { participantId,
            message,
            privateMessage: false,
            lobbyChat: true,
            timestamp: Date.now() });
    };
}


/**
 * Function to get lobby chat user display name.
 *
 * @param {Store} state - The Redux store.
 * @param {string} participantId - The knocking participant id.
 * @returns {string}
 */
function getLobbyChatDisplayName(state: IReduxState, participantId: string) {
    const { knockingParticipants } = state['features/lobby'];
    const { lobbyMessageRecipient } = state['features/chat'];

    if (participantId === lobbyMessageRecipient?.id) {
        return lobbyMessageRecipient.name;
    }

    const knockingParticipant = knockingParticipants.find(p => p.id === participantId);

    if (knockingParticipant) {
        return knockingParticipant.name;
    }

}


/**
 * Function to handle an incoming chat message.
 *
 * @param {Store} store - The Redux store.
 * @param {Object} message - The message object.
 * @param {boolean} shouldPlaySound - Whether to play the incoming message sound.
 * @param {boolean} isReaction - Whether the message is a reaction message.
 * @returns {void}
 */
function _handleReceivedMessage({ dispatch, getState }: IStore,
        { displayName, isGuest, lobbyChat, message, messageId, participantId, privateMessage, timestamp }: {
        displayName?: string; isGuest?: boolean; lobbyChat: boolean; message: string;
        messageId?: string; participantId: string; privateMessage: boolean; timestamp: number; },
        shouldPlaySound = true,
        isReaction = false
) {
    // Logic for all platforms:
    const state = getState();
    const { isOpen: isChatOpen } = state['features/chat'];
    const { soundsIncomingMessage: soundEnabled, userSelectedNotifications } = state['features/base/settings'];

    if (soundEnabled && shouldPlaySound && !isChatOpen) {
        dispatch(playSound(INCOMING_MSG_SOUND_ID));
    }

    // Provide a default for the case when a message is being
    // backfilled for a participant that has left the conference.
    const participant = getParticipantById(state, participantId) || { local: undefined };

    const localParticipant = getLocalParticipant(getState);
    let displayNameToShow = lobbyChat
        ? getLobbyChatDisplayName(state, participantId)
        : displayName || getParticipantDisplayName(state, participantId);
    const hasRead = participant.local || isChatOpen;
    const timestampToDate = timestamp ? new Date(timestamp) : new Date();
    const millisecondsTimestamp = timestampToDate.getTime();

    // skip message notifications on join (the messages having timestamp - coming from the history)
    const shouldShowNotification = userSelectedNotifications?.['notify.chatMessages']
        && !hasRead && !isReaction && !timestamp;

    if (isGuest) {
        displayNameToShow = `${displayNameToShow} ${i18next.t('visitors.chatIndicator')}`;
    }

    dispatch(addMessage({
        displayName: displayNameToShow,
        hasRead,
        participantId,
        messageType: participant.local ? MESSAGE_TYPE_LOCAL : MESSAGE_TYPE_REMOTE,
        message,
        privateMessage,
        lobbyChat,
        recipient: getParticipantDisplayName(state, localParticipant?.id ?? ''),
        timestamp: millisecondsTimestamp,
        messageId,
        isReaction
    }));

    if (shouldShowNotification) {
        dispatch(showMessageNotification({
            title: displayNameToShow,
            description: message
        }, NOTIFICATION_TIMEOUT_TYPE.MEDIUM));
    }

    if (typeof APP !== 'undefined') {
        // Logic for web only:

        APP.API.notifyReceivedChatMessage({
            body: message,
            from: participantId,
            nick: displayNameToShow,
            privateMessage,
            ts: timestamp
        });
    }
}

/**
 * Persists the sent private messages as if they were received over the muc.
 *
 * This is required as we rely on the fact that we receive all messages from the muc that we send
 * (as they are sent to everybody), but we don't receive the private messages we send to another participant.
 * But those messages should be in the store as well, otherwise they don't appear in the chat window.
 *
 * @param {Store} store - The Redux store.
 * @param {string} recipientID - The ID of the recipient the private message was sent to.
 * @param {string} message - The sent message.
 * @param {boolean} isLobbyPrivateMessage - Is a lobby message.
 * @returns {void}
 */
function _persistSentPrivateMessage({ dispatch, getState }: IStore, recipientID: string,
        message: string, isLobbyPrivateMessage = false) {
    const state = getState();
    const localParticipant = getLocalParticipant(state);

    if (!localParticipant?.id) {
        return;
    }
    const displayName = getParticipantDisplayName(state, localParticipant.id);
    const { lobbyMessageRecipient } = state['features/chat'];

    dispatch(addMessage({
        displayName,
        hasRead: true,
        participantId: localParticipant.id,
        messageType: MESSAGE_TYPE_LOCAL,
        message,
        privateMessage: !isLobbyPrivateMessage,
        lobbyChat: isLobbyPrivateMessage,
        recipient: isLobbyPrivateMessage
            ? lobbyMessageRecipient?.name
            : getParticipantDisplayName(getState, recipientID),
        timestamp: Date.now()
    }));
}

/**
 * Returns the ID of the participant who we may have wanted to send the message
 * that we're about to send.
 *
 * @param {Object} state - The Redux state.
 * @param {Object} action - The action being dispatched now.
 * @returns {string?}
 */
function _shouldSendPrivateMessageTo(state: IReduxState, action: AnyAction) {
    if (action.ignorePrivacy) {
        // Shortcut: this is only true, if we already displayed the notice, so no need to show it again.
        return undefined;
    }

    const { messages, privateMessageRecipient } = state['features/chat'];

    if (privateMessageRecipient) {
        // We're already sending a private message, no need to warn about privacy.
        return undefined;
    }

    if (!messages.length) {
        // No messages yet, no need to warn for privacy.
        return undefined;
    }

    // Platforms sort messages differently
    const lastMessage = navigator.product === 'ReactNative'
        ? messages[0] : messages[messages.length - 1];

    if (lastMessage.messageType === MESSAGE_TYPE_LOCAL) {
        // The sender is probably aware of any private messages as already sent
        // a message since then. Doesn't make sense to display the notice now.
        return undefined;
    }

    if (lastMessage.privateMessage) {
        // We show the notice if the last received message was private.
        return lastMessage.participantId;
    }

    // But messages may come rapidly, we want to protect our users from mis-sending a message
    // even when there was a reasonable recently received private message.
    const now = Date.now();
    const recentPrivateMessages = messages.filter(
        message =>
            message.messageType !== MESSAGE_TYPE_LOCAL
            && message.privateMessage
            && message.timestamp + PRIVACY_NOTICE_TIMEOUT > now);
    const recentPrivateMessage = navigator.product === 'ReactNative'
        ? recentPrivateMessages[0] : recentPrivateMessages[recentPrivateMessages.length - 1];

    if (recentPrivateMessage) {
        return recentPrivateMessage.participantId;
    }

    return undefined;
}


################################################################################

## File: .\jitsi-meet\react\features\chat\reducer.ts

import { ILocalParticipant, IParticipant } from '../base/participants/types';
import ReducerRegistry from '../base/redux/ReducerRegistry';

import {
    ADD_MESSAGE,
    ADD_MESSAGE_REACTION,
    CLEAR_MESSAGES,
    CLOSE_CHAT,
    EDIT_MESSAGE,
    OPEN_CHAT,
    REMOVE_LOBBY_CHAT_PARTICIPANT,
    SET_IS_POLL_TAB_FOCUSED,
    SET_LOBBY_CHAT_ACTIVE_STATE,
    SET_LOBBY_CHAT_RECIPIENT,
    SET_PRIVATE_MESSAGE_RECIPIENT
} from './actionTypes';
import { IMessage } from './types';

const DEFAULT_STATE = {
    isOpen: false,
    isPollsTabFocused: false,
    lastReadMessage: undefined,
    messages: [],
    reactions: {},
    nbUnreadMessages: 0,
    privateMessageRecipient: undefined,
    lobbyMessageRecipient: undefined,
    isLobbyChatActive: false
};

export interface IChatState {
    isLobbyChatActive: boolean;
    isOpen: boolean;
    isPollsTabFocused: boolean;
    lastReadMessage?: IMessage;
    lobbyMessageRecipient?: {
        id: string;
        name: string;
    } | ILocalParticipant;
    messages: IMessage[];
    nbUnreadMessages: number;
    privateMessageRecipient?: IParticipant;
}

ReducerRegistry.register<IChatState>('features/chat', (state = DEFAULT_STATE, action): IChatState => {
    switch (action.type) {
    case ADD_MESSAGE: {
        const newMessage: IMessage = {
            displayName: action.displayName,
            error: action.error,
            participantId: action.participantId,
            isReaction: action.isReaction,
            messageId: action.messageId,
            messageType: action.messageType,
            message: action.message,
            reactions: action.reactions,
            privateMessage: action.privateMessage,
            lobbyChat: action.lobbyChat,
            recipient: action.recipient,
            timestamp: action.timestamp
        };

        // React native, unlike web, needs a reverse sorted message list.
        const messages = navigator.product === 'ReactNative'
            ? [
                newMessage,
                ...state.messages
            ]
            : [
                ...state.messages,
                newMessage
            ];

        return {
            ...state,
            lastReadMessage:
                action.hasRead ? newMessage : state.lastReadMessage,
            nbUnreadMessages: state.isPollsTabFocused ? state.nbUnreadMessages + 1 : state.nbUnreadMessages,
            messages
        };
    }

    case ADD_MESSAGE_REACTION: {
        const { participantId, reactionList, messageId } = action;

        const messages = state.messages.map(message => {
            if (messageId === message.messageId) {
                const newReactions = new Map(message.reactions);

                reactionList.forEach((reaction: string) => {
                    let participants = newReactions.get(reaction);

                    if (!participants) {
                        participants = new Set();
                        newReactions.set(reaction, participants);
                    }

                    participants.add(participantId);
                });

                return {
                    ...message,
                    reactions: newReactions
                };
            }

            return message;
        });

        return {
            ...state,
            messages
        };
    }

    case CLEAR_MESSAGES:
        return {
            ...state,
            lastReadMessage: undefined,
            messages: []
        };

    case EDIT_MESSAGE: {
        let found = false;
        const newMessage = action.message;
        const messages = state.messages.map(m => {
            if (m.messageId === newMessage.messageId) {
                found = true;

                return newMessage;
            }

            return m;
        });

        // no change
        if (!found) {
            return state;
        }

        return {
            ...state,
            messages
        };
    }

    case SET_PRIVATE_MESSAGE_RECIPIENT:
        return {
            ...state,
            privateMessageRecipient: action.participant
        };

    case OPEN_CHAT:
        return {
            ...state,
            isOpen: true,
            privateMessageRecipient: action.participant
        };

    case CLOSE_CHAT:
        return {
            ...state,
            isOpen: false,
            lastReadMessage: state.messages[
                navigator.product === 'ReactNative' ? 0 : state.messages.length - 1],
            privateMessageRecipient: action.participant,
            isLobbyChatActive: false
        };

    case SET_IS_POLL_TAB_FOCUSED: {
        return {
            ...state,
            isPollsTabFocused: action.isPollsTabFocused,
            nbUnreadMessages: 0
        }; }

    case SET_LOBBY_CHAT_RECIPIENT:
        return {
            ...state,
            isLobbyChatActive: true,
            lobbyMessageRecipient: action.participant,
            privateMessageRecipient: undefined,
            isOpen: action.open
        };
    case SET_LOBBY_CHAT_ACTIVE_STATE:
        return {
            ...state,
            isLobbyChatActive: action.payload,
            isOpen: action.payload || state.isOpen,
            privateMessageRecipient: undefined
        };
    case REMOVE_LOBBY_CHAT_PARTICIPANT:
        return {
            ...state,
            messages: state.messages.filter(m => {
                if (action.removeLobbyChatMessages) {
                    return !m.lobbyChat;
                }

                return true;
            }),
            isOpen: state.isOpen && state.isLobbyChatActive ? false : state.isOpen,
            isLobbyChatActive: false,
            lobbyMessageRecipient: undefined
        };
    }

    return state;
});


################################################################################

## File: .\jitsi-meet\react\features\chat\smileys.ts

export const smileys = {
    smiley1: ':)',
    smiley2: ':(',
    smiley3: ':D',
    smiley4: ':+1:',
    smiley5: ':P',
    smiley6: ':wave:',
    smiley7: ':blush:',
    smiley8: ':slightly_smiling_face:',
    smiley9: ':scream:',
    smiley10: ':*',
    smiley11: ':-1:',
    smiley12: ':mag:',
    smiley13: ':heart:',
    smiley14: ':innocent:',
    smiley15: ':angry:',
    smiley16: ':angel:',
    smiley17: ';(',
    smiley18: ':clap:',
    smiley19: ';)',
    smiley20: ':beer:'
};


################################################################################

## File: .\jitsi-meet\react\features\chat\sounds.ts

/**
 * The name of the bundled audio file which will be played for the incoming chat
 * message sound.
 *
 * @type {string}
 */
export const INCOMING_MSG_SOUND_FILE = 'incomingMessage.mp3';


################################################################################

## File: .\jitsi-meet\react\features\chat\types.ts

import { WithTranslation } from 'react-i18next';

import { IStore } from '../app/types';

export interface IMessage {
    displayName: string;
    error?: Object;
    isReaction: boolean;
    lobbyChat: boolean;
    message: string;
    messageId: string;
    messageType: string;
    participantId: string;
    privateMessage: boolean;
    reactions: Map<string, Set<string>>;
    recipient: string;
    timestamp: number;
}

/**
 * The type of the React {@code Component} props of {@code AbstractChat}.
 */
export interface IChatProps extends WithTranslation {

    /**
     * All the chat messages in the conference.
     */
    _messages: IMessage[];

    /**
     * Number of unread chat messages.
     */
    _nbUnreadMessages: number;

    /**
     * The Redux dispatch function.
     */
    dispatch: IStore['dispatch'];
}

export interface IChatMessageProps extends WithTranslation {

    /**
     * Whether the message can be replied to.
     */
    canReply?: boolean;

    /**
     * Whether gifs are enabled or not.
     */
    gifEnabled?: boolean;

    /**
     * Whether current participant is currently knocking in the lobby room.
     */
    knocking?: boolean;

    /**
     * The representation of a chat message.
     */
    message: IMessage;

    /**
     * Whether the chat message menu is visible or not.
     */
    shouldDisplayChatMessageMenu?: boolean;

    /**
     * Whether or not the avatar image of the participant which sent the message
     * should be displayed.
     */
    showAvatar?: boolean;

    /**
     * Whether or not the name of the participant which sent the message should
     * be displayed.
     */
    showDisplayName: boolean;

    /**
     * Whether or not the time at which the message was sent should be
     * displayed.
     */
    showTimestamp: boolean;
}


################################################################################

## File: .\jitsi-meet\react\features\chat\components\AbstractMessageContainer.ts

import { Component } from 'react';

import { IMessage } from '../types';

export interface IProps {

    /**
     * The messages array to render.
     */
    messages: IMessage[];
}

/**
 * Abstract component to display a list of chat messages, grouped by sender.
 *
 * @augments PureComponent
 */
export default class AbstractMessageContainer<P extends IProps, S> extends Component<P, S> {
    static defaultProps = {
        messages: [] as IMessage[]
    };

    /**
     * Iterates over all the messages and creates nested arrays which hold
     * consecutive messages sent by the same participant.
     *
     * @private
     * @returns {Array<Array<Object>>}
     */
    _getMessagesGroupedBySender() {
        const messagesCount = this.props.messages.length;
        const groups: IMessage[][] = [];
        let currentGrouping: IMessage[] = [];
        let currentGroupParticipantId;

        for (let i = 0; i < messagesCount; i++) {
            const message = this.props.messages[i];

            if (message.participantId === currentGroupParticipantId) {
                currentGrouping.push(message);
            } else {
                currentGrouping.length && groups.push(currentGrouping);

                currentGrouping = [ message ];
                currentGroupParticipantId = message.participantId;
            }
        }

        currentGrouping.length && groups.push(currentGrouping);

        return groups;
    }
}


################################################################################

## File: .\jitsi-meet\react\features\chat\components\AbstractMessageRecipient.ts

import { PureComponent } from 'react';
import { WithTranslation } from 'react-i18next';

import { IReduxState, IStore } from '../../app/types';
import { getParticipantDisplayName, isLocalParticipantModerator } from '../../base/participants/functions';
import { setLobbyChatActiveState, setPrivateMessageRecipient } from '../actions.any';


export interface IProps extends WithTranslation {

    /**
      * Is lobby messaging active.
      */
    _isLobbyChatActive: boolean;

    /**
      * The name of the lobby message recipient, if any.
      */
    _lobbyMessageRecipient?: string;

    /**
     * Function to make the lobby message recipient inactive.
     */
    _onHideLobbyChatRecipient: () => void;

    /**
     * Function to remove the recipient setting of the chat window.
     */
    _onRemovePrivateMessageRecipient: () => void;

    /**
     * The name of the message recipient, if any.
     */
    _privateMessageRecipient?: string;

    /**
      * Shows widget if it is necessary.
      */
    _visible: boolean;
}

/**
 * Abstract class for the {@code MessageRecipient} component.
 */
export default class AbstractMessageRecipient<P extends IProps> extends PureComponent<P> {

}

/**
 * Maps part of the props of this component to Redux actions.
 *
 * @param {Function} dispatch - The Redux dispatch function.
 * @returns {IProps}
 */
export function _mapDispatchToProps(dispatch: IStore['dispatch']) {
    return {
        _onRemovePrivateMessageRecipient: () => {
            dispatch(setPrivateMessageRecipient());
        },
        _onHideLobbyChatRecipient: () => {
            dispatch(setLobbyChatActiveState(false));
        }
    };
}

/**
 * Maps part of the Redux store to the props of this component.
 *
 * @param {Object} state - The Redux state.
 * @param {any} _ownProps - Components' own props.
 * @returns {IProps}
 */
export function _mapStateToProps(state: IReduxState, _ownProps: any) {
    const { privateMessageRecipient, lobbyMessageRecipient, isLobbyChatActive } = state['features/chat'];

    return {
        _privateMessageRecipient:
            privateMessageRecipient ? getParticipantDisplayName(state, privateMessageRecipient.id) : undefined,
        _isLobbyChatActive: isLobbyChatActive,
        _lobbyMessageRecipient:
                isLobbyChatActive && lobbyMessageRecipient ? lobbyMessageRecipient.name : undefined,
        _visible: isLobbyChatActive ? isLocalParticipantModerator(state) : true
    };
}


################################################################################

## File: .\jitsi-meet\react\features\chat\components\index.native.ts

// @ts-ignore
export { default as ChatPrivacyDialog } from './native/ChatPrivacyDialog';


################################################################################

## File: .\jitsi-meet\react\features\chat\components\index.web.ts

export { default as ChatPrivacyDialog } from './web/ChatPrivacyDialog';


################################################################################

## File: .\jitsi-meet\react\features\chat\components\native\ChatButton.ts

import { connect } from 'react-redux';

import { IReduxState } from '../../../app/types';
import { CHAT_ENABLED } from '../../../base/flags/constants';
import { getFeatureFlag } from '../../../base/flags/functions';
import { translate } from '../../../base/i18n/functions';
import { IconChatUnread, IconMessage } from '../../../base/icons/svg';
import AbstractButton, { IProps as AbstractButtonProps } from '../../../base/toolbox/components/AbstractButton';
import { arePollsDisabled } from '../../../conference/functions.any';
import { navigate } from '../../../mobile/navigation/components/conference/ConferenceNavigationContainerRef';
import { screen } from '../../../mobile/navigation/routes';
import { getUnreadPollCount } from '../../../polls/functions';
import { getUnreadCount } from '../../functions';

interface IProps extends AbstractButtonProps {

    /**
     * True if the polls feature is disabled.
     */
    _isPollsDisabled?: boolean;

    /**
     * The unread message count.
     */
    _unreadMessageCount: number;
}

/**
 * Implements an {@link AbstractButton} to open the chat screen on mobile.
 */
class ChatButton extends AbstractButton<IProps> {
    accessibilityLabel = 'toolbar.accessibilityLabel.chat';
    icon = IconMessage;
    label = 'toolbar.chat';
    toggledIcon = IconChatUnread;

    /**
     * Handles clicking / pressing the button, and opens the appropriate dialog.
     *
     * @private
     * @returns {void}
     */
    _handleClick() {
        this.props._isPollsDisabled
            ? navigate(screen.conference.chat)
            : navigate(screen.conference.chatandpolls.main);
    }

    /**
     * Renders the button toggled when there are unread messages.
     *
     * @protected
     * @returns {boolean}
     */
    _isToggled() {
        return Boolean(this.props._unreadMessageCount);
    }
}

/**
 * Maps part of the redux state to the component's props.
 *
 * @param {Object} state - The Redux state.
 * @param {Object} ownProps - The properties explicitly passed to the component instance.
 * @returns {IProps}
 */
function _mapStateToProps(state: IReduxState, ownProps: any) {
    const enabled = getFeatureFlag(state, CHAT_ENABLED, true);
    const { visible = enabled } = ownProps;

    return {
        _isPollsDisabled: arePollsDisabled(state),

        // The toggled icon should also be available for new polls
        _unreadMessageCount: getUnreadCount(state) || getUnreadPollCount(state),
        visible
    };
}

export default translate(connect(_mapStateToProps)(ChatButton));


################################################################################

## File: .\jitsi-meet\react\features\chat\components\native\styles.ts

import { BoxModel } from '../../../base/styles/components/styles/BoxModel';
import BaseTheme from '../../../base/ui/components/BaseTheme.native';

const BUBBLE_RADIUS = 8;

const recipientContainer = {
    alignItems: 'center',
    backgroundColor: BaseTheme.palette.support05,
    borderRadius: BaseTheme.shape.borderRadius,
    flexDirection: 'row',
    height: 48,
    marginBottom: BaseTheme.spacing[3],
    marginHorizontal: BaseTheme.spacing[3],
    padding: BaseTheme.spacing[2]
};

const inputBar = {
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'space-between'
};

/**
 * The styles of the feature chat.
 *
 * NOTE: Sizes and colors come from the 8x8 guidelines. This is the first
 * component to receive this treating, if others happen to have similar, we
 * need to extract the brand colors and sizes into a branding feature (planned
 * for the future).
 */
export default {

    /**
     * Background of the chat screen.
     */
    backdrop: {
        backgroundColor: BaseTheme.palette.ui10,
        flex: 1
    },

    emptyComponentText: {
        color: BaseTheme.palette.text03,
        textAlign: 'center'
    },

    lobbyMessageBubble: {
        backgroundColor: BaseTheme.palette.support06
    },

    lobbyMsgNotice: {
        color: BaseTheme.palette.text04,
        fontSize: 11,
        marginTop: 6
    },

    privateNotice: {
        ...BaseTheme.palette.bodyShortRegular,
        color: BaseTheme.palette.text02
    },

    privateMessageBubble: {
        backgroundColor: BaseTheme.palette.support05
    },

    remoteMessageBubble: {
        backgroundColor: BaseTheme.palette.ui02,
        borderTopLeftRadius: 0
    },

    replyContainer: {
        alignSelf: 'stretch',
        justifyContent: 'center'
    },

    replyStyles: {
        iconStyle: {
            color: BaseTheme.palette.icon01,
            fontSize: 22,
            padding: BaseTheme.spacing[2]
        },
        underlayColor: 'transparent'
    },

    /**
     * Wrapper View for the avatar.
     */
    avatarWrapper: {
        marginRight: BaseTheme.spacing[2],
        width: 32
    },

    chatLink: {
        color: BaseTheme.palette.link01
    },

    chatMessage: {
        ...BaseTheme.typography.bodyShortRegular,
        color: BaseTheme.palette.text01
    },

    /**
     * Wrapper for the details together, such as name, message and time.
     */
    detailsWrapper: {
        alignItems: 'flex-start',
        flex: 1,
        flexDirection: 'column'
    },

    emptyComponentWrapper: {
        alignSelf: 'center',
        flex: 1,
        padding: BoxModel.padding,
        paddingTop: '8%',
        maxWidth: '80%'
    },

    /**
     * A special padding to avoid issues on some devices (such as Android devices with custom suggestions bar).
     */
    extraBarPadding: {
        paddingBottom: 30
    },

    inputBarNarrow: {
        ...inputBar,
        height: 112,
        marginHorizontal: BaseTheme.spacing[3]
    },

    inputBarWide: {
        ...inputBar,
        height: 88,
        marginHorizontal: BaseTheme.spacing[9]
    },

    customInputContainer: {
        width: '75%'
    },

    messageBubble: {
        alignItems: 'center',
        borderRadius: BUBBLE_RADIUS,
        flexDirection: 'row'
    },

    /**
     * Wrapper View for the entire block.
     */
    messageWrapper: {
        alignItems: 'flex-start',
        flex: 1,
        flexDirection: 'row',
        marginHorizontal: 17,
        marginVertical: 4
    },

    /**
     * Style modifier for the {@code detailsWrapper} for own messages.
     */
    ownMessageDetailsWrapper: {
        alignItems: 'flex-end'
    },

    replyWrapper: {
        alignItems: 'center',
        flexDirection: 'row'
    },

    /**
     * Style modifier for system (error) messages.
     */
    systemMessageBubble: {
        backgroundColor: 'rgb(247, 215, 215)'
    },

    /**
     * Wrapper for the name and the message text.
     */
    textWrapper: {
        alignItems: 'flex-start',
        flexDirection: 'column',
        padding: 9
    },

    /**
     * Text node for the timestamp.
     */
    timeText: {
        color: BaseTheme.palette.text03,
        fontSize: 13
    },

    chatContainer: {
        backgroundColor: BaseTheme.palette.ui01,
        flex: 1
    },

    tabContainer: {
        flexDirection: 'row',
        justifyContent: 'center'
    },

    tabLeftButton: {
        flex: 1,
        borderTopLeftRadius: 0,
        borderTopRightRadius: 0,
        borderBottomLeftRadius: 0
    },

    tabRightButton: {
        flex: 1,
        borderTopLeftRadius: 0,
        borderTopRightRadius: 0,
        borderBottomRightRadius: 0
    },

    gifContainer: {
        maxHeight: 150
    },

    gifImage: {
        resizeMode: 'contain',
        width: 250,
        height: undefined,
        flexGrow: 1
    },

    senderDisplayName: {
        ...BaseTheme.typography.bodyShortBold,
        color: BaseTheme.palette.text02
    },

    localMessageBubble: {
        backgroundColor: BaseTheme.palette.ui04,
        borderTopRightRadius: 0
    },

    lobbyMessageRecipientContainer: {
        ...recipientContainer,
        backgroundColor: BaseTheme.palette.support06
    },

    messageRecipientCancelIcon: {
        color: BaseTheme.palette.icon01,
        fontSize: 18
    },

    messageRecipientContainer: {
        ...recipientContainer
    },

    messageRecipientText: {
        ...BaseTheme.typography.bodyShortRegular,
        color: BaseTheme.palette.text01,
        flex: 1
    }
};


################################################################################

## File: .\jitsi-meet\react\features\chrome-extension-banner\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/chrome-banner');


################################################################################

## File: .\jitsi-meet\react\features\chrome-extension-banner\components\ChromeExtensionBanner.native.ts



################################################################################

## File: .\jitsi-meet\react\features\conference\actions.native.ts

import { IStore } from '../app/types';
import { hideDialog, openDialog } from '../base/dialog/actions';
import AlertDialog from '../base/dialog/components/native/AlertDialog';
import { getParticipantDisplayName } from '../base/participants/functions';

import { DISMISS_CALENDAR_NOTIFICATION } from './actionTypes';


/**
 * Notify that we've been kicked out of the conference.
 *
 * @param {JitsiParticipant} participant - The {@link JitsiParticipant}
 * instance which initiated the kick event.
 * @param {?Function} submit - The function to execute after submiting the dialog.
 * @returns {Function}
 */
export function notifyKickedOut(participant: any, submit?: Function) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        if (!participant || participant?.isReplaced?.()) {
            submit?.();

            return;
        }

        dispatch(openDialog(AlertDialog, {
            contentKey: {
                key: 'dialog.kickTitle',
                params: {
                    participantDisplayName: getParticipantDisplayName(getState, participant.getId())
                }
            },
            onSubmit: submit
        }));
    };
}

/**
 * Notify that we've been kicked out of the conference.
 *
 * @param {string} reasonKey - The translation key for the reason why the conference failed.
 * @param {?Function} submit - The function to execute after submiting the dialog.
 * @returns {Function}
 */
export function notifyConferenceFailed(reasonKey: string, submit?: Function) {
    return (dispatch: IStore['dispatch']) => {
        if (!reasonKey) {
            submit?.();

            return;
        }

        // we have to push the opening of the dialog to the queue
        // so that we make sure it will be visible after the events
        // of conference destroyed are done
        setTimeout(() => dispatch(openDialog(AlertDialog, {
            contentKey: {
                key: reasonKey
            },
            params: {
            },
            onSubmit: () => {
                submit?.();
                dispatch(hideDialog(AlertDialog));
            }
        })));
    };
}

/**
 * Dismisses calendar notification about next or ongoing event.
 *
 * @returns {Object}
 */
export function dismissCalendarNotification() {
    return {
        type: DISMISS_CALENDAR_NOTIFICATION
    };
}


################################################################################

## File: .\jitsi-meet\react\features\conference\actions.web.ts

import { IStore } from '../app/types';
import { configureInitialDevices, getAvailableDevices } from '../base/devices/actions.web';
import { openDialog } from '../base/dialog/actions';
import { getBackendSafeRoomName } from '../base/util/uri';

import { DISMISS_CALENDAR_NOTIFICATION } from './actionTypes';
import LeaveReasonDialog from './components/web/LeaveReasonDialog.web';
import logger from './logger';

/**
 * Opens {@code LeaveReasonDialog}.
 *
 * @param {string} [title] - The dialog title.
 *
 * @returns {Promise} Resolved when the dialog is closed.
 */
export function openLeaveReasonDialog(title?: string) {
    return (dispatch: IStore['dispatch']): Promise<void> => new Promise(resolve => {
        dispatch(openDialog(LeaveReasonDialog, {
            onClose: resolve,
            title
        }));
    });
}

/**
 * Dismisses calendar notification about next or ongoing event.
 *
 * @returns {Object}
 */
export function dismissCalendarNotification() {
    return {
        type: DISMISS_CALENDAR_NOTIFICATION
    };
}

/**
 * Setups initial devices. Makes sure we populate availableDevices list before configuring.
 *
 * @returns {Promise<any>}
 */
export function setupInitialDevices() {
    return async (dispatch: IStore['dispatch']) => {
        await dispatch(getAvailableDevices());
        await dispatch(configureInitialDevices());
    };
}

/**
 * Init.
 *
 * @returns {Promise<JitsiConnection>}
 */
export function init() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const room = getBackendSafeRoomName(getState()['features/base/conference'].room);

        // XXX For web based version we use conference initialization logic
        // from the old app (at the moment of writing).
        return dispatch(setupInitialDevices()).then(
            () => APP.conference.init({
                roomName: room
            }).catch((error: Error) => {
                APP.API.notifyConferenceLeft(APP.conference.roomName);
                logger.error(error);
            }));
    };
}


################################################################################

## File: .\jitsi-meet\react\features\conference\actionTypes.ts

/**
 * The type of (redux) action which dismisses calendar notification.
 *
 * {
 *     type: DISMISS_CALENDAR_NOTIFICATION
 * }
 */
export const DISMISS_CALENDAR_NOTIFICATION = 'DISMISS_CALENDAR_NOTIFICATION';


################################################################################

## File: .\jitsi-meet\react\features\conference\constants.ts

import { IFRAME_EMBED_ALLOWED_LOCATIONS as ADDITIONAL_LOCATIONS } from './extraConstants';

/**
 * Timeout of the conference when iframe is disabled in minutes.
 */
export const IFRAME_DISABLED_TIMEOUT_MINUTES = 5;

/**
 * A list of allowed location to embed iframe.
 */
/* eslint-disable-next-line no-extra-parens*/
export const IFRAME_EMBED_ALLOWED_LOCATIONS = ([] as string[]).concat(ADDITIONAL_LOCATIONS);


################################################################################

## File: .\jitsi-meet\react\features\conference\extraConstants.ts

/**
 * Deploy-specific configuration constants.
 */

export const IFRAME_EMBED_ALLOWED_LOCATIONS = [];


################################################################################

## File: .\jitsi-meet\react\features\conference\functions.any.ts

import { IStateful } from '../base/app/types';
import { toState } from '../base/redux/functions';
import { iAmVisitor } from '../visitors/functions';


/**
 * Tells whether or not the notifications should be displayed within
 * the conference feature based on the current Redux state.
 *
 * @param {Object|Function} stateful - The redux store state.
 * @returns {boolean}
 */
export function shouldDisplayNotifications(stateful: IStateful) {
    const state = toState(stateful);
    const { calleeInfoVisible } = state['features/invite'];

    return !calleeInfoVisible;
}


/**
 *
 * Returns true if polls feature is disabled.
 *
 * @param {(Function|Object)} stateful - The (whole) redux state, or redux's
 * {@code getState} function to be used to retrieve the state
 * features/base/config.
 * @returns {boolean}
 */
export function arePollsDisabled(stateful: IStateful) {
    const state = toState(stateful);

    return state['features/base/config']?.disablePolls || iAmVisitor(state);
}


################################################################################

## File: .\jitsi-meet\react\features\conference\functions.native.ts

export * from './functions.any';


################################################################################

## File: .\jitsi-meet\react\features\conference\functions.web.ts

import { IStore } from '../app/types';
import { isSuboptimalBrowser } from '../base/environment/environment';
import { translateToHTML } from '../base/i18n/functions';
import { showWarningNotification } from '../notifications/actions';
import { NOTIFICATION_TIMEOUT_TYPE } from '../notifications/constants';

export * from './functions.any';

/**
 * Shows the suboptimal experience notification if needed.
 *
 * @param {Function} dispatch - The dispatch method.
 * @param {Function} t - The translation function.
 * @returns {void}
 */
export function maybeShowSuboptimalExperienceNotification(dispatch: IStore['dispatch'], t: Function) {
    if (isSuboptimalBrowser()) {
        dispatch(
            showWarningNotification(
                {
                    titleKey: 'notify.suboptimalExperienceTitle',
                    description: translateToHTML(
                        t,
                        'notify.suboptimalBrowserWarning',
                        {
                            recommendedBrowserPageLink: `${window.location.origin}/static/recommendedBrowsers.html`
                        }
                    )
                }, NOTIFICATION_TIMEOUT_TYPE.LONG
            )
        );
    }
}


################################################################################

## File: .\jitsi-meet\react\features\conference\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/conference');


################################################################################

## File: .\jitsi-meet\react\features\conference\middleware.any.ts

import i18n from 'i18next';
import { batch } from 'react-redux';

// @ts-expect-error
import { API_ID } from '../../../modules/API/constants';
import { appNavigate } from '../app/actions';
import { redirectToStaticPage } from '../app/actions.any';
import { IReduxState, IStore } from '../app/types';
import {
    CONFERENCE_FAILED,
    CONFERENCE_JOINED,
    CONFERENCE_LEFT,
    ENDPOINT_MESSAGE_RECEIVED
} from '../base/conference/actionTypes';
import { getCurrentConference } from '../base/conference/functions';
import { getDisableLowerHandByModerator } from '../base/config/functions.any';
import { getURLWithoutParamsNormalized } from '../base/connection/utils';
import { hideDialog } from '../base/dialog/actions';
import { isDialogOpen } from '../base/dialog/functions';
import { getLocalizedDateFormatter } from '../base/i18n/dateUtil';
import { translateToHTML } from '../base/i18n/functions';
import i18next from '../base/i18n/i18next';
import { browser } from '../base/lib-jitsi-meet';
import { pinParticipant, raiseHand, raiseHandClear } from '../base/participants/actions';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import StateListenerRegistry from '../base/redux/StateListenerRegistry';
import { SET_REDUCED_UI } from '../base/responsive-ui/actionTypes';
import { LOWER_HAND_MESSAGE } from '../base/tracks/constants';
import { BUTTON_TYPES } from '../base/ui/constants.any';
import { inIframe } from '../base/util/iframeUtils';
import { isCalendarEnabled } from '../calendar-sync/functions';
import FeedbackDialog from '../feedback/components/FeedbackDialog';
import { setFilmstripEnabled } from '../filmstrip/actions.any';
import { isVpaasMeeting } from '../jaas/functions';
import { hideNotification, showNotification, showWarningNotification } from '../notifications/actions';
import {
    CALENDAR_NOTIFICATION_ID,
    NOTIFICATION_ICON,
    NOTIFICATION_TIMEOUT_TYPE
} from '../notifications/constants';
import { showStartRecordingNotification } from '../recording/actions';
import { showSalesforceNotification } from '../salesforce/actions';
import { setToolboxEnabled } from '../toolbox/actions.any';

import { DISMISS_CALENDAR_NOTIFICATION } from './actionTypes';
import { dismissCalendarNotification } from './actions';
import { IFRAME_DISABLED_TIMEOUT_MINUTES, IFRAME_EMBED_ALLOWED_LOCATIONS } from './constants';


let intervalID: any;


MiddlewareRegistry.register(store => next => action => {
    const result = next(action);

    switch (action.type) {
    case CONFERENCE_JOINED: {
        _conferenceJoined(store);

        break;
    }

    case SET_REDUCED_UI: {
        _setReducedUI(store);

        break;
    }

    case DISMISS_CALENDAR_NOTIFICATION:
    case CONFERENCE_LEFT:
    case CONFERENCE_FAILED: {
        clearInterval(intervalID);
        intervalID = null;

        break;
    }
    case ENDPOINT_MESSAGE_RECEIVED: {
        const { participant, data } = action;
        const { dispatch, getState } = store;

        if (data.name === LOWER_HAND_MESSAGE
            && participant.isModerator()
            && !getDisableLowerHandByModerator(getState())) {
            dispatch(raiseHand(false));
        }
        break;
    }
    }

    return result;
});

/**
 * Set up state change listener to perform maintenance tasks when the conference
 * is left or failed, close all dialogs and unpin any pinned participants.
 */
StateListenerRegistry.register(
    state => getCurrentConference(state),
    (conference, { dispatch, getState }, prevConference) => {
        const { authRequired, membersOnly, passwordRequired }
            = getState()['features/base/conference'];

        if (conference !== prevConference) {
            // Unpin participant, in order to avoid the local participant
            // remaining pinned, since it's not destroyed across runs.
            dispatch(pinParticipant(null));

            // Clear raised hands.
            dispatch(raiseHandClear());

            // XXX I wonder if there is a better way to do this. At this stage
            // we do know what dialogs we want to keep but the list of those
            // we want to hide is a lot longer. Thus we take a bit of a shortcut
            // and explicitly check.
            if (typeof authRequired === 'undefined'
                    && typeof passwordRequired === 'undefined'
                    && typeof membersOnly === 'undefined'
                    && !isDialogOpen(getState(), FeedbackDialog)) {
                // Conference changed, left or failed... and there is no
                // pending authentication, nor feedback request, so close any
                // dialog we might have open.
                dispatch(hideDialog());
            }
        }
    });

/**
 * Configures the UI. In reduced UI mode some components will
 * be hidden if there is no space to render them.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @private
 * @returns {void}
 */
function _setReducedUI({ dispatch, getState }: IStore) {
    const { reducedUI } = getState()['features/base/responsive-ui'];

    dispatch(setToolboxEnabled(!reducedUI));
    dispatch(setFilmstripEnabled(!reducedUI));
}

/**
 * Does extra sync up on properties that may need to be updated after the
 * conference was joined.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @private
 * @returns {void}
 */
function _conferenceJoined({ dispatch, getState }: IStore) {
    _setReducedUI({
        dispatch,
        getState
    });

    if (!intervalID) {
        intervalID = setInterval(() =>
            _maybeDisplayCalendarNotification({
                dispatch,
                getState
            }), 10 * 1000);
    }

    dispatch(showSalesforceNotification());
    dispatch(showStartRecordingNotification());

    _checkIframe(getState(), dispatch);
}

/**
 * Additional checks for embedding in iframe.
 *
 * @param {IReduxState} state - The current state of the app.
 * @param {Function} dispatch - The Redux dispatch function.
 * @private
 * @returns {void}
 */
function _checkIframe(state: IReduxState, dispatch: IStore['dispatch']) {
    let allowIframe = false;

    if (document.referrer === '' && browser.isElectron()) {
        // no iframe
        allowIframe = true;
    } else {
        try {
            allowIframe = IFRAME_EMBED_ALLOWED_LOCATIONS.includes(new URL(document.referrer).hostname);
        } catch (e) {
            // wrong URL in referrer
        }
    }

    if (inIframe() && state['features/base/config'].disableIframeAPI && !browser.isElectron()
        && !isVpaasMeeting(state) && !allowIframe) {
        // show sticky notification and redirect in 5 minutes
        const { locationURL } = state['features/base/connection'];
        let translationKey = 'notify.disabledIframe';
        const hostname = locationURL?.hostname ?? '';
        let domain = '';

        const mapping: Record<string, string> = {
            '8x8.vc': 'https://jaas.8x8.vc',
            'meet.jit.si': 'https://jitsi.org/jaas'
        };

        const jaasDomain = mapping[hostname];

        if (jaasDomain) {
            translationKey = 'notify.disabledIframeSecondary';
            domain = hostname;
        }

        dispatch(showWarningNotification({
            description: translateToHTML(
                i18next.t.bind(i18next),
                translationKey,
                {
                    domain,
                    jaasDomain,
                    timeout: IFRAME_DISABLED_TIMEOUT_MINUTES
                }
            )
        }, NOTIFICATION_TIMEOUT_TYPE.STICKY));

        setTimeout(() => {
            // redirect to the promotional page
            dispatch(redirectToStaticPage('static/close3.html', `#jitsi_meet_external_api_id=${API_ID}`));
        }, IFRAME_DISABLED_TIMEOUT_MINUTES * 60 * 1000);
    }
}

/**
 * Periodically checks if there is an event in the calendar for which we
 * need to show a notification.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @private
 * @returns {void}
 */
function _maybeDisplayCalendarNotification({ dispatch, getState }: IStore) {
    const state = getState();

    const calendarEnabled = isCalendarEnabled(state);
    const { events: eventList } = state['features/calendar-sync'];
    const { locationURL } = state['features/base/connection'];
    const { reducedUI } = state['features/base/responsive-ui'];

    const currentConferenceURL
        = locationURL ? getURLWithoutParamsNormalized(locationURL) : '';
    const ALERT_MILLISECONDS = 5 * 60 * 1000;
    const now = Date.now();

    let eventToShow;

    if (!calendarEnabled && reducedUI) {
        return;
    }

    if (eventList?.length) {

        for (const event of eventList) {
            const eventURL
                = event?.url && getURLWithoutParamsNormalized(new URL(event.url));

            if (eventURL && eventURL !== currentConferenceURL) {
                // @ts-ignore
                if ((!eventToShow && event.startDate > now && event.startDate < now + ALERT_MILLISECONDS)

                    // @ts-ignore
                    || (event.startDate < now && event.endDate > now)) {
                    eventToShow = event;
                }
            }
        }
    }

    _calendarNotification(
        {
            dispatch,
            getState
        }, eventToShow
    );
}

/**
 * Calendar notification.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @param {eventToShow} eventToShow - Next or ongoing event.
 * @private
 * @returns {void}
 */
function _calendarNotification({ dispatch, getState }: IStore, eventToShow: any) {
    const state = getState();

    const { locationURL } = state['features/base/connection'];

    const currentConferenceURL
        = locationURL ? getURLWithoutParamsNormalized(locationURL) : '';
    const now = Date.now();

    if (!eventToShow) {
        return;
    }

    const customActionNameKey = [ 'notify.joinMeeting', 'notify.dontRemindMe' ];
    const customActionType = [ BUTTON_TYPES.PRIMARY, BUTTON_TYPES.DESTRUCTIVE ];
    const customActionHandler = [ () => batch(() => {
        dispatch(hideNotification(CALENDAR_NOTIFICATION_ID));
        if (eventToShow?.url && (eventToShow.url !== currentConferenceURL)) {
            dispatch(appNavigate(eventToShow.url));
        }
    }), () => dispatch(dismissCalendarNotification()) ];
    const description
        = getLocalizedDateFormatter(eventToShow.startDate).fromNow();
    const icon = NOTIFICATION_ICON.WARNING;
    const title = (eventToShow.startDate < now) && (eventToShow.endDate > now)
        ? `${i18n.t('calendarSync.ongoingMeeting')}: \n${eventToShow.title}`
        : `${i18n.t('calendarSync.nextMeeting')}: \n${eventToShow.title}`;
    const uid = CALENDAR_NOTIFICATION_ID;

    dispatch(showNotification({
        customActionHandler,
        customActionNameKey,
        customActionType,
        description,
        icon,
        maxLines: 1,
        title,
        uid
    }, NOTIFICATION_TIMEOUT_TYPE.STICKY));
}


################################################################################

## File: .\jitsi-meet\react\features\conference\middleware.native.ts

import { appNavigate } from '../app/actions.native';
import { KICKED_OUT } from '../base/conference/actionTypes';
import { conferenceLeft } from '../base/conference/actions';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';

import { notifyKickedOut } from './actions.native';

import './middleware.any';

MiddlewareRegistry.register(store => next => action => {
    switch (action.type) {
    case KICKED_OUT: {
        const { dispatch } = store;

        dispatch(notifyKickedOut(
          action.participant,
          () => {
              dispatch(conferenceLeft(action.conference));
              dispatch(appNavigate(undefined));
          }
        ));

        break;
    }
    }

    return next(action);
});


################################################################################

## File: .\jitsi-meet\react\features\conference\middleware.web.ts

import i18next from 'i18next';

import { ENDPOINT_MESSAGE_RECEIVED, KICKED_OUT } from '../base/conference/actionTypes';
import { hangup } from '../base/connection/actions.web';
import { getParticipantDisplayName } from '../base/participants/functions';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import { openAllowToggleCameraDialog, setCameraFacingMode } from '../base/tracks/actions.web';
import { CAMERA_FACING_MODE_MESSAGE } from '../base/tracks/constants';

import './middleware.any';

MiddlewareRegistry.register(store => next => action => {
    switch (action.type) {
    case ENDPOINT_MESSAGE_RECEIVED: {
        const { participant, data } = action;

        if (data?.name === CAMERA_FACING_MODE_MESSAGE) {
            APP.store.dispatch(openAllowToggleCameraDialog(
                /* onAllow */ () => APP.store.dispatch(setCameraFacingMode(data.facingMode)),
                /* initiatorId */ participant.getId()
            ));
        }
        break;
    }

    case KICKED_OUT: {
        const { dispatch } = store;
        const { participant } = action;

        const participantDisplayName
                = getParticipantDisplayName(store.getState, participant.getId());

        dispatch(hangup(true, i18next.t('dialog.kickTitle', { participantDisplayName })));

        break;
    }
    }

    return next(action);
});


################################################################################

## File: .\jitsi-meet\react\features\conference\components\AbstractConference.ts

import React, { Component } from 'react';

import { IReduxState } from '../../app/types';
import { NotificationsContainer } from '../../notifications/components';
import { shouldDisplayTileView } from '../../video-layout/functions.any';
import { shouldDisplayNotifications } from '../functions';

/**
 * The type of the React {@code Component} props of {@link AbstractLabels}.
 */
export type AbstractProps = {

    /**
     * Set to {@code true} when the notifications are to be displayed.
     *
     * @protected
     * @type {boolean}
     */
    _notificationsVisible: boolean;

    /**
     * Conference room name.
     *
     * @protected
     * @type {string}
     */
    _room: string;

    /**
     * Whether or not the layout should change to support tile view mode.
     *
     * @protected
     * @type {boolean}
     */
    _shouldDisplayTileView: boolean;
};

/**
 * A container to hold video status labels, including recording status and
 * current large video quality.
 *
 * @augments Component
 */
export class AbstractConference<P extends AbstractProps, S>
    extends Component<P, S> {

    /**
     * Renders the {@code LocalRecordingLabel}.
     *
     * @param {Object} props - The properties to be passed to
     * the {@code NotificationsContainer}.
     * @protected
     * @returns {React$Element}
     */
    renderNotificationsContainer(props?: any) {
        if (this.props._notificationsVisible) {
            return (
                React.createElement(NotificationsContainer, props)
            );
        }

        return null;
    }
}

/**
 * Maps (parts of) the redux state to the associated props of the {@link Labels}
 * {@code Component}.
 *
 * @param {Object} state - The redux state.
 * @private
 * @returns {AbstractProps}
 */
export function abstractMapStateToProps(state: IReduxState) {
    return {
        _notificationsVisible: shouldDisplayNotifications(state),
        _room: state['features/base/conference'].room ?? '',
        _shouldDisplayTileView: shouldDisplayTileView(state)
    };
}


################################################################################

## File: .\jitsi-meet\react\features\conference\components\constants.ts

export const CONFERENCE_INFO = {
    alwaysVisible: [ 'raised-hands-count', 'recording' ],
    autoHide: [
        'highlight-moment',
        'subject',
        'conference-timer',
        'participants-count',
        'e2ee',
        'transcribing',
        'video-quality',
        'visitors-count',
        'insecure-room',
        'top-panel-toggle'
    ]
};


################################################################################

## File: .\jitsi-meet\react\features\conference\components\functions.any.ts

import { IReduxState } from '../../app/types';

import { CONFERENCE_INFO } from './constants';

/**
 * Retrieves the conference info labels based on config values and defaults.
 *
 * @param {Object} state - The redux state.
 * @returns {Object} The conferenceInfo object.
 */
export const getConferenceInfo = (state: IReduxState) => {
    const { conferenceInfo } = state['features/base/config'];

    if (conferenceInfo) {
        return {
            alwaysVisible: conferenceInfo.alwaysVisible ?? CONFERENCE_INFO.alwaysVisible,
            autoHide: conferenceInfo.autoHide ?? CONFERENCE_INFO.autoHide
        };
    }

    return CONFERENCE_INFO;
};


################################################################################

## File: .\jitsi-meet\react\features\conference\components\functions.native.ts

import { IReduxState } from '../../app/types';

export * from './functions.any';

/**
 * Returns whether the conference is in connecting state.
 *
 * @param {Object} state - The redux state.
 * @returns {boolean} Whether conference is connecting.
 */
export const isConnecting = (state: IReduxState) => {
    const { connecting, connection } = state['features/base/connection'];
    const {
        conference,
        joining,
        membersOnly,
        leaving
    } = state['features/base/conference'];

    // XXX There is a window of time between the successful establishment of the
    // XMPP connection and the subsequent commencement of joining the MUC during
    // which the app does not appear to be doing anything according to the redux
    // state. In order to not toggle the _connecting props during the window of
    // time in question, define _connecting as follows:
    // - the XMPP connection is connecting, or
    // - the XMPP connection is connected and the conference is joining, or
    // - the XMPP connection is connected and we have no conference yet, nor we
    //   are leaving one.
    return Boolean(
        connecting || (connection && (!membersOnly && (joining || (!conference && !leaving))))
    );
};


################################################################################

## File: .\jitsi-meet\react\features\conference\components\functions.web.ts

export * from './functions.any';

/**
 * Whether or not there are always on labels.
 *
 * @returns {boolean}
 */
export function isAlwaysOnTitleBarEmpty() {
    const bar = document.querySelector('#alwaysVisible>div');

    return bar?.childNodes.length === 0;
}


################################################################################

## File: .\jitsi-meet\react\features\conference\components\index.native.ts

export { default as ConferenceTimerDisplay } from './native/ConferenceTimerDisplay';


################################################################################

## File: .\jitsi-meet\react\features\conference\components\index.web.ts

export { default as ConferenceTimerDisplay } from './web/ConferenceTimerDisplay';


################################################################################

## File: .\jitsi-meet\react\features\conference\components\native\constants.ts

import React from 'react';

import { JitsiRecordingConstants } from '../../../base/lib-jitsi-meet';
import RecordingExpandedLabel from '../../../recording/components/native/RecordingExpandedLabel';
import VideoQualityExpandedLabel from '../../../video-quality/components/VideoQualityExpandedLabel.native';

import InsecureRoomNameExpandedLabel from './InsecureRoomNameExpandedLabel';
import RaisedHandsCountExpandedLabel from './RaisedHandsCountExpandedLabel';

export const LabelHitSlop = {
    top: 10,
    bottom: 10,
    left: 0,
    right: 0
};

/**
 * Timeout to hide the {@ExpandedLabel}.
 */
export const EXPANDED_LABEL_TIMEOUT = 5000;

export const LABEL_ID_QUALITY = 'quality';
export const LABEL_ID_RECORDING = 'recording';
export const LABEL_ID_STREAMING = 'streaming';
export const LABEL_ID_INSECURE_ROOM_NAME = 'insecure-room-name';
export const LABEL_ID_RAISED_HANDS_COUNT = 'raised-hands-count';
export const LABEL_ID_VISITORS_COUNT = 'visitors-count';

interface IExpandedLabel {
    alwaysOn?: boolean;
    component: React.ComponentType<any>;
    props?: any;
}

/**
 * The {@code ExpandedLabel} components to be rendered for the individual
 * {@code Label}s.
 */
export const EXPANDED_LABELS: {
    [key: string]: IExpandedLabel;
} = {
    [LABEL_ID_QUALITY]: {
        component: VideoQualityExpandedLabel
    },
    [LABEL_ID_RECORDING]: {
        component: RecordingExpandedLabel,
        props: {
            mode: JitsiRecordingConstants.mode.FILE
        },
        alwaysOn: true
    },
    [LABEL_ID_STREAMING]: {
        component: RecordingExpandedLabel,
        props: {
            mode: JitsiRecordingConstants.mode.STREAM
        },
        alwaysOn: true
    },
    [LABEL_ID_INSECURE_ROOM_NAME]: {
        component: InsecureRoomNameExpandedLabel
    },
    [LABEL_ID_RAISED_HANDS_COUNT]: {
        component: RaisedHandsCountExpandedLabel,
        alwaysOn: true
    }
};


################################################################################

## File: .\jitsi-meet\react\features\conference\components\native\RaisedHandsCountExpandedLabel.ts

import { WithTranslation } from 'react-i18next';

import { translate } from '../../../base/i18n/functions';
import ExpandedLabel, { IProps as AbstractProps } from '../../../base/label/components/native/ExpandedLabel';

type Props = AbstractProps & WithTranslation;

/**
 * A react {@code Component} that implements an expanded label as tooltip-like
 * component to explain the meaning of the {@code RaisedHandsCountExpandedLabel}.
 */
class RaisedHandsCountExpandedLabel extends ExpandedLabel<Props> {

    /**
     * Returns the label specific text of this {@code ExpandedLabel}.
     *
     * @returns {string}
     */
    _getLabel() {
        return this.props.t('raisedHandsLabel');
    }
}

export default translate(RaisedHandsCountExpandedLabel);


################################################################################

## File: .\jitsi-meet\react\features\conference\components\native\styles.ts

import BaseTheme from '../../../base/ui/components/BaseTheme.native';

export const INSECURE_ROOM_NAME_LABEL_COLOR = BaseTheme.palette.actionDanger;

const TITLE_BAR_BUTTON_SIZE = 24;


/**
 * The styles of the safe area view that contains the title bar.
 */
const titleBarSafeView = {
    left: 0,
    position: 'absolute',
    right: 0,
    top: 0
};

const alwaysOnTitleBar = {
    alignItems: 'center',
    alignSelf: 'flex-end',
    backgroundColor: 'rgba(0, 0, 0, .5)',
    borderRadius: BaseTheme.shape.borderRadius,
    flexDirection: 'row',
    justifyContent: 'center',
    marginTop: BaseTheme.spacing[3],
    paddingRight: BaseTheme.spacing[0],
    '&:not(:empty)': {
        padding: BaseTheme.spacing[1]
    }
};

/**
 * The styles of the feature conference.
 */
export default {

    /**
     * {@code Conference} Style.
     */
    conference: {
        alignSelf: 'stretch',
        backgroundColor: BaseTheme.palette.uiBackground,
        flex: 1
    },

    displayNameContainer: {
        margin: BaseTheme.spacing[3]
    },

    /**
     * View that contains the indicators.
     */
    indicatorContainer: {
        flex: 1,
        flexDirection: 'row'
    },

    titleBarButtonContainer: {
        borderRadius: 3,
        height: BaseTheme.spacing[7],
        marginTop: BaseTheme.spacing[1],
        marginRight: BaseTheme.spacing[1],
        zIndex: 1,
        width: BaseTheme.spacing[7]
    },

    titleBarButton: {
        iconStyle: {
            color: BaseTheme.palette.icon01,
            padding: 12,
            fontSize: TITLE_BAR_BUTTON_SIZE
        },
        underlayColor: 'transparent'
    },

    lonelyMeetingContainer: {
        alignSelf: 'stretch',
        alignItems: 'center',
        padding: BaseTheme.spacing[3]
    },

    lonelyMessage: {
        color: BaseTheme.palette.text01,
        paddingVertical: BaseTheme.spacing[2]
    },

    pipButtonContainer: {
        '&:not(:empty)': {
            borderRadius: 3,
            height: BaseTheme.spacing[7],
            marginTop: BaseTheme.spacing[1],
            marginLeft: BaseTheme.spacing[1],
            zIndex: 1,
            width: BaseTheme.spacing[7]
        }
    },

    pipButton: {
        iconStyle: {
            color: BaseTheme.palette.icon01,
            padding: 12,
            fontSize: TITLE_BAR_BUTTON_SIZE
        },
        underlayColor: 'transparent'
    },

    titleBarSafeViewColor: {
        ...titleBarSafeView,
        backgroundColor: BaseTheme.palette.uiBackground
    },

    titleBarSafeViewTransparent: {
        ...titleBarSafeView
    },

    titleBarWrapper: {
        alignItems: 'center',
        flex: 1,
        flexDirection: 'row',
        height: BaseTheme.spacing[8],
        justifyContent: 'center'
    },

    alwaysOnTitleBar: {
        ...alwaysOnTitleBar,
        marginRight: BaseTheme.spacing[2]
    },

    alwaysOnTitleBarWide: {
        ...alwaysOnTitleBar,
        marginRight: BaseTheme.spacing[12]
    },

    expandedLabelWrapper: {
        zIndex: 1
    },

    roomTimer: {
        ...BaseTheme.typography.bodyShortBold,
        color: BaseTheme.palette.text01,
        lineHeight: 14,
        textAlign: 'center'
    },

    roomTimerView: {
        backgroundColor: BaseTheme.palette.ui03,
        borderRadius: BaseTheme.shape.borderRadius,
        height: 32,
        justifyContent: 'center',
        paddingHorizontal: BaseTheme.spacing[2],
        paddingVertical: BaseTheme.spacing[1],
        minWidth: 50
    },

    roomName: {
        color: BaseTheme.palette.text01,
        ...BaseTheme.typography.bodyShortBold,
        paddingVertical: 6
    },

    roomNameView: {
        backgroundColor: 'rgba(0,0,0,0.6)',
        borderBottomLeftRadius: 3,
        borderTopLeftRadius: 3,
        flexShrink: 1,
        justifyContent: 'center',
        paddingHorizontal: 10
    },

    roomNameWrapper: {
        flexDirection: 'row',
        marginRight: 10,
        marginLeft: 8,
        flexShrink: 1,
        flexGrow: 1
    },

    /**
     * The style of the {@link View} which expands over the whole
     * {@link Conference} area and splits it between the {@link Filmstrip} and
     * the {@link Toolbox}.
     */
    toolboxAndFilmstripContainer: {
        bottom: 0,
        flexDirection: 'column',
        justifyContent: 'flex-end',
        left: 0,
        position: 'absolute',
        right: 0,
        top: 0
    },

    insecureRoomNameLabel: {
        backgroundColor: INSECURE_ROOM_NAME_LABEL_COLOR,
        borderRadius: BaseTheme.shape.borderRadius,
        height: 32
    },

    raisedHandsCountLabel: {
        alignItems: 'center',
        backgroundColor: BaseTheme.palette.warning02,
        borderRadius: BaseTheme.shape.borderRadius,
        flexDirection: 'row',
        marginBottom: BaseTheme.spacing[0],
        marginLeft: BaseTheme.spacing[0]
    },

    raisedHandsCountLabelText: {
        color: BaseTheme.palette.uiBackground,
        paddingLeft: BaseTheme.spacing[2]
    }
};


################################################################################

## File: .\jitsi-meet\react\features\conference\components\native\carmode\styles.ts

import BaseTheme from '../../../../base/ui/components/BaseTheme.native';

/**
 * The size of the microphone icon.
 */
const MICROPHONE_SIZE = 180;

/**
 * The styles of the safe area view that contains the title bar.
 */
const titleBarSafeView = {
    left: 0,
    position: 'absolute',
    right: 0,
    top: 0
};

/**
 * The styles of the native components of Carmode.
 */
export default {

    bottomContainer: {
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        bottom: BaseTheme.spacing[8]
    },

    /**
     * {@code Conference} Style.
     */
    conference: {
        backgroundColor: BaseTheme.palette.uiBackground,
        flex: 1,
        justifyContent: 'center'
    },

    microphoneStyles: {
        container: {
            borderRadius: MICROPHONE_SIZE / 2,
            height: MICROPHONE_SIZE,
            maxHeight: MICROPHONE_SIZE,
            justifyContent: 'center',
            overflow: 'hidden',
            width: MICROPHONE_SIZE,
            maxWidth: MICROPHONE_SIZE,
            flex: 1,
            zIndex: 1,
            elevation: 1
        },

        icon: {
            color: BaseTheme.palette.text01,
            fontSize: MICROPHONE_SIZE * 0.45,
            fontWeight: '100'
        },

        iconContainer: {
            alignItems: 'center',
            alignSelf: 'stretch',
            flex: 1,
            justifyContent: 'center',
            backgroundColor: BaseTheme.palette.ui03
        },

        unmuted: {
            borderWidth: 4,
            borderColor: BaseTheme.palette.success01
        }
    },

    qualityLabelContainer: {
        borderRadius: BaseTheme.shape.borderRadius,
        flexShrink: 1,
        paddingHorizontal: 2,
        justifyContent: 'center',
        marginTop: BaseTheme.spacing[2]
    },

    roomTimer: {
        ...BaseTheme.typography.bodyShortBold,
        color: BaseTheme.palette.text01,
        textAlign: 'center'
    },

    titleView: {
        width: 152,
        height: 28,
        backgroundColor: BaseTheme.palette.ui02,
        borderRadius: 12,
        alignSelf: 'center'
    },

    title: {
        margin: 'auto',
        textAlign: 'center',
        paddingVertical: BaseTheme.spacing[1],
        paddingHorizontal: BaseTheme.spacing[3],
        color: BaseTheme.palette.text02
    },

    soundDeviceButton: {
        marginBottom: BaseTheme.spacing[3],
        width: 240
    },

    endMeetingButton: {
        width: 240
    },

    headerLabels: {
        borderBottomLeftRadius: 3,
        borderTopLeftRadius: 3,
        flexShrink: 1,
        paddingHorizontal: 2,
        justifyContent: 'center'
    },

    titleBarSafeViewColor: {
        ...titleBarSafeView,
        backgroundColor: BaseTheme.palette.uiBackground
    },

    microphoneContainer: {
        flex: 1,
        alignItems: 'center',
        justifyContent: 'center'
    },

    titleBarWrapper: {
        alignItems: 'center',
        flex: 1,
        flexDirection: 'row',
        justifyContent: 'center'
    },

    roomNameWrapper: {
        flexDirection: 'row',
        marginRight: BaseTheme.spacing[2],
        flexShrink: 1,
        flexGrow: 1
    },

    roomNameView: {
        backgroundColor: 'rgba(0,0,0,0.6)',
        flexShrink: 1,
        justifyContent: 'center',
        paddingHorizontal: BaseTheme.spacing[2]
    },

    roomName: {
        color: BaseTheme.palette.text01,
        ...BaseTheme.typography.bodyShortBold
    },

    titleBar: {
        alignSelf: 'center',
        marginTop: BaseTheme.spacing[1]
    },

    videoStoppedLabel: {
        ...BaseTheme.typography.bodyShortRegularLarge,
        color: BaseTheme.palette.text01,
        marginBottom: BaseTheme.spacing[3],
        textAlign: 'center',
        width: '100%'
    },

    connectionIndicatorIcon: {
        fontSize: 20
    }
};


################################################################################

## File: .\jitsi-meet\react\features\connection-indicator\actions.web.ts

import { IStore } from '../app/types';
import getRoomName from '../base/config/getRoomName';
import { downloadJSON } from '../base/util/downloadJSON';


/**
 * Create an action for saving the conference logs.
 *
 * @returns {Function}
 */
export function saveLogs() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {

        const logs = getState()['features/base/connection'].connection?.getLogs();
        const roomName = getRoomName() || '';

        downloadJSON(logs ?? {}, `meetlog-${roomName}.json`);
    };
}


################################################################################

## File: .\jitsi-meet\react\features\connection-indicator\functions.ts

import { JitsiTrackStreamingStatus } from '../base/lib-jitsi-meet';
import { ITrack } from '../base/tracks/types';

/**
 * Checks if the passed track's streaming status is active.
 *
 * @param {Object} videoTrack - Track reference.
 * @returns {boolean} - Is streaming status active.
 */
export function isTrackStreamingStatusActive(videoTrack?: ITrack) {
    const streamingStatus = videoTrack?.streamingStatus;

    return streamingStatus === JitsiTrackStreamingStatus.ACTIVE;
}

/**
 * Checks if the passed track's streaming status is inactive.
 *
 * @param {Object} videoTrack - Track reference.
 * @returns {boolean} - Is streaming status inactive.
 */
export function isTrackStreamingStatusInactive(videoTrack?: ITrack) {
    const streamingStatus = videoTrack?.streamingStatus;

    return streamingStatus === JitsiTrackStreamingStatus.INACTIVE;
}

/**
 * Checks if the passed track's streaming status is interrupted.
 *
 * @param {Object} videoTrack - Track reference.
 * @returns {boolean} - Is streaming status interrupted.
 */
export function isTrackStreamingStatusInterrupted(videoTrack?: ITrack) {
    const streamingStatus = videoTrack?.streamingStatus;

    return streamingStatus === JitsiTrackStreamingStatus.INTERRUPTED;
}


################################################################################

## File: .\jitsi-meet\react\features\connection-indicator\middleware.ts

import { CONFERENCE_JOINED } from '../base/conference/actionTypes';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';

import statsEmitter from './statsEmitter';

/**
 * Implements the middleware of the feature connection-indicator.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
MiddlewareRegistry.register(store => next => action => {
    switch (action.type) {
    case CONFERENCE_JOINED: {
        statsEmitter.startListeningForStats(action.conference);
        break;
    }
    }

    return next(action);
});



################################################################################

## File: .\jitsi-meet\react\features\connection-indicator\statsEmitter.ts

import { union } from 'lodash-es';

import { IJitsiConference } from '../base/conference/reducer';
import {
    JitsiConnectionQualityEvents
} from '../base/lib-jitsi-meet';
import { trackCodecChanged } from '../base/tracks/actions.any';
import { getLocalTracks } from '../base/tracks/functions.any';

/**
 * Contains all the callbacks to be notified when stats are updated.
 *
 * ```
 * {
 *     userId: Function[]
 * }
 * ```
 */
const subscribers: any = {};

interface IStats {
    codec?: Object;
    framerate?: Object;
    resolution?: Object;
}

/**
 * A singleton that acts as a pub/sub service for connection stat updates.
 */
const statsEmitter = {
    /**
     * Have {@code statsEmitter} subscribe to stat updates from a given
     * conference.
     *
     * @param {JitsiConference} conference - The conference for which
     * {@code statsEmitter} should subscribe for stat updates.
     * @returns {void}
     */
    startListeningForStats(conference: IJitsiConference) {
        conference.on(JitsiConnectionQualityEvents.LOCAL_STATS_UPDATED,
            (stats: IStats) => this._onStatsUpdated(conference.myUserId(), stats));

        conference.on(JitsiConnectionQualityEvents.REMOTE_STATS_UPDATED,
            (id: string, stats: IStats) => this._emitStatsUpdate(id, stats));
    },

    /**
     * Add a subscriber to be notified when stats are updated for a specified
     * user id.
     *
     * @param {string} id - The user id whose stats updates are of interest.
     * @param {Function} callback - The function to invoke when stats for the
     * user have been updated.
     * @returns {void}
     */
    subscribeToClientStats(id: string | undefined, callback: Function) {
        if (!id) {
            return;
        }

        if (!subscribers[id]) {
            subscribers[id] = [];
        }

        subscribers[id].push(callback);
    },

    /**
     * Remove a subscriber that is listening for stats updates for a specified
     * user id.
     *
     * @param {string} id - The user id whose stats updates are no longer of
     * interest.
     * @param {Function} callback - The function that is currently subscribed to
     * stat updates for the specified user id.
     * @returns {void}
     */
    unsubscribeToClientStats(id: string, callback: Function) {
        if (!subscribers[id]) {
            return;
        }

        const filteredSubscribers = subscribers[id].filter(
            (subscriber: Function) => subscriber !== callback);

        if (filteredSubscribers.length) {
            subscribers[id] = filteredSubscribers;
        } else {
            delete subscribers[id];
        }
    },

    /**
     * Emit a stat update to all those listening for a specific user's
     * connection stats.
     *
     * @param {string} id - The user id the stats are associated with.
     * @param {Object} stats - New connection stats for the user.
     * @returns {void}
     */
    _emitStatsUpdate(id: string, stats: IStats = {}) {
        const callbacks = subscribers[id] || [];

        callbacks.forEach((callback: Function) => {
            callback(stats);
        });
    },

    /**
     * Emit a stat update to all those listening for local stat updates. Will
     * also update listeners of remote user stats of changes related to their
     * stats.
     *
     * @param {string} localUserId - The user id for the local user.
     * @param {Object} stats - Connection stats for the local user as provided
     * by the library.
     * @returns {void}
     */
    _onStatsUpdated(localUserId: string, stats: IStats) {
        const allUserFramerates = stats.framerate || {};
        const allUserResolutions = stats.resolution || {};
        const allUserCodecs = stats.codec || {};

        // FIXME resolution and framerate are maps keyed off of user ids with
        // stat values. Receivers of stats expect resolution and framerate to
        // be primitives, not maps, so here we override the 'lib-jitsi-meet'
        // stats objects.
        const modifiedLocalStats = Object.assign({}, stats, {
            framerate: allUserFramerates[localUserId as keyof typeof allUserFramerates],
            resolution: allUserResolutions[localUserId as keyof typeof allUserResolutions],
            codec: allUserCodecs[localUserId as keyof typeof allUserCodecs]
        });

        modifiedLocalStats.codec
            && Object.keys(modifiedLocalStats.codec).length
            && this._updateLocalCodecs(modifiedLocalStats.codec);

        this._emitStatsUpdate(localUserId, modifiedLocalStats);

        // Get all the unique user ids from the framerate and resolution stats
        // and update remote user stats as needed.
        const framerateUserIds = Object.keys(allUserFramerates);
        const resolutionUserIds = Object.keys(allUserResolutions);
        const codecUserIds = Object.keys(allUserCodecs);

        union(framerateUserIds, resolutionUserIds, codecUserIds)
            .filter(id => id !== localUserId)
            .forEach(id => {
                const remoteUserStats: IStats = {};

                const framerate = allUserFramerates[id as keyof typeof allUserFramerates];

                if (framerate) {
                    remoteUserStats.framerate = framerate;
                }

                const resolution = allUserResolutions[id as keyof typeof allUserResolutions];

                if (resolution) {
                    remoteUserStats.resolution = resolution;
                }

                const codec = allUserCodecs[id as keyof typeof allUserCodecs];

                if (codec) {
                    remoteUserStats.codec = codec;
                }

                this._emitStatsUpdate(id, remoteUserStats);
            });
    },

    /**
     * Updates the codec associated with the local tracks.
     * This is currently used for torture tests.
     *
     * @param {any} codecs - Codec information per local SSRC.
     * @returns {void}
     */
    _updateLocalCodecs(codecs: any) {
        if (typeof APP !== 'undefined') {
            const tracks = APP.store.getState()['features/base/tracks'];
            const localTracks = getLocalTracks(tracks);

            for (const track of localTracks) {
                const ssrc = track.jitsiTrack?.getSsrc();

                if (ssrc && Object.keys(codecs).find(key => Number(key) === ssrc)) {
                    const codecsPerSsrc = codecs[ssrc];
                    const codec = codecsPerSsrc.audio ?? codecsPerSsrc.video;

                    if (track.codec !== codec) {
                        APP.store.dispatch(trackCodecChanged(track.jitsiTrack, codec));
                    }
                }
            }
        }
    }
};

export default statsEmitter;


################################################################################

## File: .\jitsi-meet\react\features\connection-indicator\components\AbstractConnectionIndicator.ts

import { Component } from 'react';

import { IReduxState } from '../../app/types';
import { getVirtualScreenshareParticipantOwnerId } from '../../base/participants/functions';
import statsEmitter from '../statsEmitter';

const defaultAutoHideTimeout = 5000;

/**
 * The connection quality percentage that must be reached to be considered of
 * good quality and can result in the connection indicator being hidden.
 *
 * @type {number}
 */
export const INDICATOR_DISPLAY_THRESHOLD = 30;

/**
 * The type of the React {@code Component} props of {@link ConnectionIndicator}.
 */
export interface IProps {

    /**
     * How long the connection indicator should remain displayed before hiding.
     */
    _autoHideTimeout: number;

    /**
     * Whether or not the statistics are for screen share.
     */
    _isVirtualScreenshareParticipant: boolean;

    /**
     * Custom icon style.
     */
    iconStyle?: Object;

    /**
     * The ID of the participant associated with the displayed connection indication and
     * stats.
     */
    participantId: string;
}

/**
 * The type of the React {@code Component} state of {@link ConnectionIndicator}.
 */
export interface IState {

    /**
     * Whether or not a CSS class should be applied to the root for hiding the
     * connection indicator. By default the indicator should start out hidden
     * because the current connection status is not known at mount.
     */
    showIndicator: boolean;

    /**
     * Cache of the stats received from subscribing to stats emitting. The keys
     * should be the name of the stat. With each stat update, updates stats are
     * mixed in with cached stats and a new stats object is set in state.
     */
    stats: {
        bandwidth?: any;
        bitrate?: any;
        bridgeCount?: any;
        codec?: any;
        framerate?: any;
        maxEnabledResolution?: any;
        packetLoss?: any;
        percent?: number;
        resolution?: any;
        serverRegion?: any;
        transport?: any;
    };
}

/**
 * Implements a React {@link Component} which displays the current connection
 * quality.
 *
 * @augments {Component}
 */
class AbstractConnectionIndicator<P extends IProps, S extends IState> extends Component<P, S> {
    /**
     * The timeout for automatically hiding the indicator.
     */
    autoHideTimeout: number | undefined;

    /**
     * Initializes a new {@code ConnectionIndicator} instance.
     *
     * @param {P} props - The read-only properties with which the new
     * instance is to be initialized.
     */
    constructor(props: P) {
        super(props);

        // Bind event handlers so they are only bound once for every instance.
        this._onStatsUpdated = this._onStatsUpdated.bind(this);
    }

    /**
     * Starts listening for stat updates.
     *
     * @inheritdoc
     * returns {void}
     */
    componentDidMount() {
        statsEmitter.subscribeToClientStats(this._getRealParticipantId(this.props), this._onStatsUpdated);
    }

    /**
     * Updates which user's stats are being listened to.
     *
     * @inheritdoc
     * returns {void}
     */
    componentDidUpdate(prevProps: IProps) {
        const prevParticipantId = this._getRealParticipantId(prevProps);
        const participantId = this._getRealParticipantId(this.props);

        if (prevParticipantId !== participantId) {
            statsEmitter.unsubscribeToClientStats(prevParticipantId, this._onStatsUpdated);
            statsEmitter.subscribeToClientStats(participantId, this._onStatsUpdated);
        }
    }

    /**
     * Cleans up any queued processes, which includes listening for new stats
     * and clearing any timeout to hide the indicator.
     *
     * @private
     * @returns {void}
     */
    componentWillUnmount() {
        statsEmitter.unsubscribeToClientStats(this._getRealParticipantId(this.props), this._onStatsUpdated);

        clearTimeout(this.autoHideTimeout ?? 0);
    }

    /**
     * Gets the "real" participant ID. FOr a virtual screenshare participant, that is its "owner".
     *
     * @param {Props} props - The props where to extract the data from.
     * @returns {string | undefined } The resolved participant ID.
     */
    _getRealParticipantId(props: IProps) {
        if (props._isVirtualScreenshareParticipant) {
            return getVirtualScreenshareParticipantOwnerId(props.participantId);
        }

        return props.participantId;
    }

    /**
     * Callback invoked when new connection stats associated with the passed in
     * user ID are available. Will update the component's display of current
     * statistics.
     *
     * @param {Object} stats - Connection stats from the library.
     * @private
     * @returns {void}
     */
    _onStatsUpdated(stats = { connectionQuality: undefined }) {
        // Rely on React to batch setState actions.
        const { connectionQuality } = stats;
        const newPercentageState = typeof connectionQuality === 'undefined'
            ? {} : { percent: connectionQuality };
        const newStats = Object.assign(
            {},
            this.state.stats,
            stats,
            newPercentageState);

        this.setState({
            stats: newStats
        });

        this._updateIndicatorAutoHide(newStats.percent ?? 0);
    }

    /**
     * Updates the internal state for automatically hiding the indicator.
     *
     * @param {number} percent - The current connection quality percentage
     * between the values 0 and 100.
     * @private
     * @returns {void}
     */
    _updateIndicatorAutoHide(percent: number) {
        if (percent < INDICATOR_DISPLAY_THRESHOLD) {
            clearTimeout(this.autoHideTimeout ?? 0);
            this.autoHideTimeout = undefined;

            this.setState({
                showIndicator: true
            });
        } else if (this.autoHideTimeout) {
            // This clause is intentionally left blank because no further action
            // is needed if the percent is below the threshold and there is an
            // autoHideTimeout set.
        } else {
            this.autoHideTimeout = window.setTimeout(() => {
                this.setState({
                    showIndicator: false
                });
            }, this.props._autoHideTimeout);
        }
    }
}

/**
 * Maps (parts of) the Redux state to the associated props for the
 * {@code ConnectorIndicator} component.
 *
 * @param {Object} state - The Redux state.
 * @private
 * @returns {IProps}
 */
export function mapStateToProps(state: IReduxState) {
    return {
        _autoHideTimeout: state['features/base/config'].connectionIndicators?.autoHideTimeout ?? defaultAutoHideTimeout
    };
}

export default AbstractConnectionIndicator;


################################################################################

## File: .\jitsi-meet\react\features\connection-indicator\components\native\styles.ts

import BaseTheme from '../../../base/ui/components/BaseTheme.native';
import { INDICATOR_DISPLAY_THRESHOLD } from '../AbstractConnectionIndicator';

export const CONNECTOR_INDICATOR_LOST = BaseTheme.palette.ui05;
export const CONNECTOR_INDICATOR_OTHER = BaseTheme.palette.action01;
export const CONNECTOR_INDICATOR_COLORS = [

    // Full (3 bars)
    {
        color: BaseTheme.palette.success01,
        percent: INDICATOR_DISPLAY_THRESHOLD
    },

    // 2 bars.
    {
        color: BaseTheme.palette.warning01,
        percent: 10
    },

    // 1 bar.
    {
        color: BaseTheme.palette.iconError,
        percent: 0
    }
];

export const iconStyle = {
    fontSize: 14
};


################################################################################

## File: .\jitsi-meet\react\features\deep-linking\actions.ts

import { appNavigate } from '../app/actions';
import { IStore } from '../app/types';

import { OPEN_DESKTOP_APP, OPEN_WEB_APP } from './actionTypes';

/**
 * Continue to the conference page.
 *
 * @returns {Function}
 */
export function openWebApp() {
    return (dispatch: IStore['dispatch']) => {
        // In order to go to the web app we need to skip the deep linking
        // interceptor. OPEN_WEB_APP action should set launchInWeb to true in
        // the redux store. After this when appNavigate() is called the
        // deep linking interceptor will be skipped (will return undefined).
        dispatch({ type: OPEN_WEB_APP });
        dispatch(appNavigate());
    };
}

/**
 * Opens the desktop app.
 *
 * @returns {{
 *     type: OPEN_DESKTOP_APP
 * }}
 */
export function openDesktopApp() {
    return {
        type: OPEN_DESKTOP_APP
    };
}


################################################################################

## File: .\jitsi-meet\react\features\deep-linking\actionTypes.ts

/**
 * The type of the action which signals to open the conference in the desktop
 * app.
 *
 * {
 *     type: OPEN_DESKTOP
 * }
 */
export const OPEN_DESKTOP_APP = 'OPEN_DESKTOP_APP';

/**
 * The type of the action which signals to open the conference in the web app.
 *
 * {
 *     type: OPEN_WEB_APP
 * }
 */
export const OPEN_WEB_APP = 'OPEN_WEB_APP';


################################################################################

## File: .\jitsi-meet\react\features\deep-linking\constants.ts

/**
 * The namespace of the i18n/translation keys.
 *
 * @type {string}
 */
export const _TNS = 'deepLinking';


################################################################################

## File: .\jitsi-meet\react\features\deep-linking\functions.ts

import { IReduxState } from '../app/types';
import { isMobileBrowser } from '../base/environment/utils';
import { browser } from '../base/lib-jitsi-meet';
import Platform from '../base/react/Platform';
import { URI_PROTOCOL_PATTERN } from '../base/util/uri';
import { isVpaasMeeting } from '../jaas/functions';

import DeepLinkingDesktopPage from './components/DeepLinkingDesktopPage';
import DeepLinkingMobilePage from './components/DeepLinkingMobilePage';
import NoMobileApp from './components/NoMobileApp';
import { _openDesktopApp } from './openDesktopApp';

/**
 * Generates a deep linking URL based on the current window URL.
 *
 * @param {Object} state - Object containing current redux state.
 *
 * @returns {string} - The generated URL.
 */
export function generateDeepLinkingURL(state: IReduxState) {
    // If the user installed the app while this Component was displayed
    // (e.g. the user clicked the Download the App button), then we would
    // like to open the current URL in the mobile app. The only way to do it
    // appears to be a link with an app-specific scheme, not a Universal
    // Link.

    const { href } = window.location;
    const regex = new RegExp(URI_PROTOCOL_PATTERN, 'gi');

    // @ts-ignore
    const mobileConfig = state['features/base/config'].deeplinking?.[Platform.OS] || {};

    const { appScheme, appPackage } = mobileConfig;

    // Android: use an intent link, custom schemes don't work in all browsers.
    // https://developer.chrome.com/multidevice/android/intents
    if (Platform.OS === 'android') {
        // https://meet.jit.si/foo -> meet.jit.si/foo
        const url = href.replace(regex, '').substr(2);

        return `intent://${url}#Intent;scheme=${appScheme};package=${appPackage};end`;
    }

    // iOS: Replace the protocol part with the app scheme.
    return href.replace(regex, `${appScheme}:`);
}

/**
 * Resolves with the component that should be displayed if the deep linking page
 * should be shown and with <tt>undefined</tt> otherwise.
 *
 * @param {Object} state - Object containing current redux state.
 * @returns {Promise<Component>}
 */
export function getDeepLinkingPage(state: IReduxState) {
    const { room } = state['features/base/conference'];
    const { launchInWeb } = state['features/deep-linking'];
    const deeplinking = state['features/base/config'].deeplinking || {};

    // @ts-ignore
    const { appScheme } = deeplinking?.[Platform.OS as keyof typeof deeplinking] || {};

    // Show only if we are about to join a conference.
    if (launchInWeb
            || !room
            || state['features/base/config'].deeplinking?.disabled
            || browser.isElectron()
            || (isVpaasMeeting(state) && (!appScheme || appScheme === 'com.8x8.meet'))) {
        return Promise.resolve();
    }

    if (isMobileBrowser()) { // mobile
        const mobileAppPromo
            = typeof interfaceConfig === 'object'
                && interfaceConfig.MOBILE_APP_PROMO;

        return Promise.resolve(
            typeof mobileAppPromo === 'undefined' || Boolean(mobileAppPromo)
                ? DeepLinkingMobilePage : NoMobileApp);
    }

    return _openDesktopApp(state).then(
        // eslint-disable-next-line no-confusing-arrow
        result => result ? DeepLinkingDesktopPage : undefined);
}

/**
 * Opens the desktop app.
 *
 * @param {Object} state - Object containing current redux state.
 * @returns {Promise<boolean>} - Resolves with true if the attempt to open the desktop app was successful and resolves
 * with false otherwise.
 */
export function openDesktopApp(state: IReduxState) {
    return _openDesktopApp(state);
}


################################################################################

## File: .\jitsi-meet\react\features\deep-linking\middleware.ts

import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';

import { OPEN_DESKTOP_APP } from './actionTypes';
import { openDesktopApp } from './functions';

/**
 * Implements the middleware of the deep linking feature.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {
    switch (action.type) {
    case OPEN_DESKTOP_APP:
        openDesktopApp(store.getState());
        break;
    }

    return next(action);
});


################################################################################

## File: .\jitsi-meet\react\features\deep-linking\openDesktopApp.ts

import { IReduxState } from '../app/types';
import { URI_PROTOCOL_PATTERN } from '../base/util/uri';

/**
 * Opens the desktop app.
 *
 * @param {Object} _state - Object containing current redux state.
 * @returns {Promise<boolean>} - Resolves with true if the attempt to open the desktop app was successful and resolves
 * with false otherwise.
 */
export function _openDesktopApp(_state: Object) {
    const state = _state as IReduxState;
    const deeplinkingDesktop = state['features/base/config'].deeplinking?.desktop;

    if (deeplinkingDesktop?.enabled) {
        const { appScheme } = deeplinkingDesktop;
        const regex = new RegExp(URI_PROTOCOL_PATTERN, 'gi');

        window.location.href = window.location.href.replace(regex, `${appScheme}:`);

        return Promise.resolve(true);
    }

    return Promise.resolve(false);
}


################################################################################

## File: .\jitsi-meet\react\features\deep-linking\reducer.ts

import ReducerRegistry from '../base/redux/ReducerRegistry';

import { OPEN_WEB_APP } from './actionTypes';

export interface IDeepLinkingState {
    launchInWeb?: boolean;
}

ReducerRegistry.register<IDeepLinkingState>('features/deep-linking', (state = {}, action): IDeepLinkingState => {
    switch (action.type) {
    case OPEN_WEB_APP: {
        return {
            ...state,
            launchInWeb: true
        };
    }
    }

    return state;
});


################################################################################

## File: .\jitsi-meet\react\features\deep-linking\components\DeepLinkingDesktopPage.native.ts

export default {};


################################################################################

## File: .\jitsi-meet\react\features\deep-linking\components\DeepLinkingMobilePage.native.ts

export default {};


################################################################################

## File: .\jitsi-meet\react\features\deep-linking\components\NoMobileApp.native.ts

export default {};


################################################################################

## File: .\jitsi-meet\react\features\desktop-picker\actions.ts

import { openDialog } from '../base/dialog/actions';

import DesktopPicker from './components/DesktopPicker';

/**
 * Signals to open a dialog with the DesktopPicker component.
 *
 * @param {Object} options - Desktop sharing settings.
 * @param {Function} onSourceChoose - The callback to invoke when
 * a DesktopCapturerSource has been chosen.
 * @returns {Object}
 */
export function showDesktopPicker(options: { desktopSharingSources?: any; } = {}, onSourceChoose: Function) {
    const { desktopSharingSources } = options;

    return openDialog(DesktopPicker, {
        desktopSharingSources,
        onSourceChoose
    });
}


################################################################################

## File: .\jitsi-meet\react\features\desktop-picker\constants.ts

/**
 * The size of the requested thumbnails.
 *
 * @type {Object}
 */
export const THUMBNAIL_SIZE = {
    height: 300,
    width: 300
};


################################################################################

## File: .\jitsi-meet\react\features\desktop-picker\functions.ts

import logger from './logger';
import { ElectronWindowType } from './types';


/**
 * Begins a request to get available DesktopCapturerSources.
 *
 * @param {Object} options - Additional configuration for getting a list of
 * sources.
 * @param {Array} options.types - An array with DesktopCapturerSource type strings.
 * @param {Object} options.thumbnailSize - The desired height and width of the
 * return native image object used for the preview image of the source.
 * @returns {Function}
 */
export function obtainDesktopSources(options: { thumbnailSize?: Object; types: string[]; }) {
    const { JitsiMeetElectron } = window as ElectronWindowType;

    // TODO: delete this after 2 releases
    if (JitsiMeetElectron?.obtainDesktopStreams) {
        return new Promise((resolve, reject) => {
            JitsiMeetElectron.obtainDesktopStreams(
                (sources: Array<{ id: string; }>) => resolve(_separateSourcesByType(sources)),
                (error: Error) => {
                    logger.error(
                        `Error while obtaining desktop sources: ${error}`);
                    reject(error);
                },
                options
            );
        });
    }

    return APP.API.requestDesktopSources(options).then(
        ({ sources, error }: { error: Error; sources: Array<{ id: string; }>; }) => {
            if (sources) {
                return _separateSourcesByType(sources);
            } else if (error) {
                logger.error(
                    `Error while obtaining desktop sources: ${error}`);

                return null;
            }
        });
}

/**
 * Check usage of old jitsi meet electron version.
 *
 * @returns {boolean} True if we use old jitsi meet electron, otherwise false.
 */
export function oldJitsiMeetElectronUsage() {
    const { JitsiMeetElectron } = window as ElectronWindowType;

    if (JitsiMeetElectron?.obtainDesktopStreams) {
        return true;
    }

    return false;
}

/**
 * Converts an array of DesktopCapturerSources to an object with types for keys
 * and values being an array with sources of the key's type.
 *
 * @param {Array} sources - DesktopCapturerSources.
 * @private
 * @returns {Object} An object with the sources split into separate arrays based
 * on source type.
 */
export function _separateSourcesByType(sources: Array<{ id: string; }> = []) {
    const sourcesByType: any = {
        screen: [],
        window: []
    };

    sources.forEach(source => {
        const idParts = source.id.split(':');
        const type = idParts[0];

        if (sourcesByType[type]) {
            sourcesByType[type].push(source);
        }
    });

    return sourcesByType;
}


################################################################################

## File: .\jitsi-meet\react\features\desktop-picker\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/desktop-picker');


################################################################################

## File: .\jitsi-meet\react\features\desktop-picker\types.ts

export type ElectronWindowType = {
    JitsiMeetElectron?: {
        obtainDesktopStreams: Function;
    } ;
} & typeof window;


################################################################################

## File: .\jitsi-meet\react\features\device-selection\actions.web.ts

import { createDeviceChangedEvent } from '../analytics/AnalyticsEvents';
import { sendAnalytics } from '../analytics/functions';
import { IStore } from '../app/types';
import {
    setAudioInputDevice,
    setVideoInputDevice
} from '../base/devices/actions';
import { getDeviceLabelById, setAudioOutputDeviceId } from '../base/devices/functions';
import { updateSettings } from '../base/settings/actions';
import { toggleNoiseSuppression } from '../noise-suppression/actions';
import { setScreenshareFramerate } from '../screen-share/actions';

import { getAudioDeviceSelectionDialogProps, getVideoDeviceSelectionDialogProps } from './functions';
import logger from './logger';

/**
 * Submits the settings related to audio device selection.
 *
 * @param {Object} newState - The new settings.
 * @param {boolean} isDisplayedOnWelcomePage - Indicates whether the device selection dialog is displayed on the
 * welcome page or not.
 * @returns {Function}
 */
export function submitAudioDeviceSelectionTab(newState: any, isDisplayedOnWelcomePage: boolean) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const currentState = getAudioDeviceSelectionDialogProps(getState(), isDisplayedOnWelcomePage);

        if (newState.selectedAudioInputId && newState.selectedAudioInputId !== currentState.selectedAudioInputId) {
            dispatch(updateSettings({
                userSelectedMicDeviceId: newState.selectedAudioInputId,
                userSelectedMicDeviceLabel:
                    getDeviceLabelById(getState(), newState.selectedAudioInputId, 'audioInput')
            }));

            dispatch(setAudioInputDevice(newState.selectedAudioInputId));
        }

        if (newState.selectedAudioOutputId
            && newState.selectedAudioOutputId
            !== currentState.selectedAudioOutputId) {
            sendAnalytics(createDeviceChangedEvent('audio', 'output'));

            setAudioOutputDeviceId(
                newState.selectedAudioOutputId,
                dispatch,
                true,
                getDeviceLabelById(getState(), newState.selectedAudioOutputId, 'audioOutput'))
                .then(() => logger.log('changed audio output device'))
                .catch(err => {
                    logger.warn(
                        'Failed to change audio output device.',
                        'Default or previously set audio output device will',
                        ' be used instead.',
                        err);
                });
        }

        if (newState.noiseSuppressionEnabled !== currentState.noiseSuppressionEnabled) {
            dispatch(toggleNoiseSuppression());
        }
    };
}

/**
 * Submits the settings related to device selection.
 *
 * @param {Object} newState - The new settings.
 * @param {boolean} isDisplayedOnWelcomePage - Indicates whether the device selection dialog is displayed on the
 * welcome page or not.
 * @returns {Function}
 */
export function submitVideoDeviceSelectionTab(newState: any, isDisplayedOnWelcomePage: boolean) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const currentState = getVideoDeviceSelectionDialogProps(getState(), isDisplayedOnWelcomePage);

        if (newState.selectedVideoInputId && (newState.selectedVideoInputId !== currentState.selectedVideoInputId)) {
            dispatch(updateSettings({
                userSelectedCameraDeviceId: newState.selectedVideoInputId,
                userSelectedCameraDeviceLabel:
                    getDeviceLabelById(getState(), newState.selectedVideoInputId, 'videoInput')
            }));
            dispatch(setVideoInputDevice(newState.selectedVideoInputId));
        }
        if (newState.localFlipX !== currentState.localFlipX) {
            dispatch(updateSettings({
                localFlipX: newState.localFlipX
            }));
        }

        if (newState.currentFramerate !== currentState.currentFramerate) {
            const frameRate = parseInt(newState.currentFramerate, 10);

            dispatch(setScreenshareFramerate(frameRate));
        }
    };
}


################################################################################

## File: .\jitsi-meet\react\features\device-selection\functions.web.ts

import { IStore } from '../app/types';
import { IStateful } from '../base/app/types';
import { getWebHIDFeatureConfig } from '../base/config/functions.web';
import {
    addPendingDeviceRequest,
    getAvailableDevices,
    setAudioInputDeviceAndUpdateSettings,
    setAudioOutputDevice,
    setVideoInputDeviceAndUpdateSettings
} from '../base/devices/actions.web';
import {
    areDeviceLabelsInitialized,
    getAudioOutputDeviceId,
    getDeviceIdByLabel,
    groupDevicesByKind
} from '../base/devices/functions.web';
import { isIosMobileBrowser, isMobileBrowser } from '../base/environment/utils';
import JitsiMeetJS from '../base/lib-jitsi-meet';
import { toState } from '../base/redux/functions';
import {
    getUserSelectedCameraDeviceId,
    getUserSelectedMicDeviceId,
    getUserSelectedOutputDeviceId
} from '../base/settings/functions.web';
import { isNoiseSuppressionEnabled } from '../noise-suppression/functions';
import { isPrejoinPageVisible } from '../prejoin/functions';
import { SS_DEFAULT_FRAME_RATE, SS_SUPPORTED_FRAMERATES } from '../settings/constants';
import { isDeviceHidSupported } from '../web-hid/functions';

/**
 * Returns the properties for the audio device selection dialog from Redux state.
 *
 * @param {IStateful} stateful -The (whole) redux state, or redux's
 * {@code getState} function to be used to retrieve the state.
 * @param {boolean} isDisplayedOnWelcomePage - Indicates whether the device selection dialog is displayed on the
 * welcome page or not.
 * @returns {Object} - The properties for the audio device selection dialog.
 */
export function getAudioDeviceSelectionDialogProps(stateful: IStateful, isDisplayedOnWelcomePage: boolean) {
    // On mobile Safari because of https://bugs.webkit.org/show_bug.cgi?id=179363#c30, the old track is stopped
    // by the browser when a new track is created for preview. That's why we are disabling all previews.
    const disablePreviews = isIosMobileBrowser();

    const state = toState(stateful);
    const settings = state['features/base/settings'];
    const { permissions } = state['features/base/devices'];
    const inputDeviceChangeSupported = JitsiMeetJS.mediaDevices.isDeviceChangeAvailable('input');
    const speakerChangeSupported = JitsiMeetJS.mediaDevices.isDeviceChangeAvailable('output');
    const userSelectedMic = getUserSelectedMicDeviceId(state);
    const deviceHidSupported = isDeviceHidSupported() && getWebHIDFeatureConfig(state);
    const noiseSuppressionEnabled = isNoiseSuppressionEnabled(state);
    const hideNoiseSuppression = isPrejoinPageVisible(state) || isDisplayedOnWelcomePage;

    // When the previews are disabled we don't need multiple audio input support in order to change the mic. This is the
    // case for Safari on iOS.
    let disableAudioInputChange
        = !JitsiMeetJS.mediaDevices.isMultipleAudioInputSupported() && !(disablePreviews && inputDeviceChangeSupported);
    let selectedAudioInputId = settings.micDeviceId;
    let selectedAudioOutputId = getAudioOutputDeviceId();

    // audio input change will be a problem only when we are in a
    // conference and this is not supported, when we open device selection on
    // welcome page changing input devices will not be a problem
    // on welcome page we also show only what we have saved as user selected devices
    if (isDisplayedOnWelcomePage) {
        disableAudioInputChange = false;
        selectedAudioInputId = userSelectedMic;
        selectedAudioOutputId = getUserSelectedOutputDeviceId(state);
    }

    // we fill the device selection dialog with the devices that are currently
    // used or if none are currently used with what we have in settings(user selected)
    return {
        disableAudioInputChange,
        disableDeviceChange: !JitsiMeetJS.mediaDevices.isDeviceChangeAvailable(),
        hasAudioPermission: permissions.audio,
        hideAudioInputPreview: disableAudioInputChange || !JitsiMeetJS.isCollectingLocalStats() || disablePreviews,
        hideAudioOutputPreview: !speakerChangeSupported || disablePreviews,
        hideAudioOutputSelect: !speakerChangeSupported,
        hideDeviceHIDContainer: !deviceHidSupported,
        hideNoiseSuppression,
        noiseSuppressionEnabled,
        selectedAudioInputId,
        selectedAudioOutputId
    };
}

/**
 * Returns the properties for the device selection dialog from Redux state.
 *
 * @param {IStateful} stateful -The (whole) redux state, or redux's
 * {@code getState} function to be used to retrieve the state.
 * @param {boolean} isDisplayedOnWelcomePage - Indicates whether the device selection dialog is displayed on the
 * welcome page or not.
 * @returns {Object} - The properties for the device selection dialog.
 */
export function getVideoDeviceSelectionDialogProps(stateful: IStateful, isDisplayedOnWelcomePage: boolean) {
    // On mobile Safari because of https://bugs.webkit.org/show_bug.cgi?id=179363#c30, the old track is stopped
    // by the browser when a new track is created for preview. That's why we are disabling all previews.
    const disablePreviews = isMobileBrowser();

    const state = toState(stateful);
    const settings = state['features/base/settings'];
    const { permissions } = state['features/base/devices'];
    const inputDeviceChangeSupported = JitsiMeetJS.mediaDevices.isDeviceChangeAvailable('input');
    const userSelectedCamera = getUserSelectedCameraDeviceId(state);
    const { localFlipX } = state['features/base/settings'];
    const { disableLocalVideoFlip } = state['features/base/config'];
    const hideAdditionalSettings = isPrejoinPageVisible(state) || isDisplayedOnWelcomePage;
    const framerate = state['features/screen-share'].captureFrameRate ?? SS_DEFAULT_FRAME_RATE;

    let disableVideoInputSelect = !inputDeviceChangeSupported;
    let selectedVideoInputId = settings.cameraDeviceId || userSelectedCamera;

    // audio input change will be a problem only when we are in a
    // conference and this is not supported, when we open device selection on
    // welcome page changing input devices will not be a problem
    // on welcome page we also show only what we have saved as user selected devices
    if (isDisplayedOnWelcomePage) {
        disableVideoInputSelect = false;
        selectedVideoInputId = userSelectedCamera;
    }

    // we fill the device selection dialog with the devices that are currently
    // used or if none are currently used with what we have in settings(user selected)
    return {
        currentFramerate: framerate,
        desktopShareFramerates: SS_SUPPORTED_FRAMERATES,
        disableDeviceChange: !JitsiMeetJS.mediaDevices.isDeviceChangeAvailable(),
        disableVideoInputSelect,
        disableLocalVideoFlip,
        hasVideoPermission: permissions.video,
        hideAdditionalSettings,
        hideVideoInputPreview: !inputDeviceChangeSupported || disablePreviews,
        localFlipX: Boolean(localFlipX),
        selectedVideoInputId
    };
}

/**
 * Processes device requests from external applications.
 *
 * @param {Dispatch} dispatch - The redux {@code dispatch} function.
 * @param {Function} getState - The redux function that gets/retrieves the redux
 * state.
 * @param {Object} request - The request to be processed.
 * @param {Function} responseCallback - The callback that will send the
 * response.
 * @returns {boolean} - True if the request has been processed and false otherwise.
 */
export function processExternalDeviceRequest( // eslint-disable-line max-params
        dispatch: IStore['dispatch'],
        getState: IStore['getState'],
        request: any,
        responseCallback: Function) {
    if (request.type !== 'devices') {
        return false;
    }
    const state = getState();
    const settings = state['features/base/settings'];
    let result = true;

    switch (request.name) {
    case 'isDeviceListAvailable':
        responseCallback(JitsiMeetJS.mediaDevices.isDeviceListAvailable());
        break;
    case 'isDeviceChangeAvailable':
        responseCallback(
            JitsiMeetJS.mediaDevices.isDeviceChangeAvailable(
                request.deviceType));
        break;
    case 'isMultipleAudioInputSupported':
        responseCallback(JitsiMeetJS.isMultipleAudioInputSupported());
        break;
    case 'getCurrentDevices': // @ts-ignore
        dispatch(getAvailableDevices()).then((devices: MediaDeviceInfo[]) => {
            if (areDeviceLabelsInitialized(state)) {
                const deviceDescriptions: any = {
                    audioInput: undefined,
                    audioOutput: undefined,
                    videoInput: undefined
                };
                const currentlyUsedDeviceIds = new Set([
                    getAudioOutputDeviceId(),
                    settings.micDeviceId ?? getUserSelectedMicDeviceId(state),
                    settings.cameraDeviceId ?? getUserSelectedCameraDeviceId(state)
                ]);

                devices.forEach(device => {
                    const { deviceId, kind } = device;

                    if (currentlyUsedDeviceIds.has(deviceId)) {
                        switch (kind) {
                        case 'audioinput':
                            deviceDescriptions.audioInput = device;
                            break;
                        case 'audiooutput':
                            deviceDescriptions.audioOutput = device;
                            break;
                        case 'videoinput':
                            deviceDescriptions.videoInput = device;
                            break;
                        }
                    }
                });

                responseCallback(deviceDescriptions);
            } else {
                // The labels are not available if the A/V permissions are
                // not yet granted.
                dispatch(addPendingDeviceRequest({
                    type: 'devices',
                    name: 'getCurrentDevices',
                    responseCallback
                }));
            }
        });

        break;
    case 'getAvailableDevices': // @ts-ignore
        dispatch(getAvailableDevices()).then((devices: MediaDeviceInfo[]) => {
            if (areDeviceLabelsInitialized(state)) {
                responseCallback(groupDevicesByKind(devices));
            } else {
                // The labels are not available if the A/V permissions are
                // not yet granted.
                dispatch(addPendingDeviceRequest({
                    type: 'devices',
                    name: 'getAvailableDevices',
                    responseCallback
                }));
            }
        });

        break;
    case 'setDevice': {
        const { device } = request;

        if (!areDeviceLabelsInitialized(state)) {
            dispatch(addPendingDeviceRequest({
                type: 'devices',
                name: 'setDevice',
                device,
                responseCallback
            }));

            return true;
        }

        const { label, id } = device;
        const deviceId = label
            ? getDeviceIdByLabel(state, device.label, device.kind)
            : id;

        if (deviceId) {
            switch (device.kind) {
            case 'audioinput':
                dispatch(setAudioInputDeviceAndUpdateSettings(deviceId));
                break;
            case 'audiooutput':
                dispatch(setAudioOutputDevice(deviceId));
                break;
            case 'videoinput':
                dispatch(setVideoInputDeviceAndUpdateSettings(deviceId));
                break;
            default:
                result = false;
            }
        } else {
            result = false;
        }

        responseCallback(result);
        break;
    }
    default:
        return false;
    }

    return true;
}



################################################################################

## File: .\jitsi-meet\react\features\device-selection\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/device-selection');


################################################################################

## File: .\jitsi-meet\react\features\device-selection\middleware.ts

import { UPDATE_DEVICE_LIST } from '../base/devices/actionTypes';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';

/**
 * Implements the middleware of the feature device-selection.
 *
 * @param {Store} store - Redux store.
 * @returns {Function}
 */
// eslint-disable-next-line no-unused-vars
MiddlewareRegistry.register(store => next => action => {
    const result = next(action);

    if (action.type === UPDATE_DEVICE_LIST) {
        const state = store.getState();
        const { availableDevices } = state['features/base/devices'] || {};

        if (typeof APP !== 'undefined') {
            APP.API.notifyDeviceListChanged(availableDevices);
        }
    }

    return result;
});


################################################################################

## File: .\jitsi-meet\react\features\device-selection\components\DeviceSelector.native.ts



################################################################################

## File: .\jitsi-meet\react\features\display-name\actions.ts

import { openDialog } from '../base/dialog/actions';

import { DisplayNamePrompt } from './components';

/**
 * Signals to open a dialog with the {@code DisplayNamePrompt} component.
 *
 * @param {Object} params - Map containing the callbacks to be executed in the prompt:
 * - onPostSubmit - The function to invoke after a successful submit of the dialog.
 * - validateInput - The function to invoke after a change in the display name value.
 * @returns {Object}
 */
export function openDisplayNamePrompt({ onPostSubmit, validateInput }: {
    onPostSubmit?: Function;
    validateInput?: Function;
}) {
    return openDialog(DisplayNamePrompt, {
        onPostSubmit,
        validateInput
    });
}


################################################################################

## File: .\jitsi-meet\react\features\display-name\functions.ts

import { IReduxState, IStore } from '../app/types';
import { isDisplayNameVisible } from '../base/config/functions.any';
import {
    getLocalParticipant,
    getParticipantDisplayName,
    isScreenShareParticipant,
    isWhiteboardParticipant
} from '../base/participants/functions';
import { updateSettings } from '../base/settings/actions';
import { getLargeVideoParticipant } from '../large-video/functions';
import { isToolboxVisible } from '../toolbox/functions.web';
import { isLayoutTileView } from '../video-layout/functions.any';

/**
 * Appends a suffix to the display name.
 *
 * @param {string} displayName - The display name.
 * @param {string} suffix - Suffix that will be appended.
 * @returns {string} The formatted display name.
 */
export function appendSuffix(displayName: string, suffix = ''): string {
    return `${displayName || suffix}${
        displayName && suffix && displayName !== suffix ? ` (${suffix})` : ''}`;
}

/**
 * Dispatches an action to update the local participant's display name. A
 * name must be entered for the action to dispatch.
 *
 * It returns a boolean to comply the Dialog behaviour:
 *     {@code true} - the dialog should be closed.
 *     {@code false} - the dialog should be left open.
 *
 * @param {Function} dispatch - Redux dispatch function.
 * @param {Function} onPostSubmit - Function to be invoked after a successful display name change.
 * @param {string} displayName - The display name to save.
 * @returns {boolean}
 */
export function onSetDisplayName(dispatch: IStore['dispatch'], onPostSubmit?: Function) {
    return function(displayName: string) {
        if (!displayName?.trim()) {
            return false;
        }

        // Store display name in settings
        dispatch(updateSettings({
            displayName
        }));

        onPostSubmit?.();

        return true;
    };
}

/**
 * Returns true if the stage participant badge should be displayed and false otherwise.
 *
 * @param {IReduxState} state - The redux state.
 * @returns {boolean} - True if the stage participant badge should be displayed and false otherwise.
 */
export function shouldDisplayStageParticipantBadge(state: IReduxState) {
    const largeVideoParticipant = getLargeVideoParticipant(state);
    const selectedId = largeVideoParticipant?.id;
    const nameToDisplay = getParticipantDisplayName(state, selectedId ?? '');
    const localId = getLocalParticipant(state)?.id;
    const isTileView = isLayoutTileView(state);
    const toolboxVisible: boolean = isToolboxVisible(state);
    const showDisplayName = isDisplayNameVisible(state);

    return Boolean(showDisplayName
        && nameToDisplay
        && selectedId !== localId
        && !isTileView
        && !isWhiteboardParticipant(largeVideoParticipant)
        && (!isScreenShareParticipant(largeVideoParticipant) || toolboxVisible)
    );
}


################################################################################

## File: .\jitsi-meet\react\features\display-name\middleware.ts

import { hideDialog } from '../base/dialog/actions';
import { isDialogOpen } from '../base/dialog/functions';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import { SETTINGS_UPDATED } from '../base/settings/actionTypes';

import { DisplayNamePrompt } from './components';

/**
 * Middleware that captures actions related to display name setting.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(({ dispatch, getState }) => next => action => {
    switch (action.type) {
    case SETTINGS_UPDATED: {
        if (action.settings.displayName
            && isDialogOpen(getState, DisplayNamePrompt)) {
            dispatch(hideDialog(DisplayNamePrompt));
        }
    }
    }

    return next(action);
});


################################################################################

## File: .\jitsi-meet\react\features\display-name\types.ts

import { WithTranslation } from 'react-i18next';

import { IStore } from '../app/types';

/**
 * The type of the React {@code Component} props of
 * {@link AbstractDisplayNamePrompt}.
 */
export interface IProps extends WithTranslation {

    /**
     * Invoked to update the local participant's display name.
     */
    dispatch: IStore['dispatch'];

    /**
     * Function to be invoked after a successful display name change.
     */
    onPostSubmit?: Function;

    /**
     * Function to be invoked after a display name change.
     */
    validateInput?: Function;
}


################################################################################

## File: .\jitsi-meet\react\features\display-name\components\index.native.ts

export { default as DisplayNamePrompt } from './native/DisplayNamePrompt';


################################################################################

## File: .\jitsi-meet\react\features\display-name\components\index.web.ts

export { default as DisplayNamePrompt } from './web/DisplayNamePrompt';


################################################################################

## File: .\jitsi-meet\react\features\display-name\components\native\styles.ts

import BaseTheme from '../../../base/ui/components/BaseTheme.native';

export default {
    displayNameBackdrop: {
        alignSelf: 'center',
        backgroundColor: BaseTheme.palette.ui01,
        borderRadius: BaseTheme.shape.borderRadius,
        padding: 6
    },

    displayNamePadding: {
        paddingRight: 6
    },

    displayNameText: {
        color: BaseTheme.palette.text01,
        fontSize: 14,
        fontWeight: 'bold'
    }
};


################################################################################

## File: .\jitsi-meet\react\features\display-name\components\web\styles.ts

import { Theme } from '@mui/material';

/**
 * The vertical padding for the display name.
 */
export const DISPLAY_NAME_VERTICAL_PADDING = 4;

/**
 * Returns the typography for stage participant display name badge.
 *
 * @param {Theme} theme - The current theme.
 * @returns {ITypographyType}
 */
export function getStageParticipantTypography(theme: Theme) {
    return theme.typography.bodyShortRegularLarge;
}

/**
 * Returns the range of possible values for the font size for the stage participant display name badge.
 *
 * @param {Theme} theme - The current theme.
 * @returns {ILimits}
 */
export function getStageParticipantFontSizeRange(theme: Theme) {
    return {
        max: theme.typography.bodyShortRegularLarge.fontSize,
        min: theme.typography.bodyShortRegularSmall.fontSize
    };
}

/**
 * Returns the range of possible values for the line height for the stage participant display name badge.
 *
 * @param {Theme} theme - The current theme.
 * @returns {ILimits}
 */
export function getStageParticipantLineHeightRange(theme: Theme) {
    return {
        max: theme.typography.bodyShortRegularLarge.lineHeight,
        min: theme.typography.bodyShortRegularSmall.lineHeight
    };
}

/**
 * Returns the height + padding for stage participant display name badge.
 *
 * @param {Theme} theme - The current theme.
 * @param {number} clientHeight - The height of the visible area.
 * @returns {number}
 */
export function getStageParticipantNameLabelHeight(theme: Theme, clientHeight?: number) {
    const lineHeight = getStageParticipantNameLabelLineHeight(theme, clientHeight);

    return lineHeight + DISPLAY_NAME_VERTICAL_PADDING;
}

/**
 * Returns the height + padding for stage participant display name badge.
 *
 * @param {Theme} theme - The current theme.
 * @param {number} clientHeight - The height of the visible area.
 * @returns {number}
 */
export function getStageParticipantNameLabelLineHeight(theme: Theme, clientHeight?: number) {
    return scaleFontProperty(clientHeight, getStageParticipantLineHeightRange(theme));
}

interface ILimits {
    max: number;
    min: number;
}

/**
 * The default clint height limits used by scaleFontProperty.
 */
const DEFAULT_CLIENT_HEIGHT_LIMITS = {
    min: 300,
    max: 960
};

/**
 * Scales a css font property depending on the passed screen size.
 * Note: The result will be in the range of the specified propValueLimits. Also if the current screen height is
 * more/less than the values in screenLimits parameter the result will be the max/min of the propValuesLimits.
 *
 * @param {number|undefined} screenHeight - The current screen height.
 * @param {ILimits} propValuesLimits - The max and min value for the font property that we are scaling.
 * @param {ILimits} screenHeightLimits - The max and min value for screen height.
 * @returns {number} - The scaled prop value.
 */
export function scaleFontProperty(
        screenHeight: number | undefined,
        propValuesLimits: ILimits,
        screenHeightLimits: ILimits = DEFAULT_CLIENT_HEIGHT_LIMITS) {
    if (typeof screenHeight !== 'number') {
        return propValuesLimits.max;
    }

    const { max: maxPropSize, min: minPropSize } = propValuesLimits;
    const { max: maxHeight, min: minHeight } = screenHeightLimits;
    const propSizePerPxHeight = (maxPropSize - minPropSize) / (maxHeight - minHeight);

    return Math.round(
        (Math.max(Math.min(screenHeight, maxHeight), minHeight) - minHeight) * propSizePerPxHeight
    ) + minPropSize;
}


################################################################################

## File: .\jitsi-meet\react\features\dropbox\actions.ts

import { IStore } from '../app/types';

import { UPDATE_DROPBOX_TOKEN } from './actionTypes';
import { _authorizeDropbox } from './functions';
import logger from './logger';

/**
 * Action to authorize the Jitsi Recording app in dropbox.
 *
 * @returns {Function}
 */
export function authorizeDropbox() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const { locationURL } = state['features/base/connection'];
        const { dropbox = { appKey: '',
            redirectURI: undefined } } = state['features/base/config'];

        // By default we use the static page on the main domain for redirection.
        // So we need to setup only one redirect URI in dropbox app
        // configuration (not multiple for all the tenants).
        // In case deployment is running in subfolder dropbox.redirectURI
        // can be configured.
        const redirectURI
            = dropbox.redirectURI || `${locationURL?.origin}/static/oauth.html`;

        _authorizeDropbox(dropbox.appKey, redirectURI)
            .then(
                ({ token, rToken, expireDate }) => {
                    dispatch(updateDropboxToken(token, rToken, expireDate));
                })
            .catch(error => logger.log('Cannot authorize dropbox', error));
    };
}

/**
 * Action to update the dropbox access token.
 *
 * @param {string} token - The new token.
 * @param {string} rToken - The refresh token.
 * @param {number} expireDate - The token expiration date as UNIX timestamp.
 * @returns {{
 *     type: UPDATE_DROPBOX_TOKEN,
 *     token: string,
 *     rToken: string,
 *     expireDate: number
 * }}
 */
export function updateDropboxToken(token?: string, rToken?: string, expireDate?: number) {
    return {
        type: UPDATE_DROPBOX_TOKEN,
        token,
        rToken,
        expireDate
    };
}


################################################################################

## File: .\jitsi-meet\react\features\dropbox\actionTypes.ts

/**
 * The type of (redux) action to update the dropbox access token.
 *
 * {
 *     type: UPDATE_DROPBOX_TOKEN,
 *     token: string
 * }
 */
export const UPDATE_DROPBOX_TOKEN = 'UPDATE_DROPBOX_TOKEN';


################################################################################

## File: .\jitsi-meet\react\features\dropbox\functions.any.ts

export * from './functions';

import { getDisplayName, getSpaceUsage } from './functions';
import logger from './logger';

/**
 * Information related to the user's dropbox account.
 */
type DropboxUserData = {

    /**
     * The available space left in MB into the user's Dropbox account.
     */
    spaceLeft: number;

    /**
     * The display name of the user in Dropbox.
     */
    userName: string;
};

/**
 * Fetches information about the user's dropbox account.
 *
 * @param {string} token - The dropbox access token.
 * @param {string} appKey - The Jitsi Recorder dropbox app key.
 * @returns {Promise<DropboxUserData|undefined>}
 */
export function getDropboxData(
        token: string,
        appKey: string
): Promise<DropboxUserData | undefined> {
    return Promise.all(
        [ getDisplayName(token, appKey), getSpaceUsage(token, appKey) ]
    ).then(([ userName, space ]) => {
        const { allocated, used } = space;

        return {
            userName,
            spaceLeft: Math.floor((allocated - used) / 1048576)// 1MiB=1048576B
        };

    }, error => {
        logger.error(error);

        return undefined;
    });
}


################################################################################

## File: .\jitsi-meet\react\features\dropbox\functions.native.ts

import { NativeModules } from 'react-native';

import { IReduxState } from '../app/types';
import { setPictureInPictureEnabled } from '../mobile/picture-in-picture/functions';

const { Dropbox } = NativeModules;

/**
 * Action to authorize the Jitsi Recording app in dropbox.
 *
 * @param {any} _appKey - Used on web.
 * @param {any} _redirectURI - Used on web.
 * @returns {Promise<Object>} - The promise will be resolved with the dropbox
 * access token or rejected with an error.
 */
export async function _authorizeDropbox(_appKey?: any, _redirectURI?: any): Promise<any> {
    setPictureInPictureEnabled(false);

    try {
        return await Dropbox.authorize();
    } finally {
        setPictureInPictureEnabled(true);
    }
}

/**
 * Gets a new access token based on the refresh token.
 *
 * @param {string} _appKey - The dropbox appKey.
 * @param {string} _rToken - The refresh token.
 * @returns {Promise}
 */
export function getNewAccessToken(_appKey: string, _rToken: string) {
    return _authorizeDropbox();
}

/**
 * Returns the display name for the current dropbox account.
 *
 * @param {string} token - The dropbox access token.
 * @param {any} _appKey - Used on web.
 * @returns {Promise<string>} - The promise will be resolved with the display
 * name or rejected with an error.
 */
export function getDisplayName(token: string, _appKey?: any) {
    return Dropbox.getDisplayName(token);
}

/**
 * Returns information about the space usage for the current dropbox account.
 *
 * @param {string} token - The dropbox access token.
 * @param {any} _appKey - Used on web.
 * @returns {Promise<{ used: number, allocated: number}>} - The promise will be
 * resolved with the object with information about the space usage (the used
 * space and the allocated space) for the current dropbox account or rejected
 * with an error.
 */
export function getSpaceUsage(token: string, _appKey?: any) {
    return Dropbox.getSpaceUsage(token);
}

/**
 * Returns <tt>true</tt> if the dropbox features is enabled and <tt>false</tt>
 * otherwise.
 *
 * @param {Object} state - The redux state.
 * @returns {boolean}
 */
export function isEnabled(state: IReduxState) {
    const { dropbox = { appKey: undefined } } = state['features/base/config'];

    return Boolean(Dropbox?.ENABLED && typeof dropbox.appKey === 'string');
}


################################################################################

## File: .\jitsi-meet\react\features\dropbox\functions.web.ts

import { Dropbox, DropboxAuth } from 'dropbox';

import { IReduxState } from '../app/types';

/**
 * Executes the oauth flow.
 *
 * @param {string} authUrl - The URL to oauth service.
 * @returns {Promise<string>} - The URL with the authorization details.
 */
function authorize(authUrl: string): Promise<string> {
    const windowName = `oauth${Date.now()}`;

    return new Promise(resolve => {
        // eslint-disable-next-line prefer-const
        let popup: any;
        const handleAuth = ({ data }: { data: { type: string; url: string; windowName: string; }; }) => {
            if (data && data.type === 'dropbox-login' && data.windowName === windowName) {
                if (popup) {
                    popup.close();
                }
                window.removeEventListener('message', handleAuth);
                resolve(data.url);
            }
        };

        window.addEventListener('message', handleAuth);
        popup = window.open(authUrl, windowName);
    });
}

/**
 * Returns the token's expiry date as UNIX timestamp.
 *
 * @param {number} expiresIn - The seconds in which the token expires.
 * @returns {number} - The timestamp value for the expiry date.
 */
function getTokenExpiresAtTimestamp(expiresIn: number) {
    return new Date(Date.now() + (expiresIn * 1000)).getTime();
}

/**
 * Action to authorize the Jitsi Recording app in dropbox.
 *
 * @param {string} appKey - The Jitsi Recorder dropbox app key.
 * @param {string} redirectURI - The return URL.
 * @returns {Promise<Object>}
 */
export function _authorizeDropbox(
        appKey: string,
        redirectURI: string
): Promise<any> {
    const dropbox = new DropboxAuth({ clientId: appKey });

    return dropbox.getAuthenticationUrl(redirectURI, undefined, 'code', 'offline', undefined, undefined, true)

        // @ts-ignore
        .then(authorize)
        .then(returnUrl => {
            const params = new URLSearchParams(new URL(returnUrl).search);
            const code = params.get('code');

            return dropbox.getAccessTokenFromCode(redirectURI, code ?? '');
        })
        .then((resp: any) => {
            return {
                token: resp.result.access_token,
                rToken: resp.result.refresh_token,
                expireDate: getTokenExpiresAtTimestamp(resp.result.expires_in)
            };
        });
}


/**
 * Gets a new access token based on the refresh token.
 *
 * @param {string} appKey - The dropbox appKey.
 * @param {string} rToken - The refresh token.
 * @returns {Promise}
 */
export function getNewAccessToken(appKey: string, rToken: string) {
    const dropbox = new DropboxAuth({ clientId: appKey });

    dropbox.setRefreshToken(rToken);

    return dropbox.refreshAccessToken() // @ts-ignore
        .then(() => {
            return {
                token: dropbox.getAccessToken(),
                rToken: dropbox.getRefreshToken(),
                expireDate: dropbox.getAccessTokenExpiresAt().getTime()
            };
        });
}

/**
 * Returns the display name for the current dropbox account.
 *
 * @param {string} token - The dropbox access token.
 * @param {string} appKey - The Jitsi Recorder dropbox app key.
 * @returns {Promise<string>}
 */
export function getDisplayName(token: string, appKey: string) {
    const dropboxAPI = new Dropbox({
        accessToken: token,
        clientId: appKey
    });

    return (
        dropboxAPI.usersGetCurrentAccount()
            .then(account => account.result.name.display_name));
}

/**
 * Returns information about the space usage for the current dropbox account.
 *
 * @param {string} token - The dropbox access token.
 * @param {string} appKey - The Jitsi Recorder dropbox app key.
 * @returns {Promise<Object>}
 */
export function getSpaceUsage(token: string, appKey: string) {
    const dropboxAPI = new Dropbox({
        accessToken: token,
        clientId: appKey
    });

    return dropboxAPI.usersGetSpaceUsage().then(space => {
        const { allocation, used } = space.result;

        // @ts-ignore
        const { allocated } = allocation;

        return {
            allocated,
            used
        };
    });
}

/**
 * Returns <tt>true</tt> if the dropbox features is enabled and <tt>false</tt>
 * otherwise.
 *
 * @param {Object} state - The redux state.
 * @returns {boolean}
 */
export function isEnabled(state: IReduxState) {
    const { dropbox = { appKey: undefined } } = state['features/base/config'];

    return typeof dropbox.appKey === 'string';
}


################################################################################

## File: .\jitsi-meet\react\features\dropbox\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/dropbox');


################################################################################

## File: .\jitsi-meet\react\features\dropbox\reducer.ts

import PersistenceRegistry from '../base/redux/PersistenceRegistry';
import ReducerRegistry from '../base/redux/ReducerRegistry';

import { UPDATE_DROPBOX_TOKEN } from './actionTypes';

/**
 * The redux subtree of this feature.
 */
const STORE_NAME = 'features/dropbox';

export interface IDropboxState {
    expireDate?: number;
    rToken?: string;
    token?: string;
}

/**
 * Sets up the persistence of the feature {@code dropbox}.
 */
PersistenceRegistry.register(STORE_NAME);

ReducerRegistry.register<IDropboxState>(STORE_NAME, (state = {}, action): IDropboxState => {
    switch (action.type) {
    case UPDATE_DROPBOX_TOKEN:
        return {
            ...state,
            token: action.token,
            rToken: action.rToken,
            expireDate: action.expireDate
        };
    default:
        return state;
    }
});


################################################################################

## File: .\jitsi-meet\react\features\dynamic-branding\actions.any.ts

import { IStore } from '../app/types';
import { doGetJSON } from '../base/util/httpUtils';

import {
    SET_DYNAMIC_BRANDING_DATA,
    SET_DYNAMIC_BRANDING_FAILED,
    SET_DYNAMIC_BRANDING_READY
} from './actionTypes';
import { getDynamicBrandingUrl } from './functions.any';
import logger from './logger';


/**
 * Fetches custom branding data.
 * If there is no data or the request fails, sets the `customizationReady` flag
 * so the defaults can be displayed.
 *
 * @returns {Function}
 */
export function fetchCustomBrandingData() {
    return async function(dispatch: IStore['dispatch'], getState: IStore['getState']) {
        const state = getState();
        const { customizationReady } = state['features/dynamic-branding'];

        if (!customizationReady) {
            const url = await getDynamicBrandingUrl(state);

            if (url) {
                try {
                    const res = await doGetJSON(url);

                    return dispatch(setDynamicBrandingData(res));
                } catch (err) {
                    logger.error('Error fetching branding data', err);

                    return dispatch(setDynamicBrandingFailed());
                }
            }

            dispatch(setDynamicBrandingReady());
        }
    };
}

/**
 * Action used to set the user customizations.
 *
 * @param {Object} value - The custom data to be set.
 * @returns {Object}
 */
export function setDynamicBrandingData(value: Object) {
    return {
        type: SET_DYNAMIC_BRANDING_DATA,
        value
    };
}

/**
 * Action used to signal the branding elements are ready to be displayed.
 *
 * @returns {Object}
 */
export function setDynamicBrandingReady() {
    return {
        type: SET_DYNAMIC_BRANDING_READY
    };
}

/**
 * Action used to signal the branding request failed.
 *
 * @returns {Object}
 */
export function setDynamicBrandingFailed() {
    return {
        type: SET_DYNAMIC_BRANDING_FAILED
    };
}


################################################################################

## File: .\jitsi-meet\react\features\dynamic-branding\actions.native.ts

import { IStore } from '../app/types';
import { doGetJSON } from '../base/util/httpUtils';

import { UNSET_DYNAMIC_BRANDING } from './actionTypes';
import {
    setDynamicBrandingData,
    setDynamicBrandingFailed,
    setDynamicBrandingReady
} from './actions.any';
import { getDynamicBrandingUrl } from './functions.any';
import logger from './logger';


/**
 * Fetches custom branding data.
 * If there is no data or the request fails, sets the `customizationReady` flag
 * so the defaults can be displayed.
 *
 * @returns {Function}
 */
export function fetchCustomBrandingData() {
    return async function(dispatch: IStore['dispatch'], getState: IStore['getState']) {
        const state = getState();
        const dynamicBrandingUrl = await getDynamicBrandingUrl(state);

        if (dynamicBrandingUrl) {
            try {
                return dispatch(
                    setDynamicBrandingData(
                    await doGetJSON(dynamicBrandingUrl))
                );
            } catch (err) {
                logger.error('Error fetching branding data', err);

                return dispatch(
                    setDynamicBrandingFailed()
                );
            }
        } else {
            dispatch(unsetDynamicBranding());
        }

        dispatch(setDynamicBrandingReady());
    };
}

/**
 * Action used to unset branding elements.
 *
 * @returns {Object}
 */
export function unsetDynamicBranding() {
    return {
        type: UNSET_DYNAMIC_BRANDING
    };
}


################################################################################

## File: .\jitsi-meet\react\features\dynamic-branding\actionTypes.ts

/**
 * Action used to set custom user properties.
 */
export const SET_DYNAMIC_BRANDING_DATA = 'SET_DYNAMIC_BRANDING_DATA';

/**
 * Action used to signal the customization failed.
 */
export const SET_DYNAMIC_BRANDING_FAILED = 'SET_DYNAMIC_BRANDING_FAILED';

/**
 * Action used to signal the branding elements are ready to be displayed
 */
export const SET_DYNAMIC_BRANDING_READY = 'SET_DYNAMIC_BRANDING_READY';

/**
 * Action used to unset branding elements
 */
export const UNSET_DYNAMIC_BRANDING = 'UNSET_DYNAMIC_BRANDING';


################################################################################

## File: .\jitsi-meet\react\features\dynamic-branding\functions.any.ts

import { IReduxState } from '../app/types';
import { IStateful } from '../base/app/types';
import { toState } from '../base/redux/functions';

import logger from './logger';

/**
 * Extracts the fqn part from a path, where fqn represents
 * tenant/roomName.
 *
 * @param {Object} state - A redux state.
 * @returns {string}
 */
export function extractFqnFromPath(state?: IReduxState) {
    let pathname;

    if (window.location.pathname) {
        pathname = window.location.pathname;
    } else if (state?.['features/base/connection']) {
        pathname = state['features/base/connection'].locationURL?.pathname ?? '';
    } else {
        return '';
    }

    const parts = pathname.split('/');
    const len = parts.length;

    return parts.length > 2 ? `${parts[len - 2]}/${parts[len - 1]}` : parts[1];
}

/**
 * Returns the url used for fetching dynamic branding.
 *
 * @param {Object | Function} stateful - The redux store, state, or
 * {@code getState} function.
 * @returns {string}
 */
export async function getDynamicBrandingUrl(stateful: IStateful) {
    const state = toState(stateful);

    // NB: On web this is dispatched really early, before the config has been stored in the
    // state. Thus, fetch it from the window global.
    const config
        = navigator.product === 'ReactNative' ? state['features/base/config'] : window.config;
    const { dynamicBrandingUrl } = config;

    if (dynamicBrandingUrl) {
        return dynamicBrandingUrl;
    }

    const { brandingDataUrl: baseUrl } = config;
    const fqn = extractFqnFromPath(state);

    if (baseUrl && fqn) {
        return `${baseUrl}?conferenceFqn=${encodeURIComponent(fqn)}`;
    }
}

/**
 * Selector used for getting the load state of the dynamic branding data.
 *
 * @param {Object} state - Global state of the app.
 * @returns {boolean}
 */
export function isDynamicBrandingDataLoaded(state: IReduxState) {
    return state['features/dynamic-branding'].customizationReady;
}

/**
 * Fetch SVG XMLs from branding icons urls.
 *
 * @param {Object} customIcons - The map of branded icons.
 * @returns {Object}
 */
export const fetchCustomIcons = async (customIcons: Record<string, string>) => {
    const localCustomIcons: Record<string, string> = {};

    for (const [ key, url ] of Object.entries(customIcons)) {
        try {
            const response = await fetch(url);

            if (response.ok) {
                const svgXml = await response.text();

                localCustomIcons[key] = svgXml;
            } else {
                logger.error(`Failed to fetch ${url}. Status: ${response.status}`);
            }
        } catch (error) {
            logger.error(`Error fetching ${url}:`, error);
        }
    }

    return localCustomIcons;
};


################################################################################

## File: .\jitsi-meet\react\features\dynamic-branding\functions.web.ts

import { Theme } from '@mui/material';
import { adaptV4Theme, createTheme } from '@mui/material/styles';

import { breakpoints, colorMap, colors, font, shape, spacing, typography } from '../base/ui/Tokens';
import { createColorTokens } from '../base/ui/utils';

/**
 * Creates MUI branding theme based on the custom theme json.
 *
 * @param {Object} customTheme - The branded custom theme.
 * @returns {Object} - The MUI theme.
 */
export function createMuiBrandingTheme(customTheme: Theme) {
    const {
        palette: customPalette,
        shape: customShape,
        typography: customTypography,
        breakpoints: customBreakpoints,
        spacing: customSpacing
    } = customTheme;

    const newPalette = createColorTokens(colorMap, colors);

    if (customPalette) {
        overwriteRecurrsive(newPalette, customPalette);
    }

    const newShape = { ...shape };

    if (customShape) {
        overwriteRecurrsive(newShape, customShape);
    }

    const newTypography = {
        font: { ...font },
        ...typography
    };

    if (customTypography) {
        overwriteRecurrsive(newTypography, customTypography);
    }

    const newBreakpoints = { ...breakpoints };

    if (customBreakpoints) {
        overwriteRecurrsive(newBreakpoints, customBreakpoints);
    }

    let newSpacing: any = [ ...spacing ];

    if (customSpacing?.length) {
        newSpacing = customSpacing;
    }

    return createTheme(adaptV4Theme({
        spacing: newSpacing,
        palette: newPalette,
        shape: newShape,

        // @ts-ignore
        typography: newTypography,

        // @ts-ignore
        breakpoints: newBreakpoints
    }));
}

/**
* Overwrites recursively values from object 2 into object 1 based on common keys.
* (Merges object2 into object1).
*
* @param {Object} obj1 - The object holding the merged values.
* @param {Object} obj2 - The object to compare to and take values from.
* @returns {void}
*/
function overwriteRecurrsive(obj1: Object, obj2: Object) {
    Object.keys(obj2).forEach(key => {
        if (obj1.hasOwnProperty(key)) {
            if (typeof obj1[key as keyof typeof obj1] === 'object') {
                overwriteRecurrsive(obj1[key as keyof typeof obj1], obj2[key as keyof typeof obj2]);
            } else {
                // @ts-ignore
                obj1[key] = obj2[key];
            }
        }
    });
}


################################################################################

## File: .\jitsi-meet\react\features\dynamic-branding\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/dynamic-branding');


################################################################################

## File: .\jitsi-meet\react\features\dynamic-branding\middleware.any.ts

import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';

import { SET_DYNAMIC_BRANDING_DATA } from './actionTypes';
import { fetchCustomIcons } from './functions.any';
import logger from './logger';

MiddlewareRegistry.register(() => next => action => {
    switch (action.type) {
    case SET_DYNAMIC_BRANDING_DATA: {
        const { customIcons } = action.value;

        if (customIcons) {
            fetchCustomIcons(customIcons)
                .then(localCustomIcons => {
                    action.value.brandedIcons = localCustomIcons;

                    return next(action);
                })
                .catch((error: any) => {
                    logger.error('Error fetching branded custom icons:', error);
                });
        }

        break;
    }
    }

    return next(action);
});


################################################################################

## File: .\jitsi-meet\react\features\dynamic-branding\middleware.native.ts

import { SET_CONFIG } from '../base/config/actionTypes';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';

import { SET_DYNAMIC_BRANDING_DATA } from './actionTypes';
import { fetchCustomBrandingData } from './actions.native';

import './middleware.any';

MiddlewareRegistry.register(store => next => action => {
    switch (action.type) {
    case SET_CONFIG: {
        const result = next(action);

        store.dispatch(fetchCustomBrandingData());

        return result;
    }

    case SET_DYNAMIC_BRANDING_DATA: {
        const {
            avatarBackgrounds = [],
            backgroundColor,
            backgroundImageUrl,
            brandedIcons,
            didPageUrl,
            inviteDomain,
            labels,
            sharedVideoAllowedURLDomains
        } = action.value;

        action.value = {
            avatarBackgrounds,
            backgroundColor,
            backgroundImageUrl,
            brandedIcons,
            didPageUrl,
            inviteDomain,
            labels,
            sharedVideoAllowedURLDomains
        };

        // The backend may send an empty string, make sure we skip that.
        if (Array.isArray(avatarBackgrounds)) {
            // TODO: implement support for gradients.
            action.value.avatarBackgrounds = avatarBackgrounds.filter(
                (color: string) => !color.includes('linear-gradient')
            );
        }

        break;
    }
    }

    return next(action);
});


################################################################################

## File: .\jitsi-meet\react\features\dynamic-branding\middleware.web.ts

import { APP_WILL_MOUNT } from '../base/app/actionTypes';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';

import { SET_DYNAMIC_BRANDING_DATA } from './actionTypes';
import { fetchCustomBrandingData } from './actions.any';
import { createMuiBrandingTheme } from './functions.web';

import './middleware.any';

MiddlewareRegistry.register(store => next => action => {
    switch (action.type) {
    case APP_WILL_MOUNT: {

        store.dispatch(fetchCustomBrandingData());
        break;
    }
    case SET_DYNAMIC_BRANDING_DATA: {
        const { customTheme } = action.value;

        if (customTheme) {
            action.value.muiBrandedTheme = createMuiBrandingTheme(customTheme);
        }
    }
    }

    return next(action);
});


################################################################################

## File: .\jitsi-meet\react\features\dynamic-branding\reducer.ts

import ReducerRegistry from '../base/redux/ReducerRegistry';
import { type Image } from '../virtual-background/constants';

import {
    SET_DYNAMIC_BRANDING_DATA,
    SET_DYNAMIC_BRANDING_FAILED,
    SET_DYNAMIC_BRANDING_READY,
    UNSET_DYNAMIC_BRANDING
} from './actionTypes';


/**
 * The name of the redux store/state property which is the root of the redux
 * state of the feature {@code dynamic-branding}.
 */
const STORE_NAME = 'features/dynamic-branding';

const DEFAULT_STATE = {

    /**
     * The pool of avatar backgrounds.
     *
     * @public
     * @type {Array<string>}
     */
    avatarBackgrounds: [],

    /**
     * The custom background color for the LargeVideo.
     *
     * @public
     * @type {string}
     */
    backgroundColor: '',

    /**
     * The custom background image used on the LargeVideo.
     *
     * @public
     * @type {string}
     */
    backgroundImageUrl: '',

    /**
     * Flag indicating that the branding data can be displayed.
     * This is used in order to avoid image flickering / text changing(blipping).
     *
     * @public
     * @type {boolean}
     */
    customizationReady: false,

    /**
     * Flag indicating that the dynamic branding data request has failed.
     * When the request fails there is no logo (JitsiWatermark) displayed.
     *
     * @public
     * @type {boolean}
     */
    customizationFailed: false,

    /**
     * Flag indicating that the dynamic branding has not been modified and should use
     * the default options.
     *
     * @public
     * @type {boolean}
     */
    defaultBranding: true,

    /**
     * Url for a custom page for DID numbers list.
     *
     * @public
     * @type {string}
     */
    didPageUrl: '',

    /**
     * The custom invite domain.
     *
     * @public
     * @type {string}
     */
    inviteDomain: '',

    /**
     * An object containing the mapping between the language and url where the translation
     * bundle is hosted.
     *
     * @public
     * @type {Object}
     */
    labels: null,

    /**
     * The custom url used when the user clicks the logo.
     *
     * @public
     * @type {string}
     */
    logoClickUrl: '',

    /**
     * The custom logo (JitisWatermark).
     *
     * @public
     * @type {string}
     */
    logoImageUrl: '',

    /**
     * The generated MUI branded theme based on the custom theme json.
     *
     * @public
     * @type {boolean}
     */
    muiBrandedTheme: undefined,

    /**
     * The lobby/prejoin background.
     *
     * @public
     * @type {string}
     */
    premeetingBackground: '',

    /**
     * Flag used to signal if the app should use a custom logo or not.
     *
     * @public
     * @type {boolean}
     */
    useDynamicBrandingData: false,

    /**
     * An array of images to be used as virtual backgrounds instead of the default ones.
     *
     * @public
     * @type {Array<Object>}
     */
    virtualBackgrounds: []
};

export interface IDynamicBrandingState {
    avatarBackgrounds: string[];
    backgroundColor: string;
    backgroundImageUrl: string;
    brandedIcons?: Record<string, string>;
    customizationFailed: boolean;
    customizationReady: boolean;
    defaultBranding: boolean;
    didPageUrl: string;
    inviteDomain: string;
    labels: Object | null;
    logoClickUrl: string;
    logoImageUrl: string;
    muiBrandedTheme?: boolean;
    premeetingBackground: string;
    sharedVideoAllowedURLDomains?: Array<string>;
    showGiphyIntegration?: boolean;
    useDynamicBrandingData: boolean;
    virtualBackgrounds: Array<Image>;
}

/**
 * Reduces redux actions for the purposes of the feature {@code dynamic-branding}.
 */
ReducerRegistry.register<IDynamicBrandingState>(STORE_NAME, (state = DEFAULT_STATE, action): IDynamicBrandingState => {
    switch (action.type) {
    case SET_DYNAMIC_BRANDING_DATA: {
        const {
            avatarBackgrounds,
            backgroundColor,
            backgroundImageUrl,
            brandedIcons,
            defaultBranding,
            didPageUrl,
            inviteDomain,
            labels,
            logoClickUrl,
            logoImageUrl,
            muiBrandedTheme,
            premeetingBackground,
            sharedVideoAllowedURLDomains,
            showGiphyIntegration,
            virtualBackgrounds
        } = action.value;

        return {
            avatarBackgrounds,
            backgroundColor,
            backgroundImageUrl,
            brandedIcons,
            defaultBranding,
            didPageUrl,
            inviteDomain,
            labels,
            logoClickUrl,
            logoImageUrl,
            muiBrandedTheme,
            premeetingBackground,
            sharedVideoAllowedURLDomains,
            showGiphyIntegration,
            customizationFailed: false,
            customizationReady: true,
            useDynamicBrandingData: true,
            virtualBackgrounds: formatImages(virtualBackgrounds || [])
        };
    }
    case SET_DYNAMIC_BRANDING_FAILED: {
        return {
            ...state,
            customizationReady: true,
            customizationFailed: true,
            useDynamicBrandingData: true
        };
    }
    case SET_DYNAMIC_BRANDING_READY:
        return {
            ...state,
            customizationReady: true
        };

    case UNSET_DYNAMIC_BRANDING:
        return DEFAULT_STATE;
    }

    return state;
});

/**
 * Transforms the branding images into an array of Images objects ready
 * to be used as virtual backgrounds.
 *
 * @param {Array<string>} images - The branding images.
 * @private
 * @returns {{Props}}
 */
function formatImages(images: Array<string> | Array<{ src: string; tooltip?: string; }>): Array<Image> {
    return images.map((img, i) => {
        let src;
        let tooltip;

        if (typeof img === 'object') {
            ({ src, tooltip } = img);
        } else {
            src = img;
        }

        return {
            id: `branding-${i}`,
            src,
            tooltip
        };
    });
}


################################################################################

## File: .\jitsi-meet\react\features\dynamic-branding\components\native\styles.ts

export default {

    /**
     * {@code BrandingImageBackground} Style.
     */
    brandingImageBackgroundSvg: {
        position: 'absolute'
    },

    brandingImageBackground: {
        height: '100%',
        position: 'absolute',
        width: '100%'
    }
};


################################################################################

## File: .\jitsi-meet\react\features\e2ee\actions.ts

import {
    PARTICIPANT_VERIFIED,
    SET_MAX_MODE,
    SET_MEDIA_ENCRYPTION_KEY,
    START_VERIFICATION,
    TOGGLE_E2EE } from './actionTypes';

/**
 * Dispatches an action to enable / disable E2EE.
 *
 * @param {boolean} enabled - Whether E2EE is to be enabled or not.
 * @returns {Object}
 */
export function toggleE2EE(enabled: boolean) {
    return {
        type: TOGGLE_E2EE,
        enabled
    };
}

/**
 * Dispatches an action to set E2EE maxMode.
 *
 * @param {string} maxMode - The new value.
 * @returns {Object}
 */
export function setE2EEMaxMode(maxMode: string) {
    return {
        type: SET_MAX_MODE,
        maxMode
    };
}

/**
 * Dispatches an action to set media encryption key.
 *
 * @param {Object} keyInfo - Json containing key information.
 * @param {string} [keyInfo.encryptionKey] - The exported encryption key.
 * @param {number} [keyInfo.index] - The index of the encryption key.
 * @returns {{
 *     type: SET_MEDIA_ENCRYPTION_KEY,
 *     keyInfo: Object
 * }}
 */
export function setMediaEncryptionKey(keyInfo: Object) {
    return {
        type: SET_MEDIA_ENCRYPTION_KEY,
        keyInfo
    };
}

/**
 * Dispatches an action to start participant e2ee verficiation process.
 *
 * @param {string} pId - The participant id.
 * @returns {{
 *     type: START_VERIFICATION,
 *     pId: string
 * }}
 */
export function startVerification(pId: string) {
    return {
        type: START_VERIFICATION,
        pId
    };
}

/**
 * Dispatches an action to set participant e2ee verification status.
 *
 * @param {string} pId - The participant id.
 * @param {boolean} isVerified - The verifcation status.
 * @returns {{
 *     type: PARTICIPANT_VERIFIED,
 *     pId: string,
 *     isVerified: boolean
 * }}
 */
export function participantVerified(pId: string, isVerified: boolean) {
    return {
        type: PARTICIPANT_VERIFIED,
        pId,
        isVerified
    };
}


################################################################################

## File: .\jitsi-meet\react\features\e2ee\actionTypes.ts

/**
 * The type of the action which signals that E2EE needs to be enabled / disabled.
 *
 * {
 *     type: TOGGLE_E2EE
 * }
 */
export const TOGGLE_E2EE = 'TOGGLE_E2EE';

/**
 * The type of the action which signals to set new value E2EE maxMode.
 *
 * {
 *     type: SET_MAX_MODE
 * }
 */
export const SET_MAX_MODE = 'SET_MAX_MODE';

/**
 * The type of the action which signals to set media encryption key for e2ee.
 *
 * {
 *     type: SET_MEDIA_ENCRYPTION_KEY
 * }
 */
export const SET_MEDIA_ENCRYPTION_KEY = 'SET_MEDIA_ENCRYPTION_KEY';

export const START_VERIFICATION = 'START_VERIFICATION';

export const PARTICIPANT_VERIFIED = 'PARTICIPANT_VERIFIED';


################################################################################

## File: .\jitsi-meet\react\features\e2ee\constants.ts

/**
 * The identifier of the sound to be played when e2ee is disabled.
 *
 * @type {string}
 */
export const E2EE_OFF_SOUND_ID = 'E2EE_OFF_SOUND';

/**
 * The identifier of the sound to be played when e2ee is enabled.
 *
 * @type {string}
 */
export const E2EE_ON_SOUND_ID = 'E2EE_ON_SOUND';

/**
 * The number of participants after which e2ee maxMode is set to MAX_MODE.ENABLED.
 *
 * @type {integer}
 */
export const MAX_MODE_LIMIT = 20;

/**
 * If the number of participants is greater then MAX_MODE_LIMIT + MAX_MODE_THRESHOLD
 * e2ee maxMode is set to MAX_MODE.THRESHOLD_EXCEEDED.
 *
 * @type {integer}
 */
export const MAX_MODE_THRESHOLD = 5;

export const MAX_MODE = {
    /**
     * Mode for which the e2ee can be enabled or disabled.
     * If e2ee is enabled, e2ee section is enabled with a warning text.
     * If e2ee is disabled, e2ee section is disabled with a warning text.
     *
     * @type {string}
     */
    ENABLED: 'max-mode-enabled',

    /**
     * Mode for which the e2ee and the e2ee section are automatically disabled.
     *
     * @type {string}
     */
    THRESHOLD_EXCEEDED: 'max-mode-threshold-exceeded',

    /**
     * The default e2ee maxMode, e2ee can be enabled/disabled, e2ee section is enabled.
     *
     * @type {string}
     */
    DISABLED: 'max-mode-disabled'
};


################################################################################

## File: .\jitsi-meet\react\features\e2ee\functions.ts

import i18next from 'i18next';

import { IReduxState, IStore } from '../app/types';
import { IStateful } from '../base/app/types';
import { getSoundFileSrc } from '../base/media/functions';
import { getParticipantById, getParticipantCount, getParticipantCountWithFake } from '../base/participants/functions';
import { toState } from '../base/redux/functions';
import { registerSound, unregisterSound } from '../base/sounds/actions';

import {
    E2EE_OFF_SOUND_ID,
    E2EE_ON_SOUND_ID,
    MAX_MODE_LIMIT,
    MAX_MODE_THRESHOLD
} from './constants';
import {
    E2EE_OFF_SOUND_FILE,
    E2EE_ON_SOUND_FILE
} from './sounds';


/**
 * Gets the value of a specific React {@code Component} prop of the currently
 * mounted {@link App}.
 *
 * @param {IStateful} stateful - The redux store or {@code getState}
 * function.
 * @param {string} propName - The name of the React {@code Component} prop of
 * the currently mounted {@code App} to get.
 * @returns {*} The value of the specified React {@code Component} prop of the
 * currently mounted {@code App}.
 */
export function doesEveryoneSupportE2EE(stateful: IStateful) {
    const state = toState(stateful);
    const { numberOfParticipantsNotSupportingE2EE } = state['features/base/participants'];
    const { e2eeSupported } = state['features/base/conference'];
    const participantCount = getParticipantCountWithFake(state);

    if (participantCount === 1) {
        // This will happen if we are alone.

        return e2eeSupported;
    }

    return numberOfParticipantsNotSupportingE2EE === 0;
}

/**
 * Returns true is the number of participants is larger than {@code MAX_MODE_LIMIT}.
 *
 * @param {Function|Object} stateful - The redux store or {@code getState}
 * function.
 * @returns {boolean}
 */
export function isMaxModeReached(stateful: IStateful) {
    const participantCount = getParticipantCount(toState(stateful));

    return participantCount >= MAX_MODE_LIMIT;
}

/**
 * Returns true is the number of participants is larger than {@code MAX_MODE_LIMIT + MAX_MODE_THREHOLD}.
 *
 * @param {Function|Object} stateful - The redux store or {@code getState}
 * function.
 * @returns {boolean}
 */
export function isMaxModeThresholdReached(stateful: IStateful) {
    const participantCount = getParticipantCount(toState(stateful));

    return participantCount >= MAX_MODE_LIMIT + MAX_MODE_THRESHOLD;
}

/**
 * Returns whether e2ee is enabled by the backend.
 *
 * @param {Object} state - The redux state.
 * @param {string} pId - The participant id.
 * @returns {boolean}
 */
export function displayVerification(state: IReduxState, pId: string) {
    const { conference } = state['features/base/conference'];
    const participant = getParticipantById(state, pId);

    return Boolean(conference?.isE2EEEnabled()
        && participant?.e2eeVerificationAvailable
        && participant?.e2eeVerified === undefined);
}

/**
 * Unregisters the audio files based on locale.
 *
 * @param {Dispatch<any>} dispatch - The redux dispatch function.
 * @returns {void}
 */
export function unregisterE2eeAudioFiles(dispatch: IStore['dispatch']) {
    dispatch(unregisterSound(E2EE_OFF_SOUND_ID));
    dispatch(unregisterSound(E2EE_ON_SOUND_ID));
}

/**
 * Registers the audio files based on locale.
 *
 * @param {Dispatch<any>} dispatch - The redux dispatch function.
 * @param {boolean|undefined} shouldUnregister - Whether the sounds should be unregistered.
 * @returns {void}
 */
export function registerE2eeAudioFiles(dispatch: IStore['dispatch'], shouldUnregister?: boolean) {
    const language = i18next.language;

    shouldUnregister && unregisterE2eeAudioFiles(dispatch);

    dispatch(registerSound(
        E2EE_OFF_SOUND_ID,
        getSoundFileSrc(E2EE_OFF_SOUND_FILE, language)));

    dispatch(registerSound(
        E2EE_ON_SOUND_ID,
        getSoundFileSrc(E2EE_ON_SOUND_FILE, language)));
}


################################################################################

## File: .\jitsi-meet\react\features\e2ee\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/e2ee');


################################################################################

## File: .\jitsi-meet\react\features\e2ee\middleware.ts

import { IStore } from '../app/types';
import { APP_WILL_MOUNT, APP_WILL_UNMOUNT } from '../base/app/actionTypes';
import { CONFERENCE_JOINED } from '../base/conference/actionTypes';
import { getCurrentConference } from '../base/conference/functions';
import { openDialog } from '../base/dialog/actions';
import { JitsiConferenceEvents } from '../base/lib-jitsi-meet';
import { PARTICIPANT_JOINED, PARTICIPANT_LEFT } from '../base/participants/actionTypes';
import { participantUpdated } from '../base/participants/actions';
import {
    getLocalParticipant,
    getParticipantById,
    isScreenShareParticipant
} from '../base/participants/functions';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import StateListenerRegistry from '../base/redux/StateListenerRegistry';
import { playSound } from '../base/sounds/actions';

import { PARTICIPANT_VERIFIED, SET_MEDIA_ENCRYPTION_KEY, START_VERIFICATION, TOGGLE_E2EE } from './actionTypes';
import { setE2EEMaxMode, toggleE2EE } from './actions';
import ParticipantVerificationDialog from './components/ParticipantVerificationDialog';
import { E2EE_OFF_SOUND_ID, E2EE_ON_SOUND_ID, MAX_MODE } from './constants';
import {
    isMaxModeReached,
    isMaxModeThresholdReached,
    registerE2eeAudioFiles,
    unregisterE2eeAudioFiles
} from './functions';
import logger from './logger';

/**
 * Middleware that captures actions related to E2EE.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(({ dispatch, getState }) => next => action => {
    const conference = getCurrentConference(getState);

    switch (action.type) {
    case APP_WILL_MOUNT:
        registerE2eeAudioFiles(dispatch);
        break;

    case APP_WILL_UNMOUNT:
        unregisterE2eeAudioFiles(dispatch);
        break;

    case CONFERENCE_JOINED:
        _updateMaxMode(dispatch, getState);

        break;

    case PARTICIPANT_JOINED: {
        const result = next(action);

        if (!isScreenShareParticipant(action.participant) && !action.participant.local) {
            _updateMaxMode(dispatch, getState);
        }

        return result;
    }

    case PARTICIPANT_LEFT: {
        const participant = getParticipantById(getState(), action.participant?.id);
        const result = next(action);

        if (!isScreenShareParticipant(participant)) {
            _updateMaxMode(dispatch, getState);
        }

        return result;
    }

    case TOGGLE_E2EE: {
        if (conference?.isE2EESupported() && conference.isE2EEEnabled() !== action.enabled) {
            logger.debug(`E2EE will be ${action.enabled ? 'enabled' : 'disabled'}`);
            conference.toggleE2EE(action.enabled);

            // Broadcast that we enabled / disabled E2EE.
            const participant = getLocalParticipant(getState);

            dispatch(participantUpdated({
                e2eeEnabled: action.enabled,
                id: participant?.id ?? '',
                local: true
            }));

            const soundID = action.enabled ? E2EE_ON_SOUND_ID : E2EE_OFF_SOUND_ID;

            dispatch(playSound(soundID));
        }

        break;
    }

    case SET_MEDIA_ENCRYPTION_KEY: {
        if (conference?.isE2EESupported()) {
            const { exportedKey, index } = action.keyInfo;

            if (exportedKey) {
                window.crypto.subtle.importKey(
                    'raw',
                    new Uint8Array(exportedKey),
                    'AES-GCM',
                    false,
                    [ 'encrypt', 'decrypt' ])
                .then(
                    encryptionKey => {
                        conference.setMediaEncryptionKey({
                            encryptionKey,
                            index
                        });
                    })
                .catch(error => logger.error('SET_MEDIA_ENCRYPTION_KEY error', error));
            } else {
                conference.setMediaEncryptionKey({
                    encryptionKey: false,
                    index
                });
            }
        }

        break;
    }

    case PARTICIPANT_VERIFIED: {
        const { isVerified, pId } = action;

        conference?.markParticipantVerified(pId, isVerified);
        break;
    }

    case START_VERIFICATION: {
        conference?.startVerification(action.pId);
        break;
    }
    }

    return next(action);
});

/**
 * Set up state change listener to perform maintenance tasks when the conference
 * is left or failed.
 */
StateListenerRegistry.register(
    state => getCurrentConference(state),
    (conference, { dispatch }, previousConference) => {
        if (previousConference) {
            dispatch(toggleE2EE(false));
        }

        if (conference) {
            conference.on(JitsiConferenceEvents.E2EE_VERIFICATION_AVAILABLE, (pId: string) => {
                dispatch(participantUpdated({
                    e2eeVerificationAvailable: true,
                    id: pId
                }));
            });

            conference.on(JitsiConferenceEvents.E2EE_VERIFICATION_READY, (pId: string, sas: object) => {
                dispatch(openDialog(ParticipantVerificationDialog, { pId,
                    sas }));
            });

            conference.on(JitsiConferenceEvents.E2EE_VERIFICATION_COMPLETED,
                (pId: string, success: boolean, message: string) => {
                    if (message) {
                        logger.warn('E2EE_VERIFICATION_COMPLETED warning', message);
                    }
                    dispatch(participantUpdated({
                        e2eeVerified: success,
                        id: pId
                    }));
                });
        }
    });

/**
 * Sets the maxMode based on the number of participants in the conference.
 *
 * @param { Dispatch<any>} dispatch - The redux dispatch function.
 * @param {Function|Object} getState - The {@code getState} function.
 * @private
 * @returns {void}
 */
function _updateMaxMode(dispatch: IStore['dispatch'], getState: IStore['getState']) {
    const state = getState();

    const { e2ee = {} } = state['features/base/config'];

    if (e2ee.externallyManagedKey) {
        return;
    }

    const { maxMode, enabled } = state['features/e2ee'];
    const isMaxModeThresholdReachedValue = isMaxModeThresholdReached(state);
    let newMaxMode: string;

    if (isMaxModeThresholdReachedValue) {
        newMaxMode = MAX_MODE.THRESHOLD_EXCEEDED;
    } else if (isMaxModeReached(state)) {
        newMaxMode = MAX_MODE.ENABLED;
    } else {
        newMaxMode = MAX_MODE.DISABLED;
    }

    if (maxMode !== newMaxMode) {
        dispatch(setE2EEMaxMode(newMaxMode));
    }

    if (isMaxModeThresholdReachedValue && !enabled) {
        dispatch(toggleE2EE(false));
    }
}


################################################################################

## File: .\jitsi-meet\react\features\e2ee\reducer.ts

import ReducerRegistry from '../base/redux/ReducerRegistry';

import {
    SET_MAX_MODE,
    TOGGLE_E2EE
} from './actionTypes';
import { MAX_MODE } from './constants';

const DEFAULT_STATE = {
    enabled: false,
    maxMode: MAX_MODE.DISABLED
};

export interface IE2EEState {
    enabled: boolean;
    maxMode: string;
}

export interface ISas {
    emoji: Array<string>;
}

/**
 * Reduces the Redux actions of the feature features/e2ee.
 */
ReducerRegistry.register<IE2EEState>('features/e2ee', (state = DEFAULT_STATE, action): IE2EEState => {
    switch (action.type) {
    case TOGGLE_E2EE:
        return {
            ...state,
            enabled: action.enabled
        };

    case SET_MAX_MODE: {
        return {
            ...state,
            maxMode: action.maxMode
        };
    }

    default:
        return state;
    }
});


################################################################################

## File: .\jitsi-meet\react\features\e2ee\sounds.ts

/**
 * The name of the bundled audio file which will be played when e2ee is disabled.
 *
 * @type {string}
 */
export const E2EE_OFF_SOUND_FILE = 'e2eeOff.mp3';

/**
 * The name of the bundled audio file which will be played when e2ee is enabled.
 *
 * @type {string}
 */
export const E2EE_ON_SOUND_FILE = 'e2eeOn.mp3';


################################################################################

## File: .\jitsi-meet\react\features\embed-meeting\hooks.ts

import { useSelector } from 'react-redux';

import { isMobileBrowser } from '../base/environment/utils';
import { isVpaasMeeting } from '../jaas/functions';

import EmbedMeetingButton from './components/EmbedMeetingButton';

const embed = {
    key: 'embedmeeting',
    Content: EmbedMeetingButton,
    group: 4
};

/**
 * A hook that returns the embed button if it is enabled and undefined otherwise.
 *
 *  @returns {Object | undefined}
 */
export function useEmbedButton() {
    const _isVpaasMeeting = useSelector(isVpaasMeeting);

    if (!isMobileBrowser() && !_isVpaasMeeting) {
        return embed;
    }
}


################################################################################

## File: .\jitsi-meet\react\features\embed-meeting\components\EmbedMeetingButton.ts

import { connect } from 'react-redux';

import { createToolbarEvent } from '../../analytics/AnalyticsEvents';
import { sendAnalytics } from '../../analytics/functions';
import { IReduxState } from '../../app/types';
import { openDialog } from '../../base/dialog/actions';
import { isMobileBrowser } from '../../base/environment/utils';
import { translate } from '../../base/i18n/functions';
import { IconCode } from '../../base/icons/svg';
import AbstractButton, { IProps as AbstractButtonProps } from '../../base/toolbox/components/AbstractButton';
import { isVpaasMeeting } from '../../jaas/functions';

import EmbedMeetingDialog from './EmbedMeetingDialog';

/**
 * Implementation of a button for opening embed meeting dialog.
 */
class EmbedMeetingButton extends AbstractButton<AbstractButtonProps> {
    accessibilityLabel = 'toolbar.accessibilityLabel.embedMeeting';
    icon = IconCode;
    label = 'toolbar.embedMeeting';
    tooltip = 'toolbar.embedMeeting';

    /**
     * Handles clicking / pressing the button, and opens the appropriate dialog.
     *
     * @protected
     * @returns {void}
     */
    _handleClick() {
        const { dispatch } = this.props;

        sendAnalytics(createToolbarEvent('embed.meeting'));
        dispatch(openDialog(EmbedMeetingDialog));
    }
}

/**
 * Function that maps parts of Redux state tree into component props.
 *
 * @param {Object} state - Redux state.
 * @returns {Object}
 */
const mapStateToProps = (state: IReduxState) => {
    return {
        visible: !isVpaasMeeting(state) && !isMobileBrowser()
    };
};

export default translate(connect(mapStateToProps)(EmbedMeetingButton));


################################################################################

## File: .\jitsi-meet\react\features\etherpad\actions.ts

import {
    SET_DOCUMENT_EDITING_STATUS,
    SET_DOCUMENT_URL,
    TOGGLE_DOCUMENT_EDITING
} from './actionTypes';

/**
 * Dispatches an action to set whether document editing has started or stopped.
 *
 * @param {boolean} editing - Whether or not a document is currently being
 * edited.
 * @returns {{
 *    type: SET_DOCUMENT_EDITING_STATUS,
 *    editing: boolean
 * }}
 */
export function setDocumentEditingState(editing: boolean) {
    return {
        type: SET_DOCUMENT_EDITING_STATUS,
        editing
    };
}

/**
 * Dispatches an action to set the shared document URL.
 *
 * @param {string} documentUrl - The shared document URL.
 * @returns {{
 *    type: SET_DOCUMENT_URL,
 *    documentUrl: string
 * }}
 */
export function setDocumentUrl(documentUrl?: string) {
    return {
        type: SET_DOCUMENT_URL,
        documentUrl
    };
}

/**
 * Dispatches an action to show or hide Etherpad.
 *
 * @returns {{
 *    type: TOGGLE_DOCUMENT_EDITING
 * }}
 */
export function toggleDocument() {
    return {
        type: TOGGLE_DOCUMENT_EDITING
    };
}


################################################################################

## File: .\jitsi-meet\react\features\etherpad\actionTypes.ts

/**
 * The type of the action which signals document editing has stopped or started.
 *
 * {
 *     type: SET_DOCUMENT_EDITING_STATUS
 * }
 */
export const SET_DOCUMENT_EDITING_STATUS = 'SET_DOCUMENT_EDITING_STATUS';

/**
 * The type of the action which updates the shared document URL.
 *
 * {
 *     type: SET_DOCUMENT_URL
 * }
 */
export const SET_DOCUMENT_URL = 'SET_DOCUMENT_URL';

/**
 * The type of the action which signals to start or stop editing a shared
 * document.
 *
 * {
 *     type: TOGGLE_DOCUMENT_EDITING
 * }
 */
export const TOGGLE_DOCUMENT_EDITING = 'TOGGLE_DOCUMENT_EDITING';


################################################################################

## File: .\jitsi-meet\react\features\etherpad\functions.ts

import { IStateful } from '../base/app/types';
import { toState } from '../base/redux/functions';

const ETHERPAD_OPTIONS = {
    showControls: 'true',
    showChat: 'false',
    showLineNumbers: 'true',
    useMonospaceFont: 'false'
};

/**
 * Retrieves the current sahred document URL.
 *
 * @param {Function|Object} stateful - The redux store or {@code getState} function.
 * @returns {?string} - Current shared document URL or undefined.
 */
export function getSharedDocumentUrl(stateful: IStateful) {
    const state = toState(stateful);
    const { documentUrl } = state['features/etherpad'];
    const { displayName } = state['features/base/settings'];

    if (!documentUrl) {
        return undefined;
    }

    const params = new URLSearchParams(ETHERPAD_OPTIONS);

    if (displayName) {
        params.append('userName', displayName);
    }

    return `${documentUrl}?${params.toString()}`;
}


################################################################################

## File: .\jitsi-meet\react\features\etherpad\hooks.ts

import { useSelector } from 'react-redux';

import { IReduxState } from '../app/types';

import SharedDocumentButtonWeb from './components/SharedDocumentButton';

const etherpad = {
    key: 'etherpad',
    Content: SharedDocumentButtonWeb,
    group: 3
};

/**
 * A hook that returns the etherpad button if it is enabled and undefined otherwise.
 *
 *  @returns {Object | undefined}
 */
export function useEtherpadButton() {
    const visible = useSelector((state: IReduxState) => Boolean(state['features/etherpad'].documentUrl));

    if (visible) {
        return etherpad;
    }
}


################################################################################

## File: .\jitsi-meet\react\features\etherpad\middleware.ts

import { CONFERENCE_JOIN_IN_PROGRESS } from '../base/conference/actionTypes';
import { getCurrentConference } from '../base/conference/functions';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import StateListenerRegistry from '../base/redux/StateListenerRegistry';
import { sanitizeUrl } from '../base/util/uri';

import { TOGGLE_DOCUMENT_EDITING } from './actionTypes';
import { setDocumentUrl } from './actions';

const ETHERPAD_COMMAND = 'etherpad';

/**
 * Middleware that captures actions related to collaborative document editing
 * and notifies components not hooked into redux.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
// eslint-disable-next-line no-unused-vars
MiddlewareRegistry.register(({ dispatch, getState }) => next => action => {
    switch (action.type) {
    case CONFERENCE_JOIN_IN_PROGRESS: {
        const { conference } = action;

        conference.addCommandListener(ETHERPAD_COMMAND,
            ({ value }: { value: string; }) => {
                let url;
                const { etherpad_base: etherpadBase } = getState()['features/base/config'];
                const etherpadBaseUrl = sanitizeUrl(etherpadBase);

                if (etherpadBaseUrl) {
                    const urlObj = new URL(value, etherpadBaseUrl.toString());

                    // Merge query string parameters on top of internal ones
                    if (etherpadBaseUrl.search) {
                        const searchParams = new URLSearchParams(urlObj.search);

                        for (const [ key, val ] of new URLSearchParams(etherpadBaseUrl.search)) {
                            searchParams.set(key, val);
                        }
                        urlObj.search = searchParams.toString();
                    }
                    url = urlObj.toString();
                }

                dispatch(setDocumentUrl(url));
            }
        );
        break;
    }
    case TOGGLE_DOCUMENT_EDITING: {
        if (typeof APP !== 'undefined') {
            APP.UI.onEtherpadClicked();
        }
        break;
    }
    }

    return next(action);
});

/**
 * Set up state change listener to perform maintenance tasks when the conference
 * is left or failed, e.g. Clear messages or close the chat modal if it's left
 * open.
 */
StateListenerRegistry.register(
    state => getCurrentConference(state),
    (conference, { dispatch }, previousConference) => {
        if (previousConference) {
            dispatch(setDocumentUrl(undefined));
        }
    });


################################################################################

## File: .\jitsi-meet\react\features\etherpad\reducer.ts

import ReducerRegistry from '../base/redux/ReducerRegistry';

import { SET_DOCUMENT_EDITING_STATUS, SET_DOCUMENT_URL } from './actionTypes';

const DEFAULT_STATE = {

    /**
     * URL for the shared document.
     */
    documentUrl: undefined,

    /**
     * Whether or not Etherpad is currently open.
     *
     * @public
     * @type {boolean}
     */
    editing: false
};

export interface IEtherpadState {
    documentUrl?: string;
    editing: boolean;
}

/**
 * Reduces the Redux actions of the feature features/etherpad.
 */
ReducerRegistry.register<IEtherpadState>(
    'features/etherpad',
    (state = DEFAULT_STATE, action): IEtherpadState => {
        switch (action.type) {
        case SET_DOCUMENT_EDITING_STATUS:
            return {
                ...state,
                editing: action.editing
            };

        case SET_DOCUMENT_URL:
            return {
                ...state,
                documentUrl: action.documentUrl
            };

        default:
            return state;
        }
    });


################################################################################

## File: .\jitsi-meet\react\features\etherpad\components\SharedDocumentButton.native.ts

import { connect } from 'react-redux';

import { createToolbarEvent } from '../../analytics/AnalyticsEvents';
import { sendAnalytics } from '../../analytics/functions';
import { IReduxState } from '../../app/types';
import { translate } from '../../base/i18n/functions';
import { IconShareDoc } from '../../base/icons/svg';
import AbstractButton, { IProps as AbstractButtonProps } from '../../base/toolbox/components/AbstractButton';
import { navigate } from '../../mobile/navigation/components/conference/ConferenceNavigationContainerRef';
import { screen } from '../../mobile/navigation/routes';

/**
 * Implements an {@link AbstractButton} to open the chat screen on mobile.
 */
class SharedDocumentButton extends AbstractButton<AbstractButtonProps> {
    accessibilityLabel = 'toolbar.accessibilityLabel.document';
    icon = IconShareDoc;
    label = 'toolbar.documentOpen';
    tooltip = 'toolbar.documentOpen';

    /**
     * Handles clicking / pressing the button, and opens / closes the appropriate dialog.
     *
     * @private
     * @returns {void}
     */
    _handleClick() {
        const { handleClick } = this.props;

        if (handleClick) {
            handleClick();

            return;
        }

        sendAnalytics(createToolbarEvent(
            'toggle.etherpad',
            {
                enable: true
            }));

        navigate(screen.conference.sharedDocument);
    }
}

/**
 * Maps part of the redux state to the component's props.
 *
 * @param {Object} state - The redux store/state.
 * @param {Object} ownProps - The properties explicitly passed to the component
 * instance.
 * @returns {Object}
 */
function _mapStateToProps(state: IReduxState, ownProps: any) {
    const { documentUrl } = state['features/etherpad'];
    const { visible = Boolean(documentUrl) } = ownProps;

    return {
        visible
    };
}

export default translate(connect(_mapStateToProps)(SharedDocumentButton));


################################################################################

## File: .\jitsi-meet\react\features\etherpad\components\SharedDocumentButton.web.ts

import { connect } from 'react-redux';

import { createToolbarEvent } from '../../analytics/AnalyticsEvents';
import { sendAnalytics } from '../../analytics/functions';
import { IReduxState } from '../../app/types';
import { translate } from '../../base/i18n/functions';
import { IconShareDoc } from '../../base/icons/svg';
import AbstractButton, { IProps as AbstractButtonProps } from '../../base/toolbox/components/AbstractButton';
import { setOverflowMenuVisible } from '../../toolbox/actions.web';
import { toggleDocument } from '../actions';

interface IProps extends AbstractButtonProps {

    /**
     * Whether the shared document is being edited or not.
     */
    _editing: boolean;
}

/**
 * Implements an {@link AbstractButton} to open the chat screen on mobile.
 */
class SharedDocumentButton extends AbstractButton<IProps> {
    accessibilityLabel = 'toolbar.accessibilityLabel.documentOpen';
    toggledAccessibilityLabel = 'toolbar.accessibilityLabel.documentClose';
    icon = IconShareDoc;
    label = 'toolbar.documentOpen';
    toggledLabel = 'toolbar.documentClose';
    tooltip = 'toolbar.documentOpen';
    toggledTooltip = 'toolbar.documentClose';

    /**
     * Handles clicking / pressing the button, and opens / closes the appropriate dialog.
     *
     * @private
     * @returns {void}
     */
    _handleClick() {
        const { _editing, dispatch } = this.props;

        sendAnalytics(createToolbarEvent(
            'toggle.etherpad',
            {
                enable: !_editing
            }));

        dispatch(toggleDocument());
        dispatch(setOverflowMenuVisible(false));
    }

    /**
     * Indicates whether this button is in toggled state or not.
     *
     * @override
     * @protected
     * @returns {boolean}
     */
    _isToggled() {
        return this.props._editing;
    }
}

/**
 * Maps part of the redux state to the component's props.
 *
 * @param {Object} state - The redux store/state.
 * @param {Object} ownProps - The properties explicitly passed to the component
 * instance.
 * @returns {Object}
 */
function _mapStateToProps(state: IReduxState, ownProps: any) {
    const { documentUrl, editing } = state['features/etherpad'];
    const { visible = Boolean(documentUrl) } = ownProps;

    return {
        _editing: editing,
        visible
    };
}

export default translate(connect(_mapStateToProps)(SharedDocumentButton));


################################################################################

## File: .\jitsi-meet\react\features\etherpad\components\native\styles.ts

import BaseTheme from '../../../base/ui/components/BaseTheme.native';

export const INDICATOR_COLOR = BaseTheme.palette.ui07;

export default {
    indicatorWrapper: {
        alignItems: 'center',
        backgroundColor: BaseTheme.palette.ui10,
        height: '100%',
        justifyContent: 'center'
    },

    sharedDocContainer: {
        backgroundColor: BaseTheme.palette.ui10,
        flex: 1,
        paddingRight: BaseTheme.spacing[3]
    },

    sharedDoc: {
        marginBottom: BaseTheme.spacing[3]
    },

    webView: {
        backgroundColor: BaseTheme.palette.ui10
    }
};


################################################################################

## File: .\jitsi-meet\react\features\external-api\middleware.ts

// @ts-expect-error
import { getJitsiMeetTransport } from '../../../modules/transport';
import {
    CONFERENCE_FAILED,
    CONFERENCE_JOINED,
    DATA_CHANNEL_CLOSED,
    DATA_CHANNEL_OPENED,
    KICKED_OUT
} from '../base/conference/actionTypes';
import { SET_CONFIG } from '../base/config/actionTypes';
import { NOTIFY_CAMERA_ERROR, NOTIFY_MIC_ERROR } from '../base/devices/actionTypes';
import { JitsiConferenceErrors } from '../base/lib-jitsi-meet';
import {
    DOMINANT_SPEAKER_CHANGED,
    PARTICIPANT_JOINED,
    PARTICIPANT_KICKED,
    PARTICIPANT_LEFT,
    PARTICIPANT_ROLE_CHANGED,
    SET_LOADABLE_AVATAR_URL
} from '../base/participants/actionTypes';
import {
    getDominantSpeakerParticipant,
    getLocalParticipant,
    getParticipantById,
    getParticipantDisplayName
} from '../base/participants/functions';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import { getBaseUrl } from '../base/util/helpers';
import { appendSuffix } from '../display-name/functions';
import { SUBMIT_FEEDBACK_ERROR, SUBMIT_FEEDBACK_SUCCESS } from '../feedback/actionTypes';
import { SET_FILMSTRIP_VISIBLE } from '../filmstrip/actionTypes';

import './subscriber';

/**
 * The middleware of the feature {@code external-api}.
 *
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {
    // We need to do these before executing the rest of the middelware chain
    switch (action.type) {
    case DOMINANT_SPEAKER_CHANGED: {
        const dominantSpeaker = getDominantSpeakerParticipant(store.getState());

        if (dominantSpeaker?.id !== action.participant.id) {
            const result = next(action);

            APP.API.notifyDominantSpeakerChanged(action.participant.id);

            return result;
        }

        break;
    }
    case SET_LOADABLE_AVATAR_URL: {
        const { id, loadableAvatarUrl } = action.participant;
        const participant = getParticipantById(
            store.getState(),
            id
        );

        const result = next(action);

        if (participant) {
            if (loadableAvatarUrl) {
                participant.loadableAvatarUrl !== loadableAvatarUrl && APP.API.notifyAvatarChanged(
                    id,
                    loadableAvatarUrl
                );
            } else {
                // There is no loadable explicit URL. In this case the Avatar component would
                // decide to render initials or the default avatar, but the external API needs
                // a URL when it needs to be rendered, so if there is no initials, we return the default
                // Avatar URL as if it was a usual avatar URL. If there are (or may be) initials
                // we send undefined to signal the api user that it's not an URL that needs to be rendered.
                //
                // NOTE: we may implement a special URL format later to signal that the avatar is based
                // on initials, that API consumers can handle as they want, e.g. initials://jm
                APP.API.notifyAvatarChanged(
                    id,
                    participant.name ? undefined : _getDefaultAvatarUrl()
                );
            }
        }

        return result;
    }
    }

    const result = next(action);

    // These should happen after the rest of the middleware chain ran
    switch (action.type) {
    case CONFERENCE_FAILED: {
        if (action.conference
            && action.error.name === JitsiConferenceErrors.PASSWORD_REQUIRED) {
            APP.API.notifyOnPasswordRequired();
        }
        break;
    }

    case CONFERENCE_JOINED: {
        const state = store.getState();
        const { defaultLocalDisplayName } = state['features/base/config'];
        const { room } = state['features/base/conference'];
        const { loadableAvatarUrl, name, id, email } = getLocalParticipant(state) ?? {};
        const breakoutRoom = APP.conference.roomName.toString() !== room?.toLowerCase();

        // we use APP.conference.roomName as we do not update state['features/base/conference'].room when
        // moving between rooms in case of breakout rooms and it stays always with the name of the main room
        APP.API.notifyConferenceJoined(
            APP.conference.roomName,
            id,
            {
                displayName: name,
                formattedDisplayName: appendSuffix(
                    name ?? '',
                    defaultLocalDisplayName
                ),
                avatarURL: loadableAvatarUrl,
                breakoutRoom,
                email
            }
        );
        break;
    }

    case DATA_CHANNEL_CLOSED:
        APP.API.notifyDataChannelClosed(action.code, action.reason);
        break;

    case DATA_CHANNEL_OPENED:
        APP.API.notifyDataChannelOpened();
        break;

    case KICKED_OUT: {
        const state = store.getState();
        const localParticipant = getLocalParticipant(state);

        if (!localParticipant) {
            break;
        }

        const pId = action.participant.getId();

        APP.API.notifyKickedOut(
            {
                id: localParticipant.id,
                name: getParticipantDisplayName(state, localParticipant.id),
                local: true
            },
            {
                id: pId,
                name: getParticipantDisplayName(state, pId)
            }
        );
        break;
    }

    case NOTIFY_CAMERA_ERROR:
        if (action.error) {
            APP.API.notifyOnCameraError(
                action.error.name, action.error.message);
        }
        break;

    case NOTIFY_MIC_ERROR:
        if (action.error) {
            APP.API.notifyOnMicError(action.error.name, action.error.message);
        }
        break;

    case PARTICIPANT_KICKED: {
        const state = store.getState();
        const kickedParticipant = getParticipantById(state, action.kicked);
        const kickerParticipant = getParticipantById(state, action.kicker);

        if (!kickerParticipant || !kickedParticipant) {
            break;
        }

        APP.API.notifyKickedOut(
            {
                id: kickedParticipant.id,
                local: kickedParticipant.local,
                name: getParticipantDisplayName(state, kickedParticipant.id)
            },
            {
                id: kickerParticipant.id,
                local: kickerParticipant.local,
                name: getParticipantDisplayName(state, kickerParticipant.id)
            });
        break;
    }

    case PARTICIPANT_LEFT: {
        const { participant } = action;
        const { fakeParticipant } = participant;

        // Skip sending participant left event for fake participants.
        if (fakeParticipant) {
            break;
        }

        APP.API.notifyUserLeft(action.participant.id);
        break;
    }
    case PARTICIPANT_JOINED: {
        const state = store.getState();
        const { defaultRemoteDisplayName } = state['features/base/config'];
        const { participant } = action;
        const { fakeParticipant, id, local, name } = participant;

        // The version of external api outside of middleware did not emit
        // the local participant being created.
        if (!local) {
            // Skip sending participant joined event for fake participants.
            if (fakeParticipant) {
                break;
            }

            APP.API.notifyUserJoined(id, {
                displayName: name,
                formattedDisplayName: appendSuffix(
                    name || defaultRemoteDisplayName)
            });
        }

        break;
    }

    case PARTICIPANT_ROLE_CHANGED:
        APP.API.notifyUserRoleChanged(action.participant.id, action.participant.role);
        break;

    case SET_CONFIG: {
        const state = store.getState();
        const { disableBeforeUnloadHandlers = false } = state['features/base/config'];

        /**
         * Disposing the API when the user closes the page.
         */
        window.addEventListener(disableBeforeUnloadHandlers ? 'unload' : 'beforeunload', () => {
            APP.API.notifyConferenceLeft(APP.conference.roomName);
            APP.API.dispose();
            getJitsiMeetTransport().dispose();
        });

        break;
    }

    case SET_FILMSTRIP_VISIBLE:
        APP.API.notifyFilmstripDisplayChanged(action.visible);
        break;

    case SUBMIT_FEEDBACK_ERROR:
        APP.API.notifyFeedbackSubmitted(action.error || 'Unknown error');
        break;

    case SUBMIT_FEEDBACK_SUCCESS:
        APP.API.notifyFeedbackSubmitted();
        break;
    }

    return result;
});

/**
 * Returns the absolute URL of the default avatar.
 *
 * @returns {string}
 */
function _getDefaultAvatarUrl() {
    return new URL('images/avatar.png', getBaseUrl()).href;
}


################################################################################

## File: .\jitsi-meet\react\features\external-api\subscriber.ts

import { getLocalParticipant } from '../base/participants/functions';
import StateListenerRegistry from '../base/redux/StateListenerRegistry';
import { appendSuffix } from '../display-name/functions';
import { shouldDisplayTileView } from '../video-layout/functions';

/**
 * StateListenerRegistry provides a reliable way of detecting changes to
 * preferred layout state and dispatching additional actions.
 */
StateListenerRegistry.register(
    /* selector */ state => shouldDisplayTileView(state),
    /* listener */ displayTileView => {
        APP.API.notifyTileViewChanged(displayTileView);
    });

StateListenerRegistry.register(
    /* selector */ state => state['features/base/settings'].displayName,
    /* listener */ (displayName, store) => {
        const localParticipant = getLocalParticipant(store.getState());
        const { defaultLocalDisplayName } = store.getState()['features/base/config'];

        // Initial setting of the display name happens on app
        // initialization, before the local participant is ready. The initial
        // settings is not desired to be fired anyways, only changes.
        if (localParticipant) {
            const { id } = localParticipant;

            APP.API.notifyDisplayNameChanged(id, {
                displayName,
                formattedDisplayName: appendSuffix(
                    displayName,
                    defaultLocalDisplayName
                )
            });
        }
    });

StateListenerRegistry.register(
    /* selector */ state => state['features/base/settings'].email,
    /* listener */ (email, store) => {
        const localParticipant = getLocalParticipant(store.getState());

        // Initial setting of the email happens on app
        // initialization, before the local participant is ready. The initial
        // settings is not desired to be fired anyways, only changes.
        if (localParticipant) {
            const { id } = localParticipant;

            APP.API.notifyEmailChanged(id, {
                email
            });
        }
    });

/**
 * Updates the on stage participant value.
 */
StateListenerRegistry.register(
    /* selector */ state => state['features/large-video'].participantId,
    /* listener */ participantId => {
        APP.API.notifyOnStageParticipantChanged(participantId);
    }
);


################################################################################

## File: .\jitsi-meet\react\features\face-landmarks\actions.ts

import 'image-capture';
import './createImageBitmap';
import { AnyAction } from 'redux';

import {
    ADD_FACE_LANDMARKS,
    CLEAR_FACE_LANDMARKS_BUFFER,
    NEW_FACE_COORDINATES
} from './actionTypes';
import { FaceBox, FaceLandmarks } from './types';

/**
 * Adds new face landmarks to the timeline.
 *
 * @param {FaceLandmarks} faceLandmarks - The new face landmarks to timeline.
 * @param {boolean} addToBuffer - If true adds the face landmarks to a buffer in the reducer for webhook.
 * @returns {AnyAction}
 */
export function addFaceLandmarks(faceLandmarks: FaceLandmarks, addToBuffer: boolean): AnyAction {
    return {
        type: ADD_FACE_LANDMARKS,
        faceLandmarks,
        addToBuffer
    };
}

/**
 * Clears the face landmarks array in the state.
 *
 * @returns {AnyAction}
 */
export function clearFaceExpressionBuffer(): AnyAction {
    return {
        type: CLEAR_FACE_LANDMARKS_BUFFER
    };
}

/**
 * Signals that a new face box was obtained for the local participant.
 *
 * @param {FaceBox} faceBox - The face box of the local participant.
 * @returns {AnyAction}
 */
export function newFaceBox(faceBox: FaceBox): AnyAction {
    return {
        type: NEW_FACE_COORDINATES,
        faceBox
    };
}


################################################################################

## File: .\jitsi-meet\react\features\face-landmarks\actionTypes.ts

/**
 * Redux action type dispatched in order to add real-time faceLandmarks to timeline.
 *
 * {
 *      type: ADD_FACE_LANDMARKS,
 *      faceLandmarks: FaceLandmarks
 * }
 */
export const ADD_FACE_LANDMARKS = 'ADD_FACE_LANDMARKS';

/**
 * Redux action type dispatched in order to clear the faceLandmarks buffer for webhook in the state.
 *
 * {
 *      type: CLEAR_FACE_LANDMARKS_BUFFER
 * }
*/
export const CLEAR_FACE_LANDMARKS_BUFFER = 'CLEAR_FACE_LANDMARKS_BUFFER';

/**
 * Redux action type dispatched in order to update coordinates of a detected face.
 *
 * {
 *      type: UPDATE_FACE_COORDINATES,
 *      faceBox: Object({ left, bottom, right, top }),
 *      participantId: string
 * }
 */
export const UPDATE_FACE_COORDINATES = 'UPDATE_FACE_COORDINATES';

/**
 * Redux action type dispatched in order to signal new face coordinates were obtained for the local participant.
 *
 * {
 *      type: NEW_FACE_COORDINATES,
 *      faceBox: Object({ left, bottom, right, top }),
 *      participantId: string
 * }
 */
 export const NEW_FACE_COORDINATES = 'NEW_FACE_COORDINATES';


################################################################################

## File: .\jitsi-meet\react\features\face-landmarks\constants.ts

export const FACE_EXPRESSIONS_EMOJIS = {
    happy: '😊',
    neutral: '😐',
    sad: '🙁',
    surprised: '😮',
    angry: '😠',
    fearful: '😨'

    // disgusted: '🤢'
};

export const FACE_EXPRESSIONS = [ 'happy', 'neutral', 'sad', 'surprised', 'angry', 'fearful' ];

export const FACE_EXPRESSIONS_NAMING_MAPPING = {
    happy: 'happy',
    neutral: 'neutral',
    surprise: 'surprised',
    angry: 'angry',
    fear: 'fearful',
    disgust: 'disgusted',
    sad: 'sad'
};

/**
 * Time is ms used for sending expression.
 */
export const WEBHOOK_SEND_TIME_INTERVAL = 15000;

/**
 * Type of message sent from main thread to worker that contains init information:
 * such as models directory and window screen size.
 */
export const INIT_WORKER = 'INIT_WORKER';

/**
 * Type of event sent on the data channel.
 */
export const FACE_BOX_EVENT_TYPE = 'face-box';

/**
 * Type of event sent on the data channel.
 */
export const FACE_LANDMARKS_EVENT_TYPE = 'face-landmarks';

/**
 * Milliseconds interval value for sending new image data to the worker.
 */
export const SEND_IMAGE_INTERVAL_MS = 1000;

/**
 * Type of message sent from main thread to worker that contain image data and
 * will trigger a response message from the worker containing the detected face(s) info.
 */
export const DETECT_FACE = 'DETECT_FACE';

/**
 * Available detection types.
 */
export const DETECTION_TYPES = {
    FACE_BOX: 'face-box',
    FACE_EXPRESSIONS: 'face-expressions'
};

/**
 * Threshold for detection score of face.
 */
export const FACE_DETECTION_SCORE_THRESHOLD = 0.75;

/**
 * Threshold for stopping detection after a certain number of consecutive errors have occurred.
 */
export const FACE_LANDMARKS_DETECTION_ERROR_THRESHOLD = 4;

/**
 * Threshold for number of consecutive detections with no face,
 * so that when achieved there will be dispatched an action.
 */
export const NO_FACE_DETECTION_THRESHOLD = 5;

/**
 * Constant type used for signaling that no valid face detection is found.
 */
export const NO_DETECTION = 'no-detection';


################################################################################

## File: .\jitsi-meet\react\features\face-landmarks\createImageBitmap.ts

/*
* Safari < 15 polyfill for createImageBitmap
* https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/createImageBitmap
*
* Support source image types: Canvas.
*/
// @ts-nocheck
if (!('createImageBitmap' in window)) {
    window.createImageBitmap = async function(data) {
        return new Promise((resolve, reject) => {
            let dataURL;

            if (data instanceof HTMLCanvasElement) {
                dataURL = data.toDataURL();
            } else {
                reject(new Error('createImageBitmap does not handle the provided image source type'));
            }
            const img = document.createElement('img');

            img.close = () => {
                // empty
            };

            img.addEventListener('load', () => {
                resolve(img);
            });

            img.src = dataURL;
        });
    };
}


################################################################################

## File: .\jitsi-meet\react\features\face-landmarks\FaceLandmarksDetector.ts

import 'image-capture';
import './createImageBitmap';
import { IStore } from '../app/types';
import { isMobileBrowser } from '../base/environment/utils';
import { getLocalVideoTrack } from '../base/tracks/functions';
import { getBaseUrl } from '../base/util/helpers';

import {
    addFaceLandmarks,
    clearFaceExpressionBuffer,
    newFaceBox
} from './actions';
import {
    DETECTION_TYPES,
    DETECT_FACE,
    FACE_LANDMARKS_DETECTION_ERROR_THRESHOLD,
    INIT_WORKER,
    NO_DETECTION,
    NO_FACE_DETECTION_THRESHOLD,
    WEBHOOK_SEND_TIME_INTERVAL
} from './constants';
import {
    getDetectionInterval,
    sendFaceExpressionsWebhook
} from './functions';
import logger from './logger';

/**
 * Class for face language detection.
 */
class FaceLandmarksDetector {
    private static instance: FaceLandmarksDetector;
    private initialized = false;
    private imageCapture: ImageCapture | null = null;
    private worker: Worker | null = null;
    private lastFaceExpression: string | null = null;
    private lastFaceExpressionTimestamp: number | null = null;
    private webhookSendInterval: number | null = null;
    private detectionInterval: number | null = null;
    private recognitionActive = false;
    private canvas?: HTMLCanvasElement;
    private context?: CanvasRenderingContext2D | null;
    private errorCount = 0;
    private noDetectionCount = 0;
    private noDetectionStartTimestamp: number | null = null;

    /**
     * Constructor for class, checks if the environment supports OffscreenCanvas.
    */
    private constructor() {
        if (typeof OffscreenCanvas === 'undefined') {
            this.canvas = document.createElement('canvas');
            this.context = this.canvas.getContext('2d');
        }
    }

    /**
     * Function for retrieving the FaceLandmarksDetector instance.
     *
     * @returns {FaceLandmarksDetector} - FaceLandmarksDetector instance.
     */
    public static getInstance(): FaceLandmarksDetector {
        if (!FaceLandmarksDetector.instance) {
            FaceLandmarksDetector.instance = new FaceLandmarksDetector();
        }

        return FaceLandmarksDetector.instance;
    }

    /**
     * Returns if the detected environment is initialized.
     *
     * @returns {boolean}
     */
    isInitialized(): boolean {
        return this.initialized;
    }

    /**
     * Initialization function: the worker is loaded and initialized, and then if possible the detection stats.
     *
     * @param {IStore} store - Redux store with dispatch and getState methods.
     * @returns {void}
    */
    init({ dispatch, getState }: IStore) {
        if (this.isInitialized()) {
            logger.info('Worker has already been initialized');

            return;
        }

        if (isMobileBrowser() || navigator.product === 'ReactNative') {
            logger.warn('Unsupported environment for face detection');

            return;
        }

        const baseUrl = `${getBaseUrl()}libs/`;
        let workerUrl = `${baseUrl}face-landmarks-worker.min.js`;

        // @ts-ignore
        const workerBlob = new Blob([ `importScripts("${workerUrl}");` ], { type: 'application/javascript' });
        const state = getState();
        const addToBuffer = Boolean(state['features/base/config'].webhookProxyUrl);

        // @ts-ignore
        workerUrl = window.URL.createObjectURL(workerBlob);
        this.worker = new Worker(workerUrl, { name: 'Face Landmarks Worker' });
        this.worker.onmessage = ({ data }: MessageEvent<any>) => {
            const { faceExpression, faceBox, faceCount } = data;
            const messageTimestamp = Date.now();

            // if the number of faces detected is different from 1 we do not take into consideration that detection
            if (faceCount !== 1) {
                if (this.noDetectionCount === 0) {
                    this.noDetectionStartTimestamp = messageTimestamp;
                }
                this.noDetectionCount++;

                if (this.noDetectionCount === NO_FACE_DETECTION_THRESHOLD && this.noDetectionStartTimestamp) {
                    this.addFaceLandmarks(
                            dispatch,
                            this.noDetectionStartTimestamp,
                            NO_DETECTION,
                            addToBuffer
                    );
                }

                return;
            } else if (this.noDetectionCount > 0) {
                this.noDetectionCount = 0;
                this.noDetectionStartTimestamp = null;
            }

            if (faceExpression?.expression) {
                const { expression } = faceExpression;

                if (expression !== this.lastFaceExpression) {
                    this.addFaceLandmarks(
                        dispatch,
                        messageTimestamp,
                        expression,
                        addToBuffer
                    );
                }
            }

            if (faceBox) {
                dispatch(newFaceBox(faceBox));
            }

            APP.API.notifyFaceLandmarkDetected(faceBox, faceExpression);
        };

        const { faceLandmarks } = state['features/base/config'];
        const detectionTypes = [
            faceLandmarks?.enableFaceCentering && DETECTION_TYPES.FACE_BOX,
            faceLandmarks?.enableFaceExpressionsDetection && DETECTION_TYPES.FACE_EXPRESSIONS
        ].filter(Boolean);

        this.worker.postMessage({
            type: INIT_WORKER,
            baseUrl,
            detectionTypes
        });
        this.initialized = true;

        this.startDetection({
            dispatch,
            getState
        });
    }

    /**
     * The function which starts the detection process.
     *
     * @param {IStore} store - Redux store with dispatch and getState methods.
     * @param {any} track - Track from middleware; can be undefined.
     * @returns {void}
    */
    startDetection({ dispatch, getState }: IStore, track?: any) {
        if (!this.isInitialized()) {
            logger.info('Worker has not been initialized');

            return;
        }

        if (this.recognitionActive) {
            logger.log('Face landmarks detection already active.');

            return;
        }
        const state = getState();
        const localVideoTrack = track || getLocalVideoTrack(state['features/base/tracks']);

        if (!localVideoTrack || localVideoTrack.jitsiTrack?.isMuted()) {
            logger.debug('Face landmarks detection is disabled due to missing local track.');

            return;
        }
        const stream = localVideoTrack.jitsiTrack.getOriginalStream();
        const firstVideoTrack = stream.getVideoTracks()[0];

        this.imageCapture = new ImageCapture(firstVideoTrack);
        this.recognitionActive = true;
        logger.log('Start face landmarks detection');

        const { faceLandmarks } = state['features/base/config'];

        this.detectionInterval = window.setInterval(() => {

            if (this.worker && this.imageCapture) {
                this.sendDataToWorker(
                    faceLandmarks?.faceCenteringThreshold
                ).then(status => {
                    if (status) {
                        this.errorCount = 0;
                    } else if (++this.errorCount > FACE_LANDMARKS_DETECTION_ERROR_THRESHOLD) {
                        /* this prevents the detection from stopping immediately after occurring an error
                         * sometimes due to the small detection interval when starting the detection some errors
                         * might occur due to the track not being ready
                        */
                        this.stopDetection({
                            dispatch,
                            getState
                        });
                    }
                });
            }
        }, getDetectionInterval(state));

        const { webhookProxyUrl } = state['features/base/config'];

        if (faceLandmarks?.enableFaceExpressionsDetection && webhookProxyUrl) {
            this.webhookSendInterval = window.setInterval(async () => {
                const result = await sendFaceExpressionsWebhook(getState());

                if (result) {
                    dispatch(clearFaceExpressionBuffer());
                }
            }, WEBHOOK_SEND_TIME_INTERVAL);
        }
    }

    /**
     * The function which stops the detection process.
     *
     * @param {IStore} store - Redux store with dispatch and getState methods.
     * @returns {void}
    */
    stopDetection({ dispatch, getState }: IStore) {
        if (!this.recognitionActive || !this.isInitialized()) {
            return;
        }
        const stopTimestamp = Date.now();
        const addToBuffer = Boolean(getState()['features/base/config'].webhookProxyUrl);

        if (this.lastFaceExpression && this.lastFaceExpressionTimestamp) {
            this.addFaceLandmarks(dispatch, stopTimestamp, null, addToBuffer);
        }

        this.webhookSendInterval && window.clearInterval(this.webhookSendInterval);
        this.detectionInterval && window.clearInterval(this.detectionInterval);
        this.webhookSendInterval = null;
        this.detectionInterval = null;
        this.imageCapture = null;
        this.recognitionActive = false;
        logger.log('Stop face landmarks detection');
    }

    /**
     * Dispatches the action for adding new face landmarks and changes the state of the class.
     *
     * @param {IStore.dispatch} dispatch - The redux dispatch function.
     * @param {number} endTimestamp - The timestamp when the face landmarks ended.
     * @param {string} newFaceExpression - The new face expression.
     * @param {boolean} addToBuffer - Flag for adding the face landmarks to the buffer.
     * @returns {void}
     */
    private addFaceLandmarks(
            dispatch: IStore['dispatch'],
            endTimestamp: number,
            newFaceExpression: string | null,
            addToBuffer = false) {
        if (this.lastFaceExpression && this.lastFaceExpressionTimestamp) {
            dispatch(addFaceLandmarks(
                {
                    duration: endTimestamp - this.lastFaceExpressionTimestamp,
                    faceExpression: this.lastFaceExpression,
                    timestamp: this.lastFaceExpressionTimestamp
                },
                addToBuffer
            ));
        }

        this.lastFaceExpression = newFaceExpression;
        this.lastFaceExpressionTimestamp = endTimestamp;
    }

    /**
     * Sends the image data a canvas from the track in the image capture to the face detection worker.
     *
     * @param {number} faceCenteringThreshold  - Movement threshold as percentage for sharing face coordinates.
     * @returns {Promise<boolean>} - True if sent, false otherwise.
     */
    private async sendDataToWorker(faceCenteringThreshold = 10): Promise<boolean> {
        if (!this.imageCapture
            || !this.worker
            || !this.imageCapture) {
            logger.log('Environment not ready! Could not send data to worker');

            return false;
        }

        // if ImageCapture is polyfilled then it would not have the track,
        // so there would be no point in checking for its readyState
        if (this.imageCapture.track && this.imageCapture.track.readyState !== 'live') {
            logger.log('Track not ready! Could not send data to worker');

            return false;
        }

        let imageBitmap;
        let image;

        try {
            imageBitmap = await this.imageCapture.grabFrame();
        } catch (err) {
            logger.log('Could not send data to worker');

            return false;
        }

        if (typeof OffscreenCanvas === 'undefined' && this.canvas && this.context) {
            this.canvas.width = imageBitmap.width;
            this.canvas.height = imageBitmap.height;
            this.context.drawImage(imageBitmap, 0, 0);
            image = this.context.getImageData(0, 0, imageBitmap.width, imageBitmap.height);
        } else {
            image = imageBitmap;
        }

        this.worker.postMessage({
            type: DETECT_FACE,
            image,
            threshold: faceCenteringThreshold
        });

        imageBitmap.close();

        return true;
    }
}

export default FaceLandmarksDetector.getInstance();



################################################################################

## File: .\jitsi-meet\react\features\face-landmarks\FaceLandmarksHelper.ts

import { setWasmPaths } from '@tensorflow/tfjs-backend-wasm';
import { Config, FaceResult, Human } from '@vladmandic/human';

import { DETECTION_TYPES, FACE_DETECTION_SCORE_THRESHOLD, FACE_EXPRESSIONS_NAMING_MAPPING } from './constants';
import { DetectInput, DetectOutput, FaceBox, FaceExpression, InitInput } from './types';

export interface IFaceLandmarksHelper {
    detect: ({ image, threshold }: DetectInput) => Promise<DetectOutput>;
    getDetectionInProgress: () => boolean;
    getDetections: (image: ImageBitmap | ImageData) => Promise<Array<FaceResult>>;
    getFaceBox: (detections: Array<FaceResult>, threshold: number) => FaceBox | undefined;
    getFaceCount: (detections: Array<FaceResult>) => number;
    getFaceExpression: (detections: Array<FaceResult>) => FaceExpression | undefined;
    init: () => Promise<void>;
}

/**
 * Helper class for human library.
 */
export class HumanHelper implements IFaceLandmarksHelper {
    protected human: Human | undefined;
    protected faceDetectionTypes: string[];
    protected baseUrl: string;
    private detectionInProgress = false;
    private lastValidFaceBox: FaceBox | undefined;

    /**
    * Configuration for human.
    */
    private config: Partial<Config> = {
        backend: 'humangl',
        async: true,
        warmup: 'none',
        cacheModels: true,
        cacheSensitivity: 0,
        debug: false,
        deallocate: true,
        filter: { enabled: false },
        face: {
            enabled: false,
            detector: {
                enabled: false,
                rotation: false,
                modelPath: 'blazeface-front.json',
                maxDetected: 20
            },
            mesh: { enabled: false },
            iris: { enabled: false },
            emotion: {
                enabled: false,
                modelPath: 'emotion.json'
            },
            description: { enabled: false }
        },
        hand: { enabled: false },
        gesture: { enabled: false },
        body: { enabled: false },
        segmentation: { enabled: false }
    };

    /**
     * Constructor function for the helper which initialize the helper.
     *
     * @param  {InitInput} input - The input for the helper.
     * @returns {void}
     */
    constructor({ baseUrl, detectionTypes }: InitInput) {
        this.faceDetectionTypes = detectionTypes;
        this.baseUrl = baseUrl;
        this.init();
    }

    /**
     * Initializes the human helper with the available tfjs backend for the given detection types.
     *
     * @returns {Promise<void>}
     */
    async init(): Promise<void> {

        if (!this.human) {
            this.config.modelBasePath = this.baseUrl;
            if (!self.OffscreenCanvas) {
                this.config.backend = 'wasm';
                this.config.wasmPath = this.baseUrl;
                setWasmPaths(this.baseUrl);
            }

            if (this.faceDetectionTypes.length > 0 && this.config.face) {
                this.config.face.enabled = true;
            }

            if (this.faceDetectionTypes.includes(DETECTION_TYPES.FACE_BOX) && this.config.face?.detector) {
                this.config.face.detector.enabled = true;
            }

            if (this.faceDetectionTypes.includes(DETECTION_TYPES.FACE_EXPRESSIONS) && this.config.face?.emotion) {
                this.config.face.emotion.enabled = true;
            }

            const initialHuman = new Human(this.config);

            try {
                await initialHuman.load();
            } catch (err) {
                console.error(err);
            }

            this.human = initialHuman;
        }
    }

    /**
     * Gets the face box from the detections, if there is no valid detections it will return undefined..
     *
     * @param {Array<FaceResult>} detections - The array with the detections.
     * @param {number} threshold - Face box position change threshold.
     * @returns {FaceBox | undefined}
     */
    getFaceBox(detections: Array<FaceResult>, threshold: number): FaceBox | undefined {
        if (this.getFaceCount(detections) !== 1) {
            return;
        }

        const faceBox: FaceBox = {
            // normalize to percentage based
            left: Math.round(detections[0].boxRaw[0] * 100),
            right: Math.round((detections[0].boxRaw[0] + detections[0].boxRaw[2]) * 100)
        };

        faceBox.width = Math.round(faceBox.right - faceBox.left);

        if (this.lastValidFaceBox && threshold && Math.abs(this.lastValidFaceBox.left - faceBox.left) < threshold) {
            return;
        }

        this.lastValidFaceBox = faceBox;

        return faceBox;
    }

    /**
     * Gets the face expression from the detections, if there is no valid detections it will return undefined.
     *
     * @param {Array<FaceResult>} detections - The array with the detections.
     * @returns {string | undefined}
     */
    getFaceExpression(detections: Array<FaceResult>): FaceExpression | undefined {
        if (this.getFaceCount(detections) !== 1) {
            return;
        }

        const detection = detections[0];

        if (detection.emotion) {
            return {
                expression: FACE_EXPRESSIONS_NAMING_MAPPING[detection.emotion[0].emotion],
                score: detection.emotion[0].score
            };
        }
    }

    /**
     * Gets the face count from the detections, which is the number of detections.
     *
     * @param {Array<FaceResult>} detections - The array with the detections.
     * @returns {number}
     */
    getFaceCount(detections: Array<FaceResult> | undefined): number {
        if (detections) {
            return detections.length;
        }

        return 0;
    }

    /**
     * Gets the detections from the image captured from the track.
     *
     * @param {ImageBitmap | ImageData} image - The image captured from the track,
     * if OffscreenCanvas available it will be ImageBitmap, otherwise it will be ImageData.
     * @returns {Promise<Array<FaceResult>>}
     */
    async getDetections(image: ImageBitmap | ImageData): Promise<Array<FaceResult>> {
        if (!this.human || !this.faceDetectionTypes.length) {
            return [];
        }

        this.human.tf.engine().startScope();

        const imageTensor = this.human.tf.browser.fromPixels(image);
        const { face: detections } = await this.human.detect(imageTensor, this.config);

        this.human.tf.engine().endScope();

        return detections.filter(detection => detection.score > FACE_DETECTION_SCORE_THRESHOLD);
    }

    /**
     * Gathers together all the data from the detections, it's the function that will be called in the worker.
     *
     * @param {DetectInput} input - The input for the detections.
     * @returns {Promise<DetectOutput>}
     */
    public async detect({ image, threshold }: DetectInput): Promise<DetectOutput> {
        let faceExpression;
        let faceBox;

        this.detectionInProgress = true;

        const detections = await this.getDetections(image);

        if (this.faceDetectionTypes.includes(DETECTION_TYPES.FACE_EXPRESSIONS)) {
            faceExpression = this.getFaceExpression(detections);
        }

        if (this.faceDetectionTypes.includes(DETECTION_TYPES.FACE_BOX)) {
            // if more than one face is detected the face centering will be disabled.
            if (this.getFaceCount(detections) > 1) {
                this.faceDetectionTypes.splice(this.faceDetectionTypes.indexOf(DETECTION_TYPES.FACE_BOX), 1);

                // face-box for re-centering
                faceBox = {
                    left: 0,
                    right: 100,
                    width: 100
                };
            } else {
                faceBox = this.getFaceBox(detections, threshold);
            }

        }

        this.detectionInProgress = false;

        return {
            faceExpression,
            faceBox,
            faceCount: this.getFaceCount(detections)
        };
    }

    /**
     * Returns the detection state.
     *
     * @returns {boolean}
     */
    public getDetectionInProgress(): boolean {
        return this.detectionInProgress;
    }
}


################################################################################

## File: .\jitsi-meet\react\features\face-landmarks\faceLandmarksWorker.ts

import { HumanHelper, IFaceLandmarksHelper } from './FaceLandmarksHelper';
import { DETECT_FACE, INIT_WORKER } from './constants';

let helper: IFaceLandmarksHelper;

onmessage = async function({ data }: MessageEvent<any>) {
    switch (data.type) {
    case DETECT_FACE: {
        if (!helper || helper.getDetectionInProgress()) {
            return;
        }

        const detections = await helper.detect(data);

        if (detections) {
            self.postMessage(detections);
        }
        break;
    }

    case INIT_WORKER: {
        helper = new HumanHelper(data);
        break;
    }
    }
};


################################################################################

## File: .\jitsi-meet\react\features\face-landmarks\functions.ts

import { IReduxState } from '../app/types';
import { IJitsiConference } from '../base/conference/reducer';
import { getLocalParticipant } from '../base/participants/functions';
import { extractFqnFromPath } from '../dynamic-branding/functions.any';

import { FACE_BOX_EVENT_TYPE, FACE_LANDMARKS_EVENT_TYPE, SEND_IMAGE_INTERVAL_MS } from './constants';
import logger from './logger';
import { FaceBox, FaceLandmarks } from './types';

/**
 * Sends the face landmarks to other participants via the data channel.
 *
 * @param {any} conference - The current conference.
 * @param  {FaceLandmarks} faceLandmarks - Face landmarks to be sent.
 * @returns {void}
 */
export function sendFaceExpressionToParticipants(conference: any, faceLandmarks: FaceLandmarks): void {
    try {
        conference.sendEndpointMessage('', {
            type: FACE_LANDMARKS_EVENT_TYPE,
            faceLandmarks
        });
    } catch (err) {
        logger.warn('Could not broadcast the face landmarks to the other participants', err);
    }

}

/**
 * Sends the face box to all the other participants.
 *
 * @param {any} conference - The current conference.
 * @param  {FaceBox} faceBox - Face box to be sent.
 * @returns {void}
 */
export function sendFaceBoxToParticipants(
        conference: any,
        faceBox: FaceBox
): void {
    try {
        conference.sendEndpointMessage('', {
            type: FACE_BOX_EVENT_TYPE,
            faceBox
        });
    } catch (err) {
        logger.warn('Could not broadcast the face box to the other participants', err);
    }
}

/**
 * Sends the face landmarks to prosody.
 *
 * @param {any} conference - The current conference.
 * @param  {FaceLandmarks} faceLandmarks - Face landmarks to be sent.
 * @returns {void}
 */
export function sendFaceExpressionToServer(conference: IJitsiConference | undefined,
        faceLandmarks: FaceLandmarks): void {
    try {
        conference?.sendFaceLandmarks(faceLandmarks);
    } catch (err) {
        logger.warn('Could not send the face landmarks to prosody', err);
    }
}

/**
 * Sends face landmarks to backend.
 *
 * @param  {Object} state - Redux state.
 * @returns {boolean} - True if sent, false otherwise.
 */
export async function sendFaceExpressionsWebhook(state: IReduxState) {
    const { webhookProxyUrl: url } = state['features/base/config'];
    const { conference } = state['features/base/conference'];
    const { jwt } = state['features/base/jwt'];
    const { connection } = state['features/base/connection'];
    const jid = connection?.getJid();
    const localParticipant = getLocalParticipant(state);
    const { faceLandmarksBuffer } = state['features/face-landmarks'];

    if (faceLandmarksBuffer.length === 0) {
        return false;
    }

    const headers = {
        ...jwt ? { 'Authorization': `Bearer ${jwt}` } : {},
        'Content-Type': 'application/json'
    };

    const reqBody = {
        meetingFqn: extractFqnFromPath(),
        sessionId: conference?.getMeetingUniqueId(),
        submitted: Date.now(),
        emotions: faceLandmarksBuffer,
        participantId: localParticipant?.jwtId,
        participantName: localParticipant?.name,
        participantJid: jid
    };

    if (url) {
        try {
            const res = await fetch(`${url}/emotions`, {
                method: 'POST',
                headers,
                body: JSON.stringify(reqBody)
            });

            if (res.ok) {
                return true;
            }
            logger.error('Status error:', res.status);
        } catch (err) {
            logger.error('Could not send request', err);
        }
    }

    return false;
}


/**
 * Gets face box for a participant id.
 *
 * @param {string} id - The participant id.
 * @param {IReduxState} state - The redux state.
 * @returns {Object}
 */
function getFaceBoxForId(id: string, state: IReduxState) {
    return state['features/face-landmarks'].faceBoxes[id];
}

/**
 * Gets the video object position for a participant id.
 *
 * @param {IReduxState} state - The redux state.
 * @param {string} id - The participant id.
 * @returns {string} - CSS object-position in the shape of '{horizontalPercentage}% {verticalPercentage}%'.
 */
export function getVideoObjectPosition(state: IReduxState, id?: string) {
    const faceBox = id && getFaceBoxForId(id, state);

    if (faceBox) {
        const { right, width } = faceBox;

        if (right && width) {
            return `${right - (width / 2)}% 50%`;
        }
    }

    return '50% 50%';
}

/**
 * Gets the video object position for a participant id.
 *
 * @param {IReduxState} state - The redux state.
 * @returns {number} - Number of milliseconds for doing face detection.
 */
export function getDetectionInterval(state: IReduxState) {
    const { faceLandmarks } = state['features/base/config'];

    return Math.max(faceLandmarks?.captureInterval || SEND_IMAGE_INTERVAL_MS);
}


################################################################################

## File: .\jitsi-meet\react\features\face-landmarks\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/face-landmarks');


################################################################################

## File: .\jitsi-meet\react\features\face-landmarks\middleware.ts

import { AnyAction } from 'redux';

import { IStore } from '../app/types';
import {
    CONFERENCE_JOINED,
    CONFERENCE_WILL_LEAVE,
    ENDPOINT_MESSAGE_RECEIVED
} from '../base/conference/actionTypes';
import { getCurrentConference } from '../base/conference/functions';
import { getLocalParticipant, getParticipantCount } from '../base/participants/functions';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import { TRACK_ADDED, TRACK_REMOVED, TRACK_UPDATED } from '../base/tracks/actionTypes';

import FaceLandmarksDetector from './FaceLandmarksDetector';
import { ADD_FACE_LANDMARKS, NEW_FACE_COORDINATES, UPDATE_FACE_COORDINATES } from './actionTypes';
import { FACE_BOX_EVENT_TYPE } from './constants';
import { sendFaceBoxToParticipants, sendFaceExpressionToParticipants } from './functions';


MiddlewareRegistry.register((store: IStore) => (next: Function) => (action: AnyAction) => {
    const { dispatch, getState } = store;
    const { faceLandmarks: faceLandmarksConfig } = getState()['features/base/config'];
    const isEnabled = faceLandmarksConfig?.enableFaceCentering || faceLandmarksConfig?.enableFaceExpressionsDetection;

    if (action.type === CONFERENCE_JOINED) {
        if (isEnabled) {
            FaceLandmarksDetector.init(store);
        }

        return next(action);
    } else if (action.type === ENDPOINT_MESSAGE_RECEIVED) {
        // Allow using remote face centering data when local face centering is not enabled.
        const { participant, data } = action;

        if (data?.type === FACE_BOX_EVENT_TYPE) {
            dispatch({
                type: UPDATE_FACE_COORDINATES,
                faceBox: data.faceBox,
                id: participant.getId()
            });
        }

        return next(action);
    }

    if (!isEnabled) {
        return next(action);
    }

    switch (action.type) {
    case CONFERENCE_WILL_LEAVE : {
        FaceLandmarksDetector.stopDetection(store);

        break;
    }
    case TRACK_ADDED: {
        const { jitsiTrack: { isLocal, videoType }, muted } = action.track;

        if (videoType === 'camera' && isLocal() && !muted) {
            // need to pass this since the track is not yet added in the store
            FaceLandmarksDetector.startDetection(store, action.track);
        }

        break;
    }
    case TRACK_UPDATED: {
        const { jitsiTrack: { isLocal, videoType } } = action.track;

        if (videoType !== 'camera' || !isLocal()) {
            break;
        }

        const { muted } = action.track;

        if (typeof muted !== 'undefined') {
            // addresses video mute state changes
            if (muted) {
                FaceLandmarksDetector.stopDetection(store);
            } else {
                FaceLandmarksDetector.startDetection(store);
            }
        }

        break;
    }
    case TRACK_REMOVED: {
        const { jitsiTrack: { isLocal, videoType } } = action.track;

        if (videoType === 'camera' && isLocal()) {
            FaceLandmarksDetector.stopDetection(store);
        }

        break;
    }
    case ADD_FACE_LANDMARKS: {
        const state = getState();
        const { faceLandmarks } = action;
        const conference = getCurrentConference(state);

        if (getParticipantCount(state) > 1) {
            sendFaceExpressionToParticipants(conference, faceLandmarks);
        }

        // Disabling for now as there is no value of having the data in speakerstats at the server
        // sendFaceExpressionToServer(conference, faceLandmarks);

        break;
    }
    case NEW_FACE_COORDINATES: {
        const state = getState();
        const { faceBox } = action;
        const conference = getCurrentConference(state);
        const localParticipant = getLocalParticipant(state);

        if (getParticipantCount(state) > 1) {
            sendFaceBoxToParticipants(conference, faceBox);
        }

        dispatch({
            type: UPDATE_FACE_COORDINATES,
            faceBox,
            id: localParticipant?.id
        });

        break;
    }
    }

    return next(action);
});


################################################################################

## File: .\jitsi-meet\react\features\face-landmarks\reducer.ts

import ReducerRegistry from '../base/redux/ReducerRegistry';

import {
    ADD_FACE_LANDMARKS,
    CLEAR_FACE_LANDMARKS_BUFFER,
    UPDATE_FACE_COORDINATES
} from './actionTypes';
import { FaceBox, FaceLandmarks } from './types';

const defaultState = {
    faceBoxes: {},
    faceLandmarks: [],
    faceLandmarksBuffer: [],
    recognitionActive: false
};

export interface IFaceLandmarksState {
    faceBoxes: { [key: string]: FaceBox; };
    faceLandmarks: Array<FaceLandmarks>;
    faceLandmarksBuffer: Array<{
        emotion: string;
        timestamp: number;
    }>;
    recognitionActive: boolean;
}

ReducerRegistry.register<IFaceLandmarksState>('features/face-landmarks',
(state = defaultState, action): IFaceLandmarksState => {
    switch (action.type) {
    case ADD_FACE_LANDMARKS: {
        const { addToBuffer, faceLandmarks }: { addToBuffer: boolean; faceLandmarks: FaceLandmarks; } = action;

        return {
            ...state,
            faceLandmarks: [ ...state.faceLandmarks, faceLandmarks ],
            faceLandmarksBuffer: addToBuffer ? [ ...state.faceLandmarksBuffer,
                {
                    emotion: faceLandmarks.faceExpression,
                    timestamp: faceLandmarks.timestamp
                } ] : state.faceLandmarksBuffer
        };
    }
    case CLEAR_FACE_LANDMARKS_BUFFER: {
        return {
            ...state,
            faceLandmarksBuffer: []
        };
    }
    case UPDATE_FACE_COORDINATES: {
        return {
            ...state,
            faceBoxes: {
                ...state.faceBoxes,
                [action.id]: action.faceBox
            }
        };
    }
    }

    return state;
});


################################################################################

## File: .\jitsi-meet\react\features\face-landmarks\types.ts

export type DetectInput = {

    // @ts-ignore
    image: ImageBitmap | ImageData;
    threshold: number;
};

export type FaceBox = {
    left: number;
    right: number;
    width?: number;
};

export type InitInput = {
    baseUrl: string;
    detectionTypes: string[];
};

export type DetectOutput = {
    faceBox?: FaceBox;
    faceCount: number;
    faceExpression?: FaceExpression;
};

export type FaceExpression = {
    expression: string;
    score: number;
};

export type FaceLandmarks = {

    // duration in milliseconds of the face landmarks
    duration: number;
    faceExpression: string;
    score?: number;

    // the start timestamp of the expression
    timestamp: number;
};


################################################################################

## File: .\jitsi-meet\react\features\feedback\actions.web.ts

// @ts-expect-error
import { FEEDBACK_REQUEST_IN_PROGRESS } from '../../../modules/UI/UIErrors';
import { IStore } from '../app/types';
import { IJitsiConference } from '../base/conference/reducer';
import { openDialog } from '../base/dialog/actions';
import { extractFqnFromPath } from '../dynamic-branding/functions.any';

import {
    CANCEL_FEEDBACK,
    SUBMIT_FEEDBACK_ERROR,
    SUBMIT_FEEDBACK_SUCCESS
} from './actionTypes';
import FeedbackDialog from './components/FeedbackDialog.web';
import { sendFeedbackToJaaSRequest, shouldSendJaaSFeedbackMetadata } from './functions.web';

/**
 * Caches the passed in feedback in the redux store.
 *
 * @param {number} score - The quality score given to the conference.
 * @param {string} message - A description entered by the participant that
 * explains the rating.
 * @returns {{
 *     type: CANCEL_FEEDBACK,
 *     message: string,
 *     score: number
 * }}
 */
export function cancelFeedback(score: number, message: string) {
    return {
        type: CANCEL_FEEDBACK,
        message,
        score
    };
}

/**
 * Potentially open the {@code FeedbackDialog}. It will not be opened if it is
 * already open or feedback has already been submitted.
 *
 * @param {JistiConference} conference - The conference for which the feedback
 * would be about. The conference is passed in because feedback can occur after
 * a conference has been left, so references to it may no longer exist in redux.
 * @param {string} title - The feedback dialog title.
 * @returns {Promise} Resolved with value - false if the dialog is enabled and
 * resolved with true if the dialog is disabled or the feedback was already
 * submitted. Rejected if another dialog is already displayed.
 */
export function maybeOpenFeedbackDialog(conference: IJitsiConference, title?: string) {
    type R = {
        feedbackSubmitted: boolean;
        showThankYou: boolean;
        wasDialogShown: boolean;
    };

    return (dispatch: IStore['dispatch'], getState: IStore['getState']): Promise<R> => {
        const state = getState();
        const { feedbackPercentage = 100 } = state['features/base/config'];

        if (config.iAmRecorder) {
            // Intentionally fall through the if chain to prevent further action
            // from being taken with regards to showing feedback.
        } else if (state['features/base/dialog'].component === FeedbackDialog) {
            // Feedback is currently being displayed.

            return Promise.reject(FEEDBACK_REQUEST_IN_PROGRESS);
        } else if (state['features/feedback'].submitted) {
            // Feedback has been submitted already.

            return Promise.resolve({
                feedbackSubmitted: true,
                showThankYou: true,
                wasDialogShown: false
            });
        } else if (shouldSendJaaSFeedbackMetadata(state)
                && feedbackPercentage > Math.random() * 100) {
            return new Promise(resolve => {
                dispatch(openFeedbackDialog(conference, title, () => {
                    const { submitted } = getState()['features/feedback'];

                    resolve({
                        feedbackSubmitted: submitted,
                        showThankYou: false,
                        wasDialogShown: true
                    });
                }));
            });
        }

        // If the feedback functionality isn't enabled we show a "thank you"
        // message. Signaling it (true), so the caller of requestFeedback can
        // act on it.
        return Promise.resolve({
            feedbackSubmitted: false,
            showThankYou: true,
            wasDialogShown: false
        });
    };
}

/**
 * Opens {@code FeedbackDialog}.
 *
 * @param {JitsiConference} conference - The JitsiConference that is being
 * rated. The conference is passed in because feedback can occur after a
 * conference has been left, so references to it may no longer exist in redux.
 * @param {string} [title] - The feedback dialog title.
 * @param {Function} [onClose] - An optional callback to invoke when the dialog
 * is closed.
 * @returns {Object}
 */
export function openFeedbackDialog(conference?: IJitsiConference, title?: string, onClose?: Function) {
    return openDialog(FeedbackDialog, {
        conference,
        onClose,
        title
    });
}

/**
 * Sends feedback metadata to JaaS endpoint.
 *
 * @param {JitsiConference} conference - The JitsiConference that is being rated.
 * @param {Object} feedback - The feedback message and score.
 *
 * @returns {Promise}
 */
export function sendJaasFeedbackMetadata(conference: IJitsiConference, feedback: Object) {
    return (_dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();

        if (!shouldSendJaaSFeedbackMetadata(state)) {
            return Promise.resolve();
        }

        const { jaasFeedbackMetadataURL } = state['features/base/config'];
        const { jwt, user, tenant } = state['features/base/jwt'];
        const meetingFqn = extractFqnFromPath();
        const feedbackData = {
            ...feedback,
            sessionId: conference.sessionId,
            userId: user?.id,
            meetingFqn,
            jwt,
            tenant
        };

        return sendFeedbackToJaaSRequest(jaasFeedbackMetadataURL, feedbackData);
    };
}

/**
 * Send the passed in feedback.
 *
 * @param {number} score - An integer between 1 and 5 indicating the user
 * feedback. The negative integer -1 is used to denote no score was selected.
 * @param {string} message - Detailed feedback from the user to explain the
 * rating.
 * @param {JitsiConference} conference - The JitsiConference for which the
 * feedback is being left.
 * @returns {Function}
 */
export function submitFeedback(
        score: number,
        message: string,
        conference: IJitsiConference) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const promises = [];

        if (shouldSendJaaSFeedbackMetadata(state)) {
            promises.push(dispatch(sendJaasFeedbackMetadata(conference, {
                score,
                message
            })));
        }

        return Promise.allSettled(promises)
        .then(results => {
            const rejected = results.find((result): result is PromiseRejectedResult => result?.status === 'rejected');

            if (typeof rejected === 'undefined') {
                dispatch({ type: SUBMIT_FEEDBACK_SUCCESS });

                return Promise.resolve();
            }

            const error = rejected.reason;

            dispatch({
                type: SUBMIT_FEEDBACK_ERROR,
                error
            });

            return Promise.reject(error);
        });
    };
}


################################################################################

## File: .\jitsi-meet\react\features\feedback\actionTypes.ts

/**
 * The type of the action which signals feedback was closed without submitting.
 *
 * {
 *     type: CANCEL_FEEDBACK,
 *     message: string,
 *     score: number
 * }
 */
export const CANCEL_FEEDBACK = 'CANCEL_FEEDBACK';

/**
 * The type of the action which signals feedback failed to be recorded.
 *
 * {
 *     type: SUBMIT_FEEDBACK_ERROR
 *     error: string
 * }
 */
export const SUBMIT_FEEDBACK_ERROR = 'SUBMIT_FEEDBACK_ERROR';

/**
 * The type of the action which signals feedback has been recorded.
 *
 * {
 *     type: SUBMIT_FEEDBACK_SUCCESS,
 * }
 */
export const SUBMIT_FEEDBACK_SUCCESS = 'SUBMIT_FEEDBACK_SUCCESS';


################################################################################

## File: .\jitsi-meet\react\features\feedback\functions.web.ts

import { IReduxState } from '../app/types';
import { isVpaasMeeting } from '../jaas/functions';

import logger from './logger';

/**
 * Sends feedback metadata to JaaS endpoints.
 *
 * @param {string|undefined} url - The JaaS metadata endpoint URL.
 * @param {Object} feedbackData - The feedback data object.
 * @returns {Promise}
 */
export async function sendFeedbackToJaaSRequest(url: string | undefined, feedbackData: {
    jwt?: string; meetingFqn: string; message?: string; score?: number;
    sessionId: string; tenant?: string; userId?: string;
}) {
    if (!url) {
        throw new TypeError('Trying to send jaas feedback request to an undefined URL!');
    }

    const {
        jwt,
        sessionId,
        meetingFqn,
        score,
        message,
        userId,
        tenant
    } = feedbackData;
    const headers = {
        'Authorization': `Bearer ${jwt}`,
        'Content-Type': 'application/json'
    };
    const data = {
        sessionId,
        meetingFqn,
        userId,
        tenant,
        submitted: new Date().getTime(),
        rating: score,
        comments: message
    };

    try {
        const res = await fetch(url, {
            method: 'POST',
            headers,
            body: JSON.stringify(data)
        });

        if (!res.ok) {
            logger.error('Status error:', res.status);
        }
    } catch (err) {
        logger.error('Could not send request', err);
    }
}

/**
 * Returns whether jaas feedback metadata should be send or not.
 *
 * @param {IReduxState} state - The redux state.
 * @returns {boolean} - True if jaas feedback metadata should be send and false otherwise.
 */
export function shouldSendJaaSFeedbackMetadata(state: IReduxState) {
    const { jaasFeedbackMetadataURL } = state['features/base/config'];

    return Boolean(isVpaasMeeting(state) && jaasFeedbackMetadataURL);
}



################################################################################

## File: .\jitsi-meet\react\features\feedback\hooks.web.ts

import { useSelector } from 'react-redux';

import FeedbackButtonWeb from './components/FeedbackButton.web';
import { shouldSendJaaSFeedbackMetadata } from './functions.web';

const feedback = {
    key: 'feedback',
    Content: FeedbackButtonWeb,
    group: 4
};

/**
 * A hook that returns the feedback button if it is enabled and undefined otherwise.
 *
 *  @returns {Object | undefined}
 */
export function useFeedbackButton() {
    const visible = useSelector(shouldSendJaaSFeedbackMetadata);

    if (visible) {
        return feedback;
    }
}


################################################################################

## File: .\jitsi-meet\react\features\feedback\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/feedback');


################################################################################

## File: .\jitsi-meet\react\features\feedback\reducer.ts

import ReducerRegistry from '../base/redux/ReducerRegistry';

import {
    CANCEL_FEEDBACK,
    SUBMIT_FEEDBACK_ERROR,
    SUBMIT_FEEDBACK_SUCCESS
} from './actionTypes';

const DEFAULT_STATE = {
    message: '',

    // The sentinel value -1 is used to denote no rating has been set and to
    // preserve pre-redux behavior.
    score: -1,
    submitted: false
};

export interface IFeedbackState {
    message: string;
    score: number;
    submitted: boolean;
}

/**
 * Reduces the Redux actions of the feature features/feedback.
 */
ReducerRegistry.register<IFeedbackState>(
    'features/feedback',
    (state = DEFAULT_STATE, action): IFeedbackState => {
        switch (action.type) {
        case CANCEL_FEEDBACK: {
            return {
                ...state,
                message: action.message,
                score: action.score
            };
        }

        case SUBMIT_FEEDBACK_ERROR:
        case SUBMIT_FEEDBACK_SUCCESS: {
            return {
                ...state,
                message: '',
                score: -1,
                submitted: true
            };
        }
        }

        return state;
    });


################################################################################

## File: .\jitsi-meet\react\features\feedback\components\FeedbackButton.native.ts



################################################################################

## File: .\jitsi-meet\react\features\feedback\components\FeedbackButton.web.ts


import { connect } from 'react-redux';

import { createToolbarEvent } from '../../analytics/AnalyticsEvents';
import { sendAnalytics } from '../../analytics/functions';
import { IReduxState } from '../../app/types';
import { IJitsiConference } from '../../base/conference/reducer';
import { translate } from '../../base/i18n/functions';
import { IconFeedback } from '../../base/icons/svg';
import AbstractButton, { IProps as AbstractButtonProps } from '../../base/toolbox/components/AbstractButton';
import { openFeedbackDialog } from '../actions';
import { shouldSendJaaSFeedbackMetadata } from '../functions.web';

/**
 * The type of the React {@code Component} props of {@link FeedbackButton}.
 */
interface IProps extends AbstractButtonProps {

    /**
     * The {@code JitsiConference} for the current conference.
     */
    _conference?: IJitsiConference;
}

/**
 * Implementation of a button for opening feedback dialog.
 */
class FeedbackButton extends AbstractButton<IProps> {
    accessibilityLabel = 'toolbar.accessibilityLabel.feedback';
    icon = IconFeedback;
    label = 'toolbar.feedback';
    tooltip = 'toolbar.feedback';

    /**
     * Handles clicking / pressing the button, and opens the appropriate dialog.
     *
     * @protected
     * @returns {void}
     */
    _handleClick() {
        const { _conference, dispatch } = this.props;

        sendAnalytics(createToolbarEvent('feedback'));
        dispatch(openFeedbackDialog(_conference));
    }
}

const mapStateToProps = (state: IReduxState) => {
    const { conference } = state['features/base/conference'];

    return {
        _conference: conference,
        visible: shouldSendJaaSFeedbackMetadata(state)
    };
};

export default translate(connect(mapStateToProps)(FeedbackButton));


################################################################################

## File: .\jitsi-meet\react\features\feedback\components\FeedbackDialog.native.ts

import { Component } from 'react';

export default Component;


################################################################################

## File: .\jitsi-meet\react\features\filmstrip\actions.any.ts

import {
    SET_FILMSTRIP_ENABLED,
    SET_FILMSTRIP_VISIBLE,
    SET_REMOTE_PARTICIPANTS,
    SET_VISIBLE_REMOTE_PARTICIPANTS
} from './actionTypes';

/**
 * Sets whether the filmstrip is enabled.
 *
 * @param {boolean} enabled - Whether the filmstrip is enabled.
 * @returns {{
 *     type: SET_FILMSTRIP_ENABLED,
 *     enabled: boolean
 * }}
 */
export function setFilmstripEnabled(enabled: boolean) {
    return {
        type: SET_FILMSTRIP_ENABLED,
        enabled
    };
}

/**
 * Sets whether the filmstrip is visible.
 *
 * @param {boolean} visible - Whether the filmstrip is visible.
 * @returns {{
 *     type: SET_FILMSTRIP_VISIBLE,
 *     visible: boolean
 * }}
 */
export function setFilmstripVisible(visible: boolean) {
    return {
        type: SET_FILMSTRIP_VISIBLE,
        visible
    };
}

/**
 * Sets the list of the reordered remote participants based on which the visible participants in the filmstrip will be
 * determined.
 *
 * @param {Array<string>} participants - The list of the remote participant endpoint IDs.
 * @returns {{
        type: SET_REMOTE_PARTICIPANTS,
        participants: Array<string>
    }}
 */
export function setRemoteParticipants(participants: Array<string>) {
    return {
        type: SET_REMOTE_PARTICIPANTS,
        participants
    };
}

/**
 * Sets the list of the visible participants in the filmstrip by storing the start and end index from the remote
 * participants array.
 *
 * @param {number} startIndex - The start index from the remote participants array.
 * @param {number} endIndex - The end index from the remote participants array.
 * @returns {{
 *      type: SET_VISIBLE_REMOTE_PARTICIPANTS,
 *      startIndex: number,
 *      endIndex: number
 * }}
 */
export function setVisibleRemoteParticipants(startIndex: number, endIndex: number) {
    return {
        type: SET_VISIBLE_REMOTE_PARTICIPANTS,
        startIndex,
        endIndex
    };
}


################################################################################

## File: .\jitsi-meet\react\features\filmstrip\actions.native.ts

import { IStore } from '../app/types';
import conferenceStyles from '../conference/components/native/styles';

import { SET_TILE_VIEW_DIMENSIONS } from './actionTypes';
import styles from './components/native/styles';
import { SQUARE_TILE_ASPECT_RATIO, TILE_MARGIN } from './constants';
import { getColumnCount, getTileViewParticipantCount } from './functions.native';

export * from './actions.any';

/**
 * Sets the dimensions of the tile view grid. The action is only partially implemented on native as not all
 * of the values are currently used. Check the description of {@link SET_TILE_VIEW_DIMENSIONS} for the full set
 * of properties.
 *
 * @returns {Function}
 */
export function setTileViewDimensions() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const participantCount = getTileViewParticipantCount(state);
        const { clientHeight: height, clientWidth: width, safeAreaInsets = {
            left: undefined,
            right: undefined,
            top: undefined,
            bottom: undefined
        } } = state['features/base/responsive-ui'];
        const { left = 0, right = 0, top = 0, bottom = 0 } = safeAreaInsets;
        const columns = getColumnCount(state);
        const rows = Math.ceil(participantCount / columns); // @ts-ignore
        const conferenceBorder = conferenceStyles.conference.borderWidth || 0;
        const heightToUse = height - top - bottom - (2 * conferenceBorder);
        const widthToUse = width - (TILE_MARGIN * 2) - left - right - (2 * conferenceBorder);
        let tileWidth;

        // If there is going to be at least two rows, ensure that at least two
        // rows display fully on screen.
        if (participantCount / columns > 1) {
            tileWidth = Math.min(widthToUse / columns, heightToUse / 2);
        } else {
            tileWidth = Math.min(widthToUse / columns, heightToUse);
        }

        const tileHeight = Math.floor(tileWidth / SQUARE_TILE_ASPECT_RATIO);

        tileWidth = Math.floor(tileWidth);

        // Adding safeAreaInsets.bottom to the total height of all thumbnails because we add it as a padding to the
        // thumbnails container.
        const hasScroll = heightToUse < ((tileHeight + (2 * styles.thumbnail.margin)) * rows) + bottom;

        dispatch({
            type: SET_TILE_VIEW_DIMENSIONS,
            dimensions: {
                columns,
                thumbnailSize: {
                    height: tileHeight,
                    width: tileWidth
                },
                hasScroll
            }
        });
    };
}

/**
 * Add participant to the active participants list.
 *
 * @param {string} _participantId - The Id of the participant to be added.
 * @param {boolean?} _pinned - Whether the participant is pinned or not.
 * @returns {Object}
 */
export function addStageParticipant(_participantId: string, _pinned = false): any {
    return {};
}

/**
 * Remove participant from the active participants list.
 *
 * @param {string} _participantId - The Id of the participant to be removed.
 * @returns {Object}
 */
export function removeStageParticipant(_participantId: string): any {
    return {};
}


################################################################################

## File: .\jitsi-meet\react\features\filmstrip\actions.web.ts

import { IStore } from '../app/types';
import { pinParticipant } from '../base/participants/actions';
import {
    getLocalParticipant,
    getParticipantById,
    getRemoteParticipantCountWithFake
} from '../base/participants/functions';
import { getHideSelfView } from '../base/settings/functions.any';
import { getMaxColumnCount } from '../video-layout/functions.web';

import {
    ADD_STAGE_PARTICIPANT,
    CLEAR_STAGE_PARTICIPANTS,
    REMOVE_STAGE_PARTICIPANT,
    RESIZE_FILMSTRIP,
    SET_FILMSTRIP_HEIGHT,
    SET_FILMSTRIP_WIDTH,
    SET_HORIZONTAL_VIEW_DIMENSIONS,
    SET_SCREENSHARE_FILMSTRIP_PARTICIPANT,
    SET_SCREENSHARING_TILE_DIMENSIONS,
    SET_STAGE_FILMSTRIP_DIMENSIONS,
    SET_STAGE_PARTICIPANTS,
    SET_TILE_VIEW_DIMENSIONS,
    SET_TOP_PANEL_VISIBILITY,
    SET_USER_FILMSTRIP_HEIGHT,
    SET_USER_FILMSTRIP_WIDTH,
    SET_USER_IS_RESIZING,
    SET_VERTICAL_VIEW_DIMENSIONS,
    SET_VOLUME,
    TOGGLE_PIN_STAGE_PARTICIPANT
} from './actionTypes';
import {
    HORIZONTAL_FILMSTRIP_MARGIN,
    MAX_ACTIVE_PARTICIPANTS,
    SCROLL_SIZE,
    STAGE_VIEW_THUMBNAIL_VERTICAL_BORDER,
    TILE_HORIZONTAL_MARGIN,
    TILE_MIN_HEIGHT_SMALL,
    TILE_VERTICAL_CONTAINER_HORIZONTAL_MARGIN,
    TILE_VERTICAL_MARGIN,
    TILE_VIEW_DEFAULT_NUMBER_OF_VISIBLE_TILES,
    TILE_VIEW_GRID_HORIZONTAL_MARGIN,
    TILE_VIEW_GRID_VERTICAL_MARGIN,
    TOP_FILMSTRIP_HEIGHT,
    VERTICAL_FILMSTRIP_VERTICAL_MARGIN
} from './constants';
import {
    calculateNonResponsiveTileViewDimensions,
    calculateResponsiveTileViewDimensions,
    calculateThumbnailSizeForHorizontalView,
    calculateThumbnailSizeForVerticalView,
    getNumberOfPartipantsForTileView,
    getVerticalViewMaxWidth,
    isFilmstripResizable,
    isStageFilmstripAvailable,
    isStageFilmstripTopPanel
    , showGridInVerticalView } from './functions.web';

export * from './actions.any';

/**
 * Resize the filmstrip.
 *
 * @param {number} width - Width value for filmstrip.
 *
 * @returns {{
 *  type: RESIZE_FILMSTRIP,
 *  width: number,
 * }}
 */
export function resizeFilmStrip(width: number) {
    return {
        type: RESIZE_FILMSTRIP,
        width
    };
}

/**
 * Sets the dimensions of the tile view grid.
 *
 * @returns {Function}
 */
export function setTileViewDimensions() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const { clientHeight, clientWidth } = state['features/base/responsive-ui'];
        const {
            disableResponsiveTiles,
            disableTileEnlargement,
            tileView = {}
        } = state['features/base/config'];
        const { numberOfVisibleTiles = TILE_VIEW_DEFAULT_NUMBER_OF_VISIBLE_TILES } = tileView;
        const numberOfParticipants = getNumberOfPartipantsForTileView(state);
        const maxColumns = getMaxColumnCount(state);

        const {
            height,
            width,
            columns,
            rows
        } = disableResponsiveTiles
            ? calculateNonResponsiveTileViewDimensions(state)
            : calculateResponsiveTileViewDimensions({
                clientWidth,
                clientHeight,
                disableTileEnlargement,
                maxColumns,
                numberOfParticipants,
                desiredNumberOfVisibleTiles: numberOfVisibleTiles
            });
        const thumbnailsTotalHeight = (rows ?? 1) * (TILE_VERTICAL_MARGIN + (height ?? 0));
        const availableHeight = clientHeight - TILE_VIEW_GRID_VERTICAL_MARGIN;
        const hasScroll = availableHeight < thumbnailsTotalHeight;
        const filmstripWidth
            = Math.min(clientWidth - TILE_VIEW_GRID_HORIZONTAL_MARGIN,
                (columns ?? 1) * (TILE_HORIZONTAL_MARGIN + (width ?? 0)))
                + (hasScroll ? SCROLL_SIZE : 0);
        const filmstripHeight = Math.min(availableHeight, thumbnailsTotalHeight);

        dispatch({
            type: SET_TILE_VIEW_DIMENSIONS,
            dimensions: {
                gridDimensions: {
                    columns,
                    rows
                },
                thumbnailSize: {
                    height,
                    width
                },
                filmstripHeight,
                filmstripWidth,
                hasScroll
            }
        });
    };
}

/**
 * Sets the dimensions of the thumbnails in vertical view.
 *
 * @returns {Function}
 */
export function setVerticalViewDimensions() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const { clientHeight = 0, clientWidth = 0 } = state['features/base/responsive-ui'];
        const { width: filmstripWidth } = state['features/filmstrip'];
        const disableSelfView = getHideSelfView(state);
        const resizableFilmstrip = isFilmstripResizable(state);
        const _verticalViewGrid = showGridInVerticalView(state);
        const numberOfRemoteParticipants = getRemoteParticipantCountWithFake(state);
        const { localScreenShare } = state['features/base/participants'];

        let gridView = {};
        let thumbnails: any = {};
        let filmstripDimensions = {};
        let hasScroll = false;
        let remoteVideosContainerWidth;
        let remoteVideosContainerHeight;

        // grid view in the vertical filmstrip
        if (_verticalViewGrid) {
            const { tileView = {} } = state['features/base/config'];
            const { numberOfVisibleTiles = TILE_VIEW_DEFAULT_NUMBER_OF_VISIBLE_TILES } = tileView;
            const numberOfParticipants = getNumberOfPartipantsForTileView(state);
            const maxColumns = getMaxColumnCount(state, {
                width: filmstripWidth.current,
                disableResponsiveTiles: false,
                disableTileEnlargement: false
            });
            const {
                height,
                width,
                columns,
                rows
            } = calculateResponsiveTileViewDimensions({
                clientWidth: filmstripWidth.current ?? 0,
                clientHeight,
                disableTileEnlargement: false,
                maxColumns,
                noHorizontalContainerMargin: true,
                numberOfParticipants,
                desiredNumberOfVisibleTiles: numberOfVisibleTiles
            });
            const thumbnailsTotalHeight = (rows ?? 1) * (TILE_VERTICAL_MARGIN + (height ?? 0));

            hasScroll = clientHeight < thumbnailsTotalHeight;
            const widthOfFilmstrip = ((columns ?? 1) * (TILE_HORIZONTAL_MARGIN + (width ?? 0)))
                + (hasScroll ? SCROLL_SIZE : 0);
            const filmstripHeight = Math.min(clientHeight - TILE_VIEW_GRID_VERTICAL_MARGIN, thumbnailsTotalHeight);

            gridView = {
                gridDimensions: {
                    columns,
                    rows
                },
                thumbnailSize: {
                    height,
                    width
                },
                hasScroll
            };

            filmstripDimensions = {
                height: filmstripHeight,
                width: widthOfFilmstrip
            };
        } else {
            thumbnails = calculateThumbnailSizeForVerticalView(clientWidth, filmstripWidth.current ?? 0,
                resizableFilmstrip);

            remoteVideosContainerWidth
                = thumbnails?.local?.width + TILE_VERTICAL_CONTAINER_HORIZONTAL_MARGIN + SCROLL_SIZE;
            remoteVideosContainerHeight
                = clientHeight - (disableSelfView ? 0 : thumbnails?.local?.height) - VERTICAL_FILMSTRIP_VERTICAL_MARGIN;

            // Account for the height of the local screen share thumbnail when calculating the height of the remote
            // videos container.
            const localCameraThumbnailHeight = thumbnails?.local?.height;
            const localScreenShareThumbnailHeight
                = localScreenShare && !disableSelfView ? thumbnails?.local?.height : 0;

            remoteVideosContainerHeight = clientHeight
                - localCameraThumbnailHeight
                - localScreenShareThumbnailHeight
                - VERTICAL_FILMSTRIP_VERTICAL_MARGIN;

            hasScroll
                = remoteVideosContainerHeight
                    < (thumbnails?.remote.height + TILE_VERTICAL_MARGIN) * numberOfRemoteParticipants;
        }

        dispatch({
            type: SET_VERTICAL_VIEW_DIMENSIONS,
            dimensions: {
                ...thumbnails,
                remoteVideosContainer: _verticalViewGrid ? filmstripDimensions : {
                    width: remoteVideosContainerWidth,
                    height: remoteVideosContainerHeight
                },
                gridView,
                hasScroll
            }
        });
    };
}

/**
 * Sets the dimensions of the thumbnails in horizontal view.
 *
 * @returns {Function}
 */
export function setHorizontalViewDimensions() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const { clientHeight = 0, clientWidth = 0 } = state['features/base/responsive-ui'];
        const disableSelfView = getHideSelfView(state);
        const thumbnails = calculateThumbnailSizeForHorizontalView(clientHeight);
        const remoteVideosContainerWidth
            = clientWidth - (disableSelfView ? 0 : thumbnails?.local?.width) - HORIZONTAL_FILMSTRIP_MARGIN;
        const remoteVideosContainerHeight
            = thumbnails?.local?.height + TILE_VERTICAL_MARGIN + STAGE_VIEW_THUMBNAIL_VERTICAL_BORDER + SCROLL_SIZE;
        const numberOfRemoteParticipants = getRemoteParticipantCountWithFake(state);
        const hasScroll
            = remoteVideosContainerHeight
                < (thumbnails?.remote.width + TILE_HORIZONTAL_MARGIN) * numberOfRemoteParticipants;

        dispatch({
            type: SET_HORIZONTAL_VIEW_DIMENSIONS,
            dimensions: {
                ...thumbnails,
                remoteVideosContainer: {
                    width: remoteVideosContainerWidth,
                    height: remoteVideosContainerHeight
                },
                hasScroll
            }
        });
    };
}

/**
 * Sets the dimensions of the stage filmstrip tile view grid.
 *
 * @returns {Function}
 */
export function setStageFilmstripViewDimensions() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const { clientHeight, clientWidth } = state['features/base/responsive-ui'];
        const {
            tileView = {}
        } = state['features/base/config'];
        const { visible, topPanelHeight } = state['features/filmstrip'];
        const verticalWidth = visible ? getVerticalViewMaxWidth(state) : 0;
        const { numberOfVisibleTiles = MAX_ACTIVE_PARTICIPANTS } = tileView;
        const numberOfParticipants = state['features/filmstrip'].activeParticipants.length;
        const availableWidth = clientWidth - verticalWidth;
        const maxColumns = getMaxColumnCount(state, {
            width: availableWidth,
            disableResponsiveTiles: false,
            disableTileEnlargement: false
        });
        const topPanel = isStageFilmstripTopPanel(state);

        const {
            height,
            width,
            columns,
            rows
        } = calculateResponsiveTileViewDimensions({
            clientWidth: availableWidth,
            clientHeight: topPanel ? topPanelHeight?.current || TOP_FILMSTRIP_HEIGHT : clientHeight,
            disableTileEnlargement: false,
            maxColumns,
            noHorizontalContainerMargin: verticalWidth > 0,
            numberOfParticipants,
            desiredNumberOfVisibleTiles: numberOfVisibleTiles,
            minTileHeight: topPanel ? TILE_MIN_HEIGHT_SMALL : null
        });
        const thumbnailsTotalHeight = (rows ?? 1) * (TILE_VERTICAL_MARGIN + (height ?? 0));
        const hasScroll = clientHeight < thumbnailsTotalHeight;
        const filmstripWidth
            = Math.min(clientWidth - TILE_VIEW_GRID_HORIZONTAL_MARGIN,
                (columns ?? 1) * (TILE_HORIZONTAL_MARGIN + (width ?? 0)))
            + (hasScroll ? SCROLL_SIZE : 0);
        const filmstripHeight = Math.min(clientHeight - TILE_VIEW_GRID_VERTICAL_MARGIN, thumbnailsTotalHeight);

        dispatch({
            type: SET_STAGE_FILMSTRIP_DIMENSIONS,
            dimensions: {
                gridDimensions: {
                    columns,
                    rows
                },
                thumbnailSize: {
                    height,
                    width
                },
                filmstripHeight,
                filmstripWidth,
                hasScroll
            }
        });
    };
}

/**
 * Emulates a click on the n-th video.
 *
 * @param {number} n - Number that identifies the video.
 * @returns {Function}
 */
export function clickOnVideo(n: number) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const { id: localId } = getLocalParticipant(state) ?? {};

        // Use the list that correctly represents the current order of the participants as visible in the UI.
        const { remoteParticipants } = state['features/filmstrip'];
        const participants = [ localId, ...remoteParticipants ];

        if (participants.length - 1 < n) {
            return;
        }
        const { id, pinned } = getParticipantById(state, participants[n] ?? '') ?? {};

        if (isStageFilmstripAvailable(state)) {
            dispatch(togglePinStageParticipant(id ?? ''));
        } else {
            dispatch(pinParticipant(pinned ? null : id));
        }
    };
}

/**
 * Sets the volume for a thumbnail's audio.
 *
 * @param {string} participantId - The participant ID associated with the audio.
 * @param {string} volume - The volume level.
 * @returns {{
 *     type: SET_VOLUME,
 *     participantId: string,
 *     volume: number
 * }}
 */
export function setVolume(participantId: string, volume: number) {
    return {
        type: SET_VOLUME,
        participantId,
        volume
    };
}

/**
 * Sets the top filmstrip's height.
 *
 * @param {number} height - The new height of the filmstrip.
 * @returns {{
 *      type: SET_FILMSTRIP_HEIGHT,
 *      height: number
 * }}
 */
export function setFilmstripHeight(height: number) {
    return {
        type: SET_FILMSTRIP_HEIGHT,
        height
    };
}

/**
 * Sets the filmstrip's width.
 *
 * @param {number} width - The new width of the filmstrip.
 * @returns {{
 *      type: SET_FILMSTRIP_WIDTH,
 *      width: number
 * }}
 */
export function setFilmstripWidth(width: number) {
    return {
        type: SET_FILMSTRIP_WIDTH,
        width
    };
}

/**
 * Sets the filmstrip's height and the user preferred height.
 *
 * @param {number} height - The new height of the filmstrip.
 * @returns {{
 *      type: SET_USER_FILMSTRIP_WIDTH,
 *      height: number
 * }}
 */
export function setUserFilmstripHeight(height: number) {
    return {
        type: SET_USER_FILMSTRIP_HEIGHT,
        height
    };
}

/**
 * Sets the filmstrip's width and the user preferred width.
 *
 * @param {number} width - The new width of the filmstrip.
 * @returns {{
 *      type: SET_USER_FILMSTRIP_WIDTH,
 *      width: number
 * }}
 */
export function setUserFilmstripWidth(width: number) {
    return {
        type: SET_USER_FILMSTRIP_WIDTH,
        width
    };
}

/**
 * Sets whether the user is resizing or not.
 *
 * @param {boolean} resizing - Whether the user is resizing or not.
 * @returns {Object}
 */
export function setUserIsResizing(resizing: boolean) {
    return {
        type: SET_USER_IS_RESIZING,
        resizing
    };
}

/**
 * Add participant to the active participants list.
 *
 * @param {string} participantId - The Id of the participant to be added.
 * @param {boolean?} pinned - Whether the participant is pinned or not.
 * @returns {Object}
 */
export function addStageParticipant(participantId: string, pinned = false) {
    return {
        type: ADD_STAGE_PARTICIPANT,
        participantId,
        pinned
    };
}

/**
 * Remove participant from the active participants list.
 *
 * @param {string} participantId - The Id of the participant to be removed.
 * @returns {Object}
 */
export function removeStageParticipant(participantId: string) {
    return {
        type: REMOVE_STAGE_PARTICIPANT,
        participantId
    };
}

/**
 * Sets the active participants list.
 *
 * @param {Array<Object>} queue - The new list.
 * @returns {Object}
 */
export function setStageParticipants(queue: Object[]) {
    return {
        type: SET_STAGE_PARTICIPANTS,
        queue
    };
}

/**
 * Toggles the pin state of the given participant.
 *
 * @param {string} participantId - The id of the participant to be toggled.
 * @returns {Object}
 */
export function togglePinStageParticipant(participantId: string) {
    return {
        type: TOGGLE_PIN_STAGE_PARTICIPANT,
        participantId
    };
}

/**
 * Clears the stage participants list.
 *
 * @returns {Object}
 */
export function clearStageParticipants() {
    return {
        type: CLEAR_STAGE_PARTICIPANTS
    };
}

/**
 * Set the screensharing tile dimensions.
 *
 * @returns {Object}
 */
export function setScreensharingTileDimensions() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const { clientHeight, clientWidth } = state['features/base/responsive-ui'];
        const { visible, topPanelHeight, topPanelVisible } = state['features/filmstrip'];
        const verticalWidth = visible ? getVerticalViewMaxWidth(state) : 0;
        const availableWidth = clientWidth - verticalWidth;
        const topPanel = isStageFilmstripTopPanel(state) && topPanelVisible;
        const availableHeight = clientHeight - (topPanel ? topPanelHeight?.current || TOP_FILMSTRIP_HEIGHT : 0);

        dispatch({
            type: SET_SCREENSHARING_TILE_DIMENSIONS,
            dimensions: {
                filmstripHeight: availableHeight,
                filmstripWidth: availableWidth,
                thumbnailSize: {
                    width: availableWidth - TILE_HORIZONTAL_MARGIN,
                    height: availableHeight - TILE_VERTICAL_MARGIN
                }
            }
        });
    };
}

/**
 * Sets the visibility of the top panel.
 *
 * @param {boolean} visible - Whether it should be visible or not.
 * @returns {Object}
 */
export function setTopPanelVisible(visible: boolean) {
    return {
        type: SET_TOP_PANEL_VISIBILITY,
        visible
    };
}

/**
 * Sets the participant whose screenshare to be displayed on the filmstrip.
 *
 * @param {string|undefined} participantId - The id of the participant to be set.
 * @returns {Object}
 */
export function setScreenshareFilmstripParticipant(participantId?: string) {
    return {
        type: SET_SCREENSHARE_FILMSTRIP_PARTICIPANT,
        participantId
    };
}


################################################################################

## File: .\jitsi-meet\react\features\filmstrip\actionTypes.ts

/**
 * The type of (redux) action which enlarges the filmstrip.
 *
 * {
 *     type: RESIZE_FILMSTRIP,
 * }
 */
export const RESIZE_FILMSTRIP = 'RESIZE_FILMSTRIP';

 /**
 * The type of (redux) action which sets whether the filmstrip is enabled.
 *
 * {
 *     type: SET_FILMSTRIP_ENABLED,
 *     enabled: boolean
 * }
 */
export const SET_FILMSTRIP_ENABLED = 'SET_FILMSTRIP_ENABLED';

/**
 * The type of (redux) action which sets whether the filmstrip is visible.
 *
 * {
 *     type: SET_FILMSTRIP_VISIBLE,
 *     visible: boolean
 * }
 */
export const SET_FILMSTRIP_VISIBLE = 'SET_FILMSTRIP_VISIBLE';

/**
 * The type of (redux) action which sets the dimensions of the tile view grid.
 *
 * {
 *     type: SET_TILE_VIEW_DIMENSIONS,
 *     dimensions: {
 *         gridDimensions: {
 *             columns: number,
 *             height: number,
 *             minVisibleRows: number,
 *             width: number
 *         },
 *         thumbnailSize: {
 *             height: number,
 *             width: number
 *         },
 *         filmstripWidth: number
 *     }
 * }
 */
export const SET_TILE_VIEW_DIMENSIONS = 'SET_TILE_VIEW_DIMENSIONS';

/**
 * The type of (redux) action which sets the dimensions of the thumbnails in horizontal view.
 *
 * {
 *     type: SET_HORIZONTAL_VIEW_DIMENSIONS,
 *     dimensions: Object
 * }
 */
export const SET_HORIZONTAL_VIEW_DIMENSIONS = 'SET_HORIZONTAL_VIEW_DIMENSIONS';

/**
 * The type of (redux) action which sets the reordered list of the remote participants in the filmstrip.
 * {
 *      type: SET_REMOTE_PARTICIPANTS,
 *      participants: Array<string>
 * }
 */
export const SET_REMOTE_PARTICIPANTS = 'SET_REMOTE_PARTICIPANTS';

/**
 * The type of (redux) action which sets the dimensions of the thumbnails in vertical view.
 *
 * {
 *     type: SET_VERTICAL_VIEW_DIMENSIONS,
 *     dimensions: Object
 * }
 */
export const SET_VERTICAL_VIEW_DIMENSIONS = 'SET_VERTICAL_VIEW_DIMENSIONS';

/**
 * The type of (redux) action which sets the volume for a thumnail's audio.
 *
 * {
 *     type: SET_VOLUME,
 *     participantId: string,
 *     volume: number
 * }
 */
export const SET_VOLUME = 'SET_VOLUME';

/**
 * The type of the action which sets the list of visible remote participants in the filmstrip by storing the start and
 * end index in the remote participants array.
 *
 * {
 *      type: SET_VISIBLE_REMOTE_PARTICIPANTS,
 *      startIndex: number,
 *      endIndex: number
 * }
 */
export const SET_VISIBLE_REMOTE_PARTICIPANTS = 'SET_VISIBLE_REMOTE_PARTICIPANTS';

/**
 * The type of action which sets the height for the top panel filmstrip.
 * {
 *      type: SET_FILMSTRIP_HEIGHT,
 *      height: number
 * }
 */
export const SET_FILMSTRIP_HEIGHT = 'SET_FILMSTRIP_HEIGHT';

/**
 * The type of action which sets the width for the vertical filmstrip.
 * {
 *      type: SET_FILMSTRIP_WIDTH,
 *      width: number
 * }
 */
export const SET_FILMSTRIP_WIDTH = 'SET_FILMSTRIP_WIDTH';

/**
 * The type of action which sets the height for the top panel filmstrip (user resized).
 * {
 *      type: SET_USER_FILMSTRIP_HEIGHT,
 *      height: number
 * }
 */
export const SET_USER_FILMSTRIP_HEIGHT = 'SET_USER_FILMSTRIP_HEIGHT';

/**
 * The type of action which sets the width for the vertical filmstrip (user resized).
 * {
 *      type: SET_USER_FILMSTRIP_WIDTH,
 *      width: number
 * }
 */
export const SET_USER_FILMSTRIP_WIDTH = 'SET_USER_FILMSTRIP_WIDTH';

/**
 * The type of action which sets whether the user is resizing or not.
 * {
 *      type: SET_USER_IS_RESIZING,
 *      resizing: boolean
 * }
 */
export const SET_USER_IS_RESIZING = 'SET_USER_IS_RESIZING';

/**
 * The type of (redux) action which sets the dimensions of the thumbnails in stage filmstrip view.
 *
 * {
 *     type: SET_STAGE_FILMSTRIP_DIMENSIONS,
 *     dimensions: Object
 * }
 */
export const SET_STAGE_FILMSTRIP_DIMENSIONS = 'SET_STAGE_FILMSTRIP_DIMENSIONS';

/**
 * The type of Redux action which adds a participant to the active list
 * (the participants displayed on the stage filmstrip).
 * {
 *     type: ADD_STAGE_PARTICIPANT,
 *     participantId: string,
 *     pinned: boolean
 * }
 */
export const ADD_STAGE_PARTICIPANT = 'ADD_STAGE_PARTICIPANT';

/**
 * The type of Redux action which removes a participant from the active list
 * (the participants displayed on the stage filmstrip).
 * {
 *     type: REMOVE_STAGE_PARTICIPANT,
 *     participantId: string,
 * }
 */
export const REMOVE_STAGE_PARTICIPANT = 'REMOVE_STAGE_PARTICIPANT';

/**
 * The type of Redux action which sets the active participants list
 * (the participants displayed on the stage filmstrip).
 * {
 *     type: SET_STAGE_PARTICIPANTS,
 *     queue: Array<Object>
 * }
 */
export const SET_STAGE_PARTICIPANTS = 'SET_STAGE_PARTICIPANTS';

/**
 * The type of Redux action which toggles the pin state of stage participants.
 * {
 *     type: TOGGLE_PIN_STAGE_PARTICIPANT,
 *     participantId: String
 * }
 */
export const TOGGLE_PIN_STAGE_PARTICIPANT = 'TOGGLE_PIN_STAGE_PARTICIPANT';

/**
 * The type of Redux action which clears the list of stage participants.
 * {
 *     type: CLEAR_STAGE_PARTICIPANTS
 * }
 */
export const CLEAR_STAGE_PARTICIPANTS = 'CLEAR_STAGE_PARTICIPANTS';

/**
 * The type of Redux action which sets the participant to be displayed
 * on the screenshare filmstrip.
 * {
 *     type: SET_SCREENSHARE_FILMSTRIP_PARTICIPANT,
 *     participantId: string|undefined
 * }
 */
export const SET_SCREENSHARE_FILMSTRIP_PARTICIPANT = 'SET_SCREENSHARE_FILMSTRIP_PARTICIPANT';

/**
 * The type of Redux action which sets the dimensions of the screenshare tile.
 * {
 *     type: SET_SCREENSHARING_TILE_DIMENSIONS
 * }
 */
export const SET_SCREENSHARING_TILE_DIMENSIONS = 'SET_SCREENSHARING_TILE_DIMENSIONS';

/**
 * The type of Redux action which sets the visibility of the top panel.
 * {
 *     type: SET_TOP_PANEL_VISIBILITY
 * }
 */
export const SET_TOP_PANEL_VISIBILITY = 'SET_TOP_PANEL_VISIBILITY';


################################################################################

## File: .\jitsi-meet\react\features\filmstrip\constants.ts

import { BoxModel } from '../base/styles/components/styles/BoxModel';

/**
 * The size (height and width) of the small (not tile view) thumbnails.
 */
export const SMALL_THUMBNAIL_SIZE = 80;

/**
 * The height of the filmstrip in narrow aspect ratio, or width in wide.
 */
export const FILMSTRIP_SIZE = SMALL_THUMBNAIL_SIZE + BoxModel.margin;

/**
 * The aspect ratio of a tile in tile view.
 */
export const TILE_ASPECT_RATIO = 16 / 9;

/**
 * The aspect ratio of a square tile in tile view.
 */
export const SQUARE_TILE_ASPECT_RATIO = 1;

/**
 * Width below which the overflow menu(s) will be displayed as drawer(s).
 */
export const DISPLAY_DRAWER_THRESHOLD = 512;

/**
 * Breakpoint past which the aspect ratio is switched in tile view.
 * Also, past this breakpoint, if there are two participants in the conference, we enforce
 * single column view.
 * If this is to be modified, please also change the related media query from the tile_view scss file.
 */
export const ASPECT_RATIO_BREAKPOINT = 500;

/**
 * Minimum height of tile for small screens.
 */
export const TILE_MIN_HEIGHT_SMALL = 150;

/**
 * Minimum height of tile for large screens.
 */
export const TILE_MIN_HEIGHT_LARGE = 200;

/**
 * Aspect ratio for portrait tiles.
 */
export const TILE_PORTRAIT_ASPECT_RATIO = 1 / 1.3;

/**
 * The default number of visible tiles for tile view.
 */
export const TILE_VIEW_DEFAULT_NUMBER_OF_VISIBLE_TILES = 25;

/**
 * The default number of columns for tile view.
 */
export const DEFAULT_MAX_COLUMNS = 5;

/**
 * An extended number of columns for tile view.
 */
export const ABSOLUTE_MAX_COLUMNS = 7;

/**
 * Display mode constant used when video is being displayed on the small video.
 *
 * @type {number}
 * @constant
 */
export const DISPLAY_VIDEO = 0;

/**
 * Display mode constant used when the user's avatar is being displayed on
 * the small video.
 *
 * @type {number}
 * @constant
 */
export const DISPLAY_AVATAR = 1;

/**
 * Maps the display modes to class name that will be applied on the thumbnail container.
 *
 * @type {Array<string>}
 * @constant
 */
export const DISPLAY_MODE_TO_CLASS_NAME = [
    'display-video',
    'display-avatar-only'
];

/**
 * The vertical margin of a tile.
 *
 * @type {number}
 */
export const TILE_VERTICAL_MARGIN = 4;

/**
 * The horizontal margin of a tile.
 *
 * @type {number}
 */
export const TILE_HORIZONTAL_MARGIN = 4;

/**
 * The horizontal margin of a vertical filmstrip tile container.
 *
 * @type {number}
 */
export const TILE_VERTICAL_CONTAINER_HORIZONTAL_MARGIN = 2;


/**
 * The vertical margin of the tile grid container.
 *
 * @type {number}
 */
export const TILE_VIEW_GRID_VERTICAL_MARGIN = 14;

/**
 * The horizontal margin of the tile grid container.
 *
 * @type {number}
 */
export const TILE_VIEW_GRID_HORIZONTAL_MARGIN = 14;

/**
 * The height of the whole toolbar.
 */
export const TOOLBAR_HEIGHT = 72;

/**
 * The height of the whole toolbar.
 */
export const TOOLBAR_HEIGHT_MOBILE = 60;

/**
 * The size of the horizontal border of a thumbnail.
 *
 * @type {number}
 */
export const STAGE_VIEW_THUMBNAIL_HORIZONTAL_BORDER = 4;

/**
 * The size of the vertical border of a thumbnail.
 *
 * @type {number}
 */
export const STAGE_VIEW_THUMBNAIL_VERTICAL_BORDER = 4;

/**
 * The size of the scroll.
 *
 * @type {number}
 */
export const SCROLL_SIZE = 7;

/**
 * The total vertical space between the thumbnails container and the edges of the window.
 *
 * NOTE: This will include margins, paddings and the space for the 'hide filmstrip' icon.
 *
 * @type {number}
 */
export const VERTICAL_FILMSTRIP_VERTICAL_MARGIN = 26;

/**
 * The min horizontal space between the thumbnails container and the edges of the window.
 *
 * @type {number}
 */
export const VERTICAL_FILMSTRIP_MIN_HORIZONTAL_MARGIN = 10;

/**
 * The total horizontal space between the thumbnails container and the edges of the window.
 *
 * NOTE: This will include margins, paddings and the space for the 'hide filmstrip' icon.
 *
 * @type {number}
 */
export const HORIZONTAL_FILMSTRIP_MARGIN = 39;

/**
 * Sets after how many ms to show the thumbnail context menu on long touch on mobile.
 *
 * @type {number}
 */
export const SHOW_TOOLBAR_CONTEXT_MENU_AFTER = 600;

/**
 * The margin for each side of the tile view. Taken away from the available
 * width for the tile container to display in.
 *
 * NOTE: Mobile specific.
 *
 * @private
 * @type {number}
 */
export const TILE_MARGIN = 10;

/**
 * The types of thumbnails for filmstrip.
 */
export const THUMBNAIL_TYPE = {
    TILE: 'TILE',
    VERTICAL: 'VERTICAL',
    HORIZONTAL: 'HORIZONTAL'
};

/**
 * The popover position for the connection stats table.
 */
export const STATS_POPOVER_POSITION = {
    [THUMBNAIL_TYPE.TILE]: 'right-start',
    [THUMBNAIL_TYPE.VERTICAL]: 'left-start',
    [THUMBNAIL_TYPE.HORIZONTAL]: 'top-end'
};

/**
 * The tooltip position for the indicators on the thumbnail.
 */
export const INDICATORS_TOOLTIP_POSITION: {
    [x: string]: 'right' | 'left' | 'top';
} = {
    [THUMBNAIL_TYPE.TILE]: 'right',
    [THUMBNAIL_TYPE.VERTICAL]: 'left',
    [THUMBNAIL_TYPE.HORIZONTAL]: 'top'
};

/**
 * The default (and minimum) width for the vertical filmstrip (user resizable).
 */
export const DEFAULT_FILMSTRIP_WIDTH = 120;

/**
 * The default aspect ratio for the local tile.
 */
export const DEFAULT_LOCAL_TILE_ASPECT_RATIO = 16 / 9;

/**
 * The width of the filmstrip at which it no longer goes above the stage view, but it pushes it.
 */
export const FILMSTRIP_BREAKPOINT = 180;

/**
 * The width of the filmstrip at which the display mode changes from column to grid.
 */
export const FILMSTRIP_GRID_BREAKPOINT = 300;

/**
 * How much before the breakpoint should we display the background.
 * (We display the opaque background before we resize the stage view to make sure
 * the resize is not visible behind the filmstrip).
 */
export const FILMSTRIP_BREAKPOINT_OFFSET = 5;

/**
 * The minimum height for the stage view
 * (used to determine the maximum height of the user-resizable top panel).
 */
export const MIN_STAGE_VIEW_HEIGHT = 700;

/**
 * The minimum width for the stage view
 * (used to determine the maximum width of the user-resizable vertical filmstrip).
 */
export const MIN_STAGE_VIEW_WIDTH = 800;

/**
 * Horizontal margin used for the vertical filmstrip.
 */
export const VERTICAL_VIEW_HORIZONTAL_MARGIN = VERTICAL_FILMSTRIP_MIN_HORIZONTAL_MARGIN
    + SCROLL_SIZE + TILE_HORIZONTAL_MARGIN + STAGE_VIEW_THUMBNAIL_HORIZONTAL_BORDER;

/**
 * The time after which a participant should be removed from active participants.
 */
export const ACTIVE_PARTICIPANT_TIMEOUT = 1000 * 60;

/**
 * The types of filmstrip.
 */
export const FILMSTRIP_TYPE = {
    MAIN: 'main',
    STAGE: 'stage',
    SCREENSHARE: 'screenshare'
};

/**
 * The max number of participants to be displayed on the stage filmstrip.
 */
export const MAX_ACTIVE_PARTICIPANTS = 6;

/**
 * Top filmstrip default height.
 */
export const TOP_FILMSTRIP_HEIGHT = 180;


################################################################################

## File: .\jitsi-meet\react\features\filmstrip\functions.any.ts

import { IReduxState, IStore } from '../app/types';
import {
    getActiveSpeakersToBeDisplayed,
    getVirtualScreenshareParticipantOwnerId
} from '../base/participants/functions';

import { setRemoteParticipants } from './actions';
import { isFilmstripScrollVisible } from './functions';

/**
 * Computes the reorderd list of the remote participants.
 *
 * @param {*} store - The redux store.
 * @param {boolean} force - Does not short circuit, the execution, make execute all checks.
 * @param {string} participantId - The endpoint id of the participant that joined the call.
 * @returns {void}
 * @private
 */
export function updateRemoteParticipants(store: IStore, force?: boolean, participantId?: string) {
    const state = store.getState();
    let reorderedParticipants = [];
    const { sortedRemoteVirtualScreenshareParticipants } = state['features/base/participants'];

    if (!isFilmstripScrollVisible(state) && !sortedRemoteVirtualScreenshareParticipants.size && !force) {
        if (participantId) {
            const { remoteParticipants } = state['features/filmstrip'];

            reorderedParticipants = [ ...remoteParticipants, participantId ];
            store.dispatch(setRemoteParticipants(Array.from(new Set(reorderedParticipants))));
        }

        return;
    }

    const {
        fakeParticipants,
        sortedRemoteParticipants
    } = state['features/base/participants'];
    const remoteParticipants = new Map(sortedRemoteParticipants);
    const screenShareParticipants = sortedRemoteVirtualScreenshareParticipants
        ? [ ...sortedRemoteVirtualScreenshareParticipants.keys() ] : [];
    const sharedVideos = fakeParticipants ? Array.from(fakeParticipants.keys()) : [];
    const speakers = getActiveSpeakersToBeDisplayed(state);

    for (const screenshare of screenShareParticipants) {
        const ownerId = getVirtualScreenshareParticipantOwnerId(screenshare);

        remoteParticipants.delete(ownerId);
        remoteParticipants.delete(screenshare);
        speakers.delete(ownerId);
    }

    for (const sharedVideo of sharedVideos) {
        remoteParticipants.delete(sharedVideo);
    }
    for (const speaker of speakers.keys()) {
        remoteParticipants.delete(speaker);
    }

    // Always update the order of the thumnails.
    const participantsWithScreenShare = screenShareParticipants.reduce<string[]>((acc, screenshare) => {
        const ownerId = getVirtualScreenshareParticipantOwnerId(screenshare);

        acc.push(ownerId);
        acc.push(screenshare);

        return acc;
    }, []);

    reorderedParticipants = [
        ...participantsWithScreenShare,
        ...sharedVideos,
        ...Array.from(speakers.keys()),
        ...Array.from(remoteParticipants.keys())
    ];

    store.dispatch(setRemoteParticipants(Array.from(new Set(reorderedParticipants))));
}

/**
 * Private helper to calculate the reordered list of remote participants when a participant leaves.
 *
 * @param {*} store - The redux store.
 * @param {string} participantId - The endpoint id of the participant leaving the call.
 * @returns {void}
 * @private
 */
export function updateRemoteParticipantsOnLeave(store: IStore, participantId: string | null = null) {
    if (!participantId) {
        return;
    }
    const state = store.getState();
    const { remoteParticipants } = state['features/filmstrip'];
    const reorderedParticipants = new Set(remoteParticipants);

    reorderedParticipants.delete(participantId)
        && store.dispatch(setRemoteParticipants(Array.from(reorderedParticipants)));
}

/**
 * Returns whether tileview is completely disabled.
 *
 * @param {IReduxState} state - Redux state.
 * @returns {boolean} - Whether tileview is completely disabled.
 */
export function isTileViewModeDisabled(state: IReduxState) {
    const { tileView = {} } = state['features/base/config'];

    return tileView.disabled;
}


################################################################################

## File: .\jitsi-meet\react\features\filmstrip\functions.native.ts

import { IReduxState } from '../app/types';
import { IStateful } from '../base/app/types';
import { FILMSTRIP_ENABLED } from '../base/flags/constants';
import { getFeatureFlag } from '../base/flags/functions';
import {
    getLocalParticipant,
    getParticipantCountWithFake,
    getPinnedParticipant
} from '../base/participants/functions';
import Platform from '../base/react/Platform.native';
import { toState } from '../base/redux/functions';
import { ASPECT_RATIO_NARROW } from '../base/responsive-ui/constants';
import { getHideSelfView } from '../base/settings/functions.any';
import conferenceStyles from '../conference/components/native/styles';
import { shouldDisplayTileView } from '../video-layout/functions.native';

import styles from './components/native/styles';

export * from './functions.any';

/**
 * Returns true if the filmstrip on mobile is visible, false otherwise.
 *
 * NOTE: Filmstrip on mobile behaves differently to web, and is only visible
 * when there are at least 2 participants.
 *
 * @param {Object | Function} stateful - The Object or Function that can be
 * resolved to a Redux state object with the toState function.
 * @returns {boolean}
 */
export function isFilmstripVisible(stateful: IStateful) {
    const state = toState(stateful);

    const enabled = getFeatureFlag(state, FILMSTRIP_ENABLED, true);

    if (!enabled) {
        return false;
    }

    return getParticipantCountWithFake(state) > 1;
}

/**
 * Determines whether the remote video thumbnails should be displayed/visible in
 * the filmstrip.
 *
 * @param {Object} state - The full redux state.
 * @returns {boolean} - If remote video thumbnails should be displayed/visible
 * in the filmstrip, then {@code true}; otherwise, {@code false}.
 */
export function shouldRemoteVideosBeVisible(state: IReduxState) {
    if (state['features/invite'].calleeInfoVisible) {
        return false;
    }

    // Include fake participants to derive how many thumbnails are displayed,
    // as it is assumed all participants, including fake, will be displayed
    // in the filmstrip.
    const participantCount = getParticipantCountWithFake(state);
    const pinnedParticipant = getPinnedParticipant(state);
    const { disable1On1Mode } = state['features/base/config'];

    return Boolean(
        participantCount > 2

            // Always show the filmstrip when there is another participant to
            // show and the local video is pinned. Note we are not taking the
            // toolbar visibility into account here (unlike web) because
            // showing / hiding views in quick succession on mobile is taxing.
            || (participantCount > 1 && pinnedParticipant?.local)

            || disable1On1Mode);
}

/**
 * Not implemented on mobile.
 *
 * @param {any} _state - Used on web.
 * @returns {Array<string>}
 */
export function getActiveParticipantsIds(_state: any) {
    return [];
}

/**
 * Not implemented on mobile.
 *
 * @param {any} _state - Redux state.
 * @returns {Array<Object>}
 */
export function getPinnedActiveParticipants(_state: any) {
    return [];
}

/**
 * Returns the number of participants displayed in tile view.
 *
 * @param {Object | Function} stateful - The Object or Function that can be
 * resolved to a Redux state object with the toState function.
 * @returns {number} - The number of participants displayed in tile view.
 */
export function getTileViewParticipantCount(stateful: IStateful) {
    const state = toState(stateful);
    const disableSelfView = getHideSelfView(state);
    const localParticipant = getLocalParticipant(state);
    const participantCount = getParticipantCountWithFake(state) - (disableSelfView && localParticipant ? 1 : 0);

    return participantCount;
}

/**
 * Returns how many columns should be displayed for tile view.
 *
 * @param {Object | Function} stateful - The Object or Function that can be
 * resolved to a Redux state object with the toState function.
 * @returns {number} - The number of columns to be rendered in tile view.
 * @private
 */
export function getColumnCount(stateful: IStateful) {
    const state = toState(stateful);
    const participantCount = getTileViewParticipantCount(state);
    const { aspectRatio } = state['features/base/responsive-ui'];

    // For narrow view, tiles should stack on top of each other for a lonely
    // call and a 1:1 call. Otherwise tiles should be grouped into rows of
    // two.
    if (aspectRatio === ASPECT_RATIO_NARROW) {
        return participantCount >= 3 ? 2 : 1;
    }

    if (participantCount === 4) {
        // In wide view, a four person call should display as a 2x2 grid.
        return 2;
    }

    return Math.min(participantCount <= 6 ? 3 : 4, participantCount);
}

/**
 * Returns true if the filmstrip has a scroll and false otherwise.
 *
 * @param {Object} state - The redux state.
 * @returns {boolean} - True if the scroll is displayed and false otherwise.
 */
export function isFilmstripScrollVisible(state: IReduxState) {
    if (shouldDisplayTileView(state)) {
        return state['features/filmstrip']?.tileViewDimensions?.hasScroll;
    }

    const { aspectRatio, clientWidth, clientHeight, safeAreaInsets = {} } = state['features/base/responsive-ui'];
    const isNarrowAspectRatio = aspectRatio === ASPECT_RATIO_NARROW;
    const disableSelfView = getHideSelfView(state);
    const localParticipant = Boolean(getLocalParticipant(state));
    const localParticipantVisible = localParticipant && !disableSelfView;
    const participantCount
        = getParticipantCountWithFake(state)
            - (localParticipant && (shouldDisplayLocalThumbnailSeparately() || disableSelfView) ? 1 : 0);
    const { height: thumbnailHeight, width: thumbnailWidth, margin } = styles.thumbnail;
    const { height, width } = getFilmstripDimensions({
        aspectRatio,
        clientWidth,
        clientHeight,
        insets: safeAreaInsets,
        localParticipantVisible
    });

    if (isNarrowAspectRatio) {
        return width < (thumbnailWidth + (2 * margin)) * participantCount;
    }

    return height < (thumbnailHeight + (2 * margin)) * participantCount;
}

/**
 * Whether the stage filmstrip is available or not.
 *
 * @param {any} _state - Used on web.
 * @param {any} _count - Used on web.
 * @returns {boolean}
 */
export function isStageFilmstripAvailable(_state: any, _count?: any) {
    return false;
}

/**
 * Whether the stage filmstrip is enabled.
 *
 * @param {any} _state - Used on web.
 * @returns {boolean}
 */
export function isStageFilmstripEnabled(_state: any) {
    return false;
}

/**
 * Whether or not the top panel is enabled.
 *
 * @param {any} _state - Used on web.
 * @returns {boolean}
 */
export function isTopPanelEnabled(_state: any) {
    return false;

}

/**
 * Calculates the width and height of the filmstrip based on the screen size and aspect ratio.
 *
 * @param {Object} options - The screen aspect ratio, width, height and safe are insets.
 * @returns {Object} - The width and the height.
 */
export function getFilmstripDimensions({
    aspectRatio,
    clientWidth,
    clientHeight,
    insets = {},
    localParticipantVisible = true
}: {
    aspectRatio: Symbol;
    clientHeight: number;
    clientWidth: number;
    insets?: {
        bottom?: number;
        left?: number;
        right?: number;
        top?: number;
    };
    localParticipantVisible?: boolean;
}) {
    const { height, width, margin } = styles.thumbnail; // @ts-ignore
    const conferenceBorder = conferenceStyles.conference.borderWidth || 0;
    const { left = 0, right = 0, top = 0, bottom = 0 } = insets;

    if (aspectRatio === ASPECT_RATIO_NARROW) {
        return {
            height,
            width:
                (shouldDisplayLocalThumbnailSeparately() && localParticipantVisible
                    ? clientWidth - width - (margin * 2) : clientWidth)
                    - left - right - (styles.filmstripNarrow.margin * 2) - (conferenceBorder * 2)

        };
    }

    return {
        height:
            (shouldDisplayLocalThumbnailSeparately() && localParticipantVisible
                ? clientHeight - height - (margin * 2) : clientHeight)
                - top - bottom - (conferenceBorder * 2),
        width
    };
}

/**
 * Returns true if the local thumbnail should be displayed separately and false otherwise.
 *
 * @returns {boolean} - True if the local thumbnail should be displayed separately and flase otherwise.
 */
export function shouldDisplayLocalThumbnailSeparately() {
    // XXX Our current design is to have the local participant separate from
    // the remote participants. Unfortunately, Android's Video
    // implementation cannot accommodate that because remote participants'
    // videos appear on top of the local participant's video at times.
    // That's because Android's Video utilizes EGL and EGL gives us only two
    // practical layers in which we can place our participants' videos:
    // layer #0 sits behind the window, creates a hole in the window, and
    // there we render the LargeVideo; layer #1 is known as media overlay in
    // EGL terms, renders on top of layer #0, and, consequently, is for the
    // Filmstrip. With the separate LocalThumbnail, we should have left the
    // remote participants' Thumbnails in layer #1 and utilized layer #2 for
    // LocalThumbnail. Unfortunately, layer #2 is not practical (that's why
    // I said we had two practical layers only) because it renders on top of
    // everything which in our case means on top of participant-related
    // indicators such as moderator, audio and video muted, etc. For now we
    // do not have much of a choice but to continue rendering LocalThumbnail
    // as any other remote Thumbnail on Android.
    return Platform.OS !== 'android';
}

/**
 * Not implemented on mobile.
 *
 * @param {any} _state - Used on web.
 * @returns {undefined}
 */
export function getScreenshareFilmstripParticipantId(_state: any) {
    return undefined;
}




################################################################################

## File: .\jitsi-meet\react\features\filmstrip\functions.web.ts

import { IReduxState } from '../app/types';
import { IStateful } from '../base/app/types';
import { isMobileBrowser } from '../base/environment/utils';
import { MEDIA_TYPE } from '../base/media/constants';
import {
    getLocalParticipant,
    getParticipantById,
    getParticipantCount,
    getParticipantCountWithFake,
    getPinnedParticipant,
    isScreenShareParticipant
} from '../base/participants/functions';
import { toState } from '../base/redux/functions';
import { getHideSelfView } from '../base/settings/functions.any';
import {
    getVideoTrackByParticipant,
    isLocalTrackMuted,
    isRemoteTrackMuted
} from '../base/tracks/functions';
import { isTrackStreamingStatusActive } from '../connection-indicator/functions';
import { isSharingStatus } from '../shared-video/functions';
import { LAYOUTS } from '../video-layout/constants';
import { getCurrentLayout, getNotResponsiveTileViewGridDimensions } from '../video-layout/functions.web';

import {
    ASPECT_RATIO_BREAKPOINT,
    DEFAULT_FILMSTRIP_WIDTH,
    DEFAULT_LOCAL_TILE_ASPECT_RATIO,
    DISPLAY_AVATAR,
    DISPLAY_VIDEO,
    FILMSTRIP_GRID_BREAKPOINT,
    FILMSTRIP_TYPE,
    INDICATORS_TOOLTIP_POSITION,
    SCROLL_SIZE,
    SQUARE_TILE_ASPECT_RATIO,
    THUMBNAIL_TYPE,
    TILE_ASPECT_RATIO,
    TILE_HORIZONTAL_MARGIN,
    TILE_MIN_HEIGHT_LARGE,
    TILE_MIN_HEIGHT_SMALL,
    TILE_PORTRAIT_ASPECT_RATIO,
    TILE_VERTICAL_MARGIN,
    TILE_VIEW_DEFAULT_NUMBER_OF_VISIBLE_TILES,
    TILE_VIEW_GRID_HORIZONTAL_MARGIN,
    TILE_VIEW_GRID_VERTICAL_MARGIN,
    VERTICAL_VIEW_HORIZONTAL_MARGIN
} from './constants';

export * from './functions.any';

/**
 * Returns true if the filmstrip on mobile is visible, false otherwise.
 *
 * NOTE: Filmstrip on web behaves differently to mobile, much simpler, but so
 * function lies here only for the sake of consistency and to avoid flow errors
 * on import.
 *
 * @param {IStateful} stateful - The Object or Function that can be
 * resolved to a Redux state object with the toState function.
 * @returns {boolean}
 */
export function isFilmstripVisible(stateful: IStateful) {
    return toState(stateful)['features/filmstrip'].visible;
}

/**
 * Determines whether the remote video thumbnails should be displayed/visible in
 * the filmstrip.
 *
 * @param {IReduxState} state - The full redux state.
 * @returns {boolean} - If remote video thumbnails should be displayed/visible
 * in the filmstrip, then {@code true}; otherwise, {@code false}.
 */
export function shouldRemoteVideosBeVisible(state: IReduxState) {
    if (state['features/invite'].calleeInfoVisible) {
        return false;
    }

    // Include fake participants to derive how many thumbnails are displayed,
    // as it is assumed all participants, including fake, will be displayed
    // in the filmstrip.
    const participantCount = getParticipantCountWithFake(state);
    let pinnedParticipant;
    const { disable1On1Mode } = state['features/base/config'];
    const { contextMenuOpened } = state['features/base/responsive-ui'];

    return Boolean(
        contextMenuOpened
            || participantCount > 2

            // Always show the filmstrip when there is another participant to
            // show and the  local video is pinned, or the toolbar is displayed.
            || (participantCount > 1
                && disable1On1Mode !== null
                && (state['features/toolbox'].visible
                    || ((pinnedParticipant = getPinnedParticipant(state))
                        && pinnedParticipant.local)))

            || disable1On1Mode);
}

/**
 * Checks whether there is a playable video stream available for the user associated with the passed ID.
 *
 * @param {IStateful} stateful - The Object or Function that can be
 * resolved to a Redux state object with the toState function.
 * @param {string} id - The id of the participant.
 * @returns {boolean} <tt>true</tt> if there is a playable video stream available
 * or <tt>false</tt> otherwise.
 */
export function isVideoPlayable(stateful: IStateful, id: string) {
    const state = toState(stateful);
    const tracks = state['features/base/tracks'];
    const participant = id ? getParticipantById(state, id) : getLocalParticipant(state);
    const isLocal = participant?.local ?? true;
    const videoTrack = getVideoTrackByParticipant(state, participant);
    const isAudioOnly = Boolean(state['features/base/audio-only'].enabled);
    let isPlayable = false;

    if (isLocal) {
        const isVideoMuted = isLocalTrackMuted(tracks, MEDIA_TYPE.VIDEO);

        isPlayable = Boolean(videoTrack) && !isVideoMuted && !isAudioOnly;
    } else if (!participant?.fakeParticipant || isScreenShareParticipant(participant)) {
        // remote participants excluding shared video
        const isVideoMuted = isRemoteTrackMuted(tracks, MEDIA_TYPE.VIDEO, id);

        isPlayable = Boolean(videoTrack) && !isVideoMuted && !isAudioOnly && isTrackStreamingStatusActive(videoTrack);
    }

    return isPlayable;
}

/**
 * Calculates the size for thumbnails when in horizontal view layout.
 *
 * @param {number} clientHeight - The height of the app window.
 * @returns {{local: {height, width}, remote: {height, width}}}
 */
export function calculateThumbnailSizeForHorizontalView(clientHeight = 0) {
    const topBottomMargin = 15;
    const availableHeight = Math.min(clientHeight,
        (interfaceConfig.FILM_STRIP_MAX_HEIGHT || DEFAULT_FILMSTRIP_WIDTH) + topBottomMargin);
    const height = availableHeight - topBottomMargin;

    return {
        local: {
            height,
            width: Math.floor(interfaceConfig.LOCAL_THUMBNAIL_RATIO * height)
        },
        remote: {
            height,
            width: Math.floor(interfaceConfig.REMOTE_THUMBNAIL_RATIO * height)
        }
    };
}

/**
 * Calculates the size for thumbnails when in vertical view layout.
 *
 * @param {number} clientWidth - The height of the app window.
 * @param {number} filmstripWidth - The width of the filmstrip.
 * @param {boolean} isResizable - Whether the filmstrip is resizable or not.
 * @returns {{local: {height, width}, remote: {height, width}}}
 */
export function calculateThumbnailSizeForVerticalView(clientWidth = 0, filmstripWidth = 0, isResizable = false) {
    const availableWidth = Math.min(
        Math.max(clientWidth - VERTICAL_VIEW_HORIZONTAL_MARGIN, 0),
        (isResizable ? filmstripWidth : interfaceConfig.FILM_STRIP_MAX_HEIGHT) || DEFAULT_FILMSTRIP_WIDTH);

    return {
        local: {
            height: Math.floor(availableWidth
                / (interfaceConfig.LOCAL_THUMBNAIL_RATIO || DEFAULT_LOCAL_TILE_ASPECT_RATIO)),
            width: availableWidth
        },
        remote: {
            height: isResizable
                ? DEFAULT_FILMSTRIP_WIDTH
                : Math.floor(availableWidth / interfaceConfig.REMOTE_THUMBNAIL_RATIO),
            width: availableWidth
        }
    };
}

/**
 * Returns the minimum height of a thumbnail.
 *
 * @param {number} clientWidth - The width of the window.
 * @returns {number} The minimum height of a thumbnail.
 */
export function getThumbnailMinHeight(clientWidth: number) {
    return clientWidth < ASPECT_RATIO_BREAKPOINT ? TILE_MIN_HEIGHT_SMALL : TILE_MIN_HEIGHT_LARGE;
}

/**
 * Returns the default aspect ratio for a tile.
 *
 * @param {boolean} disableResponsiveTiles - Indicates whether the responsive tiles functionality is disabled.
 * @param {boolean} disableTileEnlargement - Indicates whether the tiles enlargement functionality is disabled.
 * @param {number} clientWidth - The width of the window.
 * @returns {number} The default aspect ratio for a tile.
 */
export function getTileDefaultAspectRatio(disableResponsiveTiles: boolean,
        disableTileEnlargement: boolean, clientWidth: number) {
    if (!disableResponsiveTiles && disableTileEnlargement && clientWidth < ASPECT_RATIO_BREAKPOINT) {
        return SQUARE_TILE_ASPECT_RATIO;
    }

    return TILE_ASPECT_RATIO;
}

/**
 * Returns the number of participants that will be displayed in tile view.
 *
 * @param {Object} state - The redux store state.
 * @returns {number} The number of participants that will be displayed in tile view.
 */
export function getNumberOfPartipantsForTileView(state: IReduxState) {
    const { iAmRecorder } = state['features/base/config'];
    const disableSelfView = getHideSelfView(state);
    const { localScreenShare } = state['features/base/participants'];
    const localParticipantsCount = localScreenShare ? 2 : 1;
    const numberOfParticipants = getParticipantCountWithFake(state)
        - (iAmRecorder ? 1 : 0)
        - (disableSelfView ? localParticipantsCount : 0);

    return numberOfParticipants;
}

/**
 * Calculates the dimensions (thumbnail width/height and columns/row) for tile view when the responsive tiles are
 * disabled.
 *
 * @param {Object} state - The redux store state.
 * @returns {Object} - The dimensions.
 */
export function calculateNonResponsiveTileViewDimensions(state: IReduxState) {
    const { clientHeight, clientWidth } = state['features/base/responsive-ui'];
    const { disableTileEnlargement } = state['features/base/config'];
    const { columns: c, minVisibleRows, rows: r } = getNotResponsiveTileViewGridDimensions(state);
    const size = calculateThumbnailSizeForTileView({
        columns: c,
        minVisibleRows,
        clientWidth,
        clientHeight,
        disableTileEnlargement,
        disableResponsiveTiles: true
    });

    if (typeof size === 'undefined') { // The columns don't fit into the screen. We will have horizontal scroll.
        const aspectRatio = disableTileEnlargement
            ? getTileDefaultAspectRatio(true, disableTileEnlargement, clientWidth)
            : TILE_PORTRAIT_ASPECT_RATIO;

        const height = getThumbnailMinHeight(clientWidth);

        return {
            height,
            width: aspectRatio * height,
            columns: c,
            rows: r
        };
    }

    return {
        height: size.height,
        width: size.width,
        columns: c,
        rows: r
    };
}

/**
 * Calculates the dimensions (thumbnail width/height and columns/row) for tile view when the responsive tiles are
 * enabled.
 *
 * @param {Object} state - The redux store state.
 * @returns {Object} - The dimensions.
 */
export function calculateResponsiveTileViewDimensions({
    clientWidth,
    clientHeight,
    disableTileEnlargement = false,
    noHorizontalContainerMargin = false,
    maxColumns,
    numberOfParticipants,
    desiredNumberOfVisibleTiles = TILE_VIEW_DEFAULT_NUMBER_OF_VISIBLE_TILES,
    minTileHeight
}: {
    clientHeight: number;
    clientWidth: number;
    desiredNumberOfVisibleTiles: number;
    disableTileEnlargement?: boolean;
    maxColumns: number;
    minTileHeight?: number | null;
    noHorizontalContainerMargin?: boolean;
    numberOfParticipants: number;
}) {
    let height, width;
    let columns, rows;

    interface IDimensions {
        columns?: number;
        height?: number;
        maxArea: number;
        numberOfVisibleParticipants?: number;
        rows?: number;
        width?: number;
    }

    let dimensions: IDimensions = {
        maxArea: 0
    };
    let minHeightEnforcedDimensions: IDimensions = {
        maxArea: 0
    };
    let zeroVisibleRowsDimensions: IDimensions = {
        maxArea: 0
    };

    for (let c = 1; c <= Math.min(maxColumns, numberOfParticipants, desiredNumberOfVisibleTiles); c++) {
        const r = Math.ceil(numberOfParticipants / c);

        // we want to display as much as possible tumbnails up to desiredNumberOfVisibleTiles
        const visibleRows
            = numberOfParticipants <= desiredNumberOfVisibleTiles ? r : Math.floor(desiredNumberOfVisibleTiles / c);

        const size = calculateThumbnailSizeForTileView({
            columns: c,
            minVisibleRows: visibleRows,
            clientWidth,
            clientHeight,
            disableTileEnlargement,
            disableResponsiveTiles: false,
            noHorizontalContainerMargin,
            minTileHeight
        });

        if (size) {
            const { height: currentHeight, width: currentWidth, minHeightEnforced, maxVisibleRows } = size;
            const numberOfVisibleParticipants = Math.min(c * maxVisibleRows, numberOfParticipants);

            let area = Math.round(
                (currentHeight + TILE_VERTICAL_MARGIN)
                * (currentWidth + TILE_HORIZONTAL_MARGIN)
                * numberOfVisibleParticipants);

            const currentDimensions = {
                maxArea: area,
                height: currentHeight,
                width: currentWidth,
                columns: c,
                rows: r,
                numberOfVisibleParticipants
            };
            const { numberOfVisibleParticipants: oldNumberOfVisibleParticipants = 0 } = dimensions;

            if (!minHeightEnforced) {
                if (area > dimensions.maxArea) {
                    dimensions = currentDimensions;
                } else if ((area === dimensions.maxArea)
                    && ((oldNumberOfVisibleParticipants > desiredNumberOfVisibleTiles
                            && oldNumberOfVisibleParticipants >= numberOfParticipants)
                        || (oldNumberOfVisibleParticipants < numberOfParticipants
                            && numberOfVisibleParticipants <= desiredNumberOfVisibleTiles))
                ) { // If the area of the new candidates and the old ones are equal we prefer the one that will have
                    // closer number of visible participants to desiredNumberOfVisibleTiles config.
                    dimensions = currentDimensions;
                }
            } else if (minHeightEnforced && area >= minHeightEnforcedDimensions.maxArea) {
                // If we choose configuration with minHeightEnforced there will be less than desiredNumberOfVisibleTiles
                // visible tiles, that's why we prefer more columns when the area is the same.
                minHeightEnforcedDimensions = currentDimensions;
            } else if (minHeightEnforced && maxVisibleRows === 0) {
                area = currentHeight * currentWidth * Math.min(c, numberOfParticipants);

                if (area > zeroVisibleRowsDimensions.maxArea) {
                    zeroVisibleRowsDimensions = {
                        ...currentDimensions,
                        maxArea: area
                    };
                }
            }
        }
    }

    if (dimensions.maxArea > 0) {
        ({ height, width, columns, rows } = dimensions);
    } else if (minHeightEnforcedDimensions.maxArea > 0) {
        ({ height, width, columns, rows } = minHeightEnforcedDimensions);
    } else if (zeroVisibleRowsDimensions.maxArea > 0) {
        ({ height, width, columns, rows } = zeroVisibleRowsDimensions);
    } else { // This would mean that we can't fit even one thumbnail with minimal size.
        const aspectRatio = disableTileEnlargement
            ? getTileDefaultAspectRatio(false, disableTileEnlargement, clientWidth)
            : TILE_PORTRAIT_ASPECT_RATIO;

        height = getThumbnailMinHeight(clientWidth);
        width = aspectRatio * height;
        columns = 1;
        rows = numberOfParticipants;
    }

    return {
        height,
        width,
        columns,
        rows
    };
}

/**
 * Calculates the size for thumbnails when in tile view layout.
 *
 * @param {Object} dimensions - The desired dimensions of the tile view grid.
 * @returns {{hasScroll, height, width}}
 */
export function calculateThumbnailSizeForTileView({
    columns,
    minVisibleRows,
    clientWidth,
    clientHeight,
    disableResponsiveTiles = false,
    disableTileEnlargement = false,
    noHorizontalContainerMargin = false,
    minTileHeight
}: {
    clientHeight: number;
    clientWidth: number;
    columns: number;
    disableResponsiveTiles: boolean;
    disableTileEnlargement?: boolean;
    minTileHeight?: number | null;
    minVisibleRows: number;
    noHorizontalContainerMargin?: boolean;
}) {
    const aspectRatio = getTileDefaultAspectRatio(disableResponsiveTiles, disableTileEnlargement, clientWidth);
    const minHeight = minTileHeight || getThumbnailMinHeight(clientWidth);
    const viewWidth = clientWidth - (columns * TILE_HORIZONTAL_MARGIN)
        - (noHorizontalContainerMargin ? SCROLL_SIZE : TILE_VIEW_GRID_HORIZONTAL_MARGIN);
    const availableHeight = clientHeight - TILE_VIEW_GRID_VERTICAL_MARGIN;
    const viewHeight = availableHeight - (minVisibleRows * TILE_VERTICAL_MARGIN);
    const initialWidth = viewWidth / columns;
    let initialHeight = viewHeight / minVisibleRows;
    let minHeightEnforced = false;

    if (initialHeight < minHeight) {
        minHeightEnforced = true;
        initialHeight = minHeight;
    }

    if (disableTileEnlargement) {
        const aspectRatioHeight = initialWidth / aspectRatio;

        if (aspectRatioHeight < minHeight) { // we can't fit the required number of columns.
            return;
        }

        const height = Math.min(aspectRatioHeight, initialHeight);

        return {
            height,
            width: aspectRatio * height,
            minHeightEnforced,
            maxVisibleRows: Math.floor(availableHeight / (height + TILE_VERTICAL_MARGIN))
        };
    }

    const initialRatio = initialWidth / initialHeight;
    let height = initialHeight;
    let width;

    // The biggest area of the grid will be when the grid's height is equal to clientHeight or when the grid's width is
    // equal to clientWidth.

    if (initialRatio > aspectRatio) {
        width = initialHeight * aspectRatio;
    } else if (initialRatio >= TILE_PORTRAIT_ASPECT_RATIO) {
        width = initialWidth;
    // eslint-disable-next-line no-negated-condition
    } else if (!minHeightEnforced) {
        height = initialWidth / TILE_PORTRAIT_ASPECT_RATIO;

        if (height >= minHeight) {
            width = initialWidth;
        } else { // The width is so small that we can't reach the minimum height with portrait aspect ratio.
            return;
        }
    } else {
        // We can't fit that number of columns with the desired min height and aspect ratio.
        return;
    }

    return {
        height,
        width,
        minHeightEnforced,
        maxVisibleRows: Math.floor(availableHeight / (height + TILE_VERTICAL_MARGIN))
    };
}

/**
 * Returns the width of the visible area (doesn't include the left margin/padding) of the the vertical filmstrip.
 *
 * @returns {number} - The width of the vertical filmstrip.
 */
export function getVerticalFilmstripVisibleAreaWidth() {
    // Adding 11px for the 2px right margin, 2px borders on the left and right and 5px right padding.
    // Also adding 7px for the scrollbar. Note that we are not counting the left margins and paddings because this
    // function is used for calculating the available space and they are invisible.
    // TODO: Check if we can remove the left margins and paddings from the CSS.
    // FIXME: This function is used to calculate the size of the large video, etherpad or shared video. Once everything
    // is reactified this calculation will need to move to the corresponding components.
    const filmstripMaxWidth = (interfaceConfig.FILM_STRIP_MAX_HEIGHT || DEFAULT_FILMSTRIP_WIDTH) + 18;

    return Math.min(filmstripMaxWidth, window.innerWidth);
}

/**
 * Computes information that determine the display mode.
 *
 * @param {Object} input - Object containing all necessary information for determining the display mode for
 * the thumbnail.
 * @returns {number} - One of <tt>DISPLAY_VIDEO</tt> or <tt>DISPLAY_AVATAR</tt>.
*/
export function computeDisplayModeFromInput(input: any) {
    const {
        filmstripType,
        isActiveParticipant,
        isAudioOnly,
        isCurrentlyOnLargeVideo,
        isVirtualScreenshareParticipant,
        isScreenSharing,
        canPlayEventReceived,
        isRemoteParticipant,
        stageParticipantsVisible,
        tileViewActive
    } = input;
    const adjustedIsVideoPlayable = input.isVideoPlayable && (!isRemoteParticipant || canPlayEventReceived);

    // Display video for virtual screen share participants in all layouts.
    if (isVirtualScreenshareParticipant) {
        return DISPLAY_VIDEO;
    }

    // Multi-stream is not supported on plan-b endpoints even if its is enabled via config.js. A virtual
    // screenshare tile is still created when a remote endpoint starts screenshare to keep the behavior consistent
    // and an avatar is displayed on the original participant thumbnail as long as screenshare is in progress.
    if (isScreenSharing) {
        return DISPLAY_AVATAR;
    }

    if (!tileViewActive && filmstripType === FILMSTRIP_TYPE.MAIN && ((isScreenSharing && isRemoteParticipant)
        || (stageParticipantsVisible && isActiveParticipant))) {
        return DISPLAY_AVATAR;
    } else if (isCurrentlyOnLargeVideo && !tileViewActive) {
        // Display name is always and only displayed when user is on the stage
        return adjustedIsVideoPlayable && !isAudioOnly ? DISPLAY_VIDEO : DISPLAY_AVATAR;
    } else if (adjustedIsVideoPlayable && !isAudioOnly) {
        // check hovering and change state to video with name
        return DISPLAY_VIDEO;
    }

    // check hovering and change state to avatar with name
    return DISPLAY_AVATAR;
}

/**
 * Extracts information for props and state needed to compute the display mode.
 *
 * @param {Object} props - The Thumbnail component's props.
 * @param {Object} state - The Thumbnail component's state.
 * @returns {Object}
*/
export function getDisplayModeInput(props: any, state: { canPlayEventReceived: boolean; }) {
    const {
        _currentLayout,
        _isActiveParticipant,
        _isAudioOnly,
        _isCurrentlyOnLargeVideo,
        _isVirtualScreenshareParticipant,
        _isScreenSharing,
        _isVideoPlayable,
        _participant,
        _stageParticipantsVisible,
        _videoTrack,
        filmstripType = FILMSTRIP_TYPE.MAIN
    } = props;
    const tileViewActive = _currentLayout === LAYOUTS.TILE_VIEW;
    const { canPlayEventReceived } = state;

    return {
        filmstripType,
        isActiveParticipant: _isActiveParticipant,
        isCurrentlyOnLargeVideo: _isCurrentlyOnLargeVideo,
        isAudioOnly: _isAudioOnly,
        tileViewActive,
        isVideoPlayable: _isVideoPlayable,
        canPlayEventReceived,
        videoStream: Boolean(_videoTrack),
        isRemoteParticipant: !_participant?.fakeParticipant && !_participant?.local,
        isScreenSharing: _isScreenSharing,
        isVirtualScreenshareParticipant: _isVirtualScreenshareParticipant,
        stageParticipantsVisible: _stageParticipantsVisible,
        videoStreamMuted: _videoTrack ? _videoTrack.muted : 'no stream'
    };
}

/**
 * Gets the tooltip position for the thumbnail indicators.
 *
 * @param {string} thumbnailType - The current thumbnail type.
 * @returns {string}
 */
export function getIndicatorsTooltipPosition(thumbnailType?: string) {
    return INDICATORS_TOOLTIP_POSITION[thumbnailType ?? ''] || 'top';
}

/**
 * Returns whether or not the filmstrip is resizable.
 *
 * @param {Object} state - Redux state.
 * @returns {boolean}
 */
export function isFilmstripResizable(state: IReduxState) {
    const { filmstrip } = state['features/base/config'];
    const _currentLayout = getCurrentLayout(state);

    return !filmstrip?.disableResizable && !isMobileBrowser()
        && (_currentLayout === LAYOUTS.VERTICAL_FILMSTRIP_VIEW || _currentLayout === LAYOUTS.STAGE_FILMSTRIP_VIEW);
}

/**
 * Whether or not grid should be displayed in the vertical filmstrip.
 *
 * @param {Object} state - Redux state.
 * @returns {boolean}
 */
export function showGridInVerticalView(state: IReduxState) {
    const resizableFilmstrip = isFilmstripResizable(state);
    const { width } = state['features/filmstrip'];

    return resizableFilmstrip && ((width.current ?? 0) > FILMSTRIP_GRID_BREAKPOINT);
}

/**
 * Gets the vertical filmstrip max width.
 *
 * @param {Object} state - Redux state.
 * @returns {number}
 */
export function getVerticalViewMaxWidth(state: IReduxState) {
    const { width } = state['features/filmstrip'];
    const _resizableFilmstrip = isFilmstripResizable(state);
    const _verticalViewGrid = showGridInVerticalView(state);
    let maxWidth = _resizableFilmstrip
        ? width.current || DEFAULT_FILMSTRIP_WIDTH
        : interfaceConfig.FILM_STRIP_MAX_HEIGHT || DEFAULT_FILMSTRIP_WIDTH;

    // Adding 4px for the border-right and margin-right.
    // On non-resizable filmstrip add 4px for the left margin and border.
    // Also adding 7px for the scrollbar. Also adding 9px for the drag handle.
    maxWidth += (_verticalViewGrid ? 0 : 11) + (_resizableFilmstrip ? 9 : 4);

    return maxWidth;
}

/**
 * Returns true if the scroll is displayed and false otherwise.
 *
 * @param {Object} state - The redux state.
 * @returns {boolean} - True if the scroll is displayed and false otherwise.
 */
export function isFilmstripScrollVisible(state: IReduxState) {
    const _currentLayout = getCurrentLayout(state);
    let hasScroll = false;

    switch (_currentLayout) {
    case LAYOUTS.TILE_VIEW:
        ({ hasScroll = false } = state['features/filmstrip'].tileViewDimensions ?? {});
        break;
    case LAYOUTS.VERTICAL_FILMSTRIP_VIEW:
    case LAYOUTS.STAGE_FILMSTRIP_VIEW: {
        ({ hasScroll = false } = state['features/filmstrip'].verticalViewDimensions);
        break;
    }
    case LAYOUTS.HORIZONTAL_FILMSTRIP_VIEW: {
        ({ hasScroll = false } = state['features/filmstrip'].horizontalViewDimensions);
        break;
    }
    }

    return hasScroll;
}

/**
 * Gets the ids of the active participants.
 *
 * @param {Object} state - Redux state.
 * @returns {Array<string>}
 */
export function getActiveParticipantsIds(state: IReduxState) {
    const { activeParticipants } = state['features/filmstrip'];

    return activeParticipants.map(p => p.participantId);
}

/**
 * Gets the ids of the active participants.
 *
 * @param {Object} state - Redux state.
 * @returns {Array<Object>}
 */
export function getPinnedActiveParticipants(state: IReduxState) {
    const { activeParticipants } = state['features/filmstrip'];

    return activeParticipants.filter(p => p.pinned);
}

/**
 * Get whether or not the stage filmstrip is available (enabled & can be used).
 *
 * @param {Object} state - Redux state.
 * @param {number} minParticipantCount - The min number of participants for the stage filmstrip
 * to be displayed.
 * @returns {boolean}
 */
export function isStageFilmstripAvailable(state: IReduxState, minParticipantCount = 0) {
    const { activeParticipants } = state['features/filmstrip'];
    const { remoteScreenShares } = state['features/video-layout'];
    const sharedVideo = isSharingStatus(state['features/shared-video']?.status ?? '');

    return isStageFilmstripEnabled(state) && !sharedVideo
        && activeParticipants.length >= minParticipantCount
        && (isTopPanelEnabled(state) || remoteScreenShares.length === 0);
}

/**
 * Whether the stage filmstrip should be displayed on the top.
 *
 * @param {Object} state - Redux state.
 * @param {number} minParticipantCount - The min number of participants for the stage filmstrip
 * to be displayed.
 * @returns {boolean}
 */
export function isStageFilmstripTopPanel(state: IReduxState, minParticipantCount = 0) {
    const { remoteScreenShares } = state['features/video-layout'];

    return isTopPanelEnabled(state)
        && isStageFilmstripAvailable(state, minParticipantCount) && remoteScreenShares.length > 0;
}

/**
 * Whether the stage filmstrip is disabled or not.
 *
 * @param {Object} state - Redux state.
 * @returns {boolean}
 */
export function isStageFilmstripEnabled(state: IReduxState) {
    const { filmstrip } = state['features/base/config'];

    return Boolean(!filmstrip?.disableStageFilmstrip && interfaceConfig.VERTICAL_FILMSTRIP);
}

/**
 * Whether the vertical/horizontal filmstrip is disabled.
 *
 * @param {Object} state - Redux state.
 * @returns {boolean}
 */
export function isFilmstripDisabled(state: IReduxState) {
    const { filmstrip } = state['features/base/config'];

    return Boolean(filmstrip?.disabled);
}

/**
 * Gets the thumbnail type by filmstrip type.
 *
 * @param {string} currentLayout - Current app layout.
 * @param {string} filmstripType - The current filmstrip type.
 * @returns {string}
 */
export function getThumbnailTypeFromLayout(currentLayout: string, filmstripType: string) {
    switch (currentLayout) {
    case LAYOUTS.TILE_VIEW:
        return THUMBNAIL_TYPE.TILE;
    case LAYOUTS.VERTICAL_FILMSTRIP_VIEW:
        return THUMBNAIL_TYPE.VERTICAL;
    case LAYOUTS.HORIZONTAL_FILMSTRIP_VIEW:
        return THUMBNAIL_TYPE.HORIZONTAL;
    case LAYOUTS.STAGE_FILMSTRIP_VIEW:
        if (filmstripType !== FILMSTRIP_TYPE.MAIN) {
            return THUMBNAIL_TYPE.TILE;
        }

        return THUMBNAIL_TYPE.VERTICAL;
    }
}

/**
 * Returns the id of the participant displayed on the screen share filmstrip.
 *
 * @param {Object} state - Redux state.
 * @returns {string} - The participant id.
 */
export function getScreenshareFilmstripParticipantId(state: IReduxState) {
    const { screenshareFilmstripParticipantId } = state['features/filmstrip'];
    const screenshares = state['features/video-layout'].remoteScreenShares;
    let id = screenshares.find(sId => sId === screenshareFilmstripParticipantId);

    if (!id && screenshares.length) {
        id = screenshares[0];
    }

    return id;
}

/**
 * Whether or not the top panel is enabled.
 *
 * @param {Object} state - Redux state.
 * @returns {boolean}
 */
export function isTopPanelEnabled(state: IReduxState) {
    const { filmstrip } = state['features/base/config'];
    const participantsCount = getParticipantCount(state);

    return !filmstrip?.disableTopPanel && participantsCount >= (filmstrip?.minParticipantCountForTopPanel ?? 50);

}


################################################################################

## File: .\jitsi-meet\react\features\filmstrip\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/filmstrip');


################################################################################

## File: .\jitsi-meet\react\features\filmstrip\middleware.native.ts

import { PARTICIPANT_JOINED, PARTICIPANT_LEFT } from '../base/participants/actionTypes';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import { CLIENT_RESIZED, SAFE_AREA_INSETS_CHANGED, SET_ASPECT_RATIO } from '../base/responsive-ui/actionTypes';

import { setTileViewDimensions } from './actions.native';
import { updateRemoteParticipants, updateRemoteParticipantsOnLeave } from './functions.native';
import './subscriber.native';

/**
 * The middleware of the feature Filmstrip.
 */
MiddlewareRegistry.register(store => next => action => {
    if (action.type === PARTICIPANT_LEFT) {
        // This have to be executed before we remove the participant from features/base/participants state in order to
        // remove the related thumbnail component before we need to re-render it. If we do this after next()
        // we will be in situation where the participant exists in the remoteParticipants array in features/filmstrip
        // but doesn't exist in features/base/participants state which will lead to rendering a thumbnail for
        // non-existing participant.
        updateRemoteParticipantsOnLeave(store, action.participant?.id);
    }

    const result = next(action);

    switch (action.type) {
    case CLIENT_RESIZED:
    case SAFE_AREA_INSETS_CHANGED:
    case SET_ASPECT_RATIO:
        store.dispatch(setTileViewDimensions());
        break;
    case PARTICIPANT_JOINED: {
        updateRemoteParticipants(store, false, action.participant?.id);
        break;
    }
    }

    return result;
});


################################################################################

## File: .\jitsi-meet\react\features\filmstrip\middleware.web.ts

import { batch } from 'react-redux';

// @ts-expect-error
import VideoLayout from '../../../modules/UI/videolayout/VideoLayout';
import {
    DOMINANT_SPEAKER_CHANGED,
    PARTICIPANT_JOINED,
    PARTICIPANT_LEFT
} from '../base/participants/actionTypes';
import {
    getDominantSpeakerParticipant,
    getLocalParticipant,
    getLocalScreenShareParticipant,
    isScreenShareParticipant
} from '../base/participants/functions';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import { CLIENT_RESIZED } from '../base/responsive-ui/actionTypes';
import { SETTINGS_UPDATED } from '../base/settings/actionTypes';
import { setTileView } from '../video-layout/actions.web';
import { LAYOUTS } from '../video-layout/constants';
import { getCurrentLayout } from '../video-layout/functions.web';
import { WHITEBOARD_ID } from '../whiteboard/constants';
import { isWhiteboardVisible } from '../whiteboard/functions';

import {
    ADD_STAGE_PARTICIPANT,
    CLEAR_STAGE_PARTICIPANTS,
    REMOVE_STAGE_PARTICIPANT,
    RESIZE_FILMSTRIP,
    SET_USER_FILMSTRIP_WIDTH,
    TOGGLE_PIN_STAGE_PARTICIPANT
} from './actionTypes';
import {
    addStageParticipant,
    removeStageParticipant,
    setFilmstripHeight,
    setFilmstripWidth,
    setScreenshareFilmstripParticipant,
    setStageParticipants
} from './actions.web';
import {
    ACTIVE_PARTICIPANT_TIMEOUT,
    DEFAULT_FILMSTRIP_WIDTH,
    MAX_ACTIVE_PARTICIPANTS,
    MIN_STAGE_VIEW_HEIGHT,
    MIN_STAGE_VIEW_WIDTH,
    TOP_FILMSTRIP_HEIGHT
} from './constants';
import {
    getActiveParticipantsIds,
    getPinnedActiveParticipants,
    isFilmstripResizable,
    isStageFilmstripAvailable,
    isStageFilmstripTopPanel,
    updateRemoteParticipants,
    updateRemoteParticipantsOnLeave
} from './functions.web';
import './subscriber.web';

/**
 * Map of timers.
 *
 * @type {Map}
 */
const timers = new Map();

/**
 * The middleware of the feature Filmstrip.
 */
MiddlewareRegistry.register(store => next => action => {
    if (action.type === PARTICIPANT_LEFT) {
        // This has to be executed before we remove the participant from features/base/participants state in order to
        // remove the related thumbnail component before we need to re-render it. If we do this after next()
        // we will be in situation where the participant exists in the remoteParticipants array in features/filmstrip
        // but doesn't exist in features/base/participants state which will lead to rendering a thumbnail for
        // non-existing participant.
        updateRemoteParticipantsOnLeave(store, action.participant?.id);
    }

    let result;

    switch (action.type) {
    case CLIENT_RESIZED: {
        const state = store.getState();

        if (isFilmstripResizable(state)) {
            const { width: filmstripWidth, topPanelHeight } = state['features/filmstrip'];
            const { clientWidth, clientHeight } = action;
            let height, width;

            if ((filmstripWidth.current ?? 0) > clientWidth - MIN_STAGE_VIEW_WIDTH) {
                width = Math.max(clientWidth - MIN_STAGE_VIEW_WIDTH, DEFAULT_FILMSTRIP_WIDTH);
            } else {
                width = Math.min(clientWidth - MIN_STAGE_VIEW_WIDTH, filmstripWidth.userSet ?? 0);
            }
            if (width !== filmstripWidth.current) {
                store.dispatch(setFilmstripWidth(width));
            }

            if ((topPanelHeight.current ?? 0) > clientHeight - MIN_STAGE_VIEW_HEIGHT) {
                height = Math.max(clientHeight - MIN_STAGE_VIEW_HEIGHT, TOP_FILMSTRIP_HEIGHT);
            } else {
                height = Math.min(clientHeight - MIN_STAGE_VIEW_HEIGHT, topPanelHeight.userSet ?? 0);
            }
            if (height !== topPanelHeight.current) {
                store.dispatch(setFilmstripHeight(height));
            }
        }
        break;
    }
    case PARTICIPANT_JOINED: {
        result = next(action);
        if (isScreenShareParticipant(action.participant)) {
            break;
        }

        updateRemoteParticipants(store, false, action.participant?.id);
        break;
    }
    case SETTINGS_UPDATED: {
        if (typeof action.settings?.localFlipX === 'boolean') {
            // TODO: This needs to be removed once the large video is Reactified.
            VideoLayout.onLocalFlipXChanged(action.settings.localFlipX);
        }
        if (action.settings?.disableSelfView) {
            const state = store.getState();
            const local = getLocalParticipant(state);
            const localScreenShare = getLocalScreenShareParticipant(state);
            const activeParticipantsIds = getActiveParticipantsIds(state);

            if (activeParticipantsIds.find(id => id === local?.id)) {
                store.dispatch(removeStageParticipant(local?.id ?? ''));
            }

            if (localScreenShare) {
                if (activeParticipantsIds.find(id => id === localScreenShare.id)) {
                    store.dispatch(removeStageParticipant(localScreenShare.id));
                }
            }
        }
        if (action.settings?.maxStageParticipants !== undefined) {
            const maxParticipants = action.settings.maxStageParticipants;
            const { activeParticipants } = store.getState()['features/filmstrip'];
            const newMax = Math.min(MAX_ACTIVE_PARTICIPANTS, maxParticipants);

            if (newMax < activeParticipants.length) {
                const toRemove = activeParticipants.slice(0, activeParticipants.length - newMax);

                batch(() => {
                    toRemove.forEach(p => store.dispatch(removeStageParticipant(p.participantId)));
                });
            }
        }
        break;
    }
    case SET_USER_FILMSTRIP_WIDTH: {
        VideoLayout.refreshLayout();
        break;
    }
    case RESIZE_FILMSTRIP: {
        const { width = 0 } = action;

        store.dispatch(setFilmstripWidth(width));

        break;
    }
    case ADD_STAGE_PARTICIPANT: {
        const { dispatch, getState } = store;
        const { participantId, pinned } = action;
        const state = getState();
        const { activeParticipants } = state['features/filmstrip'];
        const { maxStageParticipants } = state['features/base/settings'];
        const isWhiteboardActive = isWhiteboardVisible(state);
        let queue;

        if (activeParticipants.find(p => p.participantId === participantId)) {
            queue = activeParticipants.filter(p => p.participantId !== participantId);
            queue.push({
                participantId,
                pinned
            });
            const tid = timers.get(participantId);

            clearTimeout(tid);
            timers.delete(participantId);
        } else if (activeParticipants.length < (maxStageParticipants ?? 0)) {
            queue = [ ...activeParticipants, {
                participantId,
                pinned
            } ];
        } else {
            const notPinnedIndex = activeParticipants.findIndex(p => !p.pinned);

            if (notPinnedIndex === -1) {
                if (pinned) {
                    queue = [ ...activeParticipants, {
                        participantId,
                        pinned
                    } ];
                    queue.shift();
                }
            } else {
                queue = [ ...activeParticipants, {
                    participantId,
                    pinned
                } ];
                queue.splice(notPinnedIndex, 1);
            }
        }

        if (participantId === WHITEBOARD_ID) {
            // If the whiteboard is pinned, this action should clear the other pins.
            queue = [ {
                participantId,
                pinned: true
            } ];
        } else if (isWhiteboardActive && Array.isArray(queue)) {
            // When another participant is pinned, remove the whiteboard from the stage area.
            queue = queue.filter(p => p?.participantId !== WHITEBOARD_ID);
        }

        // If queue is undefined we haven't made any changes to the active participants. This will mostly happen
        // if the participant that we are trying to add is not pinned and all slots are currently taken by pinned
        // participants.
        // IMPORTANT: setting active participants to undefined will crash jitsi-meet.
        if (typeof queue !== 'undefined') {
            dispatch(setStageParticipants(queue));
            if (!pinned) {
                const timeoutId = setTimeout(() => dispatch(removeStageParticipant(participantId)),
                    ACTIVE_PARTICIPANT_TIMEOUT);

                timers.set(participantId, timeoutId);
            }
        }

        if (getCurrentLayout(state) === LAYOUTS.TILE_VIEW) {
            dispatch(setTileView(false));
        }
        break;
    }
    case REMOVE_STAGE_PARTICIPANT: {
        const state = store.getState();
        const { participantId } = action;
        const tid = timers.get(participantId);

        clearTimeout(tid);
        timers.delete(participantId);
        const dominant = getDominantSpeakerParticipant(state);

        if (participantId === dominant?.id) {
            const timeoutId = setTimeout(() => store.dispatch(removeStageParticipant(participantId)),
                ACTIVE_PARTICIPANT_TIMEOUT);

            timers.set(participantId, timeoutId);

            return;
        }
        break;
    }
    case DOMINANT_SPEAKER_CHANGED: {
        const { id } = action.participant;
        const state = store.getState();
        const stageFilmstrip = isStageFilmstripAvailable(state);
        const local = getLocalParticipant(state);
        const currentLayout = getCurrentLayout(state);
        const dominantSpeaker = getDominantSpeakerParticipant(state);

        if (dominantSpeaker?.id === id || id === local?.id || currentLayout === LAYOUTS.TILE_VIEW) {
            break;
        }

        if (stageFilmstrip) {
            const isPinned = getPinnedActiveParticipants(state).some(p => p.participantId === id);

            store.dispatch(addStageParticipant(id, Boolean(isPinned)));
        }
        break;
    }
    case PARTICIPANT_LEFT: {
        const state = store.getState();
        const { id } = action.participant;
        const activeParticipantsIds = getActiveParticipantsIds(state);

        if (activeParticipantsIds.find(pId => pId === id)) {
            const tid = timers.get(id);
            const { activeParticipants } = state['features/filmstrip'];

            clearTimeout(tid);
            timers.delete(id);
            store.dispatch(setStageParticipants(activeParticipants.filter(p => p.participantId !== id)));
        }
        break;
    }
    case TOGGLE_PIN_STAGE_PARTICIPANT: {
        const { dispatch, getState } = store;
        const state = getState();
        const { participantId } = action;
        const pinnedParticipants = getPinnedActiveParticipants(state);
        const dominant = getDominantSpeakerParticipant(state);

        if (isStageFilmstripTopPanel(state, 2)) {
            const screenshares = state['features/video-layout'].remoteScreenShares;

            if (screenshares.find(sId => sId === participantId)) {
                dispatch(setScreenshareFilmstripParticipant(participantId));
                break;
            }
        }

        if (pinnedParticipants.find(p => p.participantId === participantId)) {
            if (dominant?.id === participantId) {
                const { activeParticipants } = state['features/filmstrip'];
                const queue = activeParticipants.map(p => {
                    if (p.participantId === participantId) {
                        return {
                            participantId,
                            pinned: false
                        };
                    }

                    return p;
                });

                dispatch(setStageParticipants(queue));
            } else {
                dispatch(removeStageParticipant(participantId));
            }
        } else {
            dispatch(addStageParticipant(participantId, true));
        }
        break;
    }
    case CLEAR_STAGE_PARTICIPANTS: {
        const activeParticipants = getActiveParticipantsIds(store.getState());

        activeParticipants.forEach(pId => {
            const tid = timers.get(pId);

            clearTimeout(tid);
            timers.delete(pId);
        });
    }
    }

    return result ?? next(action);
});


################################################################################

## File: .\jitsi-meet\react\features\filmstrip\reducer.ts

import { PARTICIPANT_LEFT } from '../base/participants/actionTypes';
import ReducerRegistry from '../base/redux/ReducerRegistry';

import {
    CLEAR_STAGE_PARTICIPANTS,
    REMOVE_STAGE_PARTICIPANT,
    SET_FILMSTRIP_ENABLED,
    SET_FILMSTRIP_HEIGHT,
    SET_FILMSTRIP_VISIBLE,
    SET_FILMSTRIP_WIDTH,
    SET_HORIZONTAL_VIEW_DIMENSIONS,
    SET_REMOTE_PARTICIPANTS,
    SET_SCREENSHARE_FILMSTRIP_PARTICIPANT,
    SET_SCREENSHARING_TILE_DIMENSIONS,
    SET_STAGE_FILMSTRIP_DIMENSIONS,
    SET_STAGE_PARTICIPANTS,
    SET_TILE_VIEW_DIMENSIONS,
    SET_TOP_PANEL_VISIBILITY,
    SET_USER_FILMSTRIP_HEIGHT,
    SET_USER_FILMSTRIP_WIDTH,
    SET_USER_IS_RESIZING,
    SET_VERTICAL_VIEW_DIMENSIONS,
    SET_VISIBLE_REMOTE_PARTICIPANTS,
    SET_VOLUME
} from './actionTypes';

const DEFAULT_STATE = {

    /**
     * The list of participants to be displayed on the stage filmstrip.
     */
    activeParticipants: [],

    /**
     * The indicator which determines whether the {@link Filmstrip} is enabled.
     *
     * @public
     * @type {boolean}
     */
    enabled: true,

    /**
     * The horizontal view dimensions.
     *
     * @public
     * @type {Object}
     */
    horizontalViewDimensions: {},

    /**
     * Whether or not the user is actively resizing the filmstrip.
     *
     * @public
     * @type {boolean}
     */
    isResizing: false,

    /**
     * The custom audio volume levels per participant.
     *
     * @type {Object}
     */
    participantsVolume: {},

    /**
     * The ordered IDs of the remote participants displayed in the filmstrip.
     *
     * @public
     * @type {Array<string>}
     */
    remoteParticipants: [],

    /**
     * The dimensions of the screenshare filmstrip.
     */
    screenshareFilmstripDimensions: {},

    /**
     * The id of the participant whose screenshare to
     * display on the screenshare filmstrip.
     */
    screenshareFilmstripParticipantId: null,

    /**
     * The stage filmstrip view dimensions.
     *
     * @public
     * @type {Object}
     */
    stageFilmstripDimensions: {},

    /**
     * The tile view dimensions.
     *
     * @public
     * @type {Object}
     */
    tileViewDimensions: {},

    /**
     * The height of the resizable top panel.
     */
    topPanelHeight: {
        /**
         * Current height. Affected by: user top panel resize,
         * window resize.
         */
        current: null,

        /**
         * Height set by user resize. Used as the preferred height.
         */
        userSet: null
    },

    /**
     * The indicator determines if the top panel is visible.
     */
    topPanelVisible: true,

    /**
     * The vertical view dimensions.
     *
     * @public
     * @type {Object}
     */
    verticalViewDimensions: {},

    /**
     * The indicator which determines whether the {@link Filmstrip} is visible.
     *
     * @public
     * @type {boolean}
     */
    visible: true,

    /**
     * The end index in the remote participants array that is visible in the filmstrip.
     *
     * @public
     * @type {number}
     */
    visibleParticipantsEndIndex: 0,

    /**
     * The start index in the remote participants array that is visible in the filmstrip.
     *
     * @public
     * @type {number}
     */
    visibleParticipantsStartIndex: 0,

    /**
     * The visible remote participants in the filmstrip.
     *
     * @public
     * @type {Set<string>}
     */
    visibleRemoteParticipants: new Set<string>(),

    /**
     * The width of the resizable filmstrip.
     *
     * @public
     * @type {Object}
     */
    width: {
        /**
         * Current width. Affected by: user filmstrip resize,
         * window resize, panels open/ close.
         */
        current: null,

        /**
         * Width set by user resize. Used as the preferred width.
         */
        userSet: null
    }
};

interface IDimensions {
    height: number;
    width: number;
}

interface IFilmstripDimensions {
    columns?: number;
    filmstripHeight?: number;
    filmstripWidth?: number;
    gridDimensions?: {
        columns: number;
        rows: number;
    };
    hasScroll?: boolean;
    thumbnailSize?: IDimensions;
}

export interface IFilmstripState {
    activeParticipants: Array<{
        participantId: string;
        pinned?: boolean;
    }>;
    enabled: boolean;
    horizontalViewDimensions: {
        hasScroll?: boolean;
        local?: IDimensions;
        remote?: IDimensions;
        remoteVideosContainer?: IDimensions;
    };
    isResizing: boolean;
    participantsVolume: {
        [participantId: string]: number;
    };
    remoteParticipants: string[];
    screenshareFilmstripDimensions: {
        filmstripHeight?: number;
        filmstripWidth?: number;
        thumbnailSize?: IDimensions;
    };
    screenshareFilmstripParticipantId?: string | null;
    stageFilmstripDimensions: IFilmstripDimensions;
    tileViewDimensions?: IFilmstripDimensions;
    topPanelHeight: {
        current: number | null;
        userSet: number | null;
    };
    topPanelVisible: boolean;
    verticalViewDimensions: {
        gridView?: {
            gridDimensions: {
                columns: number;
                rows: number;
            };
            hasScroll: boolean;
            thumbnailSize: IDimensions;
        };
        hasScroll?: boolean;
        local?: IDimensions;
        remote?: IDimensions;
        remoteVideosContainer?: IDimensions;
    };
    visible: boolean;
    visibleParticipantsEndIndex: number;
    visibleParticipantsStartIndex: number;
    visibleRemoteParticipants: Set<string>;
    width: {
        current: number | null;
        userSet: number | null;
    };
}

ReducerRegistry.register<IFilmstripState>(
    'features/filmstrip',
    (state = DEFAULT_STATE, action): IFilmstripState => {
        switch (action.type) {
        case SET_FILMSTRIP_ENABLED:
            return {
                ...state,
                enabled: action.enabled
            };

        case SET_FILMSTRIP_VISIBLE:
            return {
                ...state,
                visible: action.visible
            };

        case SET_HORIZONTAL_VIEW_DIMENSIONS:
            return {
                ...state,
                horizontalViewDimensions: action.dimensions
            };
        case SET_REMOTE_PARTICIPANTS: {
            state.remoteParticipants = action.participants;
            const { visibleParticipantsStartIndex: startIndex, visibleParticipantsEndIndex: endIndex } = state;

            state.visibleRemoteParticipants = new Set(state.remoteParticipants.slice(startIndex, endIndex + 1));

            return { ...state };
        }
        case SET_TILE_VIEW_DIMENSIONS:
            return {
                ...state,
                tileViewDimensions: action.dimensions
            };
        case SET_VERTICAL_VIEW_DIMENSIONS:
            return {
                ...state,
                verticalViewDimensions: action.dimensions
            };
        case SET_VOLUME:
            return {
                ...state,
                participantsVolume: {
                    ...state.participantsVolume,

                    // NOTE: This would fit better in the features/base/participants. But currently we store
                    // the participants as an array which will make it expensive to search for the volume for
                    // every participant separately.
                    [action.participantId]: action.volume
                }
            };
        case SET_VISIBLE_REMOTE_PARTICIPANTS: {
            const { endIndex, startIndex } = action;
            const { remoteParticipants } = state;
            const visibleRemoteParticipants = new Set(remoteParticipants.slice(startIndex, endIndex + 1));

            return {
                ...state,
                visibleParticipantsStartIndex: startIndex,
                visibleParticipantsEndIndex: endIndex,
                visibleRemoteParticipants
            };
        }
        case PARTICIPANT_LEFT: {
            const { id, local } = action.participant;

            if (local) {
                return state;
            }
            delete state.participantsVolume[id];

            return {
                ...state
            };
        }
        case SET_FILMSTRIP_HEIGHT:{
            return {
                ...state,
                topPanelHeight: {
                    ...state.topPanelHeight,
                    current: action.height
                }
            };
        }
        case SET_FILMSTRIP_WIDTH: {
            return {
                ...state,
                width: {
                    ...state.width,
                    current: action.width
                }
            };
        }
        case SET_USER_FILMSTRIP_HEIGHT: {
            const { height } = action;

            return {
                ...state,
                topPanelHeight: {
                    current: height,
                    userSet: height
                }
            };
        }
        case SET_USER_FILMSTRIP_WIDTH: {
            const { width } = action;

            return {
                ...state,
                width: {
                    current: width,
                    userSet: width
                }
            };
        }
        case SET_USER_IS_RESIZING: {
            return {
                ...state,
                isResizing: action.resizing
            };
        }
        case SET_STAGE_FILMSTRIP_DIMENSIONS: {
            return {
                ...state,
                stageFilmstripDimensions: action.dimensions
            };
        }
        case SET_STAGE_PARTICIPANTS: {
            return {
                ...state,
                activeParticipants: action.queue
            };
        }
        case REMOVE_STAGE_PARTICIPANT: {
            return {
                ...state,
                activeParticipants: state.activeParticipants.filter(p => p.participantId !== action.participantId)
            };
        }
        case CLEAR_STAGE_PARTICIPANTS: {
            return {
                ...state,
                activeParticipants: []
            };
        }
        case SET_SCREENSHARING_TILE_DIMENSIONS: {
            return {
                ...state,
                screenshareFilmstripDimensions: action.dimensions
            };
        }
        case SET_TOP_PANEL_VISIBILITY: {
            return {
                ...state,
                topPanelVisible: action.visible
            };
        }
        case SET_SCREENSHARE_FILMSTRIP_PARTICIPANT: {
            return {
                ...state,
                screenshareFilmstripParticipantId: action.participantId
            };
        }
        }

        return state;
    });


################################################################################

## File: .\jitsi-meet\react\features\filmstrip\subscriber.any.ts

import StateListenerRegistry from '../base/redux/StateListenerRegistry';

import { isFilmstripScrollVisible, updateRemoteParticipants } from './functions';

/**
 * Listens for changes to the screensharing status of the remote participants to recompute the reordered list of the
 * remote endpoints.
 */
StateListenerRegistry.register(
    /* selector */ state => state['features/video-layout'].remoteScreenShares,
    /* listener */ (remoteScreenShares, store) => updateRemoteParticipants(store));

/**
 * Listens for changes to the remote screenshare participants to recompute the reordered list of the remote endpoints.
 * We force updateRemoteParticipants to make sure it executes and for the case where
 * sortedRemoteVirtualScreenshareParticipants becomes 0. We do not want to short circuit it in case of no screen-sharers
 * and no scroll and triggered for dominant speaker changed.
 */
StateListenerRegistry.register(
    /* selector */ state => state['features/base/participants'].sortedRemoteVirtualScreenshareParticipants,
    /* listener */ (sortedRemoteVirtualScreenshareParticipants, store) => updateRemoteParticipants(store, true));

/**
 * Listens for changes to the dominant speaker to recompute the reordered list of the remote endpoints.
 */
StateListenerRegistry.register(
    /* selector */ state => state['features/base/participants'].dominantSpeaker,
    /* listener */ (dominantSpeaker, store) => updateRemoteParticipants(store));

/**
 * Listens for changes in the filmstrip scroll visibility.
 */
StateListenerRegistry.register(
    /* selector */ state => isFilmstripScrollVisible(state),
    /* listener */ (_, store) => updateRemoteParticipants(store));


################################################################################

## File: .\jitsi-meet\react\features\filmstrip\subscriber.native.ts

import { getCurrentConference } from '../base/conference/functions';
import StateListenerRegistry from '../base/redux/StateListenerRegistry';
import { shouldDisplayTileView } from '../video-layout/functions.native';

import { setRemoteParticipants, setTileViewDimensions } from './actions.native';
import { getTileViewParticipantCount } from './functions.native';
import './subscriber.any';

/**
 * Listens for changes in the number of participants to calculate the dimensions of the tile view grid and the tiles.
 */
StateListenerRegistry.register(
    /* selector */ state => getTileViewParticipantCount(state),
    /* listener */ (_, store) => {
        const state = store.getState();

        if (shouldDisplayTileView(state)) {
            store.dispatch(setTileViewDimensions());
        }
    });

/**
 * Listens for changes in the selected layout to calculate the dimensions of the tile view grid and horizontal view.
 */
StateListenerRegistry.register(
    /* selector */ state => shouldDisplayTileView(state),
    /* listener */ (isTileView, store) => {
        if (isTileView) {
            store.dispatch(setTileViewDimensions());
        }
    });

/**
 * Listens for changes in the current conference and clears remote participants from this feature.
 */
StateListenerRegistry.register(
    state => getCurrentConference(state),
    (conference, { dispatch }, previousConference) => {
        if (conference !== previousConference) {
            dispatch(setRemoteParticipants([]));
        }
    });


################################################################################

## File: .\jitsi-meet\react\features\filmstrip\subscriber.web.ts

import { pinParticipant } from '../base/participants/actions';
import { getParticipantCountWithFake } from '../base/participants/functions';
import StateListenerRegistry from '../base/redux/StateListenerRegistry';
import { clientResized, setNarrowLayout } from '../base/responsive-ui/actions';
import { getHideSelfView } from '../base/settings/functions.any';
import { selectParticipantInLargeVideo } from '../large-video/actions.any';
import { getParticipantsPaneOpen } from '../participants-pane/functions';
import { setOverflowDrawer } from '../toolbox/actions.web';
import { LAYOUTS } from '../video-layout/constants';
import { getCurrentLayout, shouldDisplayTileView } from '../video-layout/functions.web';

import { clearStageParticipants,
    setFilmstripVisible,
    setHorizontalViewDimensions,
    setScreenshareFilmstripParticipant,
    setScreensharingTileDimensions,
    setStageFilmstripViewDimensions,
    setTileViewDimensions,
    setVerticalViewDimensions
} from './actions.web';
import {
    ASPECT_RATIO_BREAKPOINT,
    DISPLAY_DRAWER_THRESHOLD
} from './constants';
import {
    isFilmstripResizable,
    isTopPanelEnabled
} from './functions.web';

import './subscriber.any';


/**
 * Listens for changes in the number of participants to calculate the dimensions of the tile view grid and the tiles.
 */
StateListenerRegistry.register(
    /* selector */ state => {
        return {
            numberOfParticipants: getParticipantCountWithFake(state),
            disableSelfView: getHideSelfView(state),
            localScreenShare: state['features/base/participants'].localScreenShare
        };
    },
    /* listener */ (currentState, store) => {
        const state = store.getState();
        const resizableFilmstrip = isFilmstripResizable(state);

        if (shouldDisplayTileView(state)) {
            store.dispatch(setTileViewDimensions());
        }
        if (resizableFilmstrip) {
            store.dispatch(setVerticalViewDimensions());
        }
    }, {
        deepEquals: true
    });

/**
 * Listens for changes in the selected layout to calculate the dimensions of the tile view grid and horizontal view.
 */
StateListenerRegistry.register(
    /* selector */ state => {
        const { clientHeight, clientWidth } = state['features/base/responsive-ui'];

        return {
            layout: getCurrentLayout(state),
            height: clientHeight,
            width: clientWidth
        };
    },
    /* listener */ ({ layout }, store) => {
        switch (layout) {
        case LAYOUTS.TILE_VIEW: {
            const { pinnedParticipant } = store.getState()['features/base/participants'];

            if (pinnedParticipant) {
                store.dispatch(pinParticipant(null));
            }
            store.dispatch(clearStageParticipants());
            store.dispatch(setTileViewDimensions());
            break;
        }
        case LAYOUTS.HORIZONTAL_FILMSTRIP_VIEW:
            store.dispatch(setHorizontalViewDimensions());
            break;
        case LAYOUTS.VERTICAL_FILMSTRIP_VIEW:
            store.dispatch(setVerticalViewDimensions());
            if (store.getState()['features/filmstrip'].activeParticipants.length > 1) {
                store.dispatch(clearStageParticipants());
            }
            break;
        case LAYOUTS.STAGE_FILMSTRIP_VIEW:
            store.dispatch(pinParticipant(null));
            break;
        }
    }, {
        deepEquals: true
    });

/**
 * Listens for changes in the chat state to recompute available width.
 */
StateListenerRegistry.register(
    /* selector */ state => state['features/chat'].isOpen,
    /* listener */ (isChatOpen, store) => {
        const { innerWidth, innerHeight } = window;

        if (isChatOpen) {
            document.body.classList.add('shift-right');
        } else {
            document.body.classList.remove('shift-right');
        }

        store.dispatch(clientResized(innerWidth, innerHeight));
    });

/**
 * Listens for changes in the participant pane state to calculate the
 * dimensions of the tile view grid and the tiles.
 */
StateListenerRegistry.register(
    /* selector */ getParticipantsPaneOpen,
    /* listener */ (isOpen, store) => {
        const { innerWidth, innerHeight } = window;

        store.dispatch(clientResized(innerWidth, innerHeight));
    });


/**
 * Listens for changes in the client width to determine whether the overflow menu(s) should be displayed as drawers.
 */
StateListenerRegistry.register(
    /* selector */ state => state['features/base/responsive-ui'].clientWidth < DISPLAY_DRAWER_THRESHOLD,
    /* listener */ (widthBelowThreshold, store) => {
        store.dispatch(setOverflowDrawer(widthBelowThreshold));
        store.dispatch(setNarrowLayout(widthBelowThreshold));
    });

/**
 * Gracefully hide/show the filmstrip when going past threshold.
 */
StateListenerRegistry.register(
    /* selector */ state => state['features/base/responsive-ui'].clientWidth < ASPECT_RATIO_BREAKPOINT,
    /* listener */ (widthBelowThreshold, store) => {
        const state = store.getState();
        const { disableFilmstripAutohiding } = state['features/base/config'];

        if (!disableFilmstripAutohiding) {
            store.dispatch(setFilmstripVisible(!widthBelowThreshold));
        }
    });

/**
 * Listens for changes in the filmstrip width to determine the size of the tiles.
 */
StateListenerRegistry.register(
    /* selector */ state => state['features/filmstrip'].width?.current,
    /* listener */(_, store) => {
        store.dispatch(setVerticalViewDimensions());
    });

/**
 * Listens for changes in the filmstrip config to determine the size of the tiles.
 */
StateListenerRegistry.register(
    /* selector */ state => state['features/base/config'].filmstrip?.disableResizable,
    /* listener */(_, store) => {
        store.dispatch(setVerticalViewDimensions());
    });

/**
 * Listens for changes to determine the size of the stage filmstrip tiles.
 */
StateListenerRegistry.register(
    /* selector */ state => {
        return {
            remoteScreenShares: state['features/video-layout'].remoteScreenShares.length,
            length: state['features/filmstrip'].activeParticipants.length,
            width: state['features/filmstrip'].width?.current,
            visible: state['features/filmstrip'].visible,
            clientWidth: state['features/base/responsive-ui'].clientWidth,
            clientHeight: state['features/base/responsive-ui'].clientHeight,
            tileView: state['features/video-layout'].tileViewEnabled,
            height: state['features/filmstrip'].topPanelHeight?.current
        };
    },
    /* listener */(_, store) => {
        if (getCurrentLayout(store.getState()) === LAYOUTS.STAGE_FILMSTRIP_VIEW) {
            store.dispatch(setStageFilmstripViewDimensions());
        }
    }, {
        deepEquals: true
    });

/**
 * Listens for changes in the active participants count determine the stage participant (when
 * there's just one).
 */
StateListenerRegistry.register(
    /* selector */ state => state['features/filmstrip'].activeParticipants,
    /* listener */(activeParticipants, store) => {
        if (activeParticipants.length <= 1) {
            store.dispatch(selectParticipantInLargeVideo());
        }
    });

/**
 * Listens for changes to determine the size of the screenshare filmstrip.
 */
StateListenerRegistry.register(
    /* selector */ state => {
        return {
            length: state['features/video-layout'].remoteScreenShares.length,
            clientWidth: state['features/base/responsive-ui'].clientWidth,
            clientHeight: state['features/base/responsive-ui'].clientHeight,
            height: state['features/filmstrip'].topPanelHeight?.current,
            width: state['features/filmstrip'].width?.current,
            visible: state['features/filmstrip'].visible,
            topPanelVisible: state['features/filmstrip'].topPanelVisible
        };
    },
    /* listener */({ length }, store) => {
        if (length >= 1 && isTopPanelEnabled(store.getState())) {
            store.dispatch(setScreensharingTileDimensions());
        }
    }, {
        deepEquals: true
    });

/**
 * Listens for changes to clear invalid data.
 */
StateListenerRegistry.register(
    /* selector */ state => state['features/video-layout'].remoteScreenShares.length,
    /* listener */(length, store) => {
        if (length === 0) {
            store.dispatch(setScreenshareFilmstripParticipant());
        }
    }, {
        deepEquals: true
    });



################################################################################

## File: .\jitsi-meet\react\features\filmstrip\components\native\styles.ts

import BaseTheme from '../../../base/ui/components/BaseTheme.native';
import { SMALL_THUMBNAIL_SIZE } from '../../constants';

/**
 * Size for the Avatar.
 */
export const AVATAR_SIZE = 50;

const indicatorContainer = {
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    borderRadius: BaseTheme.shape.borderRadius,
    height: 24,
    margin: 2,
    padding: 2
};


/**
 * The styles of the feature filmstrip.
 */
export default {

    /**
     * The FlatList content container styles.
     */
    contentContainer: {
        alignItems: 'center',
        justifyContent: 'center',
        flex: 0
    },

    /**
     * The display name container.
     */
    displayNameContainer: {
        padding: 2
    },

    /**
     * The style of the narrow {@link Filmstrip} version which displays
     * thumbnails in a row at the bottom of the screen.
     */
    filmstripNarrow: {
        flexDirection: 'row',
        flexGrow: 0,
        justifyContent: 'flex-end',
        margin: 6
    },

    /**
     * The style of the wide {@link Filmstrip} version which displays thumbnails
     * in a column on the short size of the screen.
     *
     * NOTE: width is calculated based on the children, but it should also align
     * to {@code FILMSTRIP_SIZE}.
     */
    filmstripWide: {
        bottom: BaseTheme.spacing[0],
        flexDirection: 'column',
        flexGrow: 0,
        position: 'absolute',
        right: BaseTheme.spacing[0],
        top: BaseTheme.spacing[0]
    },

    /**
     * The styles for the FlatList container.
     */
    flatListContainer: {
        flexGrow: 1,
        flexShrink: 1,
        flex: 0
    },

    /**
     * The styles for the FlatList component in stage view.
     */
    flatListStageView: {
        flexGrow: 0
    },

    /**
     * The styles for the FlatList component in tile view.
     */
    flatListTileView: {
        flex: 0
    },

    /**
     * Container of the {@link LocalThumbnail}.
     */
    localThumbnail: {
        alignContent: 'stretch',
        alignSelf: 'stretch',
        aspectRatio: 1,
        flexShrink: 0,
        flexDirection: 'row'
    },

    /**
     * The style of a participant's Thumbnail which renders either the video or
     * the avatar of the associated participant.
     */
    thumbnail: {
        alignItems: 'stretch',
        backgroundColor: BaseTheme.palette.ui02,
        borderColor: BaseTheme.palette.ui03,
        borderRadius: BaseTheme.shape.borderRadius,
        borderStyle: 'solid',
        borderWidth: 1,
        flex: 1,
        height: SMALL_THUMBNAIL_SIZE,
        justifyContent: 'center',
        margin: 2,
        maxHeight: SMALL_THUMBNAIL_SIZE,
        maxWidth: SMALL_THUMBNAIL_SIZE,
        overflow: 'hidden',
        position: 'relative',
        width: SMALL_THUMBNAIL_SIZE
    },

    indicatorContainer: {
        ...indicatorContainer
    },

    screenShareIndicatorContainer: {
        ...indicatorContainer
    },

    /**
     * The thumbnail indicator container.
     */
    thumbnailIndicatorContainer: {
        ...indicatorContainer,
        bottom: 3,
        flex: 1,
        flexDirection: 'row',
        left: 3,
        position: 'absolute',
        maxWidth: '95%',
        overflow: 'hidden',
        padding: BaseTheme.spacing[0]
    },

    bottomIndicatorsContainer: {
        flexDirection: 'row',
        padding: BaseTheme.spacing[1]
    },

    thumbnailTopLeftIndicatorContainer: {
        ...indicatorContainer,
        backgroundColor: 'unset',
        flexDirection: 'row',
        position: 'absolute',
        top: BaseTheme.spacing[1]
    },

    raisedHandIndicator: {
        ...indicatorContainer,
        backgroundColor: BaseTheme.palette.warning02
    },

    raisedHandIcon: {
        color: BaseTheme.palette.uiBackground
    },

    thumbnailRaisedHand: {
        borderWidth: 2,
        borderColor: BaseTheme.palette.warning02
    },

    thumbnailDominantSpeaker: {
        borderWidth: 2,
        borderColor: BaseTheme.palette.action01Hover
    },

    thumbnailGif: {
        flexGrow: 1,
        resizeMode: 'contain'
    }
};


################################################################################

## File: .\jitsi-meet\react\features\filmstrip\components\web\styles.ts

import { Theme } from '@mui/material';

const BACKGROUND_COLOR = 'rgba(51, 51, 51, .5)';

/**
 * Creates the styles for the component.
 *
 * @param {Object} theme - The current theme.
 * @returns {Object}
 */
export const styles = (theme: Theme) => {
    return {
        toggleFilmstripContainer: {
            display: 'flex',
            flexWrap: 'nowrap' as const,
            alignItems: 'center',
            justifyContent: 'center',
            backgroundColor: BACKGROUND_COLOR,
            width: '32px',
            height: '24px',
            position: 'absolute' as const,
            borderRadius: '4px',
            top: 'calc(-24px - 2px)',
            left: 'calc(50% - 16px)',
            opacity: 0,
            transition: 'opacity .3s',
            zIndex: 1,

            '&:hover, &:focus-within': {
                backgroundColor: theme.palette.ui02
            }
        },

        toggleFilmstripButton: {
            fontSize: '14px',
            lineHeight: 1.2,
            textAlign: 'center' as const,
            background: 'transparent',
            height: 'auto',
            width: '100%',
            padding: 0,
            margin: 0,
            border: 'none',

            '-webkit-appearance': 'none',

            '& svg': {
                fill: theme.palette.icon01
            }
        },

        toggleVerticalFilmstripContainer: {
            transform: 'rotate(-90deg)',
            left: 'calc(-24px - 2px - 4px)',
            top: 'calc(50% - 12px)'
        },

        toggleTopPanelContainer: {
            transform: 'rotate(180deg)',
            bottom: 'calc(-24px - 6px)',
            top: 'auto'
        },

        toggleTopPanelContainerHidden: {
            visibility: 'hidden' as const
        },

        filmstrip: {
            transition: 'background .2s ease-in-out, right 1s, bottom 1s, top 1s, height .3s ease-in',
            right: 0,
            bottom: 0,

            '&:hover, &:focus-within': {
                '& .resizable-filmstrip': {
                    backgroundColor: BACKGROUND_COLOR
                },

                '& .filmstrip-hover': {
                    backgroundColor: BACKGROUND_COLOR
                },

                '& .toggleFilmstripContainer': {
                    opacity: 1
                },

                '& .dragHandleContainer': {
                    visibility: 'visible' as const
                }
            },

            '.horizontal-filmstrip &.hidden': {
                bottom: '-50px',

                '&:hover': {
                    backgroundColor: 'transparent'
                }
            },

            '&.hidden': {
                '& .toggleFilmstripContainer': {
                    opacity: 1
                }
            }
        },

        filmstripBackground: {
            backgroundColor: theme.palette.uiBackground,

            '&:hover, &:focus-within': {
                backgroundColor: theme.palette.uiBackground
            }
        },

        resizableFilmstripContainer: {
            display: 'flex',
            position: 'relative' as const,
            flexDirection: 'row' as const,
            alignItems: 'center',
            height: '100%',
            width: '100%',
            transition: 'background .2s ease-in-out',

            '& .avatar-container': {
                maxWidth: 'initial',
                maxHeight: 'initial'
            },

            '&.top-panel-filmstrip': {
                flexDirection: 'column'
            }
        },

        dragHandleContainer: {
            height: '100%',
            width: '9px',
            backgroundColor: 'transparent',
            position: 'relative' as const,
            cursor: 'col-resize',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            visibility: 'hidden' as const,

            '&:hover': {
                '& .dragHandle': {
                    backgroundColor: theme.palette.icon01
                }
            },

            '&.visible': {
                visibility: 'visible',

                '& .dragHandle': {
                    backgroundColor: theme.palette.icon01
                }
            },

            '&.top-panel': {
                order: 2,
                width: '100%',
                height: '9px',
                cursor: 'row-resize',

                '& .dragHandle': {
                    height: '3px',
                    width: '100px'
                }
            }
        },

        dragHandle: {
            backgroundColor: theme.palette.icon02,
            height: '100px',
            width: '3px',
            borderRadius: '1px'
        }
    };
};


################################################################################

## File: .\jitsi-meet\react\features\follow-me\actions.ts

import {
    SET_FOLLOW_ME_MODERATOR,
    SET_FOLLOW_ME_STATE
} from './actionTypes';

/**
 * Sets the current moderator id or clears it.
 *
 * @param {?string} id - The Follow Me moderator participant id.
 * @param {?boolean} forRecorder - Whether this is command only for recorder.
 * @returns {{
 *     type: SET_FOLLOW_ME_MODERATOR,
 *     id: string,
 *     forRecorder: boolean
 * }}
 */
export function setFollowMeModerator(id?: string, forRecorder?: boolean) {
    return {
        type: SET_FOLLOW_ME_MODERATOR,
        id,
        forRecorder
    };
}

/**
 * Sets the Follow Me feature state.
 *
 * @param {?Object} state - The current state.
 * @returns {{
 *     type: SET_FOLLOW_ME_STATE,
 *     state: Object
 * }}
 */
export function setFollowMeState(state?: Object) {
    return {
        type: SET_FOLLOW_ME_STATE,
        state
    };
}


################################################################################

## File: .\jitsi-meet\react\features\follow-me\actionTypes.ts

/**
 * The id of the Follow Me moderator.
 *
 * {
 *     type: SET_FOLLOW_ME_MODERATOR,
 *     id: boolean
 * }
 */
export const SET_FOLLOW_ME_MODERATOR = 'SET_FOLLOW_ME_MODERATOR';

/**
 * The type of (redux) action which updates the current known state of the
 * Follow Me feature.
 *
 *
 * {
 *     type: SET_FOLLOW_ME_STATE,
 *     state: boolean
 * }
 */
export const SET_FOLLOW_ME_STATE = 'SET_FOLLOW_ME_STATE';


################################################################################

## File: .\jitsi-meet\react\features\follow-me\constants.ts

/**
 * The (name of the) command which transports the state (represented by
 * {State} for the local state at the time of this writing) of a {FollowMe}
 * (instance) between participants.
 */
export const FOLLOW_ME_COMMAND = 'follow-me';


################################################################################

## File: .\jitsi-meet\react\features\follow-me\functions.ts

import { IStateful } from '../base/app/types';
import { toState } from '../base/redux/functions';

/**
 * Returns true if follow me is active and false otherwise.
 *
 * @param {Object|Function} stateful - Object or function that can be resolved
 * to the Redux state.
 * @returns {boolean} - True if follow me is active and false otherwise.
 */
export function isFollowMeActive(stateful: IStateful) {
    const state = toState(stateful);

    return Boolean(state['features/follow-me'].moderator);
}

/**
 * Returns true if follow me is active only for the recorder and false otherwise.
 *
 * @param {Object|Function} stateful - Object or function that can be resolved
 * to the Redux state.
 * @returns {boolean} - True if follow me is active and false otherwise.
 */
export function isFollowMeRecorderActive(stateful: IStateful) {
    const state = toState(stateful);

    return Boolean(state['features/follow-me'].recorder);
}


################################################################################

## File: .\jitsi-meet\react\features\follow-me\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/follow-me');


################################################################################

## File: .\jitsi-meet\react\features\follow-me\middleware.ts

import { differenceWith, isEqual } from 'lodash-es';

import { IStore } from '../app/types';
import { CONFERENCE_JOIN_IN_PROGRESS } from '../base/conference/actionTypes';
import { PARTICIPANT_LEFT } from '../base/participants/actionTypes';
import { pinParticipant } from '../base/participants/actions';
import { getParticipantById, getPinnedParticipant } from '../base/participants/functions';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import { updateSettings } from '../base/settings/actions';
import { addStageParticipant, removeStageParticipant, setFilmstripVisible } from '../filmstrip/actions';
import { setTileView } from '../video-layout/actions.any';

import {
    setFollowMeModerator,
    setFollowMeState
} from './actions';
import { FOLLOW_ME_COMMAND } from './constants';
import { isFollowMeActive } from './functions';
import logger from './logger';

import './subscriber';

/**
 * The timeout after which a follow-me command that has been received will be
 * ignored if not consumed.
 *
 * @type {number} in seconds
 * @private
 */
const _FOLLOW_ME_RECEIVED_TIMEOUT = 30;

/**
 * An instance of a timeout used as a workaround when attempting to pin a
 * non-existent particapant, which may be caused by participant join information
 * not being received yet.
 *
 * @type {TimeoutID}
 */
let nextOnStageTimeout: number;

/**
 * A count of how many seconds the nextOnStageTimeout has ticked while waiting
 * for a participant to be discovered that should be pinned. This variable
 * works in conjunction with {@code _FOLLOW_ME_RECEIVED_TIMEOUT} and
 * {@code nextOnStageTimeout}.
 *
 * @type {number}
 */
let nextOnStageTimer = 0;

/**
 * Represents "Follow Me" feature which enables a moderator to (partially)
 * control the user experience/interface (e.g. Filmstrip visibility) of (other)
 * non-moderator participant.
 */
MiddlewareRegistry.register(store => next => action => {
    switch (action.type) {
    case CONFERENCE_JOIN_IN_PROGRESS: {
        const { conference } = action;

        conference.addCommandListener(
            FOLLOW_ME_COMMAND, ({ attributes }: any, id: string) => {
                _onFollowMeCommand(attributes, id, store);
            });
        break;
    }
    case PARTICIPANT_LEFT:
        if (store.getState()['features/follow-me'].moderator === action.participant.id) {
            store.dispatch(setFollowMeModerator());
        }
        break;
    }

    return next(action);
});

/**
 * Notifies this instance about a "Follow Me" command received by the Jitsi
 * conference.
 *
 * @param {Object} attributes - The attributes carried by the command.
 * @param {string} id - The identifier of the participant who issuing the
 * command. A notable idiosyncrasy to be mindful of here is that the command
 * may be issued by the local participant.
 * @param {Object} store - The redux store. Used to calculate and dispatch
 * updates.
 * @private
 * @returns {void}
 */
function _onFollowMeCommand(attributes: any = {}, id: string, store: IStore) {
    const state = store.getState();

    // We require to know who issued the command because (1) only a
    // moderator is allowed to send commands and (2) a command MUST be
    // issued by a defined commander.
    if (typeof id === 'undefined') {
        return;
    }

    const participantSendingCommand = getParticipantById(state, id);

    if (participantSendingCommand) {
        // The Command(s) API will send us our own commands and we don't want
        // to act upon them.
        if (participantSendingCommand.local) {
            return;
        }

        if (participantSendingCommand.role !== 'moderator') {
            logger.warn('Received follow-me command not from moderator');

            return;
        }
    } else {
        // This is the case of jibri receiving commands from a hidden participant.
        const { iAmRecorder } = state['features/base/config'];
        const { conference } = state['features/base/conference'];

        // As this participant is not stored in redux store we do the checks on the JitsiParticipant from lib-jitsi-meet
        const participant = conference?.getParticipantById(id);

        if (!iAmRecorder || !participant || participant.getRole() !== 'moderator'
            || !participant.isHiddenFromRecorder()) {
            logger.warn('Something went wrong with follow-me command');

            return;
        }
    }

    if (!isFollowMeActive(state)) {
        store.dispatch(setFollowMeModerator(id, attributes.recorder));
    }

    // just a command that follow me was turned off
    if (attributes.off) {
        store.dispatch(setFollowMeModerator());

        return;
    }

    // when recorder flag is on, follow me is handled only on recorder side
    if (attributes.recorder && !store.getState()['features/base/config'].iAmRecorder) {
        return;
    }

    const oldState = state['features/follow-me'].state || {};

    store.dispatch(setFollowMeState(attributes));

    // XMPP will translate all booleans to strings, so explicitly check against
    // the string form of the boolean {@code true}.
    if (oldState.filmstripVisible !== attributes.filmstripVisible) {
        store.dispatch(setFilmstripVisible(attributes.filmstripVisible === 'true'));
    }

    if (oldState.tileViewEnabled !== attributes.tileViewEnabled) {
        store.dispatch(setTileView(attributes.tileViewEnabled === 'true'));
    }

    // For now gate etherpad checks behind a web-app check to be extra safe
    // against calling a web-app global.
    if (typeof APP !== 'undefined'
        && oldState.sharedDocumentVisible !== attributes.sharedDocumentVisible) {
        const isEtherpadVisible = attributes.sharedDocumentVisible === 'true';
        const documentManager = APP.UI.getSharedDocumentManager();

        if (documentManager
                && isEtherpadVisible !== state['features/etherpad'].editing) {
            documentManager.toggleEtherpad();
        }
    }

    const pinnedParticipant = getPinnedParticipant(state);
    const idOfParticipantToPin = attributes.nextOnStage;

    if (typeof idOfParticipantToPin !== 'undefined'
            && (!pinnedParticipant || idOfParticipantToPin !== pinnedParticipant.id)
            && oldState.nextOnStage !== attributes.nextOnStage) {
        _pinVideoThumbnailById(store, idOfParticipantToPin);
    } else if (typeof idOfParticipantToPin === 'undefined' && pinnedParticipant) {
        store.dispatch(pinParticipant(null));
    }

    if (attributes.pinnedStageParticipants !== undefined) {
        const stageParticipants = JSON.parse(attributes.pinnedStageParticipants);
        let oldStageParticipants = [];

        if (oldState.pinnedStageParticipants !== undefined) {
            oldStageParticipants = JSON.parse(oldState.pinnedStageParticipants);
        }

        if (!isEqual(stageParticipants, oldStageParticipants)) {
            const toRemove = differenceWith(oldStageParticipants, stageParticipants, isEqual);
            const toAdd = differenceWith(stageParticipants, oldStageParticipants, isEqual);

            toRemove.forEach((p: { participantId: string; }) =>
                store.dispatch(removeStageParticipant(p.participantId)));
            toAdd.forEach((p: { participantId: string; }) =>
                store.dispatch(addStageParticipant(p.participantId, true)));
        }
    }

    if (attributes.maxStageParticipants !== undefined
        && oldState.maxStageParticipants !== attributes.maxStageParticipants) {
        store.dispatch(updateSettings({
            maxStageParticipants: Number(attributes.maxStageParticipants)
        }));
    }
}

/**
 * Pins the video thumbnail given by clickId.
 *
 * @param {Object} store - The redux store.
 * @param {string} clickId - The identifier of the participant to pin.
 * @private
 * @returns {void}
 */
function _pinVideoThumbnailById(store: IStore, clickId: string) {
    if (getParticipantById(store.getState(), clickId)) {
        clearTimeout(nextOnStageTimeout);
        nextOnStageTimer = 0;

        store.dispatch(pinParticipant(clickId));
    } else {
        nextOnStageTimeout = window.setTimeout(() => {
            if (nextOnStageTimer > _FOLLOW_ME_RECEIVED_TIMEOUT) {
                nextOnStageTimer = 0;

                return;
            }

            nextOnStageTimer++;

            _pinVideoThumbnailById(store, clickId);
        }, 1000);
    }
}


################################################################################

## File: .\jitsi-meet\react\features\follow-me\reducer.ts

import ReducerRegistry from '../base/redux/ReducerRegistry';
import { set } from '../base/redux/functions';

import {
    SET_FOLLOW_ME_MODERATOR,
    SET_FOLLOW_ME_STATE
} from './actionTypes';

export interface IFollowMeState {
    moderator?: string;
    recorder?: boolean;
    state?: {
        [key: string]: string;
    };
}

/**
 * Listen for actions that contain the Follow Me feature active state, so that it can be stored.
 */
ReducerRegistry.register<IFollowMeState>(
    'features/follow-me',
    (state = {}, action): IFollowMeState => {
        switch (action.type) {

        case SET_FOLLOW_ME_MODERATOR: {
            let newState = set(state, 'moderator', action.id);

            if (action.id) {
                newState = set(newState, 'recorder', action.forRecorder);
            } else {
                // clear the state if feature becomes disabled
                newState = set(newState, 'state', undefined);
                newState = set(newState, 'recorder', undefined);
            }

            return newState;
        }
        case SET_FOLLOW_ME_STATE: {
            return set(state, 'state', action.state);
        }
        }

        return state;
    });


################################################################################

## File: .\jitsi-meet\react\features\follow-me\subscriber.ts

import { IReduxState, IStore } from '../app/types';
import { getCurrentConference } from '../base/conference/functions';
import {
    getPinnedParticipant,
    isLocalParticipantModerator
} from '../base/participants/functions';
import StateListenerRegistry from '../base/redux/StateListenerRegistry';
import { getPinnedActiveParticipants, isStageFilmstripEnabled } from '../filmstrip/functions';
import { shouldDisplayTileView } from '../video-layout/functions';

import { FOLLOW_ME_COMMAND } from './constants';

/**
 * Subscribes to changes to the Follow Me setting for the local participant to
 * notify remote participants of current user interface status.
 * Changing newSelectedValue param to off, when feature is turned of so we can
 * notify all listeners.
 */
StateListenerRegistry.register(
    /* selector */ state => state['features/base/conference'].followMeEnabled,
    /* listener */ (newSelectedValue, store) => _sendFollowMeCommand(newSelectedValue || 'off', store));

/**
 * Subscribes to changes to the currently pinned participant in the user
 * interface of the local participant.
 */
StateListenerRegistry.register(
    /* selector */ state => {
        const pinnedParticipant = getPinnedParticipant(state);

        return pinnedParticipant ? pinnedParticipant.id : null;
    },
    /* listener */ _sendFollowMeCommand);

/**
 * Subscribes to changes to the shared document (etherpad) visibility in the
 * user interface of the local participant.
 *
 * @param sharedDocumentVisible - {Boolean} {true} If the shared document was
 * shown (as a result of the toggle) or {false} if it was hidden.
 */
StateListenerRegistry.register(
    /* selector */ state => state['features/etherpad'].editing,
    /* listener */ _sendFollowMeCommand);

/**
 * Subscribes to changes to the filmstrip visibility in the user interface of
 * the local participant.
 */
StateListenerRegistry.register(
    /* selector */ state => state['features/filmstrip'].visible,
    /* listener */ _sendFollowMeCommand);

/**
 * Subscribes to changes to the stage filmstrip participants.
 */
StateListenerRegistry.register(
    /* selector */ getPinnedActiveParticipants,
    /* listener */ _sendFollowMeCommand,
    {
        deepEquals: true
    });

/**
 * Subscribes to changes to the tile view setting in the user interface of the
 * local participant.
 */
StateListenerRegistry.register(
    /* selector */ state => state['features/video-layout'].tileViewEnabled,
    /* listener */ _sendFollowMeCommand);

/**
 * Subscribes to changes to the max number of stage participants setting.
 */
StateListenerRegistry.register(
    /* selector */ state => state['features/base/settings'].maxStageParticipants,
    /* listener */ _sendFollowMeCommand);

/**
 * Private selector for returning state from redux that should be respected by
 * other participants while follow me is enabled.
 *
 * @param {Object} state - The redux state.
 * @returns {Object}
 */
function _getFollowMeState(state: IReduxState) {
    const pinnedParticipant = getPinnedParticipant(state);
    const stageFilmstrip = isStageFilmstripEnabled(state);

    return {
        recorder: state['features/base/conference'].followMeRecorderEnabled,
        filmstripVisible: state['features/filmstrip'].visible,
        maxStageParticipants: stageFilmstrip ? state['features/base/settings'].maxStageParticipants : undefined,
        nextOnStage: pinnedParticipant?.id,
        pinnedStageParticipants: stageFilmstrip ? JSON.stringify(getPinnedActiveParticipants(state)) : undefined,
        sharedDocumentVisible: state['features/etherpad'].editing,
        tileViewEnabled: shouldDisplayTileView(state)
    };
}

/**
 * Sends the follow-me command, when a local property change occurs.
 *
 * @param {*} newSelectedValue - The changed selected value from the selector.
 * @param {Object} store - The redux store.
 * @private
 * @returns {void}
 */
function _sendFollowMeCommand(
        newSelectedValue: any, store: IStore) {
    const state = store.getState();
    const conference = getCurrentConference(state);

    if (!conference) {
        return;
    }

    // Only a moderator is allowed to send commands.
    if (!isLocalParticipantModerator(state)) {
        return;
    }

    if (newSelectedValue === 'off') {
        // if the change is to off, local user turned off follow me and
        // we want to signal this

        conference.sendCommandOnce(
            FOLLOW_ME_COMMAND,
            { attributes: { off: true } }
        );

        return;
    } else if (!state['features/base/conference'].followMeEnabled) {
        return;
    }

    conference.sendCommand(
        FOLLOW_ME_COMMAND,
        { attributes: _getFollowMeState(state) }
    );
}


################################################################################

## File: .\jitsi-meet\react\features\gifs\actions.ts

import {
    ADD_GIF_FOR_PARTICIPANT,
    HIDE_GIF_FOR_PARTICIPANT,
    REMOVE_GIF_FOR_PARTICIPANT,
    SET_GIF_MENU_VISIBILITY,
    SHOW_GIF_FOR_PARTICIPANT
} from './actionTypes';

/**
 * Adds a GIF for a given participant.
 *
 * @param {string} participantId - The id of the participant that sent the GIF.
 * @param {string} gifUrl - The URL of the GIF.
 * @returns {Object}
 */
export function addGif(participantId: string, gifUrl: string) {
    return {
        type: ADD_GIF_FOR_PARTICIPANT,
        participantId,
        gifUrl
    };
}

/**
 * Removes the GIF of the given participant.
 *
 * @param {string} participantId - The Id of the participant for whom to remove the GIF.
 * @returns {Object}
 */
export function removeGif(participantId: string) {
    return {
        type: REMOVE_GIF_FOR_PARTICIPANT,
        participantId
    };
}

/**
 * Keep showing the GIF of the given participant.
 *
 * @param {string} participantId - The Id of the participant for whom to show the GIF.
 * @returns {Object}
 */
export function showGif(participantId: string) {
    return {
        type: SHOW_GIF_FOR_PARTICIPANT,
        participantId
    };
}

/**
 * Set timeout to hide the GIF of the given participant.
 *
 * @param {string} participantId - The Id of the participant for whom to show the GIF.
 * @returns {Object}
 */
export function hideGif(participantId: string) {
    return {
        type: HIDE_GIF_FOR_PARTICIPANT,
        participantId
    };
}

/**
 * Set visibility of the GIF menu.
 *
 * @param {boolean} visible - Whether or not it should be visible.
 * @returns {Object}
 */
export function setGifMenuVisibility(visible: boolean) {
    return {
        type: SET_GIF_MENU_VISIBILITY,
        visible
    };
}


################################################################################

## File: .\jitsi-meet\react\features\gifs\actionTypes.ts

/**
 * Adds a gif for a given participant.
 * {{
 *      type: ADD_GIF_FOR_PARTICIPANT,
 *      participantId: string,
 *      gifUrl: string,
 *      timeoutID: number
 * }}
 */
export const ADD_GIF_FOR_PARTICIPANT = 'ADD_GIF_FOR_PARTICIPANT';

/**
 * Set timeout to hide a gif for a given participant.
 * {{
 *      type: HIDE_GIF_FOR_PARTICIPANT,
 *      participantId: string
 * }}
 */
export const HIDE_GIF_FOR_PARTICIPANT = 'HIDE_GIF_FOR_PARTICIPANT';

/**
 * Removes a gif for a given participant.
 * {{
 *      type: REMOVE_GIF_FOR_PARTICIPANT,
 *      participantId: string
 * }}
 */
export const REMOVE_GIF_FOR_PARTICIPANT = 'REMOVE_GIF_FOR_PARTICIPANT';

/**
 * Set gif menu visibility.
 * {{
 *      type: SET_GIF_MENU_VISIBILITY,
 *      visible: boolean
 * }}
 */
export const SET_GIF_MENU_VISIBILITY = 'SET_GIF_MENU_VISIBILITY';

/**
 * Keep showing a gif for a given participant.
 * {{
 *      type: SHOW_GIF_FOR_PARTICIPANT,
 *      participantId: string
 * }}
 */
export const SHOW_GIF_FOR_PARTICIPANT = 'SHOW_GIF_FOR_PARTICIPANT';


################################################################################

## File: .\jitsi-meet\react\features\gifs\constants.ts

/**
 * The default time that GIFs will be displayed on the tile.
 */
export const GIF_DEFAULT_TIMEOUT = 5000;

/**
 * The prefix for formatted GIF messages.
 */
export const GIF_PREFIX = 'gif[';

/**
 * The Giphy default option for audience rating.
 */
export const GIF_DEFAULT_RATING = 'g';


################################################################################

## File: .\jitsi-meet\react\features\gifs\function.any.ts

import { IReduxState } from '../app/types';

import { GIF_DEFAULT_RATING, GIF_PREFIX } from './constants';
import { IGif } from './reducer';

/**
 * Returns the gif config.
 *
 * @param {IReduxState} state - Redux state.
 * @returns {Object}
 */
export function getGifConfig(state: IReduxState) {
    return state['features/base/config'].giphy || {};
}

/**
 * Get the GIF display mode.
 *
 * @param {IReduxState} state - Redux state.
 * @returns {string}
 */
export function getGifDisplayMode(state: IReduxState) {
    return getGifConfig(state).displayMode || 'all';
}

/**
 * Get the GIF audience rating.
 *
 * @param {IReduxState} state - Redux state.
 * @returns {string}
 */
export function getGifRating(state: IReduxState) {
    return getGifConfig(state).rating || GIF_DEFAULT_RATING;
}


/**
 * Gets the URL of the GIF for the given participant or null if there's none.
 *
 * @param {IReduxState} state - Redux state.
 * @param {string} participantId - Id of the participant for which to remove the GIF.
 * @returns {Object}
 */
export function getGifForParticipant(state: IReduxState, participantId: string): IGif {
    return isGifEnabled(state) ? state['features/gifs'].gifList.get(participantId) || {} : {};
}

/**
 * Returns true if a given URL is allowed to be rendered as gif and false otherwise.
 *
 * @param {string} url - The URL to be validated.
 * @returns {boolean} - True if a given URL is allowed to be rendered as gif and false otherwise.
 */
export function isGifUrlAllowed(url: string) {
    let hostname: string | undefined;

    try {
        const urlObject = new URL(url);

        hostname = urlObject?.hostname;
    } catch (_error) {
        return false;
    }

    return hostname === 'i.giphy.com';
}

/**
 * Whether or not the message is a GIF message.
 *
 * @param {string} message - Message to check.
 * @returns {boolean}
 */
export function isGifMessage(message = '') {
    const trimmedMessage = message.trim();

    if (!trimmedMessage.toLowerCase().startsWith(GIF_PREFIX)) {
        return false;
    }

    const url = extractGifURL(trimmedMessage);

    return isGifUrlAllowed(url);
}

/**
 * Extracts the URL from a gif message.
 *
 * @param {string} message - The message.
 * @returns {string} - The URL.
 */
export function extractGifURL(message = '') {
    const trimmedMessage = message.trim();

    return trimmedMessage.substring(GIF_PREFIX.length, trimmedMessage.length - 1);

}

/**
 * Returns the url of the gif selected in the gifs menu.
 *
 * @param {Object} gif - The gif data.
 * @returns {boolean}
 */
export function getGifUrl(gif?: { data?: { embed_url: string; }; embed_url?: string; }) {
    const embedUrl = gif?.embed_url || gif?.data?.embed_url || '';
    const idx = embedUrl.lastIndexOf('/');
    const id = embedUrl.substr(idx + 1);

    return `https://i.giphy.com/media/${id}/giphy.gif`;
}

/**
 * Formats the gif message.
 *
 * @param {string} url - GIF url.
 * @returns {string}
 */
export function formatGifUrlMessage(url: string) {
    return `${GIF_PREFIX}${url}]`;
}

/**
 * Get the Giphy API Key from config.
 *
 * @param {IReduxState} state - Redux state.
 * @returns {string}
 */
export function getGifAPIKey(state: IReduxState) {
    return getGifConfig(state).sdkKey ?? '';
}

/**
 * Returns whether or not the feature is enabled.
 *
 * @param {IReduxState} state - Redux state.
 * @returns {boolean}
 */
export function isGifEnabled(state: IReduxState) {
    const { disableThirdPartyRequests } = state['features/base/config'];
    const { giphy } = state['features/base/config'];
    const showGiphyIntegration = state['features/dynamic-branding']?.showGiphyIntegration !== false;

    if (navigator.product === 'ReactNative' && window.JITSI_MEET_LITE_SDK) {
        return false;
    }

    return showGiphyIntegration && Boolean(!disableThirdPartyRequests && giphy?.enabled && Boolean(giphy?.sdkKey));
}



################################################################################

## File: .\jitsi-meet\react\features\gifs\functions.native.ts

export * from './function.any';


################################################################################

## File: .\jitsi-meet\react\features\gifs\functions.web.ts

import { IReduxState } from '../app/types';

export * from './function.any';

/**
 * Returns the visibility state of the gifs menu.
 *
 * @param {IReduxState} state - The state of the application.
 * @returns {boolean}
 */
export function isGifsMenuOpen(state: IReduxState) {
    return state['features/gifs'].menuOpen;
}


################################################################################

## File: .\jitsi-meet\react\features\gifs\middleware.any.ts

import { IReduxState } from '../app/types';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';

import { ADD_GIF_FOR_PARTICIPANT, HIDE_GIF_FOR_PARTICIPANT, SHOW_GIF_FOR_PARTICIPANT } from './actionTypes';
import { removeGif } from './actions';
import { GIF_DEFAULT_TIMEOUT } from './constants';
import { getGifForParticipant } from './function.any';

/**
 * Middleware which intercepts Gifs actions to handle changes to the
 * visibility timeout of the Gifs.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {
    const { dispatch, getState } = store;
    const state = getState();

    switch (action.type) {
    case ADD_GIF_FOR_PARTICIPANT: {
        const id = action.participantId;
        const { giphy } = state['features/base/config'];

        _clearGifTimeout(state, id);
        const timeoutID = setTimeout(() => dispatch(removeGif(id)), giphy?.tileTime || GIF_DEFAULT_TIMEOUT);

        action.timeoutID = timeoutID;
        break;
    }
    case SHOW_GIF_FOR_PARTICIPANT: {
        const id = action.participantId;

        _clearGifTimeout(state, id);
        break;
    }
    case HIDE_GIF_FOR_PARTICIPANT: {
        const { giphy } = state['features/base/config'];
        const id = action.participantId;
        const timeoutID = setTimeout(() => dispatch(removeGif(id)), giphy?.tileTime || GIF_DEFAULT_TIMEOUT);

        action.timeoutID = timeoutID;
        break;
    }
    }

    return next(action);
});

/**
 * Clears GIF timeout.
 *
 * @param {IReduxState} state - Redux state.
 * @param {string} id - Id of the participant for whom to clear the timeout.
 * @returns {void}
 */
function _clearGifTimeout(state: IReduxState, id: string) {
    const gif = getGifForParticipant(state, id);

    clearTimeout(gif?.timeoutID ?? -1);
}


################################################################################

## File: .\jitsi-meet\react\features\gifs\middleware.native.ts


import './middleware.any';
import './subscriber.native';


################################################################################

## File: .\jitsi-meet\react\features\gifs\middleware.web.ts


import './middleware.any';


################################################################################

## File: .\jitsi-meet\react\features\gifs\reducer.ts

import ReducerRegistry from '../base/redux/ReducerRegistry';

import {
    ADD_GIF_FOR_PARTICIPANT,
    HIDE_GIF_FOR_PARTICIPANT,
    REMOVE_GIF_FOR_PARTICIPANT,
    SET_GIF_MENU_VISIBILITY
} from './actionTypes';

const initialState = {
    gifList: new Map(),
    menuOpen: false
};

export interface IGif {
    gifUrl?: string;
    timeoutID?: number;
}

export interface IGifsState {
    gifList: Map<string, IGif>;
    menuOpen: boolean;
}

ReducerRegistry.register<IGifsState>(
    'features/gifs',
    (state = initialState, action): IGifsState => {
        switch (action.type) {
        case ADD_GIF_FOR_PARTICIPANT: {
            const newList = state.gifList;

            newList.set(action.participantId, {
                gifUrl: action.gifUrl,
                timeoutID: action.timeoutID
            });

            return {
                ...state,
                gifList: newList
            };
        }
        case REMOVE_GIF_FOR_PARTICIPANT: {
            const newList = state.gifList;

            newList.delete(action.participantId);

            return {
                ...state,
                gifList: newList
            };
        }
        case HIDE_GIF_FOR_PARTICIPANT: {
            const newList = state.gifList;
            const gif = state.gifList.get(action.participantId);

            newList.set(action.participantId, {
                gifUrl: gif?.gifUrl ?? '',
                timeoutID: action.timeoutID
            });

            return {
                ...state,
                gifList: newList
            };
        }
        case SET_GIF_MENU_VISIBILITY:
            return {
                ...state,
                menuOpen: action.visible
            };
        }

        return state;
    });



################################################################################

## File: .\jitsi-meet\react\features\gifs\subscriber.native.ts

import { GiphySDK } from '@giphy/react-native-sdk';

import StateListenerRegistry from '../base/redux/StateListenerRegistry';

import { getGifConfig, isGifEnabled } from './function.any';

/**
 * Listens for changes in the number of participants to calculate the dimensions of the tile view grid and the tiles.
 */
StateListenerRegistry.register(
    /* selector */ state => getGifConfig(state),
    /* listener */ (_, store) => {
        const state = store.getState();

        if (isGifEnabled(state)) {
            GiphySDK.configure({ apiKey: state['features/base/config'].giphy?.sdkKey ?? '' });
        }
    }, {
        deepEquals: true
    });


################################################################################

## File: .\jitsi-meet\react\features\gifs\components\native\styles.ts

import BaseTheme from '../../../base/ui/components/BaseTheme.native';

export default {
    container: {
        backgroundColor: BaseTheme.palette.ui01,
        flex: 1
    },

    customContainer: {
        marginHorizontal: BaseTheme.spacing[3],
        marginVertical: BaseTheme.spacing[2]
    },

    grid: {
        flex: 1,
        marginLeft: BaseTheme.spacing[3],
        marginRight: BaseTheme.spacing[3]
    },

    credit: {
        alignItems: 'center',
        backgroundColor: BaseTheme.palette.ui01,
        display: 'flex',
        flexDirection: 'row',
        height: 56,
        justifyContent: 'center',
        marginBottom: BaseTheme.spacing[0],
        paddingBottom: BaseTheme.spacing[4],
        width: '100%'
    },

    creditText: {
        color: BaseTheme.palette.text01,
        fontWeight: 'bold'
    }
};


################################################################################

## File: .\jitsi-meet\react\features\google-api\actions.ts

import { IStore } from '../app/types';
import { getShareInfoText } from '../invite/functions';
import { getLiveStreaming } from '../recording/components/LiveStream/functions';

import {
    SET_GOOGLE_API_PROFILE,
    SET_GOOGLE_API_STATE
} from './actionTypes';
import { GOOGLE_API_STATES } from './constants';
// eslint-disable-next-line lines-around-comment
// @ts-ignore
import googleApi from './googleApi';

/**
 * Retrieves the current calendar events.
 *
 * @param {number} fetchStartDays - The number of days to go back when fetching.
 * @param {number} fetchEndDays - The number of days to fetch.
 * @returns {function(Dispatch<any>): Promise<CalendarEntries>}
 */
export function getCalendarEntries(
        fetchStartDays?: number, fetchEndDays?: number) {
    return () =>
        googleApi.get()
        .then(() =>
            googleApi._getCalendarEntries(fetchStartDays, fetchEndDays));
}

/**
 * Loads Google API.
 *
 * @returns {Function}
 */
export function loadGoogleAPI() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) =>
        googleApi.get()
        .then(() => {
            const {
                enableCalendarIntegration,
                googleApiApplicationClientID
            } = getState()['features/base/config'];

            const liveStreaming = getLiveStreaming(getState());

            if (getState()['features/google-api'].googleAPIState
                    === GOOGLE_API_STATES.NEEDS_LOADING) {
                return googleApi.initializeClient(
                    googleApiApplicationClientID, liveStreaming.enabled, enableCalendarIntegration);
            }

            return Promise.resolve();
        })
        .then(() => dispatch(setGoogleAPIState(GOOGLE_API_STATES.LOADED)))
        .then(() => googleApi.signInIfNotSignedIn())
        .then(() => googleApi.isSignedIn())
        .then((isSignedIn: boolean) => {
            if (isSignedIn) {
                dispatch(setGoogleAPIState(GOOGLE_API_STATES.SIGNED_IN));
            }
        });
}

/**
 * Executes a request for a list of all YouTube broadcasts associated with
 * user currently signed in to the Google API Client Library.
 *
 * @returns {function(): (Promise<*>|Promise<any[] | never>)}
 */
export function requestAvailableYouTubeBroadcasts() {
    return () =>
        googleApi.requestAvailableYouTubeBroadcasts()
        .then((response: any) => {
            // Takes in a list of broadcasts from the YouTube API,
            // removes dupes, removes broadcasts that cannot get a stream key,
            // and parses the broadcasts into flat objects.
            const broadcasts = response.result.items;

            const parsedBroadcasts: any = {};

            for (let i = 0; i < broadcasts.length; i++) {
                const broadcast = broadcasts[i];
                const boundStreamID = broadcast.contentDetails.boundStreamId;

                if (boundStreamID && !parsedBroadcasts[boundStreamID]) {
                    parsedBroadcasts[boundStreamID] = {
                        boundStreamID,
                        id: broadcast.id,
                        status: broadcast.status.lifeCycleStatus,
                        title: broadcast.snippet.title
                    };
                }
            }

            return Object.values(parsedBroadcasts);
        });
}

/**
 * Fetches the stream key for a YouTube broadcast and updates the internal
 * state to display the associated stream key as being entered.
 *
 * @param {string} boundStreamID - The bound stream ID associated with the
 * broadcast from which to get the stream key.
 * @returns {function(): (Promise<*>|Promise<{
 *  streamKey: (*|string),
 *  selectedBoundStreamID: *} | never>)}
 */
export function requestLiveStreamsForYouTubeBroadcast(boundStreamID: string) {
    return () =>
        googleApi.requestLiveStreamsForYouTubeBroadcast(boundStreamID)
            .then((response: any) => {
                const broadcasts = response.result.items;
                const streamName = broadcasts?.[0]?.cdn.ingestionInfo.streamName;
                const streamKey = streamName || '';

                return {
                    streamKey,
                    selectedBoundStreamID: boundStreamID
                };
            });
}

/**
 * Sets the current Google API state.
 *
 * @param {number} googleAPIState - The state to be set.
 * @param {Object} googleResponse - The last response from Google.
 * @returns {{
 *     type: SET_GOOGLE_API_STATE,
 *     googleAPIState: number
 * }}
 */
export function setGoogleAPIState(
        googleAPIState: number, googleResponse?: Object) {
    return {
        type: SET_GOOGLE_API_STATE,
        googleAPIState,
        googleResponse
    };
}

/**
 * Forces the Google web client application to prompt for a sign in, such as
 * when changing account, and will then fetch available YouTube broadcasts.
 *
 * @returns {function(): (Promise<*>|Promise<{
 *  streamKey: (*|string),
 *  selectedBoundStreamID: *} | never>)}
 */
export function showAccountSelection() {
    return () => googleApi.showAccountSelection(true);
}

/**
 * Prompts the participant to sign in to the Google API Client Library.
 *
 * @returns {function(Dispatch<any>): Promise<string | never>}
 */
export function signIn() {
    return (dispatch: IStore['dispatch']) => googleApi.get()
            .then(() => googleApi.signInIfNotSignedIn(true))
            .then(() => dispatch({
                type: SET_GOOGLE_API_STATE,
                googleAPIState: GOOGLE_API_STATES.SIGNED_IN
            }));
}

/**
 * Logs out the user.
 *
 * @returns {function(Dispatch<any>): Promise<string | never>}
 */
export function signOut() {
    return (dispatch: IStore['dispatch']) =>
        googleApi.get()
            .then(() => googleApi.signOut())
            .then(() => {
                dispatch({
                    type: SET_GOOGLE_API_STATE,
                    googleAPIState: GOOGLE_API_STATES.LOADED
                });
                dispatch({
                    type: SET_GOOGLE_API_PROFILE,
                    profileEmail: ''
                });
            });
}

/**
 * Updates the profile data that is currently used.
 *
 * @returns {function(Dispatch<any>): Promise<string | never>}
 */
export function updateProfile() {
    return (dispatch: IStore['dispatch']) => googleApi.get()
        .then(() => googleApi.signInIfNotSignedIn())
        .then(() => dispatch({
            type: SET_GOOGLE_API_STATE,
            googleAPIState: GOOGLE_API_STATES.SIGNED_IN
        }))
        .then(() => googleApi.getCurrentUserProfile())
        .then((profile: any) => {
            dispatch({
                type: SET_GOOGLE_API_PROFILE,
                profileEmail: profile.email
            });

            return profile.email;
        });
}

/**
 * Updates the calendar event and adds a location and text.
 *
 * @param {string} id - The event id to update.
 * @param {string} calendarId - The calendar id to use.
 * @param {string} location - The location to add to the event.
 * @returns {function(Dispatch<any>): Promise<string | never>}
 */
export function updateCalendarEvent(
        id: string, calendarId: string, location: string) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) =>
        getShareInfoText(getState(), location)
            .then(text =>
                googleApi._updateCalendarEntry(id, calendarId, location, text));
}


################################################################################

## File: .\jitsi-meet\react\features\google-api\actionTypes.ts

/**
 * The type of Redux action which changes Google API state.
 *
 * {
 *     type: SET_GOOGLE_API_STATE
 * }
 * @public
 */
export const SET_GOOGLE_API_STATE = 'SET_GOOGLE_API_STATE';

/**
 * The type of Redux action which changes Google API profile state.
 *
 * {
 *     type: SET_GOOGLE_API_PROFILE
 * }
 * @public
 */
export const SET_GOOGLE_API_PROFILE = 'SET_GOOGLE_API_PROFILE';


################################################################################

## File: .\jitsi-meet\react\features\google-api\constants.ts

/**
 * Google API URL to retrieve streams for a live broadcast of a user.
 *
 * NOTE: The URL must be appended by a broadcast ID returned by a call towards
 * {@code API_URL_LIVE_BROADCASTS}.
 *
 * @type {string}
 */
// eslint-disable-next-line max-len
export const API_URL_BROADCAST_STREAMS = 'https://content.googleapis.com/youtube/v3/liveStreams?part=id%2Csnippet%2Ccdn%2Cstatus&id=';

/**
 * Google API URL to retrieve live broadcasts of a user.
 *
 * @type {string}
 */
// eslint-disable-next-line max-len
export const API_URL_LIVE_BROADCASTS = 'https://content.googleapis.com/youtube/v3/liveBroadcasts?broadcastType=all&mine=true&part=id%2Csnippet%2CcontentDetails%2Cstatus';

/**
 * Array of API discovery doc URLs for APIs used by the googleApi.
 *
 * @type {string}
 */
export const DISCOVERY_DOCS = 'https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest';

/**
 * An enumeration of the different states the Google API can be in.
 *
 * @private
 * @type {Object}
 */
export const GOOGLE_API_STATES = {
    /**
     * The state in which the Google API still needs to be loaded.
     */
    NEEDS_LOADING: 0,

    /**
     * The state in which the Google API is loaded and ready for use.
     */
    LOADED: 1,

    /**
     * The state in which a user has been logged in through the Google API.
     */
    SIGNED_IN: 2,

    /**
     * The state in which the Google authentication is not available (e.g. Play
     * services are not installed on Android).
     */
    NOT_AVAILABLE: 3
};

/**
 * Google API auth scope to access Google calendar.
 *
 * @type {string}
 */
export const GOOGLE_SCOPE_CALENDAR = 'https://www.googleapis.com/auth/calendar';

/**
 * Google API auth scope to access user email.
 *
 * @type {string}
 */
export const GOOGLE_SCOPE_USERINFO = 'https://www.googleapis.com/auth/userinfo.email';

/**
 * Google API auth scope to access YouTube streams.
 *
 * @type {string}
 */
export const GOOGLE_SCOPE_YOUTUBE
    = 'https://www.googleapis.com/auth/youtube.readonly';


################################################################################

## File: .\jitsi-meet\react\features\google-api\googleApi.native.js

import { NativeModules } from 'react-native';

let GoogleSignin;

if (NativeModules.RNGoogleSignin) {
    GoogleSignin = require('@react-native-google-signin/google-signin').GoogleSignin;
}

import {
    API_URL_BROADCAST_STREAMS,
    API_URL_LIVE_BROADCASTS
} from './constants';

/**
 * Class to encapsulate Google API functionalities and provide a similar
 * interface to what WEB has. The methods are different, but the point is that
 * the export object is similar so no need for different export logic.
 *
 * For more detailed documentation of the {@code GoogleSignin} API, please visit
 * https://github.com/@react-native-google-signin/google-signin.
 */
class GoogleApi {
    /**
     * Wraps the {@code GoogleSignin.configure} method.
     *
     * @param {Object} config - The config object to be passed to
     * {@code GoogleSignin.configure}.
     * @returns {void}
     */
    configure(config) {
        if (GoogleSignin) {
            GoogleSignin.configure(config);
        }
    }

    /**
     * Retrieves the current tokens.
     *
     * @returns {Promise}
     */
    getTokens() {
        return GoogleSignin.getTokens();
    }

    /**
     * Retrieves the available YouTube streams the user can use for live
     * streaming.
     *
     * @param {string} accessToken - The Google auth token.
     * @returns {Promise}
     */
    getYouTubeLiveStreams(accessToken) {
        return new Promise((resolve, reject) => {

            // Fetching the list of available broadcasts first.
            this._fetchGoogleEndpoint(accessToken,
                API_URL_LIVE_BROADCASTS)
            .then(broadcasts => {
                // Then fetching all the available live streams that the
                // user has access to with the broadcasts we retrieved
                // earlier.
                this._getLiveStreamsForBroadcasts(
                    accessToken, broadcasts).then(resolve, reject);
            }, reject);
        });
    }

    /**
     * Wraps the {@code GoogleSignin.hasPlayServices} method.
     *
     * @returns {Promise<*>}
     */
    hasPlayServices() {
        if (!GoogleSignin) {
            return Promise.reject(new Error('Google SignIn not supported'));
        }

        return GoogleSignin.hasPlayServices();
    }

    /**
     * Wraps the {@code GoogleSignin.signIn} method.
     *
     * @returns {Promise<*>}
     */
    signIn() {
        return GoogleSignin.signIn();
    }

    /**
     * Wraps the {@code GoogleSignin.signInSilently} method.
     *
     * @returns {Promise<*>}
     */
    signInSilently() {
        return GoogleSignin.signInSilently();
    }

    /**
     * Wraps the {@code GoogleSignin.signOut} method.
     *
     * @returns {Promise<*>}
     */
    signOut() {
        return GoogleSignin.signOut();
    }

    /**
     * Helper method to fetch a Google API endpoint in a generic way.
     *
     * @private
     * @param {string} accessToken - The access token used for the API call.
     * @param {string} endpoint - The endpoint to fetch, including the URL
     * params if needed.
     * @returns {Promise}
     */
    _fetchGoogleEndpoint(accessToken, endpoint) {
        return new Promise((resolve, reject) => {
            const headers = {
                Authorization: `Bearer ${accessToken}`
            };

            fetch(endpoint, {
                headers
            }).then(response => response.json())
            .then(responseJSON => {
                if (responseJSON.error) {
                    reject(responseJSON.error.message);
                } else {
                    resolve(responseJSON.items || []);
                }
            }, reject);
        });
    }

    /**
     * Retrieves the available YouTube streams that are available for the
     * provided broadcast IDs.
     *
     * @private
     * @param {string} accessToken - The Google access token.
     * @param {Array<Object>} broadcasts - The list of broadcasts that we want
     * to retrieve streams for.
     * @returns {Promise}
     */
    _getLiveStreamsForBroadcasts(accessToken, broadcasts) {
        return new Promise((resolve, reject) => {
            const ids = [];

            for (const broadcast of broadcasts) {
                broadcast.contentDetails
                    && broadcast.contentDetails.boundStreamId
                    && ids.push(broadcast.contentDetails.boundStreamId);
            }

            this._fetchGoogleEndpoint(
                accessToken,
                `${API_URL_BROADCAST_STREAMS}${ids.join(',')}`)
                .then(streams => {
                    const keys = [];

                    // We construct an array of keys bind with the broadcast
                    // name for a nice display.
                    for (const stream of streams) {
                        const key = stream.cdn.ingestionInfo.streamName;
                        let title;

                        // Finding title from the broadcast with the same
                        // boundStreamId. If not found (unknown scenario), we
                        // use the key as title again.
                        for (const broadcast of broadcasts) {
                            if (broadcast.contentDetails
                                    && broadcast.contentDetails.boundStreamId
                                        === stream.id) {
                                title = broadcast.snippet.title;
                            }
                        }

                        keys.push({
                            key,
                            title: title || key
                        });
                    }

                    resolve(keys);
                }, reject);
        });
    }
}

export default new GoogleApi();


################################################################################

## File: .\jitsi-meet\react\features\google-api\googleApi.web.js

import {
    API_URL_BROADCAST_STREAMS,
    API_URL_LIVE_BROADCASTS,
    DISCOVERY_DOCS,
    GOOGLE_SCOPE_CALENDAR,
    GOOGLE_SCOPE_USERINFO,
    GOOGLE_SCOPE_YOUTUBE
} from './constants';
import logger from './logger';

const GOOGLE_API_CLIENT_LIBRARY_URL = 'https://apis.google.com/js/api.js';
const GOOGLE_GIS_LIBRARY_URL = 'https://accounts.google.com/gsi/client';

/**
 * A promise for dynamically loading the Google API Client Library.
 *
 * @private
 * @type {Promise}
 */
let googleClientLoadPromise;

/**
 * A singleton for loading and interacting with the Google API.
 */
const googleApi = {
    /**
     * Obtains Google API Client Library, loading the library dynamically if
     * needed.
     *
     * @returns {Promise}
     */
    get() {
        const globalGoogleApi = this._getGoogleApiClient();

        if (!globalGoogleApi) {
            return this.load();
        }

        return Promise.resolve(globalGoogleApi);
    },

    /**
     * Gets the profile for the user signed in to the Google API Client Library.
     *
     * @returns {Promise}
     */
    getCurrentUserProfile() {
        return this.get()
            .then(() => this.isSignedIn())
            .then(isSignedIn => {
                if (!isSignedIn) {
                    return null;
                }

                return this._getGoogleApiClient()
                    .client.oauth2
                    .userinfo.get().getPromise()
                    .then(r => r.result);
            });
    },

    /**
     * Sets the Google Web Client ID used for authenticating with Google and
     * making Google API requests.
     *
     * @param {string} clientId - The client ID to be used with the API library.
     * @param {boolean} enableYoutube - Whether youtube scope is enabled.
     * @param {boolean} enableCalendar - Whether calendar scope is enabled.
     * @returns {Promise}
     */
    initializeClient(clientId, enableYoutube, enableCalendar) {
        return this.get()
            .then(api => new Promise((resolve, reject) => {
                // setTimeout is used as a workaround for api.client.init not
                // resolving consistently when the Google API Client Library is
                // loaded asynchronously. See:
                // github.com/google/google-api-javascript-client/issues/399
                setTimeout(() => {
                    api.client.init({})
                    .then(() => {
                        if (enableCalendar) {
                            api.client.load(DISCOVERY_DOCS);
                        }
                    })
                    .then(() => {
                        api.client.load('https://www.googleapis.com/discovery/v1/apis/oauth2/v1/rest');
                    })
                    .then(resolve)
                    .catch(reject);
                }, 500);
            }))
            .then(() => new Promise((resolve, reject) => {
                try {
                    const scope
                        = `${enableYoutube ? GOOGLE_SCOPE_YOUTUBE : ''} ${enableCalendar ? GOOGLE_SCOPE_CALENDAR : ''}`
                        .trim();

                    this.tokenClient = this._getGoogleGISApiClient().accounts.oauth2.initTokenClient({
                        // eslint-disable-next-line camelcase
                        client_id: clientId,
                        scope: `${scope} ${GOOGLE_SCOPE_USERINFO}`,
                        callback: '' // defined at request time in await/promise scope.
                    });
                    resolve();
                } catch (err) {
                    reject(err);
                }
            }));
    },

    /**
     * Checks whether a user is currently authenticated with Google through an
     * initialized Google API Client Library.
     *
     * @returns {Promise}
     */
    isSignedIn() {
        return new Promise((resolve, _) => {
            const te = parseInt(this.tokenExpires, 10);
            const isExpired = isNaN(this.tokenExpires) ? true : new Date().getTime() > te;

            resolve(Boolean(!isExpired));
        });
    },

    /**
     * Generates a script tag.
     *
     * @param {string} src - The source for the script tag.
     * @returns {Promise<unknown>}
     * @private
     */
    _loadScriptTag(src) {
        return new Promise((resolve, reject) => {
            const scriptTag = document.createElement('script');

            scriptTag.async = true;
            scriptTag.addEventListener('error', () => {
                scriptTag.remove();

                reject();
            });
            scriptTag.addEventListener('load', resolve);
            scriptTag.type = 'text/javascript';

            scriptTag.src = src;

            document.head.appendChild(scriptTag);
        });
    },

    /**
     * Generates a script tag and downloads the Google API Client Library.
     *
     * @returns {Promise}
     */
    load() {
        if (googleClientLoadPromise) {
            return googleClientLoadPromise;
        }

        googleClientLoadPromise = this._loadScriptTag(GOOGLE_API_CLIENT_LIBRARY_URL)
            .catch(() => {
                googleClientLoadPromise = null;
            })
            .then(() => new Promise((resolve, reject) =>
                this._getGoogleApiClient().load('client', {
                    callback: resolve,
                    onerror: reject
                })))
            .then(this._loadScriptTag(GOOGLE_GIS_LIBRARY_URL))
            .catch(() => {
                googleClientLoadPromise = null;
            })
            .then(() => this._getGoogleApiClient());

        return googleClientLoadPromise;
    },

    /**
     * Executes a request for a list of all YouTube broadcasts associated with
     * user currently signed in to the Google API Client Library.
     *
     * @returns {Promise}
     */
    requestAvailableYouTubeBroadcasts() {
        return this.get()
            .then(api => api.client.request(API_URL_LIVE_BROADCASTS));
    },

    /**
     * Executes a request to get all live streams associated with a broadcast
     * in YouTube.
     *
     * @param {string} boundStreamID - The bound stream ID associated with a
     * broadcast in YouTube.
     * @returns {Promise}
     */
    requestLiveStreamsForYouTubeBroadcast(boundStreamID) {
        return this.get()
            .then(api => api.client.request(
                `${API_URL_BROADCAST_STREAMS}${boundStreamID}`));
    },

    /**
     * Prompts the participant to sign in to the Google API Client Library, even
     * if already signed in.
     *
     * @param {boolean} consent - Whether to show account selection dialog.
     * @returns {Promise}
     */
    showAccountSelection(consent) {
        return this.get()
            .then(api => new Promise((resolve, reject) => {
                try {
                    // Settle this promise in the response callback for requestAccessToken()
                    this.tokenClient.callback = resp => {
                        if (resp.error !== undefined) {
                            reject(resp);
                        }

                        // Get the number of seconds the token is valid for, subtract 5 minutes
                        // to account for differences in clock settings and convert to ms.
                        const expiresIn = (parseInt(api.client.getToken().expires_in, 10) - 300) * 1000;
                        const now = new Date();
                        const expireDate = new Date(now.getTime() + expiresIn);

                        this.tokenExpires = expireDate.getTime().toString();

                        resolve(resp);
                    };

                    this.tokenClient.requestAccessToken({ prompt: consent ? 'consent' : '' });
                } catch (err) {
                    logger.error('Error requesting token', err);
                }
            }));
    },

    /**
     * Prompts the participant to sign in to the Google API Client Library, if
     * not already signed in.
     *
     * @param {boolean} consent - Whether to show account selection dialog.
     * @returns {Promise}
     */
    signInIfNotSignedIn(consent) {
        return this.get()
            .then(() => this.isSignedIn())
            .then(isSignedIn => {
                if (!isSignedIn) {
                    return this.showAccountSelection(consent);
                }
            });
    },

    /**
     * Sign out from the Google API Client Library.
     *
     * @returns {Promise}
     */
    signOut() {
        return this.get()
            .then(() => {
                this.tokenClient = undefined;
                this.tokenExpires = undefined;
            });
    },

    /**
     * Parses the google calendar entries to a known format.
     *
     * @param {Object} entry - The google calendar entry.
     * @returns {{
     *  calendarId: string,
     *  description: string,
     *  endDate: string,
     *  id: string,
     *  location: string,
     *  startDate: string,
     *  title: string}}
     * @private
     */
    _convertCalendarEntry(entry) {
        return {
            calendarId: entry.calendarId,
            description: entry.description,
            endDate: entry.end.dateTime,
            id: entry.id,
            location: entry.location,
            startDate: entry.start.dateTime,
            title: entry.summary,
            url: this._getConferenceDataVideoUri(entry.conferenceData)
        };
    },

    /**
     * Checks conference data for jitsi conference solution and returns
     * its video url.
     *
     * @param {Object} conferenceData - The conference data of the event.
     * @returns {string|undefined} Returns the found video uri or undefined.
     */
    _getConferenceDataVideoUri(conferenceData = {}) {
        try {
            // check conference data coming from calendar addons
            if (conferenceData.parameters.addOnParameters.parameters
                    .conferenceSolutionType === 'jitsi') {
                const videoEntry = conferenceData.entryPoints.find(
                    e => e.entryPointType === 'video');

                if (videoEntry) {
                    return videoEntry.uri;
                }
            }
        } catch (error) {
            // we don't care about undefined fields
        }
    },

    /**
     * Retrieves calendar entries from all available calendars.
     *
     * @param {number} fetchStartDays - The number of days to go back
     * when fetching.
     * @param {number} fetchEndDays - The number of days to fetch.
     * @returns {Promise<CalendarEntry>}
     * @private
     */
    _getCalendarEntries(fetchStartDays, fetchEndDays) {
        return this.get()
            .then(() => this.isSignedIn())
            .then(isSignedIn => {
                if (!isSignedIn) {
                    return null;
                }

                // user can edit the events, so we want only those that
                // can be edited
                return this._getGoogleApiClient()
                    .client.calendar.calendarList.list();
            })
            .then(calendarList => {

                // no result, maybe not signed in
                if (!calendarList) {
                    return Promise.resolve();
                }

                const calendarIds
                    = calendarList.result.items.map(en => {
                        return {
                            id: en.id,
                            accessRole: en.accessRole
                        };
                    });
                const promises = calendarIds.map(({ id, accessRole }) => {
                    const startDate = new Date();
                    const endDate = new Date();

                    startDate.setDate(startDate.getDate() + fetchStartDays);
                    endDate.setDate(endDate.getDate() + fetchEndDays);

                    // retrieve the events and adds to the result the calendarId
                    return this._getGoogleApiClient()
                        .client.calendar.events.list({
                            'calendarId': id,
                            'timeMin': startDate.toISOString(),
                            'timeMax': endDate.toISOString(),
                            'showDeleted': false,
                            'singleEvents': true,
                            'orderBy': 'startTime'
                        })
                        .then(result => result.result.items
                            .map(item => {
                                const resultItem = { ...item };

                                // add the calendarId only for the events
                                // we can edit
                                if (accessRole === 'writer'
                                    || accessRole === 'owner') {
                                    resultItem.calendarId = id;
                                }

                                return resultItem;
                            }));
                });

                return Promise.all(promises)
                    .then(results => [].concat(...results))
                    .then(entries =>
                        entries.map(e => this._convertCalendarEntry(e)));
            });
    },

    /**
     * Updates the calendar event and adds a location and text.
     *
     * @param {string} id - The event id to update.
     * @param {string} calendarId - The calendar id to use.
     * @param {string} location - The location to add to the event.
     * @param {string} text - The description text to set/append.
     * @returns {Promise<T | never>}
     * @private
     */
    _updateCalendarEntry(id, calendarId, location, text) {
        return this.get()
            .then(() => this.isSignedIn())
            .then(isSignedIn => {
                if (!isSignedIn) {
                    return null;
                }

                return this._getGoogleApiClient()
                    .client.calendar.events.get({
                        'calendarId': calendarId,
                        'eventId': id
                    }).then(event => {
                        let newDescription = text;

                        if (event.result.description) {
                            newDescription = `${event.result.description}\n\n${
                                text}`;
                        }

                        return this._getGoogleApiClient()
                            .client.calendar.events.patch({
                                'calendarId': calendarId,
                                'eventId': id,
                                'description': newDescription,
                                'location': location
                            });
                    });

            });
    },

    /**
     * Returns the global Google API Client Library object. Direct use of this
     * method is discouraged; instead use the {@link get} method.
     *
     * @private
     * @returns {Object|undefined}
     */
    _getGoogleApiClient() {
        return window.gapi;
    },


    /**
     * Returns the global Google Identity Services Library object.
     *
     * @private
     * @returns {Object|undefined}
     */
    _getGoogleGISApiClient() {
        return window.google;
    }
};

export default googleApi;


################################################################################

## File: .\jitsi-meet\react\features\google-api\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/base/redux');


################################################################################

## File: .\jitsi-meet\react\features\google-api\reducer.ts

import ReducerRegistry from '../base/redux/ReducerRegistry';

import {
    SET_GOOGLE_API_PROFILE,
    SET_GOOGLE_API_STATE
} from './actionTypes';
import { GOOGLE_API_STATES } from './constants';

/**
 * The default state is the Google API needs loading.
 *
 * @type {{googleAPIState: number}}
 */
const DEFAULT_STATE = {
    googleAPIState: GOOGLE_API_STATES.NEEDS_LOADING,
    profileEmail: ''
};

export interface IGoogleApiState {
    googleAPIState: number;
    googleResponse?: Object;
    profileEmail: string;
}

/**
 * Reduces the Redux actions of the feature features/google-api.
 */
ReducerRegistry.register<IGoogleApiState>('features/google-api',
    (state = DEFAULT_STATE, action): IGoogleApiState => {
        switch (action.type) {
        case SET_GOOGLE_API_STATE:
            return {
                ...state,
                googleAPIState: action.googleAPIState,
                googleResponse: action.googleResponse
            };
        case SET_GOOGLE_API_PROFILE:
            return {
                ...state,
                profileEmail: action.profileEmail
            };
        }

        return state;
    });


################################################################################

## File: .\jitsi-meet\react\features\google-api\components\styles.ts

import { createStyleSheet } from '../../base/styles/functions.any';

/**
 * For styling explanations, see:
 * https://developers.google.com/identity/branding-guidelines.
 */
const BUTTON_HEIGHT = 40;

/**
 * The styles of the React {@code Components} of google-api.
 */
export default createStyleSheet({

    /**
     * Image of the sign in button (Google branded).
     */
    signInImage: {
        flex: 1
    },

    /**
     * An image-based button for sign in.
     */
    signInButton: {
        alignItems: 'center',
        height: BUTTON_HEIGHT,
        justifyContent: 'center'
    },

    /**
     * A text-based button for sign out (no sign out button guidance for
     * Google).
     */
    signOutButton: {
        alignSelf: 'center',
        maxWidth: 120,
        width: 'auto'
    }
});


################################################################################

## File: .\jitsi-meet\react\features\invite\actions.any.ts

import { IStore } from '../app/types';
import { getInviteURL } from '../base/connection/functions';
import { getLocalParticipant, getParticipantCount } from '../base/participants/functions';
import { inviteVideoRooms } from '../videosipgw/actions';

import { getDialInConferenceID, getDialInNumbers } from './_utils';
import {
    ADD_PENDING_INVITE_REQUEST,
    BEGIN_ADD_PEOPLE,
    HIDE_ADD_PEOPLE_DIALOG,
    REMOVE_PENDING_INVITE_REQUESTS,
    SET_CALLEE_INFO_VISIBLE,
    UPDATE_DIAL_IN_NUMBERS_FAILED,
    UPDATE_DIAL_IN_NUMBERS_SUCCESS
} from './actionTypes';
import { INVITE_TYPES } from './constants';
import {
    invitePeopleAndChatRooms,
    inviteSipEndpoints
} from './functions';
import logger from './logger';
import { IInvitee } from './types';

/**
 * Creates a (redux) action to signal that a click/tap has been performed on
 * {@link InviteButton} and that the execution flow for adding/inviting people
 * to the current conference/meeting is to begin.
 *
 * @returns {{
 *     type: BEGIN_ADD_PEOPLE
 * }}
 */
export function beginAddPeople() {
    return {
        type: BEGIN_ADD_PEOPLE
    };
}

/**
 * Creates a (redux) action to signal that the {@code AddPeopleDialog}
 * should close.
 *
 * @returns {{
 *     type: HIDE_ADD_PEOPLE_DIALOG
 * }}
 */
export function hideAddPeopleDialog() {
    return {
        type: HIDE_ADD_PEOPLE_DIALOG
    };
}


/**
 * Invites (i.e. Sends invites to) an array of invitees (which may be a
 * combination of users, rooms, phone numbers, and video rooms.
 *
 * @param  {Array<Object>} invitees - The recipients to send invites to.
 * @param  {Array<Object>} showCalleeInfo - Indicates whether the
 * {@code CalleeInfo} should be displayed or not.
 * @returns {Promise<Array<Object>>} A {@code Promise} resolving with an array
 * of invitees who were not invited (i.e. Invites were not sent to them).
 */
export function invite(
        invitees: IInvitee[],
        showCalleeInfo = false) {
    return (
            dispatch: IStore['dispatch'],
            getState: IStore['getState']): Promise<IInvitee[]> => {
        const state = getState();
        const participantsCount = getParticipantCount(state);
        const { calleeInfoVisible } = state['features/invite'];

        if (showCalleeInfo
                && !calleeInfoVisible
                && invitees.length === 1
                && invitees[0].type === INVITE_TYPES.USER
                && participantsCount === 1) {
            dispatch(setCalleeInfoVisible(true, invitees[0]));
        }

        const { conference, password } = state['features/base/conference'];

        if (typeof conference === 'undefined') {
            // Only keep invitees which can get an invite request from Jitsi UI
            const jitsiInvitees = invitees.filter(({ type }) => type !== INVITE_TYPES.EMAIL);

            // Invite will fail before CONFERENCE_JOIN. The request will be
            // cached in order to be executed on CONFERENCE_JOIN.
            if (jitsiInvitees.length) {
                return new Promise(resolve => {
                    dispatch(addPendingInviteRequest({
                        invitees: jitsiInvitees,
                        callback: (failedInvitees: any) => resolve(failedInvitees)
                    }));
                });
            }
        }

        let allInvitePromises: Promise<any>[] = [];
        let invitesLeftToSend = [ ...invitees ];

        const {
            callFlowsEnabled,
            inviteServiceUrl,
            inviteServiceCallFlowsUrl
        } = state['features/base/config'];
        const inviteUrl = getInviteURL(state);
        const { sipInviteUrl } = state['features/base/config'];
        const { locationURL } = state['features/base/connection'];
        const { jwt = '' } = state['features/base/jwt'];
        const { name: displayName } = getLocalParticipant(state) ?? {};

        // First create all promises for dialing out.
        const phoneNumbers
            = invitesLeftToSend.filter(({ type }) => type === INVITE_TYPES.PHONE);

        // For each number, dial out. On success, remove the number from
        // {@link invitesLeftToSend}.
        const phoneInvitePromises = typeof conference === 'undefined'
            ? []
            : phoneNumbers.map(item => {
                const numberToInvite = item.number;

                return conference.dial(numberToInvite)
                .then(() => {
                    invitesLeftToSend
                        = invitesLeftToSend.filter(
                            invitee => invitee !== item);
                })
                .catch((error: Error) =>
                    logger.error('Error inviting phone number:', error));
            });

        allInvitePromises = allInvitePromises.concat(phoneInvitePromises);

        const usersAndRooms
            = invitesLeftToSend.filter(
                ({ type }) => [ INVITE_TYPES.USER, INVITE_TYPES.EMAIL, INVITE_TYPES.ROOM ].includes(type));

        if (usersAndRooms.length) {
            // Send a request to invite all the rooms and users. On success,
            // filter all rooms and users from {@link invitesLeftToSend}.
            const peopleInvitePromise
                = invitePeopleAndChatRooms(
                    (callFlowsEnabled
                        ? inviteServiceCallFlowsUrl : inviteServiceUrl) ?? '',
                    inviteUrl,
                    usersAndRooms,
                    state)
                .then(() => {
                    invitesLeftToSend
                        = invitesLeftToSend.filter(
                            ({ type }) => ![ INVITE_TYPES.USER, INVITE_TYPES.EMAIL, INVITE_TYPES.ROOM ].includes(type));
                })
                .catch(error => {
                    dispatch(setCalleeInfoVisible(false));
                    logger.error('Error inviting people:', error);
                });

            allInvitePromises.push(peopleInvitePromise);
        }

        // Sipgw calls are fire and forget. Invite them to the conference, then
        // immediately remove them from invitesLeftToSend.
        const vrooms
            = invitesLeftToSend.filter(({ type }) => type === INVITE_TYPES.VIDEO_ROOM);

        conference
            && vrooms.length > 0
            && dispatch(inviteVideoRooms(conference, vrooms));

        invitesLeftToSend
            = invitesLeftToSend.filter(({ type }) => type !== INVITE_TYPES.VIDEO_ROOM);

        const sipEndpoints
            = invitesLeftToSend.filter(({ type }) => type === INVITE_TYPES.SIP);

        conference && inviteSipEndpoints(
            sipEndpoints,

            // @ts-ignore
            locationURL,
            sipInviteUrl,
            jwt,
            conference.options.name,
            password,
            displayName
        );

        invitesLeftToSend
            = invitesLeftToSend.filter(({ type }) => type !== INVITE_TYPES.SIP);

        return (
            Promise.all(allInvitePromises)
                .then(() => invitesLeftToSend));
    };
}

/**
 * Sends AJAX requests for dial-in numbers and conference ID.
 *
 * @returns {Function}
 */
export function updateDialInNumbers() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const { dialInConfCodeUrl, dialInNumbersUrl, hosts }
            = state['features/base/config'];
        const { numbersFetched } = state['features/invite'];
        const mucURL = hosts?.muc;

        if (numbersFetched || !dialInConfCodeUrl || !dialInNumbersUrl || !mucURL) {
            // URLs for fetching dial in numbers not defined
            return;
        }

        const { locationURL = {} } = state['features/base/connection'];
        const { room = '' } = state['features/base/conference'];

        Promise.all([
            getDialInNumbers(dialInNumbersUrl, room, mucURL), // @ts-ignore
            getDialInConferenceID(dialInConfCodeUrl, room, mucURL, locationURL)
        ])
            .then(([ dialInNumbers, { conference, id, message, sipUri } ]) => {
                if (!conference || !id) {
                    return Promise.reject(message);
                }

                dispatch({
                    type: UPDATE_DIAL_IN_NUMBERS_SUCCESS,
                    conferenceID: id,
                    dialInNumbers,
                    sipUri
                });
            })
            .catch(error => {
                dispatch({
                    type: UPDATE_DIAL_IN_NUMBERS_FAILED,
                    error
                });
            });
    };
}

/**
 * Sets the visibility of {@code CalleeInfo}.
 *
 * @param {boolean|undefined} [calleeInfoVisible] - If {@code CalleeInfo} is
 * to be displayed/visible, then {@code true}; otherwise, {@code false} or
 * {@code undefined}.
 * @param {Object|undefined} [initialCalleeInfo] - Callee information.
 * @returns {{
 *     type: SET_CALLEE_INFO_VISIBLE,
 *     calleeInfoVisible: (boolean|undefined),
 *     initialCalleeInfo
 * }}
 */
export function setCalleeInfoVisible(
        calleeInfoVisible: boolean,
        initialCalleeInfo?: Object) {
    return {
        type: SET_CALLEE_INFO_VISIBLE,
        calleeInfoVisible,
        initialCalleeInfo
    };
}

/**
 * Adds pending invite request.
 *
 * @param {Object} request - The request.
 * @returns {{
 *     type: ADD_PENDING_INVITE_REQUEST,
 *     request: Object
 * }}
 */
export function addPendingInviteRequest(
        request: { callback: Function; invitees: Array<Object>; }) {
    return {
        type: ADD_PENDING_INVITE_REQUEST,
        request
    };
}

/**
 * Removes all pending invite requests.
 *
 * @returns {{
 *     type: REMOVE_PENDING_INVITE_REQUEST
 * }}
 */
export function removePendingInviteRequests() {
    return {
        type: REMOVE_PENDING_INVITE_REQUESTS
    };
}


################################################################################

## File: .\jitsi-meet\react\features\invite\actions.native.ts

import { IStore } from '../app/types';
import { addPeopleFeatureControl } from '../base/participants/functions';
import { navigate } from '../mobile/navigation/components/conference/ConferenceNavigationContainerRef';
import { screen } from '../mobile/navigation/routes';
import { beginShareRoom } from '../share-room/actions';

export * from './actions.any';

/**
 * Starts the process for inviting people. Depending on the system config it
 * may use the system share sheet or the invite people dialog.
 *
 * @returns {Function}
 */
export function doInvitePeople() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();

        if (addPeopleFeatureControl(state)) {
            return navigate(screen.conference.invite);
        }

        return dispatch(beginShareRoom());
    };
}


################################################################################

## File: .\jitsi-meet\react\features\invite\actions.web.ts

export * from './actions.any';


################################################################################

## File: .\jitsi-meet\react\features\invite\actionTypes.ts

/**
 * The type of redux action which will add pending invite request to the redux
 * store.
 *
 * {
 *     type: ADD_PENDING_INVITE_REQUEST,
 *     request: Object
 * }
 */
export const ADD_PENDING_INVITE_REQUEST = 'ADD_PENDING_INVITE_REQUEST';

/**
 * The type of the (redux) action which signals that a click/tap has been
 * performed on {@link InviteButton} and that the execution flow for
 * adding/inviting people to the current conference/meeting is to begin.
 *
 * {
 *     type: BEGIN_ADD_PEOPLE
 * }
 */
export const BEGIN_ADD_PEOPLE = 'BEGIN_ADD_PEOPLE';

/**
 * The type of redux action which will remove pending invite requests from the
 * redux store.
 *
 * {
 *     type: REMOVE_PENDING_INVITE_REQUESTS
 * }
 */
export const REMOVE_PENDING_INVITE_REQUESTS
    = 'REMOVE_PENDING_INVITE_REQUESTS';

/**
 * The type of redux action which sets the visibility of {@code CalleeInfo}.
 *
 * {
 *     type: SET_CALLEE_INFO_VISIBLE,
 *     calleeInfoVisible: boolean
 * }
 */
export const SET_CALLEE_INFO_VISIBLE = 'SET_CALLEE_INFO_VISIBLE';

/**
 * The type of redux action to signal that the {@code AddPeopleDialog} should close.
 */
export const HIDE_ADD_PEOPLE_DIALOG = 'HIDE_ADD_PEOPLE_DIALOG';

/**
 * The type of the action which signals an error occurred while requesting dial-
 * in numbers.
 *
 * {
 *     type: UPDATE_DIAL_IN_NUMBERS_FAILED,
 *     error: Object
 * }
 */
export const UPDATE_DIAL_IN_NUMBERS_FAILED
    = 'UPDATE_DIAL_IN_NUMBERS_FAILED';

/**
 * The type of the action which signals a request for dial-in numbers has
 * succeeded.
 *
 * {
 *     type: UPDATE_DIAL_IN_NUMBERS_SUCCESS,
 *     conferenceID: Object,
 *     dialInNumbers: Object
 * }
 */
export const UPDATE_DIAL_IN_NUMBERS_SUCCESS
    = 'UPDATE_DIAL_IN_NUMBERS_SUCCESS';


################################################################################

## File: .\jitsi-meet\react\features\invite\constants.ts

/**
 * The pathName for the dialInInfo page.
 *
 * @type {string}
 */
export const DIAL_IN_INFO_PAGE_PATH_NAME = 'static/dialInInfo.html';

/**
 * The identifier of the sound to be played when the status of an outgoing call
 * is expired.
 *
 * @type {string}
 */
export const OUTGOING_CALL_EXPIRED_SOUND_ID
    = 'OUTGOING_CALL_EXPIRED_SOUND';

/**
 * The identifier of the sound to be played when the status of an outgoing call
 * is rejected.
 *
 * @type {string}
 */
export const OUTGOING_CALL_REJECTED_SOUND_ID
    = 'OUTGOING_CALL_REJECTED_SOUND';

/**
 * The identifier of the sound to be played when the status of an outgoing call
 * is ringing.
 *
 * @type {string}
 */
export const OUTGOING_CALL_RINGING_SOUND_ID = 'OUTGOING_CALL_RINGING_SOUND';

/**
 * The identifier of the sound to be played when outgoing call is started.
 *
 * @type {string}
 */
export const OUTGOING_CALL_START_SOUND_ID = 'OUTGOING_CALL_START_SOUND';

/**
 * Regex for matching sip addresses.
 */
// eslint-disable-next-line max-len
export const SIP_ADDRESS_REGEX = /^[+a-zA-Z0-9]+(?:([^\s>:@]+)(?::([^\s@>]+))?@)?([\w\-.]+)(?::(\d+))?((?:;[^\s=?>;]+(?:=[^\s?;]+)?)*)(?:\?(([^\s&=>]+=[^\s&=>]+)(&[^\s&=>]+=[^\s&=>]+)*))?$/;

/**
 * Different invite types mapping.
 */
export const INVITE_TYPES = {
    EMAIL: 'email',
    PHONE: 'phone',
    ROOM: 'room',
    SIP: 'sip',
    USER: 'user',
    VIDEO_ROOM: 'videosipgw'
};

export const UPGRADE_OPTIONS_TEXT = 'jaas.8x8.vc';
export const UPGRADE_OPTIONS_LINK = 'https://jaas.8x8.vc/#/plan/upgrade';


################################################################################

## File: .\jitsi-meet\react\features\invite\functions.ts

// @ts-expect-error
import { jitsiLocalStorage } from '@jitsi/js-utils';

import { IReduxState } from '../app/types';
import { IStateful } from '../base/app/types';
import { getRoomName } from '../base/conference/functions';
import { getInviteURL } from '../base/connection/functions';
import { isIosMobileBrowser } from '../base/environment/utils';
import i18next from '../base/i18n/i18next';
import { isJwtFeatureEnabled } from '../base/jwt/functions';
import { JitsiRecordingConstants } from '../base/lib-jitsi-meet';
import { getLocalParticipant, isLocalParticipantModerator } from '../base/participants/functions';
import { toState } from '../base/redux/functions';
import { doGetJSON } from '../base/util/httpUtils';
import { parseURLParams } from '../base/util/parseURLParams';
import {
    StatusCode,
    appendURLParam,
    parseURIString
} from '../base/util/uri';
import { isVpaasMeeting } from '../jaas/functions';
import { getActiveSession } from '../recording/functions';

import { getDialInConferenceID, getDialInNumbers } from './_utils';
import {
    DIAL_IN_INFO_PAGE_PATH_NAME,
    INVITE_TYPES,
    SIP_ADDRESS_REGEX,
    UPGRADE_OPTIONS_TEXT
} from './constants';
import logger from './logger';
import { IInvitee } from './types';


export const sharingFeatures = {
    email: 'email',
    url: 'url',
    dialIn: 'dial-in',
    embed: 'embed'
};

/**
 * Sends an ajax request to check if the phone number can be called.
 *
 * @param {string} dialNumber - The dial number to check for validity.
 * @param {string} dialOutAuthUrl - The endpoint to use for checking validity.
 * @param {string} region - The region we are connected to.
 * @returns {Promise} - The promise created by the request.
 */
export function checkDialNumber(
        dialNumber: string,
        dialOutAuthUrl: string,
        region: string
): Promise<{ allow?: boolean; country?: string; phone?: string; }> {
    const fullUrl = `${dialOutAuthUrl}?phone=${dialNumber}&region=${region}`;

    return new Promise((resolve, reject) =>
        fetch(fullUrl)
            .then(res => {
                if (res.ok) {
                    resolve(res.json());
                } else {
                    reject(new Error('Request not successful!'));
                }
            })
            .catch(reject));
}

/**
 * Sends an ajax request to check if the outbound call is permitted.
 *
 * @param {string} dialOutRegionUrl - The config endpoint.
 * @param {string} jwt - The jwt token.
 * @param {string} appId - The customer id.
 * @param {string} phoneNumber - The destination phone number.
 * @returns {Promise} - The promise created by the request.
 */
export function checkOutboundDestination(
        dialOutRegionUrl: string,
        jwt: string,
        appId: string,
        phoneNumber: string
): Promise<any> {
    return doGetJSON(dialOutRegionUrl, true, {
        body: JSON.stringify({
            appId,
            phoneNumber
        }),
        method: 'POST',
        headers: {
            'Authorization': `Bearer ${jwt}`,
            'Content-Type': 'application/json'
        }
    });
}

/**
 * Removes all non-numeric characters from a string.
 *
 * @param {string} text - The string from which to remove all characters except
 * numbers.
 * @returns {string} A string with only numbers.
 */
export function getDigitsOnly(text = ''): string {
    return text.replace(/\D/g, '');
}

/**
 * Type of the options to use when sending a search query.
 */
export type GetInviteResultsOptions = {

    /**
     * Whether or not to search for people.
     */
    addPeopleEnabled: boolean;

    /**
     * The customer id.
     */
    appId: string;

    /**
     * The endpoint to use for checking phone number validity.
     */
    dialOutAuthUrl: string;

    /**
     * Whether or not to check phone numbers.
     */
    dialOutEnabled: boolean;

    /**
     * The endpoint to use for checking dial permission to an outbound destination.
     */
    dialOutRegionUrl: string;

    /**
     * The jwt token to pass to the search service.
     */
    jwt: string;

    /**
     * Array with the query types that will be executed -
     * "conferenceRooms" | "user" | "room".
     */
    peopleSearchQueryTypes: Array<string>;

    /**
     * Key in localStorage holding the alternative token for people directory.
     */
    peopleSearchTokenLocation?: string;

    /**
     * The url to query for people.
     */
    peopleSearchUrl: string;

    /**
     * The region we are connected to.
     */
    region: string;

    /**
     * Whether or not to check sip invites.
     */
    sipInviteEnabled: boolean;
};

/**
 * Combines directory search with phone number validation to produce a single
 * set of invite search results.
 *
 * @param {string} query - Text to search.
 * @param {GetInviteResultsOptions} options - Options to use when searching.
 * @returns {Promise<*>}
 */
export function getInviteResultsForQuery(
        query: string,
        options: GetInviteResultsOptions
): Promise<any> {
    const text = query.trim();

    const {
        addPeopleEnabled,
        appId,
        dialOutAuthUrl,
        dialOutRegionUrl,
        dialOutEnabled,
        peopleSearchQueryTypes,
        peopleSearchUrl,
        peopleSearchTokenLocation,
        region,
        sipInviteEnabled,
        jwt
    } = options;

    let peopleSearchPromise;

    if (addPeopleEnabled && text) {
        peopleSearchPromise = searchDirectory(
            peopleSearchUrl,
            jwt,
            text,
            peopleSearchQueryTypes,
            peopleSearchTokenLocation);
    } else {
        peopleSearchPromise = Promise.resolve([]);
    }


    let hasCountryCode = text.startsWith('+');
    let phoneNumberPromise;

    // Phone numbers are handled a specially to enable both cases of restricting
    // numbers to telephone number-y numbers and accepting any arbitrary string,
    // which may be valid for SIP (jigasi) calls. If the dialOutAuthUrl is
    // defined, then it is assumed the call is to a telephone number and
    // some validation of the number is completed, with the + sign used as a way
    // for the UI to detect and enforce the usage of a country code. If the
    // dialOutAuthUrl is not defined, accept anything because this is assumed
    // to be the SIP (jigasi) case.
    if (dialOutEnabled && dialOutAuthUrl && isMaybeAPhoneNumber(text)) {
        let numberToVerify = text;

        // When the number to verify does not start with a +, we assume no
        // proper country code has been entered. In such a case, prepend 1 for
        // the country code. The service currently takes care of prepending the
        // +.
        if (!hasCountryCode && !text.startsWith('1')) {
            numberToVerify = `1${numberToVerify}`;
        }

        // The validation service works properly when the query is digits only
        // so ensure only digits get sent.
        numberToVerify = getDigitsOnly(numberToVerify);

        phoneNumberPromise = checkDialNumber(numberToVerify, dialOutAuthUrl, region);
    } else if (dialOutEnabled && !dialOutAuthUrl) {
        // fake having a country code to hide the country code reminder
        hasCountryCode = true;

        // With no auth url, let's say the text is a valid number
        phoneNumberPromise = Promise.resolve({
            allow: true,
            country: '',
            phone: text
        });
    } else {
        phoneNumberPromise = Promise.resolve<{ allow?: boolean; country?: string; phone?: string; }>({});
    }

    return Promise.all([ peopleSearchPromise, phoneNumberPromise ])
        .then(async ([ peopleResults, phoneResults ]) => {
            const results: any[] = [
                ...peopleResults
            ];

            /**
             * This check for phone results is for the day the call to searching
             * people might return phone results as well. When that day comes
             * this check will make it so the server checks are honored and the
             * local appending of the number is not done. The local appending of
             * the phone number can then be cleaned up when convenient.
             */
            const hasPhoneResult
                = peopleResults.find(result => result.type === INVITE_TYPES.PHONE);

            if (!hasPhoneResult && typeof phoneResults.allow === 'boolean') {
                const result = {
                    allowed: phoneResults.allow,
                    country: phoneResults.country,
                    type: INVITE_TYPES.PHONE,
                    number: phoneResults.phone,
                    originalEntry: text,
                    showCountryCodeReminder: !hasCountryCode
                };

                if (!phoneResults.allow) {
                    try {
                        const response = await checkOutboundDestination(dialOutRegionUrl, jwt, appId, text);

                        result.allowed = response.allowed;
                    } catch (error) {
                        logger.error('Error checking permission to dial to outbound destination', error);
                    }
                }

                results.push(result);
            }

            if (sipInviteEnabled && isASipAddress(text)) {
                results.push({
                    type: INVITE_TYPES.SIP,
                    address: text
                });
            }

            return results;
        });
}

/**
 * Creates a custom no new lines message for iOS default mail describing how to dial in to the conference.
 *
 * @returns {string}
 */
export function getInviteTextiOS({
    state,
    phoneNumber,
    t
}: { phoneNumber?: string | null; state: IReduxState; t?: Function; }) {
    if (!isIosMobileBrowser()) {
        return '';
    }

    const dialIn = state['features/invite'];
    const inviteUrl = getInviteURL(state);
    const localParticipant = getLocalParticipant(state);
    const localParticipantName = localParticipant?.name;

    const inviteURL = _decodeRoomURI(inviteUrl);

    let invite = localParticipantName
        ? t?.('info.inviteTextiOSPersonal', { name: localParticipantName })
        : t?.('info.inviteURLFirstPartGeneral');

    invite += ' ';

    invite += t?.('info.inviteTextiOSInviteUrl', { inviteUrl });
    invite += ' ';

    if (shouldDisplayDialIn(dialIn) && isSharingEnabled(sharingFeatures.dialIn)) {
        invite += t?.('info.inviteTextiOSPhone', {
            number: phoneNumber,
            conferenceID: dialIn.conferenceID,
            didUrl: getDialInfoPageURL(state)
        });
    }
    invite += ' ';
    invite += t?.('info.inviteTextiOSJoinSilent', { silentUrl: `${inviteURL}#config.startSilent=true` });

    return invite;
}

/**
 * Creates a message describing how to dial in to the conference.
 *
 * @returns {string}
 */
export function getInviteText({
    state,
    phoneNumber,
    t
}: { phoneNumber?: string | null; state: IReduxState; t?: Function; }) {
    const dialIn = state['features/invite'];
    const inviteUrl = getInviteURL(state);
    const currentLiveStreamingSession = getActiveSession(state, JitsiRecordingConstants.mode.STREAM);
    const liveStreamViewURL = currentLiveStreamingSession?.liveStreamViewURL;
    const localParticipant = getLocalParticipant(state);
    const localParticipantName = localParticipant?.name;

    const inviteURL = _decodeRoomURI(inviteUrl);
    let invite = localParticipantName
        ? t?.('info.inviteURLFirstPartPersonal', { name: localParticipantName })
        : t?.('info.inviteURLFirstPartGeneral');

    invite += t?.('info.inviteURLSecondPart', {
        url: inviteURL
    });

    if (liveStreamViewURL) {
        const liveStream = t?.('info.inviteLiveStream', {
            url: liveStreamViewURL
        });

        invite = `${invite}\n${liveStream}`;
    }

    if (shouldDisplayDialIn(dialIn) && isSharingEnabled(sharingFeatures.dialIn)) {
        const dial = t?.('info.invitePhone', {
            number: phoneNumber,
            conferenceID: dialIn.conferenceID
        });
        const moreNumbers = t?.('info.invitePhoneAlternatives', {
            url: getDialInfoPageURL(state),
            silentUrl: `${inviteURL}#config.startSilent=true`
        });

        invite = `${invite}\n${dial}\n${moreNumbers}`;
    }

    return invite;
}

/**
 * Helper for determining how many of each type of user is being invited. Used
 * for logging and sending analytics related to invites.
 *
 * @param {Array} inviteItems - An array with the invite items, as created in
 * {@link _parseQueryResults}.
 * @returns {Object} An object with keys as user types and values as the number
 * of invites for that type.
 */
export function getInviteTypeCounts(inviteItems: IInvitee[] = []) {
    const inviteTypeCounts: any = {};

    inviteItems.forEach(({ type }) => {
        if (!inviteTypeCounts[type]) {
            inviteTypeCounts[type] = 0;
        }
        inviteTypeCounts[type]++;
    });

    return inviteTypeCounts;
}

/**
 * Sends a post request to an invite service.
 *
 * @param {string} inviteServiceUrl - The invite service that generates the
 * invitation.
 * @param {string} inviteUrl - The url to the conference.
 * @param {Immutable.List} inviteItems - The list of the "user" or "room" type
 * items to invite.
 * @param {IReduxState} state - Global state.
 * @returns {Promise} - The promise created by the request.
 */
export function invitePeopleAndChatRooms(
        inviteServiceUrl: string,
        inviteUrl: string,
        inviteItems: Array<Object>,
        state: IReduxState
): Promise<any> {

    if (!inviteItems || inviteItems.length === 0) {
        return Promise.resolve();
    }

    // Parse all the query strings of the search directory endpoint
    const { jwt = '' } = state['features/base/jwt'];
    const { peopleSearchTokenLocation } = state['features/base/config'];

    let token = jwt;

    // If token is empty, check for alternate token
    if (!token && peopleSearchTokenLocation) {
        token = jitsiLocalStorage.getItem(peopleSearchTokenLocation) ?? '';
    }

    const headers = {
        ...token ? { 'Authorization': `Bearer ${token}` } : {},
        'Content-Type': 'application/json'
    };

    return fetch(
        inviteServiceUrl,
        {
            body: JSON.stringify({
                'invited': inviteItems,
                'url': inviteUrl
            }),
            method: 'POST',
            headers
        }
    );
}

/**
 * Determines if adding people is currently enabled.
 *
 * @param {IReduxState} state - Current state.
 * @returns {boolean} Indication of whether adding people is currently enabled.
 */
export function isAddPeopleEnabled(state: IReduxState): boolean {
    const {
        peopleSearchUrl,
        peopleSearchTokenLocation
    } = state['features/base/config'];

    const hasToken = Boolean(state['features/base/jwt'].jwt || Boolean(peopleSearchTokenLocation));

    return Boolean(hasToken && Boolean(peopleSearchUrl) && !isVpaasMeeting(state));
}

/**
 * Determines if dial out is currently enabled or not.
 *
 * @param {IReduxState} state - Current state.
 * @returns {boolean} Indication of whether dial out is currently enabled.
 */
export function isDialOutEnabled(state: IReduxState): boolean {
    const { conference } = state['features/base/conference'];
    const isModerator = isLocalParticipantModerator(state);

    return isJwtFeatureEnabled(state, 'outbound-call', isModerator, false)
        && conference && conference.isSIPCallingSupported();
}

/**
 * Determines if inviting sip endpoints is enabled or not.
 *
 * @param {IReduxState} state - Current state.
 * @returns {boolean} Indication of whether sip invite is currently enabled.
 */
export function isSipInviteEnabled(state: IReduxState): boolean {
    const { sipInviteUrl } = state['features/base/config'];
    const isModerator = isLocalParticipantModerator(state);

    return isJwtFeatureEnabled(state, 'sip-outbound-call', isModerator, false)
        && Boolean(sipInviteUrl);
}

/**
 * Checks whether a string looks like it could be for a phone number.
 *
 * @param {string} text - The text to check whether or not it could be a phone
 * number.
 * @private
 * @returns {boolean} True if the string looks like it could be a phone number.
 */
function isMaybeAPhoneNumber(text: string): boolean {
    if (!isPhoneNumberRegex().test(text)) {
        return false;
    }

    const digits = getDigitsOnly(text);

    return Boolean(digits.length);
}

/**
 * Checks whether a string matches a sip address format.
 *
 * @param {string} text - The text to check.
 * @returns {boolean} True if provided text matches a sip address format.
 */
function isASipAddress(text: string): boolean {
    return SIP_ADDRESS_REGEX.test(text);
}

/**
 * RegExp to use to determine if some text might be a phone number.
 *
 * @returns {RegExp}
 */
function isPhoneNumberRegex(): RegExp {
    let regexString = '^[0-9+()-\\s]*$';

    if (typeof interfaceConfig !== 'undefined') {
        regexString = interfaceConfig.PHONE_NUMBER_REGEX || regexString;
    }

    return new RegExp(regexString);
}

/**
 * Sends an ajax request to a directory service.
 *
 * @param {string} serviceUrl - The service to query.
 * @param {string} jwt - The jwt token to pass to the search service.
 * @param {string} text - Text to search.
 * @param {Array<string>} queryTypes - Array with the query types that will be
 * executed - "conferenceRooms" | "user" | "room" | "email".
 * @param {string} peopleSearchTokenLocation - The localStorage key holding the token value for alternate auth.
 * @returns {Promise} - The promise created by the request.
 */
export function searchDirectory( // eslint-disable-line max-params
        serviceUrl: string,
        jwt: string,
        text: string,
        queryTypes: Array<string> = [ 'conferenceRooms', 'user', 'room', 'email' ],
        peopleSearchTokenLocation?: string
): Promise<Array<{ type: string; }>> {

    const query = encodeURIComponent(text);
    const queryTypesString = encodeURIComponent(JSON.stringify(queryTypes));

    let token = jwt;

    // If token is empty, check for alternate token
    if (!token && peopleSearchTokenLocation) {
        token = jitsiLocalStorage.getItem(peopleSearchTokenLocation) ?? '';
    }

    const headers = {
        ...token ? { 'Authorization': `Bearer ${token}` } : {}
    };

    return fetch(`${serviceUrl}?query=${query}&queryTypes=${
        queryTypesString}`,
            {
                method: 'GET',
                headers
            })
            .then(response => {
                const jsonify = response.json();

                if (response.ok) {
                    return jsonify;
                }

                return jsonify
                    .then(result => Promise.reject(result));
            })
            .catch(error => {
                logger.error(
                    'Error searching directory:', error);

                return Promise.reject(error);
            });
}

/**
 * Returns descriptive text that can be used to invite participants to a meeting
 * (share via mobile or use it for calendar event description).
 *
 * @param {IReduxState} state - The current state.
 * @param {string} inviteUrl - The conference/location URL.
 * @param {boolean} useHtml - Whether to return html text.
 * @param {boolean} skipDialIn - Whether to skip dial-in options or not.
 * @returns {Promise<string>} A {@code Promise} resolving with a
 * descriptive text that can be used to invite participants to a meeting.
 */
export function getShareInfoText(
        state: IReduxState, inviteUrl: string, useHtml?: boolean, skipDialIn?: boolean): Promise<string> {
    let roomUrl = _decodeRoomURI(inviteUrl);

    if (useHtml) {
        roomUrl = `<a href="${roomUrl}">${roomUrl}</a>`;
    }

    let infoText = i18next.t('share.mainText', { roomUrl });

    const { room } = parseURIString(inviteUrl);
    const { dialInConfCodeUrl, dialInNumbersUrl, hosts } = state['features/base/config'];
    const { locationURL = {} } = state['features/base/connection'];
    const mucURL = hosts?.muc;

    if (skipDialIn || !dialInConfCodeUrl || !dialInNumbersUrl || !mucURL) {
        // URLs for fetching dial in numbers not defined.
        return Promise.resolve(infoText);
    }

    let hasPaymentError = false;

    // We are requesting numbers and conferenceId directly
    // not using updateDialInNumbers, because custom room
    // is specified and we do not want to store the data
    // in the state.
    const numbersPromise = Promise.all([
        getDialInNumbers(dialInNumbersUrl, room, mucURL), // @ts-ignore
        getDialInConferenceID(dialInConfCodeUrl, room, mucURL, locationURL)
    ]).then(([ numbers, {
        conference, id, message } ]) => {

        if (!conference || !id) {
            return Promise.reject(message);
        }

        return {
            numbers,
            conferenceID: id
        };
    });

    return numbersPromise.then(({ conferenceID, numbers }) => {
        const phoneNumber = _getDefaultPhoneNumber(numbers) || '';

        return `${
            i18next.t('info.dialInNumber')} ${
            phoneNumber} ${
            i18next.t('info.dialInConferenceID')} ${
            conferenceID}#\n\n`;
    })
    .catch(error => {
        logger.error('Error fetching numbers or conferenceID', error);
        hasPaymentError = error?.status === StatusCode.PaymentRequired;
    })
    .then(defaultDialInNumber => {
        if (hasPaymentError) {
            infoText += `${
                i18next.t('info.dialInNumber')} ${i18next.t('info.reachedLimit')} ${
                i18next.t('info.upgradeOptions')} ${UPGRADE_OPTIONS_TEXT}`;

            return infoText;
        }

        let dialInfoPageUrl = getDialInfoPageURL(state, room);

        if (useHtml) {
            dialInfoPageUrl = `<a href="${dialInfoPageUrl}">${dialInfoPageUrl}</a>`;
        }

        infoText += i18next.t('share.dialInfoText', {
            defaultDialInNumber,
            dialInfoPageUrl });

        return infoText;
    });
}

/**
 * Generates the URL for the static dial in info page.
 *
 * @param {IReduxState} state - The state from the Redux store.
 * @param {string?} roomName - The conference name. Optional name, if missing will be extracted from state.
 * @returns {string}
 */
export function getDialInfoPageURL(state: IReduxState, roomName?: string) {
    const { didPageUrl } = state['features/dynamic-branding'];
    const conferenceName = roomName ?? getRoomName(state);
    const { locationURL } = state['features/base/connection'];
    const { href = '' } = locationURL ?? {};
    const room = _decodeRoomURI(conferenceName ?? '');

    const url = didPageUrl || `${href.substring(0, href.lastIndexOf('/'))}/${DIAL_IN_INFO_PAGE_PATH_NAME}`;

    return appendURLParam(url, 'room', room);
}

/**
 * Generates the URL for the static dial in info page.
 *
 * @param {string} uri - The conference URI string.
 * @returns {string}
 */
export function getDialInfoPageURLForURIString(
        uri?: string) {
    if (!uri) {
        return undefined;
    }
    const { protocol, host, contextRoot, room } = parseURIString(uri);
    let url = `${protocol}//${host}${contextRoot}${DIAL_IN_INFO_PAGE_PATH_NAME}`;

    url = appendURLParam(url, 'room', room);

    const { release } = parseURLParams(uri, true, 'search');

    release && (url = appendURLParam(url, 'release', release));

    return url;
}

/**
 * Returns whether or not dial-in related UI should be displayed.
 *
 * @param {Object} dialIn - Dial in information.
 * @returns {boolean}
 */
export function shouldDisplayDialIn(dialIn: any) {
    const { conferenceID, numbers, numbersEnabled } = dialIn;
    const phoneNumber = _getDefaultPhoneNumber(numbers);

    return Boolean(
            conferenceID
            && numbers
            && numbersEnabled
            && phoneNumber);
}

/**
 * Returns if multiple dial-in numbers are available.
 *
 * @param {Array<string>|Object} dialInNumbers - The array or object of
 * numbers to check.
 * @private
 * @returns {boolean}
 */
export function hasMultipleNumbers(dialInNumbers?: { numbers: Object; } | string[]) {
    if (!dialInNumbers) {
        return false;
    }

    if (Array.isArray(dialInNumbers)) {
        return dialInNumbers.length > 1;
    }

    // deprecated and will be removed
    const { numbers } = dialInNumbers;

    // eslint-disable-next-line no-confusing-arrow
    return Boolean(numbers && Object.values(numbers).map(a => Array.isArray(a) ? a.length : 0)
        .reduce((a, b) => a + b) > 1);
}

/**
 * Sets the internal state of which dial-in number to display.
 *
 * @param {Array<string>|Object} dialInNumbers - The array or object of
 * numbers to choose a number from.
 * @private
 * @returns {string|null}
 */
export function _getDefaultPhoneNumber(
        dialInNumbers?: { numbers: any; } | Array<{ default: string; formattedNumber: string; }>): string | null {

    if (!dialInNumbers) {
        return null;
    }

    if (Array.isArray(dialInNumbers)) {
        // new syntax follows
        // find the default country inside dialInNumbers, US one
        // or return the first one
        const defaultNumber = dialInNumbers.find(number => number.default);

        if (defaultNumber) {
            return defaultNumber.formattedNumber;
        }

        return dialInNumbers.length > 0
            ? dialInNumbers[0].formattedNumber : null;
    }

    const { numbers } = dialInNumbers;

    if (numbers && Object.keys(numbers).length > 0) {
        // deprecated and will be removed
        const firstRegion = Object.keys(numbers)[0];

        return firstRegion && numbers[firstRegion][0];
    }

    return null;
}

/**
 * Decodes URI only if doesn't contain a space(' ').
 *
 * @param {string} url - The string to decode.
 * @returns {string} - It the string contains space, encoded value is '%20' returns
 * same string, otherwise decoded one.
 * @private
 */
export function _decodeRoomURI(url: string) {
    let roomUrl = url;

    // we want to decode urls when the do not contain space, ' ', which url encoded is %20
    if (roomUrl && !roomUrl.includes('%20')) {
        roomUrl = decodeURI(roomUrl);
    }

    // Handles a special case where the room name has % encoded, the decoded will have
    // % followed by a char (non-digit) which is not a valid URL and room name ... so we do not
    // want to show this decoded
    if (roomUrl.match(/.*%[^\d].*/)) {
        return url;
    }

    return roomUrl;
}

/**
 * Returns the stored conference id.
 *
 * @param {IStateful} stateful - The Object or Function that can be
 * resolved to a Redux state object with the toState function.
 * @returns {string}
 */
export function getConferenceId(stateful: IStateful) {
    return toState(stateful)['features/invite'].conferenceID;
}

/**
 * Returns the default dial in number from the store.
 *
 * @param {IStateful} stateful - The Object or Function that can be
 * resolved to a Redux state object with the toState function.
 * @returns {string | null}
 */
export function getDefaultDialInNumber(stateful: IStateful) {
    // @ts-ignore
    return _getDefaultPhoneNumber(toState(stateful)['features/invite'].numbers);
}

/**
 * Executes the dial out request.
 *
 * @param {string} url - The url for dialing out.
 * @param {Object} body - The body of the request.
 * @param {string} reqId - The unique request id.
 * @returns {Object}
 */
export async function executeDialOutRequest(url: string, body: Object, reqId: string) {
    const res = await fetch(url, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'request-id': reqId
        },
        body: JSON.stringify(body)
    });

    const json = await res.json();

    return res.ok ? json : Promise.reject(json);
}

/**
 * Executes the dial out status request.
 *
 * @param {string} url - The url for dialing out.
 * @param {string} reqId - The unique request id used on the dial out request.
 * @returns {Object}
 */
export async function executeDialOutStatusRequest(url: string, reqId: string) {
    const res = await fetch(url, {
        method: 'GET',
        headers: {
            'Content-Type': 'application/json',
            'request-id': reqId
        }
    });

    const json = await res.json();

    return res.ok ? json : Promise.reject(json);
}

/**
 * Returns true if a specific sharing feature is enabled in interface configuration.
 *
 * @param {string} sharingFeature - The sharing feature to check.
 * @returns {boolean}
 */
export function isSharingEnabled(sharingFeature: string) {
    return typeof interfaceConfig === 'undefined'
        || typeof interfaceConfig.SHARING_FEATURES === 'undefined'
        || (interfaceConfig.SHARING_FEATURES.length && interfaceConfig.SHARING_FEATURES.indexOf(sharingFeature) > -1);
}

/**
 * Sends a post request to an invite service.
 *
 * @param {Array} inviteItems - The list of the "sip" type items to invite.
 * @param {URL} locationURL - The URL of the location.
 * @param {string} sipInviteUrl - The invite service that generates the invitation.
 * @param {string} jwt - The jwt token.
 * @param {string} roomName - The name to the conference.
 * @param {string} roomPassword - The password of the conference.
 * @param {string} displayName - The user display name.
 * @returns {Promise} - The promise created by the request.
 */
export function inviteSipEndpoints( // eslint-disable-line max-params
        inviteItems: Array<{ address: string; }>,
        locationURL: URL,
        sipInviteUrl: string,
        jwt: string,
        roomName: string,
        roomPassword: String,
        displayName: string
): Promise<any> {
    if (inviteItems.length === 0) {
        return Promise.resolve();
    }

    const regex = new RegExp(`/${roomName}`, 'i');
    const baseUrl = Object.assign(new URL(locationURL.toString()), {
        pathname: locationURL.pathname.replace(regex, ''),
        hash: '',
        search: ''
    });

    return fetch(
        sipInviteUrl,
        {
            body: JSON.stringify({
                callParams: {
                    callUrlInfo: {
                        baseUrl,
                        callName: roomName
                    },
                    passcode: roomPassword
                },
                sipClientParams: {
                    displayName,
                    sipAddress: inviteItems.map(item => item.address)
                }
            }),
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${jwt}`,
                'Content-Type': 'application/json'
            }
        }
    );
}


################################################################################

## File: .\jitsi-meet\react\features\invite\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/invite');


################################################################################

## File: .\jitsi-meet\react\features\invite\middleware.any.ts

import { AnyAction } from 'redux';

import { IStore } from '../app/types';
import { APP_WILL_MOUNT, APP_WILL_UNMOUNT } from '../base/app/actionTypes';
import { CONFERENCE_JOINED } from '../base/conference/actionTypes';
import {
    PARTICIPANT_JOINED,
    PARTICIPANT_LEFT,
    PARTICIPANT_UPDATED
} from '../base/participants/actionTypes';
import { pinParticipant } from '../base/participants/actions';
import { PARTICIPANT_JOINED_SOUND_ID } from '../base/participants/constants';
import {
    getLocalParticipant,
    getParticipantCount,
    getParticipantPresenceStatus,
    getRemoteParticipants
} from '../base/participants/functions';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import {
    playSound,
    registerSound,
    stopSound,
    unregisterSound
} from '../base/sounds/actions';
import {
    CALLING,
    CONNECTED_USER,
    EXPIRED,
    INVITED,
    REJECTED,
    RINGING
} from '../presence-status/constants';

import {
    SET_CALLEE_INFO_VISIBLE,
    UPDATE_DIAL_IN_NUMBERS_FAILED
} from './actionTypes';
import {
    invite,
    removePendingInviteRequests,
    setCalleeInfoVisible
} from './actions';
import {
    OUTGOING_CALL_EXPIRED_SOUND_ID,
    OUTGOING_CALL_REJECTED_SOUND_ID,
    OUTGOING_CALL_RINGING_SOUND_ID,
    OUTGOING_CALL_START_SOUND_ID
} from './constants';
import logger from './logger';
import { sounds } from './sounds';

/**
 * Maps the presence status with the ID of the sound that will be played when
 * the status is received.
 */
const statusToRingtone = {
    [CALLING]: OUTGOING_CALL_START_SOUND_ID,
    [CONNECTED_USER]: PARTICIPANT_JOINED_SOUND_ID,
    [EXPIRED]: OUTGOING_CALL_EXPIRED_SOUND_ID,
    [INVITED]: OUTGOING_CALL_START_SOUND_ID,
    [REJECTED]: OUTGOING_CALL_REJECTED_SOUND_ID,
    [RINGING]: OUTGOING_CALL_RINGING_SOUND_ID
};

/**
 * The middleware of the feature invite common to mobile/react-native and
 * Web/React.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {
    let oldParticipantPresence;
    const { dispatch, getState } = store;
    const state = getState();

    if (action.type === PARTICIPANT_UPDATED
        || action.type === PARTICIPANT_LEFT) {
        oldParticipantPresence
            = getParticipantPresenceStatus(state, action.participant.id);
    }

    if (action.type === SET_CALLEE_INFO_VISIBLE) {
        if (action.calleeInfoVisible) {
            dispatch(pinParticipant(getLocalParticipant(state)?.id));
        } else {
            // unpin participant
            dispatch(pinParticipant());
        }
    }

    const result = next(action);

    switch (action.type) {
    case APP_WILL_MOUNT:
        for (const [ soundId, sound ] of sounds.entries()) {
            dispatch(registerSound(soundId, sound.file, sound.options));
        }
        break;

    case APP_WILL_UNMOUNT:
        for (const soundId of sounds.keys()) {
            dispatch(unregisterSound(soundId));
        }
        break;

    case CONFERENCE_JOINED:
        _onConferenceJoined(store);
        break;

    case PARTICIPANT_JOINED:
    case PARTICIPANT_LEFT:
    case PARTICIPANT_UPDATED: {
        _maybeHideCalleeInfo(action, store);

        const newParticipantPresence
            = getParticipantPresenceStatus(state, action.participant.id);

        if (oldParticipantPresence === newParticipantPresence) {
            break;
        }

        const oldSoundId
            = oldParticipantPresence
            && statusToRingtone[oldParticipantPresence as keyof typeof statusToRingtone];
        const newSoundId
            = newParticipantPresence
            && statusToRingtone[newParticipantPresence as keyof typeof statusToRingtone];


        if (oldSoundId === newSoundId) {
            break;
        }

        if (oldSoundId) {
            dispatch(stopSound(oldSoundId));
        }

        if (newSoundId) {
            dispatch(playSound(newSoundId));
        }

        break;
    }
    case UPDATE_DIAL_IN_NUMBERS_FAILED:
        logger.error(
            'Error encountered while fetching dial-in numbers:',
            action.error);
        break;
    }

    return result;
});

/**
 * Hides the callee info layot if there are more than 1 real
 * (not poltergeist, shared video, etc.) participants in the call.
 *
 * @param {Object} action - The redux action.
 * @param {IStore} store - The redux store.
 * @returns {void}
 */
function _maybeHideCalleeInfo(action: AnyAction, store: IStore) {
    const state = store.getState();

    if (!state['features/invite'].calleeInfoVisible) {
        return;
    }
    const participants = getRemoteParticipants(state);
    const participantCount = getParticipantCount(state);
    let numberOfPoltergeists = 0;

    participants.forEach(p => {
        if (p.botType === 'poltergeist') {
            numberOfPoltergeists++;
        }
    });
    const numberOfRealParticipants = participantCount - numberOfPoltergeists;

    if ((numberOfPoltergeists > 1 || numberOfRealParticipants > 1)
        || (action.type === PARTICIPANT_LEFT && participantCount === 1)) {
        store.dispatch(setCalleeInfoVisible(false));
    }
}

/**
 * Executes the pending invitation requests if any.
 *
 * @param {IStore} store - The redux store.
 * @returns {void}
 */
function _onConferenceJoined(store: IStore) {
    const { dispatch, getState } = store;

    const pendingInviteRequests
        = getState()['features/invite'].pendingInviteRequests || [];

    pendingInviteRequests.forEach(({ invitees, callback }) => {
        dispatch(invite(invitees))
            .then(failedInvitees => {
                callback(failedInvitees);
            });
    });

    dispatch(removePendingInviteRequests());
}


################################################################################

## File: .\jitsi-meet\react\features\invite\middleware.native.ts



################################################################################

## File: .\jitsi-meet\react\features\invite\middleware.web.ts

import { AnyAction } from 'redux';

import { IStore } from '../app/types';
import { hideDialog, openDialog } from '../base/dialog/actions';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';

import { BEGIN_ADD_PEOPLE, HIDE_ADD_PEOPLE_DIALOG } from './actionTypes';
import AddPeopleDialog from './components/add-people-dialog/web/AddPeopleDialog';
import './middleware.any';

/**
 * The middleware of the feature invite specific to Web/React.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {
    switch (action.type) {
    case BEGIN_ADD_PEOPLE:
        return _beginAddPeople(store, next, action);
    case HIDE_ADD_PEOPLE_DIALOG:
        return _hideAddPeopleDialog(store, next, action);
    }

    return next(action);
});

/**
 * Notifies the feature invite that the action {@link BEGIN_ADD_PEOPLE} is being
 * dispatched within a specific redux {@code store}.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @param {Dispatch} next - The redux {@code dispatch} function to dispatch the
 * specified {@code action} to the specified {@code store}.
 * @param {Action} action - The redux action {@code BEGIN_ADD_PEOPLE} which is
 * being dispatched in the specified {@code store}.
 * @private
 * @returns {*} The value returned by {@code next(action)}.
 */
function _beginAddPeople({ dispatch }: IStore, next: Function, action: AnyAction) {
    const result = next(action);

    dispatch(openDialog(AddPeopleDialog));

    return result;
}

/**
 * Notifies the feature invite that the action {@link HIDE_ADD_PEOPLE_DIALOG} is being
 * dispatched within a specific redux {@code store}.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @param {Dispatch} next - The redux {@code dispatch} function to dispatch the
 * specified {@code action} to the specified {@code store}.
 * @param {Action} action - The redux action {@code HIDE_ADD_PEOPLE_DIALOG} which is
 * being dispatched in the specified {@code store}.
 * @private
 * @returns {*} The value returned by {@code next(action)}.
 */
function _hideAddPeopleDialog({ dispatch }: IStore, next: Function, action: AnyAction) {
    dispatch(hideDialog(AddPeopleDialog));

    return next(action);
}


################################################################################

## File: .\jitsi-meet\react\features\invite\reducer.ts

import ReducerRegistry from '../base/redux/ReducerRegistry';

import {
    ADD_PENDING_INVITE_REQUEST,
    REMOVE_PENDING_INVITE_REQUESTS,
    SET_CALLEE_INFO_VISIBLE,
    UPDATE_DIAL_IN_NUMBERS_FAILED,
    UPDATE_DIAL_IN_NUMBERS_SUCCESS
} from './actionTypes';
import logger from './logger';
import { IInvitee } from './types';

const DEFAULT_STATE = {
    /**
     * The indicator which determines whether (the) {@code CalleeInfo} is
     * visible.
     *
     * @type {boolean|undefined}
     */
    calleeInfoVisible: false,
    numbersEnabled: true,
    numbersFetched: false,
    pendingInviteRequests: []
};

export interface IInviteState {
    calleeInfoVisible?: boolean;
    conferenceID?: string | number;
    error?: {
        status: number;
    };
    initialCalleeInfo?: {
        id: string;
        name: string;
        status: string;
    };
    numbers?: string[];
    numbersEnabled: boolean;
    numbersFetched: boolean;
    pendingInviteRequests: Array<{
        callback: Function;
        invitees: IInvitee[];
    }>;
    sipUri?: string;
}

ReducerRegistry.register<IInviteState>('features/invite', (state = DEFAULT_STATE, action): IInviteState => {
    switch (action.type) {
    case ADD_PENDING_INVITE_REQUEST:
        return {
            ...state,
            pendingInviteRequests: [
                ...state.pendingInviteRequests,
                action.request
            ]
        };

    case REMOVE_PENDING_INVITE_REQUESTS:
        return {
            ...state,
            pendingInviteRequests: []
        };

    case SET_CALLEE_INFO_VISIBLE:
        return {
            ...state,
            calleeInfoVisible: action.calleeInfoVisible,
            initialCalleeInfo: action.initialCalleeInfo
        };

    case UPDATE_DIAL_IN_NUMBERS_FAILED:
        return {
            ...state,
            error: action.error
        };

    case UPDATE_DIAL_IN_NUMBERS_SUCCESS: {
        if (Array.isArray(action.dialInNumbers)) {
            return {
                ...state,
                conferenceID: action.conferenceID,
                error: undefined,
                numbers: action.dialInNumbers,
                sipUri: action.sipUri,
                numbersEnabled: true,
                numbersFetched: true
            };
        }

        // this is the old format which is deprecated
        logger.warn('Using deprecated API for retrieving phone numbers');

        const { numbersEnabled } = action.dialInNumbers;

        return {
            ...state,
            conferenceID: action.conferenceID,
            error: undefined,
            numbers: action.dialInNumbers,
            numbersEnabled,
            numbersFetched: true
        };
    }
    }

    return state;
});


################################################################################

## File: .\jitsi-meet\react\features\invite\sounds.ts

import {
    OUTGOING_CALL_EXPIRED_SOUND_ID,
    OUTGOING_CALL_REJECTED_SOUND_ID,
    OUTGOING_CALL_RINGING_SOUND_ID,
    OUTGOING_CALL_START_SOUND_ID
} from './constants';

/**
 * Maps the sounds IDs with the filenames sounds associated with them.
 *
 * @type {Map<string, string>}
 */
export const sounds = new Map([

    /**
     * The name of the sound file which will be played when outgoing call is
     * expired.
     */
    [ OUTGOING_CALL_EXPIRED_SOUND_ID, { file: 'rejected.mp3' } ],

    /**
     * The name of the sound file which will be played when outgoing call is
     * rejected.
     */
    [ OUTGOING_CALL_REJECTED_SOUND_ID, { file: 'rejected.mp3' } ],

    /**
     * The name of the sound file which will be played when the status of an
     * outgoing call is ringing.
     */
    [
        OUTGOING_CALL_RINGING_SOUND_ID,
        {
            file: 'outgoingRinging.mp3',
            options: { loop: true }
        }
    ],

    /**
     * The name of the sound file which will be played when outgoing call is
     * started.
     */
    [ OUTGOING_CALL_START_SOUND_ID, { file: 'outgoingStart.mp3' } ]
]);


################################################################################

## File: .\jitsi-meet\react\features\invite\types.ts

import { MultiSelectItem } from '../base/ui/components/types';

export interface IInvitee {
    address: string;
    allowed?: boolean;
    id?: string;
    name?: string;
    number: string;
    originalEntry?: string;
    phone?: string;
    showCountryCodeReminder?: boolean;
    type: string;
    user_id?: string;
}

export interface IInviteSelectItem extends MultiSelectItem {
    filterValues?: string[];
    item: IInvitee;
    tag?: any;
}


################################################################################

## File: .\jitsi-meet\react\features\invite\_utils.ts

/**
 * Utility class with no dependencies. Used in components that are stripped in separate bundles
 * and requires as less dependencies as possible.
 */

import { getURLWithoutParams } from '../base/connection/utils';
import { doGetJSON } from '../base/util/httpUtils';

/**
 * Formats the conference pin in readable way for UI to display it.
 * Formats the pin in 3 groups of digits:
 * XXXX XXXX XX or XXXXX XXXXX XXX.
 * The length of first and second group is Math.ceil(pin.length / 3).
 *
 * @param {Object} conferenceID - The conference id to format, string or number.
 * @returns {string} - The formatted conference pin.
 * @private
 */
export function _formatConferenceIDPin(conferenceID: Object) {
    const conferenceIDStr = conferenceID.toString();

    // let's split the conferenceID in 3 parts, to be easier to read
    const partLen = Math.ceil(conferenceIDStr.length / 3);

    return `${
        conferenceIDStr.substring(0, partLen)} ${
        conferenceIDStr.substring(partLen, 2 * partLen)} ${
        conferenceIDStr.substring(2 * partLen, conferenceIDStr.length)}`;
}

/**
 * Sends a GET request to obtain the conference ID necessary for identifying
 * which conference to join after dialing the dial-in service.
 * This function is used not only in the main app bundle but in separate bundles for the dial in numbers page,
 * and we do want to limit the dependencies.
 *
 * @param {string} baseUrl - The url for obtaining the conference ID (pin) for
 * dialing into a conference.
 * @param {string} roomName - The conference name to find the associated
 * conference ID.
 * @param {string} mucURL - In which MUC the conference exists.
 * @param {URL} url - The address we are loaded in.
 * @returns {Promise} - The promise created by the request.
 */
export function getDialInConferenceID(
        baseUrl: string,
        roomName: string,
        mucURL: string,
        url: URL
): Promise<any> {
    const separator = baseUrl.includes('?') ? '&' : '?';
    const conferenceIDURL
        = `${baseUrl}${separator}conference=${roomName}@${mucURL}&url=${getURLWithoutParams(url).href}`;

    return doGetJSON(conferenceIDURL, true);
}

/**
 * Sends a GET request for phone numbers used to dial into a conference.
 * This function is used not only in the main app bundle but in separate bundles for the dial in numbers page,
 * and we do want to limit the dependencies.
 *
 * @param {string} url - The service that returns conference dial-in numbers.
 * @param {string} roomName - The conference name to find the associated
 * conference ID.
 * @param {string} mucURL - In which MUC the conference exists.
 * @returns {Promise} - The promise created by the request. The returned numbers
 * may be an array of Objects containing numbers, with keys countryCode,
 * tollFree, formattedNumber or an object with countries as keys and arrays of
 * phone number strings, as the second one should not be used and is deprecated.
 */
export function getDialInNumbers(
        url: string,
        roomName: string,
        mucURL: string
): Promise<any> {
    const separator = url.includes('?') ? '&' : '?';

    // when roomName and mucURL are available
    // provide conference when looking up dial in numbers

    return doGetJSON(url + (roomName && mucURL ? `${separator}conference=${roomName}@${mucURL}` : ''), true);
}


################################################################################

## File: .\jitsi-meet\react\features\invite\components\add-people-dialog\native\styles.ts

import { BoxModel } from '../../../../base/styles/components/styles/BoxModel';
import BaseTheme from '../../../../base/ui/components/BaseTheme.native';

export const AVATAR_SIZE = 40;
export const DARK_GREY = 'rgb(28, 32, 37)';
export const LIGHT_GREY = 'rgb(209, 219, 232)';

export default {

    addPeopleContainer: {
        backgroundColor: BaseTheme.palette.ui01,
        flex: 1
    },

    avatar: {
        backgroundColor: LIGHT_GREY
    },

    customContainer: {
        marginHorizontal: BaseTheme.spacing[3],
        marginVertical: BaseTheme.spacing[2]
    },

    avatarText: {
        color: DARK_GREY,
        fontSize: 12
    },

    bottomBar: {
        alignItems: 'center',
        justifyContent: 'center',
        backgroundColor: BaseTheme.palette.ui01
    },

    clearButton: {
        paddingTop: 7
    },

    clearIcon: {
        color: BaseTheme.palette.ui02,
        fontSize: 18,
        textAlign: 'center'
    },

    /**
     * A special padding to avoid issues on some devices (such as Android devices with custom suggestions bar).
     */
    extraBarPadding: {
        paddingBottom: 30
    },

    headerCloseIcon: {
        marginLeft: 12
    },

    headerSendInvite: {
        color: BaseTheme.palette.text01,
        marginRight: 12
    },

    invitedList: {
        padding: 3
    },

    itemLinesStyle: {
        color: 'rgb(118, 136, 152)',
        fontSize: 13
    },

    itemText: {
        color: BaseTheme.palette.text01,
        fontSize: 14,
        fontWeight: 'normal'
    },

    itemWrapper: {
        alignItems: 'center',
        flexDirection: 'row',
        paddingLeft: 5
    },

    resultList: {
        flex: 1,
        padding: 5
    },

    selectedIcon: {
        color: BaseTheme.palette.icon01,
        fontSize: 20,
        marginRight: BoxModel.margin,
        padding: 2
    },

    separator: {
        borderBottomColor: BaseTheme.palette.ui07,
        borderBottomWidth: 1,
        marginLeft: 85
    },

    searchIcon: {
        color: BaseTheme.palette.icon01,
        fontSize: 22
    },

    shareIcon: {
        fontSize: 42
    },

    unselectIcon: {
        color: BaseTheme.palette.ui01,
        fontSize: 16,
        left: AVATAR_SIZE / -3,
        position: 'relative',
        top: AVATAR_SIZE / -3
    },

    sendBtn: {
        marginRight: BaseTheme.spacing[3]
    }
};


################################################################################

## File: .\jitsi-meet\react\features\invite\components\add-people-dialog\web\InviteButton.ts

import { connect } from 'react-redux';

import { createToolbarEvent } from '../../../../analytics/AnalyticsEvents';
import { sendAnalytics } from '../../../../analytics/functions';
import { translate } from '../../../../base/i18n/functions';
import { IconAddUser } from '../../../../base/icons/svg';
import AbstractButton, { IProps as AbstractButtonProps } from '../../../../base/toolbox/components/AbstractButton';
import { beginAddPeople } from '../../../actions.any';

/**
 * Implementation of a button for opening invite people dialog.
 */
class InviteButton extends AbstractButton<AbstractButtonProps> {
    accessibilityLabel = 'toolbar.accessibilityLabel.invite';
    icon = IconAddUser;
    label = 'toolbar.invite';
    tooltip = 'toolbar.invite';

    /**
     * Handles clicking / pressing the button, and opens the appropriate dialog.
     *
     * @protected
     * @returns {void}
     */
    _handleClick() {
        const { dispatch } = this.props;

        sendAnalytics(createToolbarEvent('invite'));
        dispatch(beginAddPeople());
    }
}

export default translate(connect()(InviteButton));


################################################################################

## File: .\jitsi-meet\react\features\invite\components\callee-info\styles.native.ts

import { StyleSheet } from 'react-native';

import { ColorPalette } from '../../../base/styles/components/styles/ColorPalette';
import { createStyleSheet } from '../../../base/styles/functions.native';

export default createStyleSheet({
    // XXX The names below were preserved for the purposes of compatibility
    // with the existing CSS class names on Web.

    /**
     * The style of {@code CalleeInfo}.
     */
    ringing: {
        ...StyleSheet.absoluteFillObject,
        alignItems: 'center',
        backgroundColor: ColorPalette.black,
        flex: 0,
        flexDirection: 'column',
        justifyContent: 'center',
        opacity: 0.8
    },

    'ringing__avatar': {
        borderRadius: 50,
        flex: 0,
        height: 100,
        width: 100
    },

    'ringing__caller-info': {
        alignItems: 'center',
        flex: 0,
        flexDirection: 'row',
        justifyContent: 'center'
    },

    'ringing__content': {
        alignItems: 'center',
        flex: 0,
        flexDirection: 'column',
        justifyContent: 'center'
    },

    /**
     * The style of {@code Text} within {@code CalleeInfo}.
     */
    'ringing__text': {
        color: ColorPalette.white
    }
});


################################################################################

## File: .\jitsi-meet\react\features\invite\components\callee-info\styles.web.ts

export default {};


################################################################################

## File: .\jitsi-meet\react\features\invite\components\dial-in-info-page\DialInInfoApp.native.ts



################################################################################

## File: .\jitsi-meet\react\features\invite\components\dial-in-info-page\NoRoomError.native.ts



################################################################################

## File: .\jitsi-meet\react\features\invite\components\dial-in-summary\native\styles.ts

import BaseTheme from '../../../../base/ui/components/BaseTheme.native';

export const INDICATOR_COLOR = BaseTheme.palette.ui07;

const WV_BACKGROUND = BaseTheme.palette.ui03;

export default {

    backDrop: {
        backgroundColor: WV_BACKGROUND,
        flex: 1
    },

    indicatorWrapper: {
        alignItems: 'center',
        backgroundColor: BaseTheme.palette.ui10,
        height: '100%',
        justifyContent: 'center'
    },

    webView: {
        backgroundColor: WV_BACKGROUND,
        flex: 1
    }
};


################################################################################

## File: .\jitsi-meet\react\features\jaas\actions.any.ts

import { IStore } from '../app/types';

import { SET_DETAILS } from './actionTypes';
import { getVpaasTenant, sendGetDetailsRequest } from './functions';
import logger from './logger';

/**
 * Action used to set the jaas customer details in store.
 *
 * @param {Object} details - The customer details object.
 * @returns {Object}
 */
function setCustomerDetails(details: Object) {
    return {
        type: SET_DETAILS,
        payload: details
    };
}

/**
 * Sends a request for retrieving jaas customer details.
 *
 * @returns {Function}
 */
export function getCustomerDetails() {
    return async function(dispatch: IStore['dispatch'], getState: IStore['getState']) {
        const state = getState();
        const baseUrl = state['features/base/config'].jaasActuatorUrl ?? '';
        const appId = getVpaasTenant(state);

        const shouldSendRequest = Boolean(baseUrl && appId);

        if (shouldSendRequest) {
            try {
                const details = await sendGetDetailsRequest({
                    appId,
                    baseUrl
                });

                dispatch(setCustomerDetails(details));
            } catch (err) {
                logger.error('Could not send request', err);
            }
        }
    };
}


################################################################################

## File: .\jitsi-meet\react\features\jaas\actions.native.ts

/**
 * Shows a dialog prompting users to upgrade, if requested feature is disabled.
 *
 * @param {string} _feature - Used on web.
 * @returns {Function}
 */
export function maybeShowPremiumFeatureDialog(_feature: string) {
    return function() {
        return false;
    };
}


################################################################################

## File: .\jitsi-meet\react\features\jaas\actions.web.ts

import { IStore } from '../app/types';
import { openDialog } from '../base/dialog/actions';

import PremiumFeatureDialog from './components/web/PremiumFeatureDialog';
import { isFeatureDisabled } from './functions';

/**
 * Shows a dialog prompting users to upgrade, if requested feature is disabled.
 *
 * @param {string} feature - The feature to check availability for.
 *
 * @returns {Function}
 */
export function maybeShowPremiumFeatureDialog(feature: string) {
    return function(dispatch: IStore['dispatch'], getState: IStore['getState']) {
        if (isFeatureDisabled(getState(), feature)) {
            dispatch(openDialog(PremiumFeatureDialog));

            return true;
        }

        return false;
    };
}


################################################################################

## File: .\jitsi-meet\react\features\jaas\actionTypes.ts

/**
 * Action used to store jaas customer details
 */
export const SET_DETAILS = 'SET_DETAILS';

################################################################################

## File: .\jitsi-meet\react\features\jaas\constants.ts

/**
 * JaaS customer statuses which represent their account state.
 */
export const STATUSES = {
    ACTIVE: 'ACTIVE',
    BLOCKED: 'BLOCKED'
};

/**
 * URL for displaying JaaS upgrade options.
 */
export const JAAS_UPGRADE_URL = 'https://jaas.8x8.vc/#/plan/upgrade';

/**
 * The prefix for the vpaas tenant.
 */
export const VPAAS_TENANT_PREFIX = 'vpaas-magic-cookie-';


################################################################################

## File: .\jitsi-meet\react\features\jaas\functions.ts

import { IReduxState } from '../app/types';
import { IJitsiConference } from '../base/conference/reducer';

import { VPAAS_TENANT_PREFIX } from './constants';
import logger from './logger';

/**
 * Returns the full vpaas tenant if available, given a path.
 *
 * @param {string} path - The meeting url path.
 * @returns {string}
 */
function extractVpaasTenantFromPath(path: string) {
    const [ , tenant ] = path.split('/');

    if (tenant.startsWith(VPAAS_TENANT_PREFIX)) {
        return tenant;
    }

    return '';
}

/**
 * Returns the vpaas tenant.
 *
 * @param {IReduxState} state - The global state.
 * @returns {string}
 */
export function getVpaasTenant(state: IReduxState) {
    return extractVpaasTenantFromPath(state['features/base/connection'].locationURL?.pathname ?? '');
}

/**
 * Returns true if the current meeting is a vpaas one.
 *
 * @param {IReduxState} state - The state of the app.
 * @returns {boolean}
 */
export function isVpaasMeeting(state: IReduxState) {
    const connection = state['features/base/connection'];

    if (connection?.locationURL?.pathname) {
        return Boolean(
            extractVpaasTenantFromPath(connection?.locationURL?.pathname)
        );
    }

    return false;
}

/**
 * Sends a request for retrieving the conference creator's customer id.
 *
 * @param {IJitsiConference} conference - The conference state.
 * @param {IReduxState} state - The state of the app.
 * @returns {Object} - Object containing customerId field.
 */
export async function sendGetCustomerIdRequest(conference: IJitsiConference, state: IReduxState) {
    const { jaasConferenceCreatorUrl } = state['features/base/config'];

    const roomJid = conference?.room?.roomjid;

    if (jaasConferenceCreatorUrl && roomJid) {
        const fullUrl = `${jaasConferenceCreatorUrl}?conference=${encodeURIComponent(roomJid)}`;
        const response = await fetch(fullUrl);
        const responseBody = await response.json();

        if (response.ok) {
            return responseBody;
        }

        logger.error(`Failed to fetch ${fullUrl}. with: ${JSON.stringify(responseBody)}`);
    }
}

/**
 * Sends a request for retrieving jaas customer details.
 *
 * @param {Object} reqData - The request info.
 * @param {string} reqData.appId - The client appId.
 * @param {string} reqData.baseUrl - The base url for the request.
 * @returns {void}
 */
export async function sendGetDetailsRequest({ appId, baseUrl }: {
    appId: string;
    baseUrl: string;
}) {
    const fullUrl = `${baseUrl}/v1/public/tenants/${encodeURIComponent(appId)}`;

    try {
        const res = await fetch(fullUrl);

        if (res.ok) {
            return res.json();
        }

        throw new Error('Request not successful');
    } catch (err: any) {
        throw new Error(err);

    }
}

/**
 * Returns the billing id for vpaas meetings.
 *
 * @param {IReduxState} state - The state of the app.
 * @param {string} feature - Feature to be looked up for disable state.
 * @returns {boolean}
 */
export function isFeatureDisabled(state: IReduxState, feature: string) {
    return state['features/jaas'].disabledFeatures.includes(feature);
}

/**
 * Sends a request for retrieving jaas JWT.
 *
 * @param {Object} reqData - The request info.
 * @param {string} reqData.appId - The client appId.
 * @param {string} reqData.baseUrl - The base url for the request.
 * @returns {void}
 */
export async function sendGetJWTRequest({ appId, baseUrl }: {
    appId: string;
    baseUrl: string;
}) {
    const fullUrl = `${baseUrl}/v1/public/token/${encodeURIComponent(appId)}`;

    try {
        const res = await fetch(fullUrl, {
            method: 'GET'
        });

        if (res.ok) {
            return res.json();
        }

        throw new Error('Request not successful');
    } catch (err: any) {
        throw new Error(err);

    }
}

/**
 * Gets a jaas JWT.
 *
 * @param {IReduxState} state - Redux state.
 * @returns {string} The JWT.
 */
export async function getJaasJWT(state: IReduxState) {
    const baseUrl = state['features/base/config'].jaasTokenUrl;
    const appId = getVpaasTenant(state);

    const shouldSendRequest = Boolean(baseUrl && appId);

    if (shouldSendRequest) {
        try {
            const jwt = await sendGetJWTRequest({
                appId,
                baseUrl: baseUrl ?? ''
            });

            return jwt.token;
        } catch (err) {
            logger.error('Could not send request', err);
        }
    }
}


################################################################################

## File: .\jitsi-meet\react\features\jaas\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/jaas');


################################################################################

## File: .\jitsi-meet\react\features\jaas\middleware.any.ts

import { createVpaasConferenceJoinedEvent } from '../analytics/AnalyticsEvents';
import { sendAnalytics } from '../analytics/functions';
import { IReduxState } from '../app/types';
import { CONFERENCE_JOINED } from '../base/conference/actionTypes';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';

import { getVpaasTenant, isVpaasMeeting } from './functions';

/**
 * The redux middleware for billing counter.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */

MiddlewareRegistry.register(store => next => action => {
    switch (action.type) {
    case CONFERENCE_JOINED: {
        _maybeTrackVpaasConferenceJoin(store.getState());

        break;
    }
    }

    return next(action);
});

/**
 * Tracks the conference join event if the meeting is a vpaas one.
 *
 * @param {Store} state - The app state.
 * @returns {Function}
 */
function _maybeTrackVpaasConferenceJoin(state: IReduxState) {
    if (isVpaasMeeting(state)) {
        sendAnalytics(createVpaasConferenceJoinedEvent(
            getVpaasTenant(state)));
    }
}


################################################################################

## File: .\jitsi-meet\react\features\jaas\middleware.native.ts



################################################################################

## File: .\jitsi-meet\react\features\jaas\middleware.web.ts

import { redirectToStaticPage } from '../app/actions.web';
import { CONFERENCE_JOINED } from '../base/conference/actionTypes';
import {
    JitsiConferenceErrors,
    JitsiConferenceEvents
} from '../base/lib-jitsi-meet';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';

import { SET_DETAILS } from './actionTypes';
import { STATUSES } from './constants';
import logger from './logger';

/**
 * The redux middleware for jaas.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {
    switch (action.type) {
    case CONFERENCE_JOINED: {
        const { conference } = action;

        if (store.getState()['features/base/config'].iAmRecorder) {
            // We don't register anything on web if we are in iAmRecorder mode
            return next(action);
        }

        conference.on(
            JitsiConferenceEvents.CONFERENCE_ERROR, (errorType: string, errorMsg: string) => {
                errorType === JitsiConferenceErrors.SETTINGS_ERROR && logger.error(errorMsg);
            });
        break;
    }

    case SET_DETAILS: {
        const { status } = action.payload;

        if (status === STATUSES.BLOCKED) {
            store.dispatch(redirectToStaticPage('/static/planLimit.html'));
        }
        break;
    }
    }

    return next(action);
});


################################################################################

## File: .\jitsi-meet\react\features\jaas\reducer.ts

import ReducerRegistry from '../base/redux/ReducerRegistry';

import {
    SET_DETAILS
} from './actionTypes';
import { STATUSES } from './constants';

const DEFAULT_STATE = {
    disabledFeatures: [],
    status: STATUSES.ACTIVE
};

export interface IJaaSState {
    [key: string]: any;
}

/**
 * Listen for actions that mutate the billing-counter state.
 */
ReducerRegistry.register<IJaaSState>(
    'features/jaas', (state = DEFAULT_STATE, action): IJaaSState => {
        switch (action.type) {

        case SET_DETAILS: {
            return action.payload;
        }

        default:
            return state;
        }
    }
);


################################################################################

## File: .\jitsi-meet\react\features\keyboard-shortcuts\actions.ts

import { batch } from 'react-redux';
import { AnyAction } from 'redux';

import { ACTION_SHORTCUT_PRESSED, ACTION_SHORTCUT_RELEASED, createShortcutEvent } from '../analytics/AnalyticsEvents';
import { sendAnalytics } from '../analytics/functions';
import { IStore } from '../app/types';
import { clickOnVideo } from '../filmstrip/actions.web';
import { openSettingsDialog } from '../settings/actions.web';
import { SETTINGS_TABS } from '../settings/constants';
import { iAmVisitor } from '../visitors/functions';

import {
    DISABLE_KEYBOARD_SHORTCUTS,
    ENABLE_KEYBOARD_SHORTCUTS,
    REGISTER_KEYBOARD_SHORTCUT,
    UNREGISTER_KEYBOARD_SHORTCUT
} from './actionTypes';
import { areKeyboardShortcutsEnabled, getKeyboardShortcuts } from './functions';
import logger from './logger';
import { IKeyboardShortcut } from './types';
import { getKeyboardKey, getPriorityFocusedElement } from './utils';

/**
 * Action to register a new shortcut.
 *
 * @param {IKeyboardShortcut} shortcut - The shortcut to register.
 * @returns {AnyAction}
*/
export const registerShortcut = (shortcut: IKeyboardShortcut): AnyAction => {
    return {
        type: REGISTER_KEYBOARD_SHORTCUT,
        shortcut
    };
};

/**
* Action to unregister a shortcut.
*
* @param {string} character - The character of the shortcut to unregister.
* @param {boolean} altKey - Whether the shortcut used altKey.
* @returns {AnyAction}
*/
export const unregisterShortcut = (character: string, altKey = false): AnyAction => {
    return {
        alt: altKey,
        type: UNREGISTER_KEYBOARD_SHORTCUT,
        character
    };
};

/**
 * Action to enable keyboard shortcuts.
 *
 * @returns {AnyAction}
 */
export const enableKeyboardShortcuts = (): AnyAction => {
    return {
        type: ENABLE_KEYBOARD_SHORTCUTS
    };
};


/**
 * Action to enable keyboard shortcuts.
 *
 * @returns {AnyAction}
 */
export const disableKeyboardShortcuts = (): AnyAction => {
    return {
        type: DISABLE_KEYBOARD_SHORTCUTS
    };
};

type KeyHandler = ((e: KeyboardEvent) => void) | undefined;

let keyDownHandler: KeyHandler;
let keyUpHandler: KeyHandler;

/**
 * Initialise global shortcuts.
 * Global shortcuts are shortcuts for features that don't have a button or
 * link associated with the action. In other words they represent actions
 * triggered _only_ with a shortcut.
 *
 * @param {Function} dispatch - The redux dispatch function.
 * @returns {void}
 */
function initGlobalKeyboardShortcuts(dispatch: IStore['dispatch']) {
    batch(() => {
        dispatch(registerShortcut({
            character: '?',
            helpDescription: 'keyboardShortcuts.toggleShortcuts',
            handler: () => {
                sendAnalytics(createShortcutEvent('help'));
                dispatch(openSettingsDialog(SETTINGS_TABS.SHORTCUTS, false));
            }
        }));

        // register SPACE shortcut in two steps to insure visibility of help message
        dispatch(registerShortcut({
            character: ' ',
            helpCharacter: 'SPACE',
            helpDescription: 'keyboardShortcuts.pushToTalk',
            handler: () => {
                // Handled directly on the global handler.
            }
        }));

        dispatch(registerShortcut({
            character: '0',
            helpDescription: 'keyboardShortcuts.focusLocal',
            handler: () => {
                dispatch(clickOnVideo(0));
            }
        }));

        for (let num = 1; num < 10; num++) {
            dispatch(registerShortcut({
                character: `${num}`,

                // only show help hint for the first shortcut
                helpCharacter: num === 1 ? '1-9' : undefined,
                helpDescription: num === 1 ? 'keyboardShortcuts.focusRemote' : undefined,
                handler: () => {
                    dispatch(clickOnVideo(num));
                }
            }));
        }
    });
}

/**
 * Unregisters global shortcuts.
 *
 * @param {Function} dispatch - The redux dispatch function.
 * @returns {void}
 */
function unregisterGlobalKeyboardShortcuts(dispatch: IStore['dispatch']) {
    batch(() => {
        dispatch(unregisterShortcut('?'));

        // register SPACE shortcut in two steps to insure visibility of help message
        dispatch(unregisterShortcut(' '));

        dispatch(unregisterShortcut('0'));

        for (let num = 1; num < 10; num++) {
            dispatch(unregisterShortcut(`${num}`));
        }
    });
}

/**
 * Initializes keyboard shortcuts.
 *
 * @returns {Function}
*/
export function initKeyboardShortcuts() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        initGlobalKeyboardShortcuts(dispatch);

        const pttDelay = 50;
        let pttTimeout: number | undefined;

        // Used to chain the push to talk operations in order to fix an issue when on press we actually need to create
        // a new track and the release happens before the track is created. In this scenario the release is ignored.
        // The chaining would also prevent creating multiple new tracks if the space bar is pressed and released
        // multiple times before the new track creation finish.
        // TODO: Revisit the fix once we have better track management in LJM. It is possible that we would not need the
        // chaining at all.
        let mutePromise = Promise.resolve();

        keyUpHandler = (e: KeyboardEvent) => {
            const state = getState();
            const enabled = areKeyboardShortcutsEnabled(state);
            const shortcuts = getKeyboardShortcuts(state);

            if (!enabled || getPriorityFocusedElement()) {
                return;
            }

            const key = getKeyboardKey(e).toUpperCase();

            if (key === ' ') {
                clearTimeout(pttTimeout);
                pttTimeout = window.setTimeout(() => {
                    sendAnalytics(createShortcutEvent('push.to.talk', ACTION_SHORTCUT_RELEASED));
                    logger.log('Talk shortcut released');
                    mutePromise = mutePromise.then(() =>
                        APP.conference.muteAudio(true).catch(() => { /* nothing to be done */ }));
                }, pttDelay);
            }

            if (shortcuts.has(key)) {
                shortcuts.get(key)?.handler(e);
            }
        };

        keyDownHandler = (e: KeyboardEvent) => {
            const state = getState();
            const enabled = areKeyboardShortcutsEnabled(state);

            if (!enabled || iAmVisitor(state)) {
                return;
            }

            const focusedElement = getPriorityFocusedElement();
            const key = getKeyboardKey(e).toUpperCase();

            if (key === ' ' && !focusedElement) {
                clearTimeout(pttTimeout);
                sendAnalytics(createShortcutEvent('push.to.talk', ACTION_SHORTCUT_PRESSED));
                logger.log('Talk shortcut pressed');
                mutePromise = mutePromise.then(() =>
                    APP.conference.muteAudio(false).catch(() => { /* nothing to be done */ }));
            } else if (key === 'ESCAPE') {
                focusedElement?.blur();
            }
        };

        window.addEventListener('keyup', keyUpHandler);
        window.addEventListener('keydown', keyDownHandler);
    };
}

/**
 * Unregisters the global shortcuts and removes the global keyboard listeners.
 *
 * @returns {Function}
 */
export function disposeKeyboardShortcuts() {
    return (dispatch: IStore['dispatch']) => {
        // The components that are registering shortcut should take care of unregistering them.
        unregisterGlobalKeyboardShortcuts(dispatch);

        keyUpHandler && window.removeEventListener('keyup', keyUpHandler);
        keyDownHandler && window.removeEventListener('keydown', keyDownHandler);
        keyDownHandler = keyUpHandler = undefined;
    };
}


################################################################################

## File: .\jitsi-meet\react\features\keyboard-shortcuts\actionTypes.ts

/**
 *  The type of the action which signals that the keyboard shortcuts should be initialized.
 */
export const INIT_KEYBOARD_SHORTCUTS = 'INIT_KEYBOARD_SHORTCUTS';

/**
 * The type of the action which signals that a keyboard shortcut should be registered.
 */
export const REGISTER_KEYBOARD_SHORTCUT = 'REGISTER_KEYBOARD_SHORTCUT';

/**
 * The type of the action which signals that a keyboard shortcut should be unregistered.
 */
export const UNREGISTER_KEYBOARD_SHORTCUT = 'UNREGISTER_KEYBOARD_SHORTCUT';

/**
 * The type of the action which signals that a keyboard shortcut should be enabled.
 */
export const ENABLE_KEYBOARD_SHORTCUTS = 'ENABLE_KEYBOARD_SHORTCUTS';

/**
 * The type of the action which signals that a keyboard shortcut should be disabled.
 */
export const DISABLE_KEYBOARD_SHORTCUTS = 'DISABLE_KEYBOARD_SHORTCUTS';


################################################################################

## File: .\jitsi-meet\react\features\keyboard-shortcuts\functions.ts

import { IReduxState } from '../app/types';

/**
 * Returns whether or not the keyboard shortcuts are enabled.
 *
 * @param {Object} state - The redux state.
 * @returns {boolean} - Whether or not the keyboard shortcuts are enabled.
 */
export function areKeyboardShortcutsEnabled(state: IReduxState) {
    return state['features/keyboard-shortcuts'].enabled;
}

/**
 * Returns the keyboard shortcuts map.
 *
 * @param {Object} state - The redux state.
 * @returns {Map} - The keyboard shortcuts map.
 */
export function getKeyboardShortcuts(state: IReduxState) {
    return state['features/keyboard-shortcuts'].shortcuts;
}

/**
 * Returns the keyboard shortcuts help descriptions.
 *
 * @param {Object} state - The redux state.
 * @returns {Map} - The keyboard shortcuts help descriptions.
 */
export function getKeyboardShortcutsHelpDescriptions(state: IReduxState) {
    return state['features/keyboard-shortcuts'].shortcutsHelp;
}


################################################################################

## File: .\jitsi-meet\react\features\keyboard-shortcuts\hooks.ts

import { useSelector } from 'react-redux';

import { isMobileBrowser } from '../base/environment/utils';

import KeyboardShortcutsButton from './components/KeyboardShortcutsButton';
import { areKeyboardShortcutsEnabled } from './functions';

const shortcuts = {
    key: 'shortcuts',
    Content: KeyboardShortcutsButton,
    group: 4
};

/**
 * A hook that returns the keyboard shortcuts button if it is enabled and undefined otherwise.
 *
 *  @returns {Object | undefined}
 */
export function useKeyboardShortcutsButton() {
    const _areKeyboardShortcutsEnabled = useSelector(areKeyboardShortcutsEnabled);

    if (!isMobileBrowser() && _areKeyboardShortcutsEnabled) {
        return shortcuts;
    }
}


################################################################################

## File: .\jitsi-meet\react\features\keyboard-shortcuts\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/keyboard-shortcuts');


################################################################################

## File: .\jitsi-meet\react\features\keyboard-shortcuts\middleware.ts

import { AnyAction } from 'redux';

import { IStore } from '../app/types';
import { CONFERENCE_JOINED, CONFERENCE_LEFT } from '../base/conference/actionTypes';
import { SET_CONFIG } from '../base/config/actionTypes';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import { CAPTURE_EVENTS } from '../remote-control/actionTypes';

import {
    disableKeyboardShortcuts,
    disposeKeyboardShortcuts,
    enableKeyboardShortcuts,
    initKeyboardShortcuts
} from './actions';

MiddlewareRegistry.register((store: IStore) => (next: Function) => (action: AnyAction) => {
    const { dispatch } = store;

    switch (action.type) {
    case CAPTURE_EVENTS:
        if (action.isCapturingEvents) {
            dispatch(disableKeyboardShortcuts());
        } else {
            dispatch(enableKeyboardShortcuts());
        }

        return next(action);
    case SET_CONFIG: {
        const result = next(action);

        const state = store.getState();
        const { disableShortcuts } = state['features/base/config'];

        if (disableShortcuts !== undefined) {
            if (disableShortcuts) {
                dispatch(disableKeyboardShortcuts());
            } else {
                dispatch(enableKeyboardShortcuts());
            }
        }

        return result;
    }
    case CONFERENCE_JOINED:
        dispatch(initKeyboardShortcuts());
        break;
    case CONFERENCE_LEFT:
        dispatch(disposeKeyboardShortcuts());
    }

    return next(action);
});


################################################################################

## File: .\jitsi-meet\react\features\keyboard-shortcuts\reducer.ts

import PersistenceRegistry from '../base/redux/PersistenceRegistry';
import ReducerRegistry from '../base/redux/ReducerRegistry';

import {
    DISABLE_KEYBOARD_SHORTCUTS,
    ENABLE_KEYBOARD_SHORTCUTS,
    REGISTER_KEYBOARD_SHORTCUT,
    UNREGISTER_KEYBOARD_SHORTCUT
} from './actionTypes';
import { IKeyboardShortcutsState } from './types';

/**
 * The redux subtree of this feature.
 */
const STORE_NAME = 'features/keyboard-shortcuts';

const defaultState = {
    enabled: true,
    shortcuts: new Map(),
    shortcutsHelp: new Map()
};

PersistenceRegistry.register(STORE_NAME, {
    enabled: true
});

ReducerRegistry.register<IKeyboardShortcutsState>(STORE_NAME,
(state = defaultState, action): IKeyboardShortcutsState => {
    switch (action.type) {
    case ENABLE_KEYBOARD_SHORTCUTS:
        return {
            ...state,
            enabled: true
        };
    case DISABLE_KEYBOARD_SHORTCUTS:
        return {
            ...state,
            enabled: false
        };
    case REGISTER_KEYBOARD_SHORTCUT: {
        const shortcutKey = action.shortcut.alt ? `:${action.shortcut.character}` : action.shortcut.character;

        return {
            ...state,
            shortcuts: new Map(state.shortcuts)
                .set(shortcutKey, action.shortcut),
            shortcutsHelp: action.shortcut.helpDescription
                ? new Map(state.shortcutsHelp)
                .set(action.shortcut.helpCharacter ?? shortcutKey, action.shortcut.helpDescription)
                : state.shortcutsHelp
        };
    }
    case UNREGISTER_KEYBOARD_SHORTCUT: {
        const shortcutKey = action.alt ? `:${action.character}` : action.character;
        const shortcuts = new Map(state.shortcuts);

        shortcuts.delete(shortcutKey);

        const shortcutsHelp = new Map(state.shortcutsHelp);

        shortcutsHelp.delete(shortcutKey);

        return {
            ...state,
            shortcuts,
            shortcutsHelp
        };
    }
    }

    return state;
});


################################################################################

## File: .\jitsi-meet\react\features\keyboard-shortcuts\types.ts

export interface IKeyboardShortcut {

  // whether or not the alt key must be pressed
  alt?: boolean;

  // the character to be pressed that triggers the action
  character: string;

  // the function to be executed when the shortcut is pressed
  handler: Function;

  // character to be displayed in the help dialog shortcuts list
  helpCharacter?: string;

  // help description of the shortcut, to be displayed in the help dialog
  helpDescription?: string;
}

export interface IKeyboardShortcutsState {
  enabled: boolean;
  shortcuts: Map<string, IKeyboardShortcut>;
  shortcutsHelp: Map<string, string>;
}


################################################################################

## File: .\jitsi-meet\react\features\keyboard-shortcuts\utils.ts

/**
 * Prefer keyboard handling of these elements over global shortcuts.
 * If a button is triggered using the Spacebar it should not trigger PTT.
 * If an input element is focused and M is pressed it should not mute audio.
 */
const _elementsBlacklist = [
    'input',
    'textarea',
    'button',
    '[role=button]',
    '[role=menuitem]',
    '[role=radio]',
    '[role=tab]',
    '[role=option]',
    '[role=switch]',
    '[role=range]',
    '[role=log]'
];

/**
* Returns the currently focused element if it is not blacklisted.
*
* @returns {HTMLElement|null} - The currently focused element.
*/
export const getPriorityFocusedElement = (): HTMLElement | null =>
    document.querySelector(`:focus:is(${_elementsBlacklist.join(',')})`);

/**
* Returns the keyboard key from a KeyboardEvent.
*
* @param {KeyboardEvent} e - The KeyboardEvent.
* @returns {string} - The keyboard key.
*/
export const getKeyboardKey = (e: KeyboardEvent): string => {
    // @ts-ignore
    const { altKey, code, key, shiftKey, type, which, ctrlKey } = e;

    // If alt is pressed a different char can be returned so this takes
    // the char from the code. It also prefixes with a colon to differentiate
    // alt combo from simple keypress.
    if (altKey) {
        const replacedKey = code.replace('Key', '');

        return `:${replacedKey}`;
    }

    // If e.key is a string, then it is assumed it already plainly states
    // the key pressed. This may not be true in all cases, such as with Edge
    // and "?", when the browser cannot properly map a key press event to a
    // keyboard key. To be safe, when a key is "Unidentified" it must be
    // further analyzed by jitsi to a key using e.which.
    if (typeof key === 'string' && key !== 'Unidentified') {
        if (ctrlKey) {
            return `-${key}`;
        }

        return key;
    }

    if (type === 'keypress'
            && ((which >= 32 && which <= 126)
                || (which >= 160 && which <= 255))) {
        return String.fromCharCode(which);
    }

    // try to fallback (0-9A-Za-z and QWERTY keyboard)
    switch (which) {
    case 27:
        return 'Escape';
    case 191:
        return shiftKey ? '?' : '/';
    }

    if (shiftKey || type === 'keypress') {
        return String.fromCharCode(which);
    }

    return String.fromCharCode(which).toLowerCase();
};


################################################################################

## File: .\jitsi-meet\react\features\keyboard-shortcuts\components\KeyboardShortcutsButton.ts

import { connect } from 'react-redux';

import { createToolbarEvent } from '../../analytics/AnalyticsEvents';
import { sendAnalytics } from '../../analytics/functions';
import { IReduxState } from '../../app/types';
import { isMobileBrowser } from '../../base/environment/utils';
import { translate } from '../../base/i18n/functions';
import { IconShortcuts } from '../../base/icons/svg';
import AbstractButton, { IProps as AbstractButtonProps } from '../../base/toolbox/components/AbstractButton';
import { openSettingsDialog } from '../../settings/actions.web';
import { SETTINGS_TABS } from '../../settings/constants';
import { areKeyboardShortcutsEnabled } from '../functions';

/**
 * Implementation of a button for opening keyboard shortcuts dialog.
 */
class KeyboardShortcutsButton extends AbstractButton<AbstractButtonProps> {
    accessibilityLabel = 'toolbar.accessibilityLabel.shortcuts';
    icon = IconShortcuts;
    label = 'toolbar.shortcuts';
    tooltip = 'toolbar.shortcuts';

    /**
     * Handles clicking / pressing the button, and opens the appropriate dialog.
     *
     * @protected
     * @returns {void}
     */
    _handleClick() {
        const { dispatch } = this.props;

        sendAnalytics(createToolbarEvent('shortcuts'));
        dispatch(openSettingsDialog(SETTINGS_TABS.SHORTCUTS));
    }
}

/**
 * Function that maps parts of Redux state tree into component props.
 *
 * @param {Object} state - Redux state.
 * @returns {Object}
 */
const mapStateToProps = (state: IReduxState) => {
    return {
        visible: !isMobileBrowser() && areKeyboardShortcutsEnabled(state)
    };
};

export default translate(connect(mapStateToProps)(KeyboardShortcutsButton));


################################################################################

## File: .\jitsi-meet\react\features\large-video\actions.any.ts

import { IReduxState, IStore } from '../app/types';
import { IStateful } from '../base/app/types';
import { MEDIA_TYPE } from '../base/media/constants';
import {
    getDominantSpeakerParticipant,
    getLocalParticipant,
    getLocalScreenShareParticipant,
    getParticipantById,
    getPinnedParticipant,
    getRemoteParticipants,
    getVirtualScreenshareParticipantByOwnerId
} from '../base/participants/functions';
import { toState } from '../base/redux/functions';
import { isStageFilmstripAvailable } from '../filmstrip/functions';
import { getAutoPinSetting } from '../video-layout/functions';

import {
    SELECT_LARGE_VIDEO_PARTICIPANT,
    SET_LARGE_VIDEO_DIMENSIONS,
    UPDATE_KNOWN_LARGE_VIDEO_RESOLUTION
} from './actionTypes';

/**
 * Action to select the participant to be displayed in LargeVideo based on the
 * participant id provided. If a participant id is not provided, the LargeVideo
 * participant will be selected based on a variety of factors: If there is a
 * dominant or pinned speaker, or if there are remote tracks, etc.
 *
 * @param {string} participant - The participant id of the user that needs to be
 * displayed on the large video.
 * @returns {Function}
 */
export function selectParticipantInLargeVideo(participant?: string) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();

        if (isStageFilmstripAvailable(state, 2)) {
            return;
        }

        // Keep Etherpad open.
        if (state['features/etherpad'].editing) {
            return;
        }

        const participantId = participant ?? _electParticipantInLargeVideo(state);
        const largeVideo = state['features/large-video'];
        const remoteScreenShares = state['features/video-layout'].remoteScreenShares;
        let latestScreenshareParticipantId;

        if (remoteScreenShares?.length) {
            latestScreenshareParticipantId = remoteScreenShares[remoteScreenShares.length - 1];
        }

        // When trying to auto pin screenshare, always select the endpoint even though it happens to be
        // the large video participant in redux (for the reasons listed above in the large video selection
        // logic above). The auto pin screenshare logic kicks in after the track is added
        // (which updates the large video participant and selects all endpoints because of the auto tile
        // view mode). If the screenshare endpoint is not among the forwarded endpoints from the bridge,
        // it needs to be selected again at this point.
        if (participantId !== largeVideo.participantId || participantId === latestScreenshareParticipantId) {
            dispatch({
                type: SELECT_LARGE_VIDEO_PARTICIPANT,
                participantId
            });
        }
    };
}

/**
 * Updates the currently seen resolution of the video displayed on large video.
 *
 * @param {number} resolution - The current resolution (height) of the video.
 * @returns {{
 *     type: UPDATE_KNOWN_LARGE_VIDEO_RESOLUTION,
 *     resolution: number
 * }}
 */
export function updateKnownLargeVideoResolution(resolution: number) {
    return {
        type: UPDATE_KNOWN_LARGE_VIDEO_RESOLUTION,
        resolution
    };
}

/**
 * Sets the dimenstions of the large video in redux.
 *
 * @param {number} height - The height of the large video.
 * @param {number} width - The width of the large video.
 * @returns {{
 *     type: SET_LARGE_VIDEO_DIMENSIONS,
 *     height: number,
 *     width: number
 * }}
 */
export function setLargeVideoDimensions(height: number, width: number) {
    return {
        type: SET_LARGE_VIDEO_DIMENSIONS,
        height,
        width
    };
}

/**
 * Returns the most recent existing remote video track.
 *
 * @param {Function|Object} stateful - The redux store or {@code getState} function.
 * @private
 * @returns {(Track|undefined)}
 */
function _electLastVisibleRemoteParticipant(stateful: IStateful) {
    const state = toState(stateful);
    const tracks = state['features/base/tracks'];

    // First we try to get most recent remote video track.
    for (let i = tracks.length - 1; i >= 0; --i) {
        const track = tracks[i];

        if (!track.local && track.mediaType === MEDIA_TYPE.VIDEO && track.participantId) {
            const participant = getParticipantById(state, track.participantId);

            if (participant) {
                return participant;
            }
        }
    }
}

/**
 * Returns the identifier of the participant who is to be on the stage and
 * should be displayed in {@code LargeVideo}.
 *
 * @param {Object} state - The Redux state from which the participant to be
 * displayed in {@code LargeVideo} is to be elected.
 * @private
 * @returns {(string|undefined)}
 */
function _electParticipantInLargeVideo(state: IReduxState) {
    // If a participant is pinned, they will be shown in the LargeVideo (regardless of whether they are local or
    // remote) when the filmstrip on stage is disabled.
    let participant = getPinnedParticipant(state);

    if (participant) {
        return participant.id;
    }

    const autoPinSetting = getAutoPinSetting();

    if (autoPinSetting) {
        // when the setting auto_pin_latest_screen_share is true as spot does, prioritize local screenshare
        if (autoPinSetting === true) {
            const localScreenShareParticipant = getLocalScreenShareParticipant(state);

            if (localScreenShareParticipant) {
                return localScreenShareParticipant.id;
            }
        }

        // Pick the most recent remote screenshare that was added to the conference.
        const remoteScreenShares = state['features/video-layout'].remoteScreenShares;

        if (remoteScreenShares?.length) {
            return remoteScreenShares[remoteScreenShares.length - 1];
        }
    }

    // Next, pick the dominant speaker (other than self).
    participant = getDominantSpeakerParticipant(state);
    if (participant && !participant.local) {
        // Return the screensharing participant id associated with this endpoint if multi-stream is enabled and
        // auto_pin_latest_screen_share setting is disabled.
        const screenshareParticipant = getVirtualScreenshareParticipantByOwnerId(state, participant.id);

        return screenshareParticipant?.id ?? participant.id;
    }

    // In case this is the local participant.
    participant = undefined;

    // Next, pick the most recent participant with video.
    const lastVisibleRemoteParticipant = _electLastVisibleRemoteParticipant(state);

    if (lastVisibleRemoteParticipant) {
        return lastVisibleRemoteParticipant.id;
    }

    // Last, select the participant that joined last (other than poltergist or other bot type participants).
    const participants = [ ...getRemoteParticipants(state).values() ];

    for (let i = participants.length; i > 0 && !participant; i--) {
        const p = participants[i - 1];

        !p.botType && (participant = p);
    }
    if (participant) {
        return participant.id;
    }

    return getLocalParticipant(state)?.id;
}


################################################################################

## File: .\jitsi-meet\react\features\large-video\actions.native.ts

export * from './actions.any';


################################################################################

## File: .\jitsi-meet\react\features\large-video\actions.web.ts

// @ts-expect-error
import VideoLayout from '../../../modules/UI/videolayout/VideoLayout';
import { IStore } from '../app/types';
import { getParticipantById } from '../base/participants/functions';
import { getVideoTrackByParticipant } from '../base/tracks/functions.web';

import { SET_SEE_WHAT_IS_BEING_SHARED } from './actionTypes';

export * from './actions.any';

/**
* Captures a screenshot of the video displayed on the large video.
*
* @returns {Function}
*/
export function captureLargeVideoScreenshot() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const largeVideo = state['features/large-video'];
        const promise = Promise.resolve();

        if (!largeVideo?.participantId) {
            return promise;
        }

        const participant = getParticipantById(state, largeVideo.participantId);
        const participantTrack = getVideoTrackByParticipant(state, participant);

        // Participants that join the call video muted do not have a jitsiTrack attached.
        if (!participantTrack?.jitsiTrack) {
            return promise;
        }
        const videoStream = participantTrack.jitsiTrack.getOriginalStream();

        if (!videoStream) {
            return promise;
        }

        // Get the video element for the large video, cast HTMLElement to HTMLVideoElement to make flow happy.
        /* eslint-disable-next-line no-extra-parens*/
        const videoElement = (document.getElementById('largeVideo') as any);

        if (!videoElement) {
            return promise;
        }

        // Create a HTML canvas and draw video on to the canvas.
        const [ track ] = videoStream.getVideoTracks();
        const { height, width } = track.getSettings() ?? track.getConstraints();
        const canvasElement = document.createElement('canvas');
        const ctx = canvasElement.getContext('2d');

        canvasElement.style.display = 'none';
        canvasElement.height = parseInt(height, 10);
        canvasElement.width = parseInt(width, 10);
        ctx?.drawImage(videoElement, 0, 0);
        const dataURL = canvasElement.toDataURL('image/png', 1.0);

        // Cleanup.
        ctx?.clearRect(0, 0, canvasElement.width, canvasElement.height);
        canvasElement.remove();

        return Promise.resolve(dataURL);
    };
}

/**
 * Resizes the large video container based on the dimensions provided.
 *
 * @param {number} width - Width that needs to be applied on the large video container.
 * @param {number} height - Height that needs to be applied on the large video container.
 * @returns {Function}
 */
export function resizeLargeVideo(width: number, height: number) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const largeVideo = state['features/large-video'];

        if (largeVideo) {
            const largeVideoContainer = VideoLayout.getLargeVideo();

            largeVideoContainer.updateContainerSize(width, height);
            largeVideoContainer.resize();
        }
    };
}

/**
 * Updates the value used to display what is being shared.
 *
 * @param {boolean} seeWhatIsBeingShared - The current value.
 * @returns {{
 *     type: SET_SEE_WHAT_IS_BEING_SHARED,
 *     seeWhatIsBeingShared: boolean
 * }}
 */
export function setSeeWhatIsBeingShared(seeWhatIsBeingShared: boolean) {
    return {
        type: SET_SEE_WHAT_IS_BEING_SHARED,
        seeWhatIsBeingShared
    };
}


################################################################################

## File: .\jitsi-meet\react\features\large-video\actionTypes.ts

/**
 * Action to select the participant to be displayed in LargeVideo.
 *
 * {
 *     type: SELECT_LARGE_VIDEO_PARTICIPANT,
 *     participantId: (string|undefined)
 * }
 */
export const SELECT_LARGE_VIDEO_PARTICIPANT
    = 'SELECT_LARGE_VIDEO_PARTICIPANT';

/**
 * Action to set the dimensions of the large video.
 *
 * {
 *     type: SET_LARGE_VIDEO_DIMENSIONS,
 *     height: number,
 *     width: number
 * }
 */
export const SET_LARGE_VIDEO_DIMENSIONS = 'SET_LARGE_VIDEO_DIMENSIONS';

/**
 * Action to update the redux store with the current resolution of large video.
 *
 * @returns {{
 *     type: UPDATE_KNOWN_LARGE_VIDEO_RESOLUTION,
 *     resolution: number
 * }}
 */
export const UPDATE_KNOWN_LARGE_VIDEO_RESOLUTION
    = 'UPDATE_KNOWN_LARGE_VIDEO_RESOLUTION';

/**
 * Action to set the redux store of the current show me what I'm sharing flag value.
 *
 * @returns {{
 *     type: SET_SEE_WHAT_IS_BEING_SHARED,
 *     seeWhatIsBeingShared: boolean
 * }}
 */
export const SET_SEE_WHAT_IS_BEING_SHARED
        = 'SET_SEE_WHAT_IS_BEING_SHARED';


################################################################################

## File: .\jitsi-meet\react\features\large-video\functions.ts

import { IReduxState } from '../app/types';
import { getParticipantById } from '../base/participants/functions';

/**
 * Selector for the participant currently displaying on the large video.
 *
 * @param {Object} state - The redux state.
 * @returns {Object}
 */
export function getLargeVideoParticipant(state: IReduxState) {
    const { participantId } = state['features/large-video'];

    return getParticipantById(state, participantId ?? '');
}


################################################################################

## File: .\jitsi-meet\react\features\large-video\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/large-video');


################################################################################

## File: .\jitsi-meet\react\features\large-video\middleware.ts

import {
    DOMINANT_SPEAKER_CHANGED,
    PARTICIPANT_JOINED,
    PARTICIPANT_LEFT,
    PIN_PARTICIPANT
} from '../base/participants/actionTypes';
import { getDominantSpeakerParticipant, getLocalParticipant } from '../base/participants/functions';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import { isTestModeEnabled } from '../base/testing/functions';
import {
    TRACK_ADDED,
    TRACK_REMOVED
} from '../base/tracks/actionTypes';
import { TOGGLE_DOCUMENT_EDITING } from '../etherpad/actionTypes';

import { selectParticipantInLargeVideo } from './actions';
import logger from './logger';

import './subscriber';

/**
 * Middleware that catches actions related to participants and tracks and
 * dispatches an action to select a participant depicted by LargeVideo.
 *
 * @param {Store} store - Redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {
    switch (action.type) {
    case DOMINANT_SPEAKER_CHANGED: {
        const state = store.getState();
        const localParticipant = getLocalParticipant(state);
        const dominantSpeaker = getDominantSpeakerParticipant(state);


        if (dominantSpeaker?.id === action.participant.id) {
            return next(action);
        }

        const result = next(action);

        if (isTestModeEnabled(state)) {
            logger.info(`Dominant speaker changed event for: ${action.participant.id}`);
        }

        if (localParticipant && localParticipant.id !== action.participant.id) {
            store.dispatch(selectParticipantInLargeVideo());
        }

        return result;
    }
    case PIN_PARTICIPANT: {
        const result = next(action);

        store.dispatch(selectParticipantInLargeVideo(action.participant?.id));

        return result;
    }
    case PARTICIPANT_JOINED:
    case PARTICIPANT_LEFT:
    case TOGGLE_DOCUMENT_EDITING:
    case TRACK_ADDED:
    case TRACK_REMOVED: {
        const result = next(action);

        store.dispatch(selectParticipantInLargeVideo());

        return result;
    }
    }
    const result = next(action);

    return result;
});


################################################################################

## File: .\jitsi-meet\react\features\large-video\reducer.ts

import { PARTICIPANT_ID_CHANGED } from '../base/participants/actionTypes';
import ReducerRegistry from '../base/redux/ReducerRegistry';

import {
    SELECT_LARGE_VIDEO_PARTICIPANT,
    SET_LARGE_VIDEO_DIMENSIONS,
    SET_SEE_WHAT_IS_BEING_SHARED,
    UPDATE_KNOWN_LARGE_VIDEO_RESOLUTION
} from './actionTypes';

export interface ILargeVideoState {
    height?: number;
    participantId?: string;
    resolution?: number;
    seeWhatIsBeingShared?: boolean;
    width?: number;
}

ReducerRegistry.register<ILargeVideoState>('features/large-video', (state = {}, action): ILargeVideoState => {
    switch (action.type) {

    // When conference is joined, we update ID of local participant from default
    // 'local' to real ID. However, in large video we might have already
    // selected 'local' as participant on stage. So in this case we must update
    // ID of participant on stage to match ID in 'participants' state to avoid
    // additional changes in state and (re)renders.
    case PARTICIPANT_ID_CHANGED:
        if (state.participantId === action.oldValue) {
            return {
                ...state,
                participantId: action.newValue
            };
        }
        break;

    case SELECT_LARGE_VIDEO_PARTICIPANT:
        return {
            ...state,
            participantId: action.participantId
        };

    case SET_LARGE_VIDEO_DIMENSIONS:
        return {
            ...state,
            height: action.height,
            width: action.width
        };

    case UPDATE_KNOWN_LARGE_VIDEO_RESOLUTION:
        return {
            ...state,
            resolution: action.resolution
        };

    case SET_SEE_WHAT_IS_BEING_SHARED:
        return {
            ...state,
            seeWhatIsBeingShared: action.seeWhatIsBeingShared
        };

    }

    return state;
});


################################################################################

## File: .\jitsi-meet\react\features\large-video\subscriber.native.ts



################################################################################

## File: .\jitsi-meet\react\features\large-video\subscriber.web.ts

// @ts-expect-error
import VideoLayout from '../../../modules/UI/videolayout/VideoLayout';
import StateListenerRegistry from '../base/redux/StateListenerRegistry';
import { getVideoTrackByParticipant } from '../base/tracks/functions.web';

import { getLargeVideoParticipant } from './functions';

/**
 * Updates the on stage participant video.
 */
StateListenerRegistry.register(
    /* selector */ state => state['features/large-video'].participantId,
    /* listener */ participantId => {
        VideoLayout.updateLargeVideo(participantId, true);
    }
);

/**
 * Schedules a large video update when the streaming status of the track associated with the large video changes.
 */
StateListenerRegistry.register(
    /* selector */ state => {
        const largeVideoParticipant = getLargeVideoParticipant(state);
        const videoTrack = getVideoTrackByParticipant(state, largeVideoParticipant);

        return {
            participantId: largeVideoParticipant?.id,
            streamingStatus: videoTrack?.streamingStatus
        };
    },
    /* listener */ ({ participantId, streamingStatus }, previousState: any = {}) => {
        if (streamingStatus !== previousState.streamingStatus) {
            VideoLayout.updateLargeVideo(participantId, true);
        }
    }, {
        deepEquals: true
    }
);


################################################################################

## File: .\jitsi-meet\react\features\large-video\components\LargeVideoBackground.native.ts



################################################################################

## File: .\jitsi-meet\react\features\large-video\components\styles.ts

/**
 * Size for the Avatar.
 */
export const AVATAR_SIZE = 200;


################################################################################

## File: .\jitsi-meet\react\features\lobby\actions.any.ts

import { IStore } from '../app/types';
import { conferenceWillJoin, setPassword } from '../base/conference/actions';
import { getCurrentConference, sendLocalParticipant } from '../base/conference/functions';
import { getLocalParticipant } from '../base/participants/functions';
import { IParticipant } from '../base/participants/types';
import { onLobbyChatInitialized, removeLobbyChatParticipant, sendMessage } from '../chat/actions.any';
import { LOBBY_CHAT_MESSAGE } from '../chat/constants';
import { handleLobbyMessageReceived } from '../chat/middleware';
import { hideNotification, showNotification } from '../notifications/actions';
import { LOBBY_NOTIFICATION_ID } from '../notifications/constants';
import { joinConference } from '../prejoin/actions';

import {
    KNOCKING_PARTICIPANT_ARRIVED_OR_UPDATED,
    KNOCKING_PARTICIPANT_LEFT,
    REMOVE_LOBBY_CHAT_WITH_MODERATOR,
    SET_KNOCKING_STATE,
    SET_LOBBY_MODE_ENABLED,
    SET_LOBBY_PARTICIPANT_CHAT_STATE,
    SET_LOBBY_VISIBILITY,
    SET_PASSWORD_JOIN_FAILED
} from './actionTypes';
import { LOBBY_CHAT_INITIALIZED, MODERATOR_IN_CHAT_WITH_LEFT } from './constants';
import { getKnockingParticipants, getLobbyConfig, getLobbyEnabled, isEnablingLobbyAllowed } from './functions';
import logger from './logger';
import { IKnockingParticipant } from './types';

/**
 * Tries to join with a preset password.
 *
 * @param {string} password - The password to join with.
 * @returns {Function}
 */
export function joinWithPassword(password: string) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const conference = getCurrentConference(getState);

        dispatch(setPassword(conference, conference?.join, password));
    };
}

/**
 * Action to be dispatched when a knocking poarticipant leaves before any response.
 *
 * @param {string} id - The ID of the participant.
 * @returns {{
 *     id: string,
 *     type: KNOCKING_PARTICIPANT_LEFT
 * }}
 */
export function knockingParticipantLeft(id: string) {
    return {
        id,
        type: KNOCKING_PARTICIPANT_LEFT
    };
}

/**
 * Action to be executed when a participant starts knocking or an already knocking participant gets updated.
 *
 * @param {Object} participant - The knocking participant.
 * @returns {{
 *     participant: Object,
 *     type: KNOCKING_PARTICIPANT_ARRIVED_OR_UPDATED
 * }}
 */
export function participantIsKnockingOrUpdated(participant: IKnockingParticipant | Object) {
    return {
        participant,
        type: KNOCKING_PARTICIPANT_ARRIVED_OR_UPDATED
    };
}

/**
 * Handles a knocking participant and dismisses the notification.
 *
 * @param {string} id - The id of the knocking participant.
 * @param {boolean} approved - True if the participant is approved, false otherwise.
 * @returns {Function}
 */
export function answerKnockingParticipant(id: string, approved: boolean) {
    return (dispatch: IStore['dispatch']) => {
        dispatch(setKnockingParticipantApproval(id, approved));
        dispatch(hideNotification(LOBBY_NOTIFICATION_ID));
    };
}

/**
 * Approves (lets in) or rejects a knocking participant.
 *
 * @param {string} id - The id of the knocking participant.
 * @param {boolean} approved - True if the participant is approved, false otherwise.
 * @returns {Function}
 */
export function setKnockingParticipantApproval(id: string, approved: boolean) {
    return async (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const conference = getCurrentConference(getState);

        if (conference) {
            if (approved) {
                conference.lobbyApproveAccess(id);
            } else {
                conference.lobbyDenyAccess(id);
            }
        }
    };
}

/**
 * Action used to admit multiple participants in the conference.
 *
 * @param {Array<Object>} participants - A list of knocking participants.
 * @returns {void}
 */
export function admitMultiple(participants: Array<IKnockingParticipant>) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const conference = getCurrentConference(getState);

        conference?.lobbyApproveAccess(participants.map(p => p.id));
    };
}

/**
 * Approves the request of a knocking participant to join the meeting.
 *
 * @param {string} id - The id of the knocking participant.
 * @returns {Function}
 */
export function approveKnockingParticipant(id: string) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const conference = getCurrentConference(getState);

        conference?.lobbyApproveAccess(id);
    };
}

/**
 * Denies the request of a knocking participant to join the meeting.
 *
 * @param {string} id - The id of the knocking participant.
 * @returns {Function}
 */
export function rejectKnockingParticipant(id: string) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const conference = getCurrentConference(getState);

        conference?.lobbyDenyAccess(id);
    };
}

/**
 * Action to set the knocking state of the participant.
 *
 * @param {boolean} knocking - The new state.
 * @returns {{
 *     state: boolean,
 *     type: SET_KNOCKING_STATE
 * }}
 */
export function setKnockingState(knocking: boolean) {
    return {
        knocking,
        type: SET_KNOCKING_STATE
    };
}

/**
 * Action to set the new state of the lobby mode.
 *
 * @param {boolean} enabled - The new state to set.
 * @returns {{
 *     enabled: boolean,
 *     type: SET_LOBBY_MODE_ENABLED
 * }}
 */
export function setLobbyModeEnabled(enabled: boolean) {
    return {
        enabled,
        type: SET_LOBBY_MODE_ENABLED
    };
}

/**
 * Action to be dispatched when we failed to join with a password.
 *
 * @param {boolean} failed - True of recent password join failed.
 * @returns {{
 *     failed: boolean,
 *     type: SET_PASSWORD_JOIN_FAILED
 * }}
 */
export function setPasswordJoinFailed(failed: boolean) {
    return {
        failed,
        type: SET_PASSWORD_JOIN_FAILED
    };
}

/**
 * Starts knocking and waiting for approval.
 *
 * @returns {Function}
 */
export function startKnocking() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const { membersOnly } = state['features/base/conference'];

        logger.info(`Lobby starting knocking (membersOnly = ${membersOnly})`);

        if (!membersOnly) {

            // no membersOnly, this means we got lobby screen shown as someone
            // tried to join a conference that has lobby enabled without setting display name
            // join conference should trigger the lobby/member_only path after setting the display name
            // this is possible only for web, where we can join without a prejoin screen
            dispatch(joinConference());

            return;
        }

        const localParticipant = getLocalParticipant(state);

        dispatch(conferenceWillJoin(membersOnly));

        // We need to update the conference object with the current display name, if approved
        // we want to send that display name, it was not updated in case when pre-join is disabled
        sendLocalParticipant(state, membersOnly);

        membersOnly?.joinLobby(localParticipant?.name, localParticipant?.email);
        dispatch(setLobbyMessageListener());
        dispatch(setKnockingState(true));
    };
}

/**
 * Action to toggle lobby mode on or off.
 *
 * @param {boolean} enabled - The desired (new) state of the lobby mode.
 * @returns {Function}
 */
export function toggleLobbyMode(enabled: boolean) {
    return async (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const conference = getCurrentConference(getState);

        if (enabled) {
            if (isEnablingLobbyAllowed(getState())) {
                conference?.enableLobby();
            } else {
                logger.info('Ignoring enable lobby request because there are visitors in the call already.');
            }
        } else {
            conference?.disableLobby();
        }
    };
}

/**
 * Action to open the lobby screen.
 *
 * @returns {openDialog}
 */
export function openLobbyScreen() {
    return {
        type: SET_LOBBY_VISIBILITY,
        visible: true
    };
}

/**
 * Action to hide the lobby screen.
 *
 * @returns {hideDialog}
 */
export function hideLobbyScreen() {
    return {
        type: SET_LOBBY_VISIBILITY,
        visible: false
    };
}

/**
 * Action to handle chat initialized in the lobby room.
 *
 * @param {Object} payload - The payload received,
 * contains the information about the two participants
 * that will chat with each other in the lobby room.
 *
 * @returns {Promise<void>}
 */
export function handleLobbyChatInitialized(payload: { attendee: IParticipant; moderator: IParticipant; }) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const conference = getCurrentConference(state);

        const id = conference?.myLobbyUserId();

        dispatch({
            type: SET_LOBBY_PARTICIPANT_CHAT_STATE,
            participant: payload.attendee,
            moderator: payload.moderator
        });

        dispatch(onLobbyChatInitialized(payload));

        const attendeeIsKnocking = getKnockingParticipants(state).some(p => p.id === payload.attendee.id);

        if (attendeeIsKnocking && conference?.getRole() === 'moderator' && payload.moderator.id !== id) {
            dispatch(showNotification({
                titleKey: 'lobby.lobbyChatStartedNotification',
                titleArguments: {
                    moderator: payload.moderator.name ?? '',
                    attendee: payload.attendee.name ?? ''
                }
            }));
        }
    };
}

/**
 * Action to send message to the moderator.
 *
 * @param {string} message - The message to be sent.
 *
 * @returns {Promise<void>}
 */
export function onSendMessage(message: string) {
    return (dispatch: IStore['dispatch']) => {
        dispatch(sendMessage(message));
    };
}

/**
 * Action to send lobby message to every participant. Only allowed for moderators.
 *
 * @param {Object} message - The message to be sent.
 *
 * @returns {Promise<void>}
 */
export function sendLobbyChatMessage(message: Object) {
    return async (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const conference = getCurrentConference(getState);

        conference?.sendLobbyMessage(message);
    };
}

/**
 * Sets lobby listeners if lobby has been enabled.
 *
 * @returns {Function}
 */
export function maybeSetLobbyChatMessageListener() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const lobbyEnabled = getLobbyEnabled(state);

        if (lobbyEnabled) {
            dispatch(setLobbyMessageListener());
        }
    };
}

/**
 * Action to handle the event when a moderator leaves during lobby chat.
 *
 * @param {string} participantId - The participant id of the moderator who left.
 * @returns {Function}
 */
export function updateLobbyParticipantOnLeave(participantId: string) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const { knocking, knockingParticipants } = state['features/lobby'];
        const { lobbyMessageRecipient } = state['features/chat'];
        const { conference } = state['features/base/conference'];

        if (knocking && lobbyMessageRecipient && lobbyMessageRecipient.id === participantId) {
            return dispatch(removeLobbyChatParticipant(true));
        }

        if (!knocking) {
            // inform knocking participant when their moderator leaves
            const participantToNotify = knockingParticipants.find(p => p.chattingWithModerator === participantId);

            if (participantToNotify) {
                conference?.sendLobbyMessage({
                    type: MODERATOR_IN_CHAT_WITH_LEFT,
                    moderatorId: participantToNotify.chattingWithModerator
                }, participantToNotify.id);
            }
            dispatch({
                type: REMOVE_LOBBY_CHAT_WITH_MODERATOR,
                moderatorId: participantId
            });
        }
    };
}

/**
 * Handles all messages received in the lobby room.
 *
 * @returns {Function}
 */
export function setLobbyMessageListener() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const conference = getCurrentConference(state);
        const { enableChat = true } = getLobbyConfig(state);

        if (!enableChat) {
            return;
        }

        conference?.addLobbyMessageListener((message: any, participantId: string) => {
            if (message.type === LOBBY_CHAT_MESSAGE) {
                return dispatch(handleLobbyMessageReceived(message.message, participantId));
            }
            if (message.type === LOBBY_CHAT_INITIALIZED) {
                return dispatch(handleLobbyChatInitialized(message));
            }
            if (message.type === MODERATOR_IN_CHAT_WITH_LEFT) {
                return dispatch(updateLobbyParticipantOnLeave(message.moderatorId));
            }
        });
    };
}



################################################################################

## File: .\jitsi-meet\react\features\lobby\actions.native.ts

import { batch } from 'react-redux';

import { appNavigate } from '../app/actions.native';
import { IStore } from '../app/types';

import { hideLobbyScreen, setKnockingState } from './actions.any';

export * from './actions.any';

/**
 * Cancels the ongoing knocking and abandons the join flow.
 *
 * @returns {Function}
 */
export function cancelKnocking() {
    return (dispatch: IStore['dispatch']) => {
        batch(() => {
            dispatch(setKnockingState(false));
            dispatch(hideLobbyScreen());
            dispatch(appNavigate(undefined));
        });
    };
}


################################################################################

## File: .\jitsi-meet\react\features\lobby\actions.web.ts

import { maybeRedirectToWelcomePage } from '../app/actions.web';
import { IStore } from '../app/types';

export * from './actions.any';

/**
 * Cancels the ongoing knocking and abandons the join flow.
 *
 * @returns {Function}
 */
export function cancelKnocking() {
    return async (dispatch: IStore['dispatch']) => {
        // when we are redirecting the library should handle any
        // unload and clean of the connection.
        APP.API.notifyReadyToClose();
        dispatch(maybeRedirectToWelcomePage());
    };
}


################################################################################

## File: .\jitsi-meet\react\features\lobby\actionTypes.ts

/**
 * Action type to signal the arriving or updating of a knocking participant.
 */
export const KNOCKING_PARTICIPANT_ARRIVED_OR_UPDATED = 'KNOCKING_PARTICIPANT_ARRIVED_OR_UPDATED';

/**
 * Action type to signal the leave of a knocking participant.
 */
export const KNOCKING_PARTICIPANT_LEFT = 'KNOCKING_PARTICIPANT_LEFT';

/**
 * Action type to set the new state of the lobby mode.
 */
export const SET_LOBBY_MODE_ENABLED = 'SET_LOBBY_MODE_ENABLED';

/**
 * Action type to set the knocking state of the participant.
 */
export const SET_KNOCKING_STATE = 'SET_KNOCKING_STATE';

/**
 * Action type to set the lobby visibility.
 */
export const SET_LOBBY_VISIBILITY = 'TOGGLE_LOBBY_VISIBILITY';

/**
 * Action type to set the password join failed status.
 */
export const SET_PASSWORD_JOIN_FAILED = 'SET_PASSWORD_JOIN_FAILED';

/**
 * Action type to set a lobby chat participant's state to chatting
 */
 export const SET_LOBBY_PARTICIPANT_CHAT_STATE = 'SET_LOBBY_PARTICIPANT_CHAT_STATE';

 /**
  * Action type to remove chattingWithModerator field
  */
 export const REMOVE_LOBBY_CHAT_WITH_MODERATOR = 'REMOVE_LOBBY_CHAT_WITH_MODERATOR';


################################################################################

## File: .\jitsi-meet\react\features\lobby\constants.ts

/**
 * Hide these emails when trying to join a lobby.
 */
export const HIDDEN_EMAILS = [ 'inbound-sip-jibri@jitsi.net', 'outbound-sip-jibri@jitsi.net' ];

/**
 * The identifier of the sound to be played when a participant joins lobby.
 *
 * @type {string}
 */
export const KNOCKING_PARTICIPANT_SOUND_ID = 'KNOCKING_PARTICIPANT_SOUND';

/**
 * Lobby chat initialized message type.
 *
 * @type {string}
 */
export const LOBBY_CHAT_INITIALIZED = 'LOBBY_CHAT_INITIALIZED';

/**
   * Event message sent to knocking participant when moderator in chat with leaves.
   *
   * @type {string}
   */
export const MODERATOR_IN_CHAT_WITH_LEFT = 'MODERATOR_IN_CHAT_WITH_LEFT';


################################################################################

## File: .\jitsi-meet\react\features\lobby\functions.ts

import { IReduxState } from '../app/types';
import { getCurrentConference } from '../base/conference/functions';
import { getVisitorsCount } from '../visitors/functions';

import { IKnockingParticipant } from './types';


/**
* Selector to return lobby enable state.
*
* @param {IReduxState} state - State object.
* @returns {boolean}
*/
export function getLobbyEnabled(state: IReduxState) {
    return state['features/lobby'].lobbyEnabled;
}

/**
* Selector to return a list of knocking participants.
*
* @param {IReduxState} state - State object.
* @returns {Array<Object>}
*/
export function getKnockingParticipants(state: IReduxState) {
    return state['features/lobby'].knockingParticipants;
}

/**
 * Selector to return lobby visibility.
 *
 * @param {IReduxState} state - State object.
 * @returns {any}
 */
export function getIsLobbyVisible(state: IReduxState) {
    return state['features/lobby'].lobbyVisible;
}

/**
 * Selector to return array with knocking participant ids.
 *
 * @param {IReduxState} state - State object.
 * @returns {Array}
 */
export function getKnockingParticipantsById(state: IReduxState) {
    return getKnockingParticipants(state).map(participant => participant.id);
}

/**
 * Selector to return the lobby config.
 *
 * @param {IReduxState} state - State object.
 * @returns {Object}
 */
export function getLobbyConfig(state: IReduxState) {
    return state['features/base/config']?.lobby || {};
}

/**
 * Function that handles the visibility of the lobby chat message.
 *
 * @param {Object} participant - Lobby Participant.
 * @returns {Function}
 */
export function showLobbyChatButton(
        participant: IKnockingParticipant
) {
    return function(state: IReduxState) {

        const { enableChat = true } = getLobbyConfig(state);
        const { lobbyMessageRecipient, isLobbyChatActive } = state['features/chat'];
        const conference = getCurrentConference(state);

        const lobbyLocalId = conference?.myLobbyUserId();

        if (!enableChat) {
            return false;
        }

        if (!isLobbyChatActive
        && (!participant.chattingWithModerator
        || participant.chattingWithModerator === lobbyLocalId)
        ) {
            return true;
        }

        if (isLobbyChatActive && lobbyMessageRecipient
        && participant.id !== lobbyMessageRecipient.id
            && (!participant.chattingWithModerator
                || participant.chattingWithModerator === lobbyLocalId)) {
            return true;
        }

        return false;
    };
}

/**
 * Returns true if enabling lobby is allowed and false otherwise.
 *
 * @param {IReduxState} state - State object.
 * @returns {boolean}
 */
export function isEnablingLobbyAllowed(state: IReduxState) {
    return getVisitorsCount(state) <= 0;
}


################################################################################

## File: .\jitsi-meet\react\features\lobby\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/lobby');


################################################################################

## File: .\jitsi-meet\react\features\lobby\middleware.ts

import i18n from 'i18next';
import { batch } from 'react-redux';
import { AnyAction } from 'redux';

import { IStore } from '../app/types';
import { APP_WILL_MOUNT, APP_WILL_UNMOUNT } from '../base/app/actionTypes';
import {
    CONFERENCE_FAILED,
    CONFERENCE_JOINED,
    ENDPOINT_MESSAGE_RECEIVED
} from '../base/conference/actionTypes';
import { conferenceWillJoin } from '../base/conference/actions';
import {
    JitsiConferenceErrors,
    JitsiConferenceEvents
} from '../base/lib-jitsi-meet';
import {
    getFirstLoadableAvatarUrl,
    getParticipantDisplayName
} from '../base/participants/functions';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import StateListenerRegistry from '../base/redux/StateListenerRegistry';
import {
    playSound,
    registerSound,
    unregisterSound
} from '../base/sounds/actions';
import { isTestModeEnabled } from '../base/testing/functions';
import { BUTTON_TYPES } from '../base/ui/constants.any';
import { openChat } from '../chat/actions';
import {
    handleLobbyChatInitialized,
    removeLobbyChatParticipant
} from '../chat/actions.any';
import { arePollsDisabled } from '../conference/functions.any';
import { hideNotification, showNotification } from '../notifications/actions';
import {
    LOBBY_NOTIFICATION_ID,
    NOTIFICATION_ICON,
    NOTIFICATION_TIMEOUT_TYPE,
    NOTIFICATION_TYPE
} from '../notifications/constants';
import { INotificationProps } from '../notifications/types';
import { open as openParticipantsPane } from '../participants-pane/actions';
import { getParticipantsPaneOpen } from '../participants-pane/functions';
import {
    isPrejoinEnabledInConfig,
    isPrejoinPageVisible,
    shouldAutoKnock
} from '../prejoin/functions';

import {
    KNOCKING_PARTICIPANT_ARRIVED_OR_UPDATED,
    KNOCKING_PARTICIPANT_LEFT
} from './actionTypes';
import {
    approveKnockingParticipant,
    hideLobbyScreen,
    knockingParticipantLeft,
    openLobbyScreen,
    participantIsKnockingOrUpdated,
    rejectKnockingParticipant,
    setLobbyMessageListener,
    setLobbyModeEnabled,
    setPasswordJoinFailed,
    startKnocking
} from './actions';
import { updateLobbyParticipantOnLeave } from './actions.any';
import { KNOCKING_PARTICIPANT_SOUND_ID } from './constants';
import { getKnockingParticipants, showLobbyChatButton } from './functions';
import { KNOCKING_PARTICIPANT_FILE } from './sounds';
import { IKnockingParticipant } from './types';


MiddlewareRegistry.register(store => next => action => {
    switch (action.type) {
    case APP_WILL_MOUNT:
        store.dispatch(registerSound(KNOCKING_PARTICIPANT_SOUND_ID, KNOCKING_PARTICIPANT_FILE));
        break;
    case APP_WILL_UNMOUNT:
        store.dispatch(unregisterSound(KNOCKING_PARTICIPANT_SOUND_ID));
        break;
    case CONFERENCE_FAILED:
        return _conferenceFailed(store, next, action);
    case CONFERENCE_JOINED:
        return _conferenceJoined(store, next, action);
    case ENDPOINT_MESSAGE_RECEIVED: {
        const { participant, data } = action;

        _maybeSendLobbyNotification(participant, data, store);

        break;
    }
    case KNOCKING_PARTICIPANT_ARRIVED_OR_UPDATED: {
        // We need the full update result to be in the store already
        const result = next(action);

        _findLoadableAvatarForKnockingParticipant(store, action.participant);
        _handleLobbyNotification(store);

        return result;
    }
    case KNOCKING_PARTICIPANT_LEFT: {
        // We need the full update result to be in the store already
        const result = next(action);

        _handleLobbyNotification(store);

        return result;
    }
    }

    return next(action);
});

/**
 * Registers a change handler for state['features/base/conference'].conference to
 * set the event listeners needed for the lobby feature to operate.
 */
StateListenerRegistry.register(
    state => state['features/base/conference'].conference,
    (conference, { dispatch, getState }, previousConference) => {
        if (conference && !previousConference) {
            conference.on(JitsiConferenceEvents.MEMBERS_ONLY_CHANGED, (enabled: boolean) => {
                dispatch(setLobbyModeEnabled(enabled));
                if (enabled) {
                    dispatch(setLobbyMessageListener());
                }
            });

            conference.on(JitsiConferenceEvents.LOBBY_USER_JOINED, (id: string, name: string) => {
                const { soundsParticipantKnocking } = getState()['features/base/settings'];

                batch(() => {
                    dispatch(
                        participantIsKnockingOrUpdated({
                            id,
                            name
                        })
                    );
                    if (soundsParticipantKnocking) {
                        dispatch(playSound(KNOCKING_PARTICIPANT_SOUND_ID));
                    }

                    const isParticipantsPaneVisible = getParticipantsPaneOpen(getState());

                    if (typeof APP !== 'undefined') {
                        APP.API.notifyKnockingParticipant({
                            id,
                            name
                        });
                    }

                    if (isParticipantsPaneVisible || navigator.product === 'ReactNative') {
                        return;
                    }

                    _handleLobbyNotification({
                        dispatch,
                        getState
                    });
                });
            });

            conference.on(JitsiConferenceEvents.LOBBY_USER_UPDATED, (id: string, participant: IKnockingParticipant) => {
                dispatch(
                    participantIsKnockingOrUpdated({
                        ...participant,
                        id
                    })
                );
            });

            conference.on(JitsiConferenceEvents.LOBBY_USER_LEFT, (id: string) => {
                batch(() => {
                    dispatch(knockingParticipantLeft(id));
                    dispatch(removeLobbyChatParticipant());
                    dispatch(updateLobbyParticipantOnLeave(id));
                });
            });
        }
    }
);

/**
 * Function to handle the lobby notification.
 *
 * @param {Object} store - The Redux store.
 * @returns {void}
 */
function _handleLobbyNotification(store: IStore) {
    const { dispatch, getState } = store;
    const knockingParticipants = getKnockingParticipants(getState());

    if (knockingParticipants.length === 0) {
        dispatch(hideNotification(LOBBY_NOTIFICATION_ID));

        return;
    }

    let notificationTitle;
    let customActionNameKey;
    let customActionHandler;
    let customActionType;
    let descriptionKey;
    let icon;

    if (knockingParticipants.length === 1) {
        const firstParticipant = knockingParticipants[0];
        const showChat = showLobbyChatButton(firstParticipant)(getState());

        descriptionKey = 'notify.participantWantsToJoin';
        notificationTitle = firstParticipant.name;
        icon = NOTIFICATION_ICON.PARTICIPANT;
        customActionNameKey = [ 'participantsPane.actions.admit', 'participantsPane.actions.reject' ];
        customActionType = [ BUTTON_TYPES.PRIMARY, BUTTON_TYPES.DESTRUCTIVE ];
        customActionHandler = [ () => batch(() => {
            dispatch(hideNotification(LOBBY_NOTIFICATION_ID));
            dispatch(approveKnockingParticipant(firstParticipant.id));
        }),
        () => batch(() => {
            dispatch(hideNotification(LOBBY_NOTIFICATION_ID));
            dispatch(rejectKnockingParticipant(firstParticipant.id));
        }) ];

        // This checks if lobby chat button is available
        // and, if so, it adds it to the customActionNameKey array
        if (showChat) {
            customActionNameKey.splice(1, 0, 'lobby.chat');
            customActionType.splice(1, 0, BUTTON_TYPES.SECONDARY);
            customActionHandler.splice(1, 0, () => batch(() => {
                dispatch(handleLobbyChatInitialized(firstParticipant.id));
                dispatch(openChat({}, arePollsDisabled(getState())));
            }));
        }
    } else {
        descriptionKey = 'notify.participantsWantToJoin';
        notificationTitle = i18n.t('notify.waitingParticipants', {
            waitingParticipants: knockingParticipants.length
        });
        icon = NOTIFICATION_ICON.PARTICIPANTS;
        customActionNameKey = [ 'notify.viewLobby' ];
        customActionType = [ BUTTON_TYPES.PRIMARY ];
        customActionHandler = [ () => batch(() => {
            dispatch(hideNotification(LOBBY_NOTIFICATION_ID));
            dispatch(openParticipantsPane());
        }) ];
    }

    dispatch(showNotification({
        title: notificationTitle,
        descriptionKey,
        uid: LOBBY_NOTIFICATION_ID,
        customActionNameKey,
        customActionType,
        customActionHandler,
        icon
    }, NOTIFICATION_TIMEOUT_TYPE.STICKY));
}

/**
 * Function to handle the conference failed event and navigate the user to the lobby screen
 * based on the failure reason.
 *
 * @param {Object} store - The Redux store.
 * @param {Function} next - The Redux next function.
 * @param {Object} action - The Redux action.
 * @returns {Object}
 */
function _conferenceFailed({ dispatch, getState }: IStore, next: Function, action: AnyAction) {
    const { error } = action;
    const state = getState();
    const { membersOnly } = state['features/base/conference'];
    const nonFirstFailure = Boolean(membersOnly);
    const { isDisplayNameRequiredError } = state['features/lobby'];

    if (error.name === JitsiConferenceErrors.MEMBERS_ONLY_ERROR) {
        if (typeof error.recoverable === 'undefined') {
            error.recoverable = true;
        }

        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const [ _lobbyJid, lobbyWaitingForHost ] = error.params;

        const result = next(action);

        dispatch(openLobbyScreen());

        // if there was an error about display name and pre-join is not enabled
        if (shouldAutoKnock(state)
                || (isDisplayNameRequiredError && !isPrejoinEnabledInConfig(state))
                || lobbyWaitingForHost) {
            dispatch(startKnocking());
        }

        // In case of wrong password we need to be in the right state if in the meantime someone allows us to join
        if (nonFirstFailure) {
            dispatch(conferenceWillJoin(membersOnly));
        }

        dispatch(setPasswordJoinFailed(nonFirstFailure));

        return result;
    } else if (error.name === JitsiConferenceErrors.DISPLAY_NAME_REQUIRED) {
        const [ isLobbyEnabled ] = error.params;

        const result = next(action);

        // if the error is due to required display name because lobby is enabled for the room
        // if not showing the prejoin page then show lobby UI
        if (isLobbyEnabled && !isPrejoinPageVisible(state)) {
            dispatch(openLobbyScreen());
        }

        return result;
    }

    dispatch(hideLobbyScreen());

    if (error.name === JitsiConferenceErrors.CONFERENCE_ACCESS_DENIED) {
        dispatch(
            showNotification({
                appearance: NOTIFICATION_TYPE.ERROR,
                hideErrorSupportLink: true,
                titleKey: 'lobby.joinRejectedTitle',
                descriptionKey: 'lobby.joinRejectedMessage'
            }, NOTIFICATION_TIMEOUT_TYPE.LONG)
        );
    }

    return next(action);
}

/**
 * Handles cleanup of lobby state when a conference is joined.
 *
 * @param {Object} store - The Redux store.
 * @param {Function} next - The Redux next function.
 * @param {Object} action - The Redux action.
 * @returns {Object}
 */
function _conferenceJoined({ dispatch }: IStore, next: Function, action: AnyAction) {
    dispatch(hideLobbyScreen());

    return next(action);
}

/**
 * Finds the loadable avatar URL and updates the participant accordingly.
 *
 * @param {Object} store - The Redux store.
 * @param {Object} participant - The knocking participant.
 * @returns {void}
 */
function _findLoadableAvatarForKnockingParticipant(store: IStore, { id }: { id: string; }) {
    const { dispatch, getState } = store;
    const updatedParticipant = getState()['features/lobby'].knockingParticipants.find(p => p.id === id);
    const { disableThirdPartyRequests } = getState()['features/base/config'];

    if (!disableThirdPartyRequests && updatedParticipant && !updatedParticipant.loadableAvatarUrl) {
        getFirstLoadableAvatarUrl(updatedParticipant, store).then((result: { isUsingCORS: boolean; src: string; }) => {
            if (result) {
                const { isUsingCORS, src } = result;

                dispatch(
                    participantIsKnockingOrUpdated({
                        loadableAvatarUrl: src,
                        id,
                        isUsingCORS
                    })
                );
            }
        });
    }
}

/**
 * Check the endpoint message that arrived through the conference and
 * sends a lobby notification, if the message belongs to the feature.
 *
 * @param {Object} origin - The origin (initiator) of the message.
 * @param {Object} message - The actual message.
 * @param {Object} store - The Redux store.
 * @returns {void}
 */
function _maybeSendLobbyNotification(origin: any, message: any, { dispatch, getState }: IStore) {
    if (!origin?._id || message?.type !== 'lobby-notify') {
        return;
    }

    const notificationProps: INotificationProps = {
        descriptionArguments: {
            originParticipantName: getParticipantDisplayName(getState, origin._id),
            targetParticipantName: message.name
        },
        titleKey: 'lobby.notificationTitle'
    };

    switch (message.event) {
    case 'LOBBY-ENABLED':
        notificationProps.descriptionKey = `lobby.notificationLobby${message.value ? 'En' : 'Dis'}abled`;
        break;
    case 'LOBBY-ACCESS-GRANTED':
        notificationProps.descriptionKey = 'lobby.notificationLobbyAccessGranted';
        break;
    case 'LOBBY-ACCESS-DENIED':
        notificationProps.descriptionKey = 'lobby.notificationLobbyAccessDenied';
        break;
    }

    dispatch(
        showNotification(
            notificationProps,
            isTestModeEnabled(getState()) ? NOTIFICATION_TIMEOUT_TYPE.STICKY : NOTIFICATION_TIMEOUT_TYPE.MEDIUM
        )
    );
}


################################################################################

## File: .\jitsi-meet\react\features\lobby\reducer.ts

import {
    CONFERENCE_FAILED,
    CONFERENCE_JOINED,
    CONFERENCE_LEFT,
    SET_PASSWORD
} from '../base/conference/actionTypes';
import { JitsiConferenceErrors } from '../base/lib-jitsi-meet';
import ReducerRegistry from '../base/redux/ReducerRegistry';

import {
    KNOCKING_PARTICIPANT_ARRIVED_OR_UPDATED,
    KNOCKING_PARTICIPANT_LEFT,
    REMOVE_LOBBY_CHAT_WITH_MODERATOR,
    SET_KNOCKING_STATE,
    SET_LOBBY_MODE_ENABLED,
    SET_LOBBY_PARTICIPANT_CHAT_STATE,
    SET_LOBBY_VISIBILITY,
    SET_PASSWORD_JOIN_FAILED
} from './actionTypes';
import { IKnockingParticipant } from './types';

const DEFAULT_STATE = {
    isDisplayNameRequiredError: false,
    knocking: false,
    knockingParticipants: [],
    lobbyEnabled: false,
    lobbyVisible: false,
    passwordJoinFailed: false
};

export interface ILobbyState {

    /**
     * A conference error when we tried to join into a room with no display name
     * when lobby is enabled in the room.
     */
    isDisplayNameRequiredError: boolean;
    knocking: boolean;
    knockingParticipants: IKnockingParticipant[];
    lobbyEnabled: boolean;
    lobbyVisible: boolean;
    passwordJoinFailed: boolean;
}

/**
 * Reduces redux actions which affect the display of notifications.
 *
 * @param {Object} state - The current redux state.
 * @param {Object} action - The redux action to reduce.
 * @returns {Object} The next redux state which is the result of reducing the
 * specified {@code action}.
 */
ReducerRegistry.register<ILobbyState>('features/lobby', (state = DEFAULT_STATE, action): ILobbyState => {
    switch (action.type) {
    case CONFERENCE_FAILED: {
        if (action.error.name === JitsiConferenceErrors.DISPLAY_NAME_REQUIRED) {
            return {
                ...state,
                isDisplayNameRequiredError: true
            };
        }

        return {
            ...state,
            knocking: false
        };
    }
    case CONFERENCE_JOINED:
    case CONFERENCE_LEFT:
        return {
            ...state,
            knocking: false,
            passwordJoinFailed: false
        };
    case KNOCKING_PARTICIPANT_ARRIVED_OR_UPDATED:
        return _knockingParticipantArrivedOrUpdated(action.participant, state);
    case KNOCKING_PARTICIPANT_LEFT:
        return {
            ...state,
            knockingParticipants: state.knockingParticipants.filter(p => p.id !== action.id)
        };
    case SET_KNOCKING_STATE:
        return {
            ...state,
            knocking: action.knocking,
            passwordJoinFailed: false
        };
    case SET_LOBBY_MODE_ENABLED:
        return {
            ...state,
            lobbyEnabled: action.enabled
        };
    case SET_LOBBY_VISIBILITY:
        return {
            ...state,
            lobbyVisible: action.visible
        };
    case SET_PASSWORD:
        return {
            ...state,
            passwordJoinFailed: false
        };
    case SET_PASSWORD_JOIN_FAILED:
        return {
            ...state,
            passwordJoinFailed: action.failed
        };
    case SET_LOBBY_PARTICIPANT_CHAT_STATE:
        return {
            ...state,
            knockingParticipants: state.knockingParticipants.map(participant => {
                if (participant.id === action.participant.id) {
                    return {
                        ...participant,
                        chattingWithModerator: action.moderator.id
                    };
                }

                return participant;
            })
        };
    case REMOVE_LOBBY_CHAT_WITH_MODERATOR:
        return {
            ...state,
            knockingParticipants: state.knockingParticipants.map(participant => {
                if (participant.chattingWithModerator === action.moderatorId) {
                    return {
                        ...participant,
                        chattingWithModerator: undefined
                    };
                }

                return participant;
            })
        };
    }

    return state;
});

/**
 * Stores or updates a knocking participant.
 *
 * @param {Object} participant - The arrived or updated knocking participant.
 * @param {Object} state - The current Redux state of the feature.
 * @returns {Object}
 */
function _knockingParticipantArrivedOrUpdated(participant: IKnockingParticipant, state: ILobbyState) {
    let existingParticipant = state.knockingParticipants.find(p => p.id === participant.id);

    existingParticipant = {
        ...existingParticipant,
        ...participant
    };

    return {
        ...state,
        knockingParticipants: [
            ...state.knockingParticipants.filter(p => p.id !== participant.id),
            existingParticipant
        ]
    };
}


################################################################################

## File: .\jitsi-meet\react\features\lobby\sounds.ts

/**
 * The name of the bundled sound file which will be played when a
 * participant enters lobby.
 */
export const KNOCKING_PARTICIPANT_FILE = 'knock.mp3';


################################################################################

## File: .\jitsi-meet\react\features\lobby\types.ts

import { IParticipant } from '../base/participants/types';

export interface IKnockingParticipant extends IParticipant {
    chattingWithModerator?: string;
}


################################################################################

## File: .\jitsi-meet\react\features\lobby\components\native\styles.ts

import BaseTheme from '../../../base/ui/components/BaseTheme.native';

export default {

    lobbyChatWrapper: {
        backgroundColor: BaseTheme.palette.ui01,
        flex: 1
    },

    passwordJoinButtons: {
        top: 40
    },

    contentContainer: {
        alignItems: 'center',
        backgroundColor: BaseTheme.palette.uiBackground,
        bottom: 0,
        display: 'flex',
        height: 388,
        justifyContent: 'center',
        position: 'absolute',
        width: '100%',
        zIndex: 1
    },

    formWrapper: {
        alignItems: 'center',
        justifyContent: 'center'
    },

    customInput: {
        position: 'relative',
        textAlign: 'center',
        top: BaseTheme.spacing[6],
        width: 352
    },

    joiningMessage: {
        color: BaseTheme.palette.text01,
        marginHorizontal: BaseTheme.spacing[3],
        textAlign: 'center'
    },

    loadingIndicator: {
        marginBottom: BaseTheme.spacing[3]
    },

    // KnockingParticipantList

    knockingParticipantList: {
        backgroundColor: BaseTheme.palette.ui01
    },


    knockingParticipantListDetails: {
        flex: 1,
        marginLeft: BaseTheme.spacing[2]
    },

    knockingParticipantListEntry: {
        alignItems: 'center',
        backgroundColor: BaseTheme.palette.ui01,
        flexDirection: 'row'
    },

    knockingParticipantListText: {
        color: 'white'
    },

    lobbyButtonAdmit: {
        position: 'absolute',
        right: 184,
        top: 6
    },

    lobbyButtonChat: {
        position: 'absolute',
        right: 104,
        top: 6
    },

    lobbyButtonReject: {
        position: 'absolute',
        right: 16,
        top: 6
    },

    lobbyTitle: {
        ...BaseTheme.typography.heading5,
        color: BaseTheme.palette.text01,
        marginBottom: BaseTheme.spacing[3],
        textAlign: 'center'
    },

    lobbyWaitingFragmentContainer: {
        height: 260
    }
};


################################################################################

## File: .\jitsi-meet\react\features\mobile\audio-mode\actionTypes.ts

/**
 * The type of redux action to set Audio Mode device list.
 *
 * {
 *     type: _SET_AUDIOMODE_DEVICES,
 *     devices: Array
 * }
 *
 * @protected
 */
export const _SET_AUDIOMODE_DEVICES = '_SET_AUDIOMODE_DEVICES';

/**
 * The type of redux action to set Audio Mode module's subscriptions.
 *
 * {
 *     type: _SET_AUDIOMODE_SUBSCRIPTIONS,
 *     subscriptions: Array|undefined
 * }
 *
 * @protected
 */
export const _SET_AUDIOMODE_SUBSCRIPTIONS = '_SET_AUDIOMODE_SUBSCRIPTIONS';


################################################################################

## File: .\jitsi-meet\react\features\mobile\audio-mode\logger.ts

import { getLogger } from '../../base/logging/functions';

export default getLogger('features/mobile/audio-mode');


################################################################################

## File: .\jitsi-meet\react\features\mobile\audio-mode\middleware.ts

import { NativeEventEmitter, NativeModules } from 'react-native';
import { AnyAction } from 'redux';

import { IStore } from '../../app/types';
import { APP_WILL_MOUNT, APP_WILL_UNMOUNT } from '../../base/app/actionTypes';
import { SET_AUDIO_ONLY } from '../../base/audio-only/actionTypes';
import {
    CONFERENCE_FAILED,
    CONFERENCE_JOINED,
    CONFERENCE_LEFT
} from '../../base/conference/actionTypes';
import { getCurrentConference } from '../../base/conference/functions';
import { AUDIO_FOCUS_DISABLED } from '../../base/flags/constants';
import { getFeatureFlag } from '../../base/flags/functions';
import MiddlewareRegistry from '../../base/redux/MiddlewareRegistry';

import { _SET_AUDIOMODE_DEVICES, _SET_AUDIOMODE_SUBSCRIPTIONS } from './actionTypes';
import logger from './logger';

const { AudioMode } = NativeModules;
const AudioModeEmitter = new NativeEventEmitter(AudioMode);

/**
 * Middleware that captures conference actions and sets the correct audio mode
 * based on the type of conference. Audio-only conferences don't use the speaker
 * by default, and video conferences do.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {
    /* eslint-disable no-fallthrough */

    switch (action.type) {
    case _SET_AUDIOMODE_SUBSCRIPTIONS:
        _setSubscriptions(store);
        break;
    case APP_WILL_UNMOUNT: {
        store.dispatch({
            type: _SET_AUDIOMODE_SUBSCRIPTIONS,
            subscriptions: undefined
        });
        break;
    }
    case APP_WILL_MOUNT:
        _appWillMount(store);
    case CONFERENCE_FAILED: // eslint-disable-line no-fallthrough
    case CONFERENCE_LEFT:

    /*
    * NOTE: We moved the audio mode setting from CONFERENCE_WILL_JOIN to
    * CONFERENCE_JOINED because in case of a locked room, the app goes
    * through CONFERENCE_FAILED state and gets to CONFERENCE_JOINED only
    * after a correct password, so we want to make sure we have the correct
    * audio mode set up when we finally get to the conf, but also make sure
    * that the app is in the right audio mode if the user leaves the
    * conference after the password prompt appears.
    */
    case CONFERENCE_JOINED:
    case SET_AUDIO_ONLY:
        return _updateAudioMode(store, next, action);

    }

    /* eslint-enable no-fallthrough */

    return next(action);
});

/**
 * Notifies this feature that the action {@link APP_WILL_MOUNT} is being
 * dispatched within a specific redux {@code store}.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @private
 * @returns {void}
 */
function _appWillMount(store: IStore) {
    const subscriptions = [
        AudioModeEmitter.addListener(AudioMode.DEVICE_CHANGE_EVENT, _onDevicesUpdate, store)
    ];

    store.dispatch({
        type: _SET_AUDIOMODE_SUBSCRIPTIONS,
        subscriptions
    });
}

/**
 * Handles audio device changes. The list will be stored on the redux store.
 *
 * @param {Object} devices - The current list of devices.
 * @private
 * @returns {void}
 */
function _onDevicesUpdate(devices: any) {
    // @ts-ignore
    const { dispatch } = this; // eslint-disable-line @typescript-eslint/no-invalid-this

    dispatch({
        type: _SET_AUDIOMODE_DEVICES,
        devices
    });
}

/**
 * Notifies this feature that the action
 * {@link _SET_AUDIOMODE_SUBSCRIPTIONS} is being dispatched within
 * a specific redux {@code store}.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @private
 * @returns {void}
 */
function _setSubscriptions({ getState }: IStore) {
    const { subscriptions } = getState()['features/mobile/audio-mode'];

    if (subscriptions) {
        for (const subscription of subscriptions) {
            subscription.remove();
        }
    }
}

/**
 * Updates the audio mode based on the current (redux) state.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @param {Dispatch} next - The redux {@code dispatch} function to dispatch the
 * specified {@code action} in the specified {@code store}.
 * @param {Action} action - The redux action which is
 * being dispatched in the specified {@code store}.
 * @private
 * @returns {*} The value returned by {@code next(action)}.
 */
function _updateAudioMode({ getState }: IStore, next: Function, action: AnyAction) {
    const result = next(action);
    const state = getState();
    const conference = getCurrentConference(state);
    const { enabled: audioOnly } = state['features/base/audio-only'];
    let mode: string;

    if (getFeatureFlag(state, AUDIO_FOCUS_DISABLED, false)) {
        return result;
    } else if (conference) {
        mode = audioOnly ? AudioMode.AUDIO_CALL : AudioMode.VIDEO_CALL;
    } else {
        mode = AudioMode.DEFAULT;
    }

    AudioMode.setMode(mode).catch((err: any) => logger.error(`Failed to set audio mode ${String(mode)}: ${err}`));

    return result;
}


################################################################################

## File: .\jitsi-meet\react\features\mobile\audio-mode\reducer.ts

import ReducerRegistry from '../../base/redux/ReducerRegistry';
import { equals, set } from '../../base/redux/functions';

import { _SET_AUDIOMODE_DEVICES, _SET_AUDIOMODE_SUBSCRIPTIONS } from './actionTypes';
import { IRawDevice } from './components/AudioRoutePickerDialog';

export interface IMobileAudioModeState {
    devices: IRawDevice[];
    subscriptions: {
        remove: Function;
    }[];
}

const DEFAULT_STATE = {
    devices: [],
    subscriptions: []
};

ReducerRegistry.register<IMobileAudioModeState>('features/mobile/audio-mode',
(state = DEFAULT_STATE, action): IMobileAudioModeState => {
    switch (action.type) {
    case _SET_AUDIOMODE_DEVICES: {
        const { devices } = action;

        if (equals(state.devices, devices)) {
            return state;
        }

        return set(state, 'devices', devices);
    }
    case _SET_AUDIOMODE_SUBSCRIPTIONS:
        return set(state, 'subscriptions', action.subscriptions);
    }

    return state;
});


################################################################################

## File: .\jitsi-meet\react\features\mobile\audio-mode\components\AudioDeviceToggleButton.ts

import { connect } from 'react-redux';

import { openSheet } from '../../../base/dialog/actions';
import { translate } from '../../../base/i18n/functions';
import { IconVolumeUp } from '../../../base/icons/svg';
import AbstractButton, { IProps as AbstractButtonProps } from '../../../base/toolbox/components/AbstractButton';

import AudioRoutePickerDialog from './AudioRoutePickerDialog';

/**
 * Implements an {@link AbstractButton} to open the audio device list.
 */
class AudioDeviceToggleButton extends AbstractButton<AbstractButtonProps> {
    accessibilityLabel = 'toolbar.accessibilityLabel.audioRoute';
    icon = IconVolumeUp;
    label = 'toolbar.accessibilityLabel.audioRoute';

    /**
     * Handles clicking / pressing the button, and opens the appropriate dialog.
     *
     * @private
     * @returns {void}
     */
    _handleClick() {
        this.props.dispatch(openSheet(AudioRoutePickerDialog));
    }
}


export default translate(connect()(AudioDeviceToggleButton));


################################################################################

## File: .\jitsi-meet\react\features\mobile\audio-mode\components\styles.ts

import { MD_ITEM_HEIGHT } from '../../../base/dialog/components/native/styles';
import { createStyleSheet } from '../../../base/styles/functions.any';
import BaseTheme from '../../../base/ui/components/BaseTheme.native';

/**
 * The React {@code Component} styles of {@code AudioRoutePickerDialog}.
 *
 * It uses a {@code BottomSheet} and these have been implemented as per the
 * Material Design guidelines:
 * {@link https://material.io/guidelines/components/bottom-sheets.html}.
 */
export default createStyleSheet({
    /**
     * Base style for each row.
     */
    deviceRow: {
        alignItems: 'center',
        flexDirection: 'row',
        height: MD_ITEM_HEIGHT,
        marginLeft: BaseTheme.spacing[3]
    },

    /**
     * Style for the {@code Icon} element in a row.
     */
    deviceIcon: {
        color: BaseTheme.palette.icon01,
        fontSize: BaseTheme.spacing[4]
    },

    /**
     * Style for the {@code Text} element in a row.
     */
    deviceText: {
        color: BaseTheme.palette.text01,
        fontSize: 16,
        marginLeft: BaseTheme.spacing[5]
    },

    /**
     * Style for a row which is marked as selected.
     */
    selectedText: {
        color: BaseTheme.palette.action01
    }
});


################################################################################

## File: .\jitsi-meet\react\features\mobile\background\actions.ts

import { NativeEventSubscription } from 'react-native';

import { APP_STATE_CHANGED, _SET_APP_STATE_SUBSCRIPTION } from './actionTypes';

/**
 * Sets subscription for app state.
 *
 * @param {Function} subscription - Subscription for the native event.
 * @private
 * @returns {{
 *     type: _SET_APP_STATE_SUBSCRIPTION,
 *     subscription: NativeEventSubscription
 * }}
 */
export function _setAppStateSubscription(subscription?: NativeEventSubscription) {
    return {
        type: _SET_APP_STATE_SUBSCRIPTION,
        subscription
    };
}

/**
 * Signals that the App state has changed (in terms of execution state). The
 * application can be in 3 states: 'active', 'inactive' and 'background'.
 *
 * @param {string} appState - The new App state.
 * @public
 * @returns {{
 *     type: APP_STATE_CHANGED,
 *     appState: string
 * }}
 * @see {@link https://facebook.github.io/react-native/docs/appstate.html}
 */
export function appStateChanged(appState: string) {
    return {
        type: APP_STATE_CHANGED,
        appState
    };
}


################################################################################

## File: .\jitsi-meet\react\features\mobile\background\actionTypes.ts

/**
 * The type of redux action used for app state subscription.
 *
 * {
 *     type: _SET_APP_STATE_SUBSCRIPTION,
 *     subscription: NativeEventSubscription
 * }
 *
 * @protected
 */
export const _SET_APP_STATE_SUBSCRIPTION = '_SET_APP_STATE_SUBSCRIPTION';

/**
 * The type of redux action which signals that the app state has changed (in
 * terms of execution mode). The app state can be one of 'active', 'inactive',
 * or 'background'.
 *
 * {
 *     type: APP_STATE_CHANGED,
 *     appState: string
 * }
 *
 * @public
 * @see {@link https://facebook.github.io/react-native/docs/appstate.html}
 */
export const APP_STATE_CHANGED = 'APP_STATE_CHANGED';


################################################################################

## File: .\jitsi-meet\react\features\mobile\background\middleware.native.ts

import { AppState } from 'react-native';

import { IStore } from '../../app/types';
import { APP_WILL_MOUNT, APP_WILL_UNMOUNT } from '../../base/app/actionTypes';
import MiddlewareRegistry from '../../base/redux/MiddlewareRegistry';

import { _setAppStateSubscription, appStateChanged } from './actions';

/**
 * Middleware that captures App lifetime actions and subscribes to application
 * state changes. When the application state changes it will fire the action
 * required to mute or unmute the local video in case the application goes to
 * the background or comes back from it.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 * @see {@link https://facebook.github.io/react-native/docs/appstate.html}
 */
MiddlewareRegistry.register(store => next => action => {
    switch (action.type) {

    case APP_WILL_MOUNT: {
        const { dispatch } = store;

        _setAppStateListener(store, _onAppStateChange.bind(undefined, dispatch));
        break;
    }

    case APP_WILL_UNMOUNT:
        _setAppStateListener(store, undefined);
        break;
    }

    return next(action);
});

/**
 * Called by React Native's AppState API to notify that the application state
 * has changed. Dispatches the change within the (associated) redux store.
 *
 * @param {Dispatch} dispatch - The redux {@code dispatch} function.
 * @param {string} appState - The current application execution state.
 * @private
 * @returns {void}
 */
function _onAppStateChange(dispatch: IStore['dispatch'], appState: string) {
    dispatch(appStateChanged(appState));
}

/**
 * Notifies the feature filmstrip that the action
 * {@link _SET_IMMERSIVE_LISTENER} is being dispatched within a specific redux
 * store.
 *
 * @param {Store} store - The redux store in which the specified action is being
 * dispatched.
 * @param {any} listener - Listener for app state status.
 * @private
 * @returns {Object} The value returned by {@code next(action)}.
 */
function _setAppStateListener({ dispatch, getState }: IStore, listener: any) {
    const { subscription } = getState()['features/background'];

    subscription?.remove();

    dispatch(_setAppStateSubscription(listener ? AppState.addEventListener('change', listener) : undefined));
}


################################################################################

## File: .\jitsi-meet\react\features\mobile\background\reducer.ts

import { NativeEventSubscription } from 'react-native';

import ReducerRegistry from '../../base/redux/ReducerRegistry';

import { APP_STATE_CHANGED, _SET_APP_STATE_SUBSCRIPTION } from './actionTypes';

export interface IBackgroundState {
    appState: string;
    subscription?: NativeEventSubscription;
}

/**
 * The default/initial redux state of the feature background.
 */
const DEFAULT_STATE = {
    appState: 'active'
};

ReducerRegistry.register<IBackgroundState>('features/background', (state = DEFAULT_STATE, action): IBackgroundState => {
    switch (action.type) {

    case _SET_APP_STATE_SUBSCRIPTION:
        return {
            ...state,
            subscription: action.subscription
        };

    case APP_STATE_CHANGED:
        return {
            ...state,
            appState: action.appState
        };
    }

    return state;
});


################################################################################

## File: .\jitsi-meet\react\features\mobile\call-integration\actionTypes.ts

/**
 * The type of redux action to set CallKit's and ConnectionService's event
 * subscriptions.
 *
 * {
 *     type: _SET_CALL_INTEGRATION_SUBSCRIPTIONS,
 *     subscriptions: Array|undefined
 * }
 *
 * @protected
 */
export const _SET_CALL_INTEGRATION_SUBSCRIPTIONS
    = '_SET_CALL_INTEGRATION_SUBSCRIPTIONS';


################################################################################

## File: .\jitsi-meet\react\features\mobile\call-integration\CallKit.ts

import { NativeEventEmitter, NativeModules } from 'react-native';

import { getName } from '../../app/functions.native';

/**
 * Thin wrapper around Apple's CallKit functionality.
 *
 * In CallKit requests are performed via actions (either user or system started)
 * and async events are reported via dedicated methods. This class exposes that
 * functionality in the form of methods and events. One important thing to note
 * is that even if an action is started by the system (because the user pressed
 * the "end call" button in the CallKit view, for example) the event will be
 * emitted in the same way as it would if the action originated from calling
 * the "endCall" method in this class, for example.
 *
 * Emitted events:
 * - performAnswerCallAction: The user pressed the answer button.
 * - performEndCallAction: The call should be ended.
 * - performSetMutedCallAction: The call muted state should change. The
 *   ancillary `data` object contains a `muted` attribute.
 * - providerDidReset: The system has reset, all calls should be terminated.
 *   This event gets no associated data.
 *
 * All events get a `data` object with a `callUUID` property, unless stated
 * otherwise.
 */
let CallKit = NativeModules.RNCallKit;

// XXX Rather than wrapping RNCallKit in a new class and forwarding the many
// methods of the latter to the former, add the one additional method that we
// need to RNCallKit.
if (CallKit) {
    const eventEmitter = new NativeEventEmitter(CallKit);

    CallKit = {
        ...CallKit,
        addListener: eventEmitter.addListener.bind(eventEmitter),
        registerSubscriptions(context: any, delegate: any) {
            CallKit.setProviderConfiguration({
                iconTemplateImageName: 'CallKitIcon',
                localizedName: getName()
            });

            return [
                CallKit.addListener(
                    'performEndCallAction',
                    delegate._onPerformEndCallAction,
                    context),
                CallKit.addListener(
                    'performSetMutedCallAction',
                    delegate._onPerformSetMutedCallAction,
                    context),

                // According to CallKit's documentation, when the system resets
                // we should terminate all calls. Hence, providerDidReset is
                // the same to us as performEndCallAction.
                CallKit.addListener(
                    'providerDidReset',
                    delegate._onPerformEndCallAction,
                    context)
            ];
        }
    };
}

export default CallKit;


################################################################################

## File: .\jitsi-meet\react\features\mobile\call-integration\ConnectionService.ts

import { NativeEventEmitter, NativeModules } from 'react-native';

let ConnectionService = NativeModules.ConnectionService;

// XXX Rather than wrapping ConnectionService in a new class and forwarding
// the many methods of the latter to the former, add the one additional
// method that we need to ConnectionService.
if (ConnectionService) {
    const eventEmitter = new NativeEventEmitter(ConnectionService);

    ConnectionService = {
        ...ConnectionService,
        addListener: eventEmitter.addListener.bind(eventEmitter),
        registerSubscriptions(context: any, delegate: any) {
            return [
                ConnectionService.addListener(
                    'org.jitsi.meet:features/connection_service#disconnect',
                    delegate._onPerformEndCallAction,
                    context),
                ConnectionService.addListener(
                    'org.jitsi.meet:features/connection_service#abort',
                    delegate._onPerformEndCallAction,
                    context)
            ];
        },
        setMuted() {
            // Currently no-op, but remember to remove when implemented on
            // the native side
        }
    };
}

export default ConnectionService;


################################################################################

## File: .\jitsi-meet\react\features\mobile\call-integration\functions.ts

import { IStateful } from '../../base/app/types';
import { CALL_INTEGRATION_ENABLED } from '../../base/flags/constants';
import { getFeatureFlag } from '../../base/flags/functions';
import { toState } from '../../base/redux/functions';

/**
 * Checks if call integration is enabled or not.
 *
 * @param {Function|Object} stateful - The redux store or {@code getState}
 * function.
 * @returns {string} - Default URL for the app.
 */
export function isCallIntegrationEnabled(stateful: IStateful) {
    const state = toState(stateful);
    const { disableCallIntegration } = state['features/base/settings'];
    const flag = getFeatureFlag(state, CALL_INTEGRATION_ENABLED);

    // The feature flag has precedence.
    return flag ?? !disableCallIntegration;
}


################################################################################

## File: .\jitsi-meet\react\features\mobile\call-integration\middleware.ts

import { Alert, NativeModules, Platform } from 'react-native';
import { AnyAction } from 'redux';
import { v4 as uuidv4 } from 'uuid';

import { createTrackMutedEvent } from '../../analytics/AnalyticsEvents';
import { sendAnalytics } from '../../analytics/functions';
import { appNavigate } from '../../app/actions';
import { IReduxState, IStore } from '../../app/types';
import { APP_WILL_MOUNT, APP_WILL_UNMOUNT } from '../../base/app/actionTypes';
import { SET_AUDIO_ONLY } from '../../base/audio-only/actionTypes';
import {
    CONFERENCE_FAILED,
    CONFERENCE_JOINED,
    CONFERENCE_LEFT,
    CONFERENCE_WILL_JOIN,
    CONFERENCE_WILL_LEAVE
} from '../../base/conference/actionTypes';
import {
    getConferenceName,
    getCurrentConference
} from '../../base/conference/functions';
import { IJitsiConference } from '../../base/conference/reducer';
import { getInviteURL } from '../../base/connection/functions';
import { setAudioMuted } from '../../base/media/actions';
import { MEDIA_TYPE } from '../../base/media/constants';
import { isVideoMutedByAudioOnly } from '../../base/media/functions';
import MiddlewareRegistry from '../../base/redux/MiddlewareRegistry';
import {
    TRACK_ADDED,
    TRACK_REMOVED,
    TRACK_UPDATED
} from '../../base/tracks/actionTypes';
import { isLocalTrackMuted } from '../../base/tracks/functions.any';

import CallKit from './CallKit';
import ConnectionService from './ConnectionService';
import { _SET_CALL_INTEGRATION_SUBSCRIPTIONS } from './actionTypes';
import { isCallIntegrationEnabled } from './functions';

const { AudioMode } = NativeModules;
const CallIntegration = CallKit || ConnectionService;

/**
 * Middleware that captures system actions and hooks up CallKit.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
CallIntegration && MiddlewareRegistry.register(store => next => action => {
    switch (action.type) {
    case _SET_CALL_INTEGRATION_SUBSCRIPTIONS:
        return _setCallKitSubscriptions(store, next, action);

    case APP_WILL_MOUNT:
        return _appWillMount(store, next, action);

    case APP_WILL_UNMOUNT:
        store.dispatch({
            type: _SET_CALL_INTEGRATION_SUBSCRIPTIONS,
            subscriptions: undefined
        });
        break;

    case CONFERENCE_FAILED:
        return _conferenceFailed(store, next, action);

    case CONFERENCE_JOINED:
        return _conferenceJoined(store, next, action);

    // If a conference is being left in a graceful manner then
    // the CONFERENCE_WILL_LEAVE fires as soon as the conference starts
    // disconnecting. We need to destroy the call on the native side as soon
    // as possible, because the disconnection process is asynchronous and
    // Android not always supports two simultaneous calls at the same time
    // (even though it should according to the spec).
    case CONFERENCE_LEFT:
    case CONFERENCE_WILL_LEAVE:
        return _conferenceLeft(store, next, action);

    case CONFERENCE_WILL_JOIN:
        return _conferenceWillJoin(store, next, action);

    case SET_AUDIO_ONLY:
        return _setAudioOnly(store, next, action);

    case TRACK_ADDED:
    case TRACK_REMOVED:
    case TRACK_UPDATED:
        return _syncTrackState(store, next, action);
    }

    return next(action);
});

/**
 * Notifies the feature callkit that the action {@link APP_WILL_MOUNT} is being
 * dispatched within a specific redux {@code store}.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @param {Dispatch} next - The redux {@code dispatch} function to dispatch the
 * specified {@code action} in the specified {@code store}.
 * @param {Action} action - The redux action {@code APP_WILL_MOUNT} which is
 * being dispatched in the specified {@code store}.
 * @private
 * @returns {*} The value returned by {@code next(action)}.
 */
function _appWillMount({ dispatch, getState }: IStore, next: Function, action: AnyAction) {
    const result = next(action);

    const context = {
        dispatch,
        getState
    };

    const delegate = {
        _onPerformSetMutedCallAction,
        _onPerformEndCallAction
    };

    if (isCallIntegrationEnabled(getState)) {
        const subscriptions = CallIntegration.registerSubscriptions(context, delegate);

        subscriptions && dispatch({
            type: _SET_CALL_INTEGRATION_SUBSCRIPTIONS,
            subscriptions
        });
    }

    return result;
}

/**
 * Notifies the feature callkit that the action {@link CONFERENCE_FAILED} is
 * being dispatched within a specific redux {@code store}.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @param {Dispatch} next - The redux {@code dispatch} function to dispatch the
 * specified {@code action} in the specified {@code store}.
 * @param {Action} action - The redux action {@code CONFERENCE_FAILED} which is
 * being dispatched in the specified {@code store}.
 * @private
 * @returns {*} The value returned by {@code next(action)}.
 */
function _conferenceFailed({ getState }: IStore, next: Function, action: AnyAction) {
    const result = next(action);

    if (!isCallIntegrationEnabled(getState)) {
        return result;
    }

    // XXX Certain CONFERENCE_FAILED errors are recoverable i.e. they have
    // prevented the user from joining a specific conference but the app may be
    // able to eventually join the conference.
    if (!action.error.recoverable) {
        const { callUUID } = action.conference;

        if (callUUID) {
            delete action.conference.callUUID;
            CallIntegration.reportCallFailed(callUUID);
        }
    }

    return result;
}

/**
 * Notifies the feature callkit that the action {@link CONFERENCE_JOINED} is
 * being dispatched within a specific redux {@code store}.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @param {Dispatch} next - The redux {@code dispatch} function to dispatch the
 * specified {@code action} in the specified {@code store}.
 * @param {Action} action - The redux action {@code CONFERENCE_JOINED} which is
 * being dispatched in the specified {@code store}.
 * @private
 * @returns {*} The value returned by {@code next(action)}.
 */
function _conferenceJoined({ getState }: IStore, next: Function, action: AnyAction) {
    const result = next(action);

    if (!isCallIntegrationEnabled(getState)) {
        return result;
    }

    const { callUUID } = action.conference;

    if (callUUID) {
        CallIntegration.reportConnectedOutgoingCall(callUUID)
            .then(() => {
                // iOS 13 doesn't like the mute state to be false before the call is started
                // so we update it here in case the user selected startWithAudioMuted.
                if (Platform.OS === 'ios') {
                    _updateCallIntegrationMuted(action.conference, getState());
                }
            })
            .catch(() => {
                // Currently errors here are only emitted by Android.
                //
                // Some Samsung devices will fail to fully engage ConnectionService if no SIM card
                // was ever installed on the device. We could check for it, but it would require
                // the CALL_PHONE permission, which is not something we want to do, so fallback to
                // not using ConnectionService.
                _handleConnectionServiceFailure(getState());
            });
    }

    return result;
}

/**
 * Notifies the feature callkit that the action {@link CONFERENCE_LEFT} is being
 * dispatched within a specific redux {@code store}.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @param {Dispatch} next - The redux {@code dispatch} function to dispatch the
 * specified {@code action} in the specified {@code store}.
 * @param {Action} action - The redux action {@code CONFERENCE_LEFT} which is
 * being dispatched in the specified {@code store}.
 * @private
 * @returns {*} The value returned by {@code next(action)}.
 */
function _conferenceLeft({ getState }: IStore, next: Function, action: AnyAction) {
    const result = next(action);

    if (!isCallIntegrationEnabled(getState)) {
        return result;
    }

    const { callUUID } = action.conference;

    if (callUUID) {
        delete action.conference.callUUID;
        CallIntegration.endCall(callUUID);
    }

    return result;
}

/**
 * Notifies the feature callkit that the action {@link CONFERENCE_WILL_JOIN} is
 * being dispatched within a specific redux {@code store}.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @param {Dispatch} next - The redux {@code dispatch} function to dispatch the
 * specified {@code action} in the specified {@code store}.
 * @param {Action} action - The redux action {@code CONFERENCE_WILL_JOIN} which
 * is being dispatched in the specified {@code store}.
 * @private
 * @returns {*} The value returned by {@code next(action)}.
 */
function _conferenceWillJoin({ dispatch, getState }: IStore, next: Function, action: AnyAction) {
    const result = next(action);

    if (!isCallIntegrationEnabled(getState)) {
        return result;
    }

    const { conference } = action;
    const state = getState();
    const { callHandle, callUUID } = state['features/base/config'];
    const url = getInviteURL(state);
    const handle = callHandle || url.toString();
    const hasVideo = !isVideoMutedByAudioOnly(state);

    // If we already have a callUUID set, don't start a new call.
    if (conference.callUUID) {
        return result;
    }

    // When assigning the call UUID, do so in upper case, since iOS will return
    // it upper-cased.
    conference.callUUID = (callUUID || uuidv4()).toUpperCase();

    CallIntegration.startCall(conference.callUUID, handle, hasVideo)
        .then(() => {
            const displayName = getConferenceName(state);

            CallIntegration.updateCall(
                conference.callUUID,
                {
                    displayName,
                    hasVideo
                });

            // iOS 13 doesn't like the mute state to be false before the call is started
            // so delay it until the conference was joined.
            if (Platform.OS !== 'ios') {
                _updateCallIntegrationMuted(conference, state);
            }
        })
        .catch((error: any) => {
            // Currently this error codes are emitted only by Android.
            //
            if (error.code === 'CREATE_OUTGOING_CALL_FAILED') {
                // We're not tracking the call anymore - it doesn't exist on
                // the native side.
                delete conference.callUUID;
                dispatch(appNavigate(undefined));
                Alert.alert(
                    'Call aborted',
                    'There\'s already another call in progress.'
                        + ' Please end it first and try again.',
                    [
                        { text: 'OK' }
                    ],
                    { cancelable: false });
            } else {
                // Some devices fail because the CALL_PHONE permission is not granted, which is
                // nonsense, because it's not needed for self-managed connections.
                // Some other devices fail because ConnectionService is not supported.
                // Be that as it may, fallback to non-ConnectionService audio device handling.

                _handleConnectionServiceFailure(state);
            }
        });

    return result;
}

/**
 * Handles a ConnectionService fatal error by falling back to non-ConnectionService device management.
 *
 * @param {Object} state - Redux store.
 * @returns {void}
 */
function _handleConnectionServiceFailure(state: IReduxState) {
    const conference = getCurrentConference(state);

    if (conference) {
        // We're not tracking the call anymore.
        delete conference.callUUID;

        // ConnectionService has fatally failed. Alas, this also means audio device management would be broken, so
        // fallback to not using ConnectionService.
        // NOTE: We are not storing this in Settings, in case it's a transient issue, as far fetched as
        // that may be.
        if (AudioMode.setUseConnectionService) {
            AudioMode.setUseConnectionService(false);

            const hasVideo = !isVideoMutedByAudioOnly(state);

            // Set the desired audio mode, since we just reset the whole thing.
            AudioMode.setMode(hasVideo ? AudioMode.VIDEO_CALL : AudioMode.AUDIO_CALL);
        }
    }
}

/**
 * Handles CallKit's event {@code performEndCallAction}.
 *
 * @param {Object} event - The details of the CallKit event
 * {@code performEndCallAction}.
 * @returns {void}
 */
function _onPerformEndCallAction({ callUUID }: { callUUID: string; }) {
    // @ts-ignore
    const { dispatch, getState } = this; // eslint-disable-line @typescript-eslint/no-invalid-this
    const conference = getCurrentConference(getState);

    if (conference && conference.callUUID === callUUID) {
        // We arrive here when a call is ended by the system, for example, when
        // another incoming call is received and the user selects "End &
        // Accept".
        delete conference.callUUID;
        dispatch(appNavigate(undefined));
    }
}

/**
 * Handles CallKit's event {@code performSetMutedCallAction}.
 *
 * @param {Object} event - The details of the CallKit event
 * {@code performSetMutedCallAction}.
 * @returns {void}
 */
function _onPerformSetMutedCallAction({ callUUID, muted }: { callUUID: string; muted: boolean; }) {
    // @ts-ignore
    const { dispatch, getState } = this; // eslint-disable-line @typescript-eslint/no-invalid-this
    const conference = getCurrentConference(getState);

    if (conference && conference.callUUID === callUUID) {
        muted = Boolean(muted); // eslint-disable-line no-param-reassign
        sendAnalytics(
            createTrackMutedEvent('audio', 'call-integration', muted));
        dispatch(setAudioMuted(muted, /* ensureTrack */ true));
    }
}

/**
 * Update CallKit with the audio only state of the conference. When a conference
 * is in audio only mode we will tell CallKit the call has no video. This
 * affects how the call is saved in the recent calls list.
 *
 * XXX: Note that here we are taking the `audioOnly` value straight from the
 * action, instead of examining the state. This is intentional, as setting the
 * audio only involves multiple actions which will be reflected in the state
 * later, but we are just interested in knowing if the mode is going to be
 * set or not.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @param {Dispatch} next - The redux {@code dispatch} function to dispatch the
 * specified {@code action} in the specified {@code store}.
 * @param {Action} action - The redux action which is being dispatched in the
 * specified {@code store}.
 * @private
 * @returns {*} The value returned by {@code next(action)}.
 */
function _setAudioOnly({ getState }: IStore, next: Function, action: AnyAction) {
    const result = next(action);
    const state = getState();

    if (!isCallIntegrationEnabled(state)) {
        return result;
    }

    const conference = getCurrentConference(state);

    if (conference?.callUUID) {
        CallIntegration.updateCall(
            conference.callUUID,
            { hasVideo: !action.audioOnly });
    }

    return result;
}

/**
 * Notifies the feature callkit that the action
 * {@link _SET_CALL_INTEGRATION_SUBSCRIPTIONS} is being dispatched within
 * a specific redux {@code store}.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @param {Dispatch} next - The redux {@code dispatch} function to dispatch the
 * specified {@code action} in the specified {@code store}.
 * @param {Action} action - The redux action
 * {@code _SET_CALL_INTEGRATION_SUBSCRIPTIONS} which is being dispatched in
 * the specified {@code store}.
 * @private
 * @returns {*} The value returned by {@code next(action)}.
 */
function _setCallKitSubscriptions({ getState }: IStore, next: Function, action: AnyAction) {
    const { subscriptions } = getState()['features/call-integration'];

    if (subscriptions) {
        for (const subscription of subscriptions) {
            subscription.remove();
        }
    }

    return next(action);
}

/**
 * Synchronize the muted state of tracks with CallKit.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @param {Dispatch} next - The redux {@code dispatch} function to dispatch the
 * specified {@code action} in the specified {@code store}.
 * @param {Action} action - The redux action which is being dispatched in the
 * specified {@code store}.
 * @private
 * @returns {*} The value returned by {@code next(action)}.
 */
function _syncTrackState({ getState }: IStore, next: Function, action: AnyAction) {
    const result = next(action);

    if (!isCallIntegrationEnabled(getState)) {
        return result;
    }

    const { jitsiTrack } = action.track;
    const state = getState();
    const conference = getCurrentConference(state);

    if (jitsiTrack.isLocal() && conference && conference.callUUID) {
        switch (jitsiTrack.getType()) {
        case 'audio': {
            _updateCallIntegrationMuted(conference, state);
            break;
        }
        case 'video': {
            CallIntegration.updateCall(
                conference.callUUID,
                { hasVideo: !isVideoMutedByAudioOnly(state) });
            break;
        }

        }
    }

    return result;
}

/**
 * Update the muted state in the native side.
 *
 * @param {Object} conference - The current active conference.
 * @param {Object} state - The redux store state.
 * @private
 * @returns {void}
 */
function _updateCallIntegrationMuted(conference: IJitsiConference, state: IReduxState) {
    const muted = isLocalTrackMuted(state['features/base/tracks'], MEDIA_TYPE.AUDIO);

    CallIntegration.setMuted(conference.callUUID, muted);
}


################################################################################

## File: .\jitsi-meet\react\features\mobile\call-integration\reducer.ts

import ReducerRegistry from '../../base/redux/ReducerRegistry';
import { set } from '../../base/redux/functions';

import CallKit from './CallKit';
import ConnectionService from './ConnectionService';
import { _SET_CALL_INTEGRATION_SUBSCRIPTIONS } from './actionTypes';

export interface ICallIntegrationState {
    subscriptions?: any;
}

(CallKit || ConnectionService) && ReducerRegistry.register<ICallIntegrationState>(
    'features/call-integration',
    (state = {}, action): ICallIntegrationState => {
        switch (action.type) {
        case _SET_CALL_INTEGRATION_SUBSCRIPTIONS:
            return set(state, 'subscriptions', action.subscriptions);
        }

        return state;
    });


################################################################################

## File: .\jitsi-meet\react\features\mobile\external-api\actions.ts

import { READY_TO_CLOSE, SCREEN_SHARE_PARTICIPANTS_UPDATED } from './actionTypes';


/**
 * Creates a (redux) action which signals that the SDK is ready to be closed.
 *
 * @returns {{
 *     type: READY_TO_CLOSE
 * }}
 */
export function readyToClose() {
    return {
        type: READY_TO_CLOSE
    };
}

/**
 * Creates a (redux) action which signals that the list of known participants
 * with screen shares has changed.
 *
 * @param {string} participantIds - The participants which currently have active
 * screen share streams.
 * @returns {{
 *     type: SCREEN_SHARE_PARTICIPANTS_UPDATED,
 *     participantId: string
 * }}
 */
export function setParticipantsWithScreenShare(participantIds: Array<string>) {
    return {
        type: SCREEN_SHARE_PARTICIPANTS_UPDATED,
        participantIds
    };
}


################################################################################

## File: .\jitsi-meet\react\features\mobile\external-api\actionTypes.ts

/**
 * The type of the action which indicates the SDK is ready to be closed.
 *
 * @returns {{
 *     type: READY_TO_CLOSE
 * }}
 */
export const READY_TO_CLOSE = 'READY_TO_CLOSE';

/**
 * The type of the action which sets the list of known participant IDs which
 * have an active screen share.
 *
 * @returns {{
    *     type: SCREEN_SHARE_PARTICIPANTS_UPDATED,
    *     participantIds: Array<string>
    * }}
    */
export const SCREEN_SHARE_PARTICIPANTS_UPDATED
    = 'SCREEN_SHARE_PARTICIPANTS_UPDATED';


################################################################################

## File: .\jitsi-meet\react\features\mobile\external-api\functions.ts

import { debounce } from 'lodash-es';
import { NativeModules } from 'react-native';

import { IParticipant } from '../../base/participants/types';

import { readyToClose } from './actions';


/**
 * Sends a specific event to the native counterpart of the External API. Native
 * apps may listen to such events via the mechanisms provided by the (native)
 * mobile Jitsi Meet SDK.
 *
 * @param {Object} store - The redux store.
 * @param {string} name - The name of the event to send.
 * @param {Object} data - The details/specifics of the event to send determined
 * by/associated with the specified {@code name}.
 * @returns {void}
 */
export function sendEvent(store: Object, name: string, data: Object) {
    NativeModules.ExternalAPI.sendEvent(name, data);
}

/**
 * Debounced sending of `readyToClose`.
 */
export const _sendReadyToClose = debounce(dispatch => {
    dispatch(readyToClose());
}, 2500, { leading: true });

/**
 * Returns a participant info object based on the passed participant object from redux.
 *
 * @param {Participant} participant - The participant object from the redux store.
 * @returns {Object} - The participant info object.
 */
export function participantToParticipantInfo(participant: IParticipant) {
    return {
        isLocal: participant.local,
        email: participant.email,
        name: participant.name,
        participantId: participant.id,
        displayName: participant.displayName,
        avatarUrl: participant.avatarURL,
        role: participant.role
    };
}


################################################################################

## File: .\jitsi-meet\react\features\mobile\external-api\logger.ts

import { getLogger } from '../../base/logging/functions';

export default getLogger('features/mobile/external-api');


################################################################################

## File: .\jitsi-meet\react\features\mobile\external-api\middleware.ts

/* eslint-disable lines-around-comment */

import { debounce } from 'lodash-es';
import { NativeEventEmitter, NativeModules } from 'react-native';
import { AnyAction } from 'redux';

// @ts-expect-error
import { ENDPOINT_TEXT_MESSAGE_NAME } from '../../../../modules/API/constants';
import { appNavigate } from '../../app/actions.native';
import { IStore } from '../../app/types';
import { APP_WILL_MOUNT, APP_WILL_UNMOUNT } from '../../base/app/actionTypes';
import {
    CONFERENCE_BLURRED,
    CONFERENCE_FAILED,
    CONFERENCE_FOCUSED,
    CONFERENCE_JOINED,
    CONFERENCE_LEFT,
    CONFERENCE_WILL_JOIN,
    ENDPOINT_MESSAGE_RECEIVED,
    SET_ROOM
} from '../../base/conference/actionTypes';
import { JITSI_CONFERENCE_URL_KEY } from '../../base/conference/constants';
import {
    forEachConference,
    getCurrentConference,
    isRoomValid
} from '../../base/conference/functions';
import { IJitsiConference } from '../../base/conference/reducer';
import { CONNECTION_DISCONNECTED } from '../../base/connection/actionTypes';
import {
    JITSI_CONNECTION_CONFERENCE_KEY,
    JITSI_CONNECTION_URL_KEY
} from '../../base/connection/constants';
import { getURLWithoutParams } from '../../base/connection/utils';
import {
    JitsiConferenceEvents } from '../../base/lib-jitsi-meet';
import { SET_AUDIO_MUTED, SET_VIDEO_MUTED } from '../../base/media/actionTypes';
import { toggleCameraFacingMode } from '../../base/media/actions';
import { MEDIA_TYPE, VIDEO_TYPE } from '../../base/media/constants';
import { PARTICIPANT_JOINED, PARTICIPANT_LEFT } from '../../base/participants/actionTypes';
import {
    getLocalParticipant,
    getParticipantById,
    getRemoteParticipants,
    isScreenShareParticipantById
} from '../../base/participants/functions';
import MiddlewareRegistry from '../../base/redux/MiddlewareRegistry';
import StateListenerRegistry from '../../base/redux/StateListenerRegistry';
import { toggleScreensharing } from '../../base/tracks/actions.native';
import { getLocalTracks, isLocalTrackMuted } from '../../base/tracks/functions.native';
import { ITrack } from '../../base/tracks/types';
import { CLOSE_CHAT, OPEN_CHAT } from '../../chat/actionTypes';
import { closeChat, openChat, sendMessage, setPrivateMessageRecipient } from '../../chat/actions.native';
import { setRequestingSubtitles } from '../../subtitles/actions.any';
import { CUSTOM_OVERFLOW_MENU_BUTTON_PRESSED } from '../../toolbox/actionTypes';
import { muteLocal } from '../../video-menu/actions.native';
import { ENTER_PICTURE_IN_PICTURE } from '../picture-in-picture/actionTypes';
// @ts-ignore
import { isExternalAPIAvailable } from '../react-native-sdk/functions';

import { READY_TO_CLOSE } from './actionTypes';
import { setParticipantsWithScreenShare } from './actions';
import { participantToParticipantInfo, sendEvent } from './functions';
import logger from './logger';

/**
 * Event which will be emitted on the native side when a chat message is received
 * through the channel.
 */
const CHAT_MESSAGE_RECEIVED = 'CHAT_MESSAGE_RECEIVED';

/**
 * Event which will be emitted on the native side when the chat dialog is displayed/closed.
 */
const CHAT_TOGGLED = 'CHAT_TOGGLED';

/**
 * Event which will be emitted on the native side to indicate the conference
 * has ended either by user request or because an error was produced.
 */
const CONFERENCE_TERMINATED = 'CONFERENCE_TERMINATED';

/**
 * Event which will be emitted on the native side to indicate a message was received
 * through the channel.
 */
const ENDPOINT_TEXT_MESSAGE_RECEIVED = 'ENDPOINT_TEXT_MESSAGE_RECEIVED';

/**
 * Event which will be emitted on the native side to indicate a participant toggles
 * the screen share.
 */
const SCREEN_SHARE_TOGGLED = 'SCREEN_SHARE_TOGGLED';

/**
 * Event which will be emitted on the native side with the participant info array.
 */
const PARTICIPANTS_INFO_RETRIEVED = 'PARTICIPANTS_INFO_RETRIEVED';

const externalAPIEnabled = isExternalAPIAvailable();

let eventEmitter: any;

const { ExternalAPI } = NativeModules;

if (externalAPIEnabled) {
    eventEmitter = new NativeEventEmitter(ExternalAPI);
}

/**
 * Middleware that captures Redux actions and uses the ExternalAPI module to
 * turn them into native events so the application knows about them.
 *
 * @param {Store} store - Redux store.
 * @returns {Function}
 */
externalAPIEnabled && MiddlewareRegistry.register(store => next => action => {
    const oldAudioMuted = store.getState()['features/base/media'].audio.muted;
    const result = next(action);
    const { type } = action;

    switch (type) {
    case APP_WILL_MOUNT:
        _registerForNativeEvents(store);
        break;
    case APP_WILL_UNMOUNT:
        _unregisterForNativeEvents();
        break;
    case CONFERENCE_FAILED: {
        const { error, ...data } = action;

        // XXX Certain CONFERENCE_FAILED errors are recoverable i.e. they have
        // prevented the user from joining a specific conference but the app may
        // be able to eventually join the conference. For example, the app will
        // ask the user for a password upon
        // JitsiConferenceErrors.PASSWORD_REQUIRED and will retry joining the
        // conference afterwards. Such errors are to not reach the native
        // counterpart of the External API (or at least not in the
        // fatality/finality semantics attributed to
        // conferenceFailed:/onConferenceFailed).
        if (!error.recoverable) {
            _sendConferenceEvent(store, /* action */ {
                error: _toErrorString(error),
                ...data
            });
        }
        break;
    }

    case CONFERENCE_LEFT:
        _sendConferenceEvent(store, action);
        break;

    case CONFERENCE_JOINED:
        _sendConferenceEvent(store, action);
        _registerForEndpointTextMessages(store);
        break;

    case CONFERENCE_BLURRED:
        sendEvent(store, CONFERENCE_BLURRED, {});
        break;

    case CONFERENCE_FOCUSED:
        sendEvent(store, CONFERENCE_FOCUSED, {});
        break;

    case CONNECTION_DISCONNECTED: {
        // FIXME: This is a hack. See the description in the JITSI_CONNECTION_CONFERENCE_KEY constant definition.
        // Check if this connection was attached to any conference.
        // If it wasn't, fake a CONFERENCE_TERMINATED event.
        const { connection } = action;
        const conference = connection[JITSI_CONNECTION_CONFERENCE_KEY];

        if (!conference) {
            // This action will arrive late, so the locationURL stored on the state is no longer valid.
            const locationURL = connection[JITSI_CONNECTION_URL_KEY];

            sendEvent(
                store,
                CONFERENCE_TERMINATED,
                /* data */ {
                    url: _normalizeUrl(locationURL)
                });
        }

        break;
    }

    case CUSTOM_OVERFLOW_MENU_BUTTON_PRESSED: {
        const { id, text } = action;

        sendEvent(
            store,
            CUSTOM_OVERFLOW_MENU_BUTTON_PRESSED,
            {
                id,
                text
            });

        break;
    }

    case ENDPOINT_MESSAGE_RECEIVED: {
        const { participant, data } = action;

        if (data?.name === ENDPOINT_TEXT_MESSAGE_NAME) {
            sendEvent(
                store,
                ENDPOINT_TEXT_MESSAGE_RECEIVED,
                /* data */ {
                    message: data.text,
                    senderId: participant.getId()
                });
        }

        break;
    }

    case ENTER_PICTURE_IN_PICTURE:
        sendEvent(store, type, /* data */ {});
        break;

    case OPEN_CHAT:
    case CLOSE_CHAT: {
        sendEvent(
            store,
            CHAT_TOGGLED,
            /* data */ {
                isOpen: action.type === OPEN_CHAT
            });
        break;
    }

    case PARTICIPANT_JOINED:
    case PARTICIPANT_LEFT: {
        // Skip these events while not in a conference. SDK users can still retrieve them.
        const { conference } = store.getState()['features/base/conference'];

        if (!conference) {
            break;
        }

        const { participant } = action;

        const isVirtualScreenshareParticipant = isScreenShareParticipantById(store.getState(), participant.id);

        if (isVirtualScreenshareParticipant) {
            break;
        }

        sendEvent(
            store,
            action.type,
            participantToParticipantInfo(participant) /* data */
        );
        break;
    }

    case READY_TO_CLOSE:
        sendEvent(store, type, /* data */ {});
        break;

    case SET_ROOM:
        _maybeTriggerEarlyConferenceWillJoin(store, action);
        break;

    case SET_AUDIO_MUTED:
        if (action.muted !== oldAudioMuted) {
            sendEvent(
                store,
                'AUDIO_MUTED_CHANGED',
                /* data */ {
                    muted: action.muted
                });
        }
        break;

    case SET_VIDEO_MUTED:
        sendEvent(
            store,
            'VIDEO_MUTED_CHANGED',
            /* data */ {
                muted: action.muted
            });
        break;
    }

    return result;
});

/**
 * Listen for changes to the known media tracks and look
 * for updates to screen shares for emitting native events.
 * The listener is debounced to avoid state thrashing that might occur,
 * especially when switching in or out of p2p.
 */
externalAPIEnabled && StateListenerRegistry.register(
    /* selector */ state => state['features/base/tracks'],
    /* listener */ debounce((tracks: ITrack[], store: IStore) => {
        const oldScreenShares = store.getState()['features/mobile/external-api'].screenShares || [];
        const newScreenShares = tracks
            .filter(track => track.mediaType === MEDIA_TYPE.SCREENSHARE || track.videoType === VIDEO_TYPE.DESKTOP)
            .map(track => track.participantId);

        oldScreenShares.forEach(participantId => {
            if (!newScreenShares.includes(participantId)) {
                sendEvent(
                    store,
                    SCREEN_SHARE_TOGGLED,
                    /* data */ {
                        participantId,
                        sharing: false
                    });
            }
        });

        newScreenShares.forEach(participantId => {
            if (!oldScreenShares.includes(participantId)) {
                sendEvent(
                    store,
                    SCREEN_SHARE_TOGGLED,
                    /* data */ {
                        participantId,
                        sharing: true
                    });
            }
        });

        store.dispatch(setParticipantsWithScreenShare(newScreenShares));

    }, 100));

/**
 * Registers for events sent from the native side via NativeEventEmitter.
 *
 * @param {Store} store - The redux store.
 * @private
 * @returns {void}
 */
function _registerForNativeEvents(store: IStore) {
    const { getState, dispatch } = store;

    eventEmitter.addListener(ExternalAPI.HANG_UP, () => {
        dispatch(appNavigate(undefined));
    });

    eventEmitter.addListener(ExternalAPI.SET_AUDIO_MUTED, ({ muted }: any) => {
        dispatch(muteLocal(muted, MEDIA_TYPE.AUDIO));
    });

    eventEmitter.addListener(ExternalAPI.SET_VIDEO_MUTED, ({ muted }: any) => {
        dispatch(muteLocal(muted, MEDIA_TYPE.VIDEO));
    });

    eventEmitter.addListener(ExternalAPI.SEND_ENDPOINT_TEXT_MESSAGE, ({ to, message }: any) => {
        const conference = getCurrentConference(getState());

        try {
            conference?.sendEndpointMessage(to, {
                name: ENDPOINT_TEXT_MESSAGE_NAME,
                text: message
            });
        } catch (error) {
            logger.warn('Cannot send endpointMessage', error);
        }
    });

    eventEmitter.addListener(ExternalAPI.TOGGLE_SCREEN_SHARE, ({ enabled }: any) => {
        dispatch(toggleScreensharing(enabled));
    });

    eventEmitter.addListener(ExternalAPI.RETRIEVE_PARTICIPANTS_INFO, ({ requestId }: any) => {

        const participantsInfo = [];
        const remoteParticipants = getRemoteParticipants(store);
        const localParticipant = getLocalParticipant(store);

        localParticipant && participantsInfo.push(participantToParticipantInfo(localParticipant));
        remoteParticipants.forEach(participant => {
            if (!participant.fakeParticipant) {
                participantsInfo.push(participantToParticipantInfo(participant));
            }
        });

        sendEvent(
            store,
            PARTICIPANTS_INFO_RETRIEVED,
            /* data */ {
                participantsInfo,
                requestId
            });
    });

    eventEmitter.addListener(ExternalAPI.OPEN_CHAT, ({ to }: any) => {
        const participant = getParticipantById(store, to);

        dispatch(openChat(participant));
    });

    eventEmitter.addListener(ExternalAPI.CLOSE_CHAT, () => {
        dispatch(closeChat());
    });

    eventEmitter.addListener(ExternalAPI.SEND_CHAT_MESSAGE, ({ message, to }: any) => {
        const participant = getParticipantById(store, to);

        if (participant) {
            dispatch(setPrivateMessageRecipient(participant));
        }

        dispatch(sendMessage(message));
    });

    eventEmitter.addListener(ExternalAPI.SET_CLOSED_CAPTIONS_ENABLED,
        ({ enabled, displaySubtitles, language }: any) => {
            dispatch(setRequestingSubtitles(enabled, displaySubtitles, language));
        });

    eventEmitter.addListener(ExternalAPI.TOGGLE_CAMERA, () => {
        dispatch(toggleCameraFacingMode());
    });
}

/**
 * Unregister for events sent from the native side via NativeEventEmitter.
 *
 * @private
 * @returns {void}
 */
function _unregisterForNativeEvents() {
    eventEmitter.removeAllListeners(ExternalAPI.HANG_UP);
    eventEmitter.removeAllListeners(ExternalAPI.SET_AUDIO_MUTED);
    eventEmitter.removeAllListeners(ExternalAPI.SET_VIDEO_MUTED);
    eventEmitter.removeAllListeners(ExternalAPI.SEND_ENDPOINT_TEXT_MESSAGE);
    eventEmitter.removeAllListeners(ExternalAPI.TOGGLE_SCREEN_SHARE);
    eventEmitter.removeAllListeners(ExternalAPI.RETRIEVE_PARTICIPANTS_INFO);
    eventEmitter.removeAllListeners(ExternalAPI.OPEN_CHAT);
    eventEmitter.removeAllListeners(ExternalAPI.CLOSE_CHAT);
    eventEmitter.removeAllListeners(ExternalAPI.SEND_CHAT_MESSAGE);
    eventEmitter.removeAllListeners(ExternalAPI.SET_CLOSED_CAPTIONS_ENABLED);
    eventEmitter.removeAllListeners(ExternalAPI.TOGGLE_CAMERA);
}

/**
 * Registers for endpoint messages sent on conference data channel.
 *
 * @param {Store} store - The redux store.
 * @private
 * @returns {void}
 */
function _registerForEndpointTextMessages(store: IStore) {
    const conference = getCurrentConference(store.getState());

    conference?.on(
        JitsiConferenceEvents.MESSAGE_RECEIVED,
            (id: string, message: string, timestamp: number) => {
                sendEvent(
                    store,
                    CHAT_MESSAGE_RECEIVED,
                    /* data */ {
                        senderId: id,
                        message,
                        isPrivate: false,
                        timestamp
                    });
            }
    );

    conference?.on(
        JitsiConferenceEvents.PRIVATE_MESSAGE_RECEIVED,
        (id: string, message: string, timestamp: number) => {
            sendEvent(
                    store,
                    CHAT_MESSAGE_RECEIVED,
                    /* data */ {
                        senderId: id,
                        message,
                        isPrivate: true,
                        timestamp
                    });
        }
    );
}

/**
 * Returns a {@code String} representation of a specific error {@code Object}.
 *
 * @param {Error|Object|string} error - The error {@code Object} to return a
 * {@code String} representation of.
 * @returns {string} A {@code String} representation of the specified
 * {@code error}.
 */
function _toErrorString(
        error: Error | { message?: string; name?: string; } | string) {
    // XXX In lib-jitsi-meet and jitsi-meet we utilize errors in the form of
    // strings, Error instances, and plain objects which resemble Error.
    return (
        error
            ? typeof error === 'string'
                ? error
                : Error.prototype.toString.apply(error)
            : '');
}

/**
 * If {@link SET_ROOM} action happens for a valid conference room this method
 * will emit an early {@link CONFERENCE_WILL_JOIN} event to let the external API
 * know that a conference is being joined. Before that happens a connection must
 * be created and only then base/conference feature would emit
 * {@link CONFERENCE_WILL_JOIN}. That is fine for the Jitsi Meet app, because
 * that's the a conference instance gets created, but it's too late for
 * the external API to learn that. The latter {@link CONFERENCE_WILL_JOIN} is
 * swallowed in {@link _swallowEvent}.
 *
 * @param {Store} store - The redux store.
 * @param {Action} action - The redux action.
 * @returns {void}
 */
function _maybeTriggerEarlyConferenceWillJoin(store: IStore, action: AnyAction) {
    const { locationURL } = store.getState()['features/base/connection'];
    const { room } = action;

    isRoomValid(room) && locationURL && sendEvent(
        store,
        CONFERENCE_WILL_JOIN,
        /* data */ {
            url: _normalizeUrl(locationURL)
        });
}

/**
 * Normalizes the given URL for presentation over the external API.
 *
 * @param {URL} url -The URL to normalize.
 * @returns {string} - The normalized URL as a string.
 */
function _normalizeUrl(url: URL) {
    return getURLWithoutParams(url).href;
}

/**
 * Sends an event to the native counterpart of the External API for a specific
 * conference-related redux action.
 *
 * @param {Store} store - The redux store.
 * @param {Action} action - The redux action.
 * @returns {void}
 */
function _sendConferenceEvent(
        store: IStore,
        action: {
            conference: IJitsiConference;
            isAudioMuted?: boolean;
            type: string;
            url?: string;
        }) {
    const { conference, type, ...data } = action;

    // For these (redux) actions, conference identifies a JitsiConference
    // instance. The external API cannot transport such an object so we have to
    // transport an "equivalent".
    if (conference) { // @ts-ignore
        data.url = _normalizeUrl(conference[JITSI_CONFERENCE_URL_KEY]);

        const localTracks = getLocalTracks(store.getState()['features/base/tracks']);
        const isAudioMuted = isLocalTrackMuted(localTracks, MEDIA_TYPE.AUDIO);

        data.isAudioMuted = isAudioMuted;
    }

    if (_swallowEvent(store, action, data)) {
        return;
    }

    let type_;

    switch (type) {
    case CONFERENCE_FAILED:
    case CONFERENCE_LEFT:
        type_ = CONFERENCE_TERMINATED;
        break;
    default:
        type_ = type;
        break;
    }

    sendEvent(store, type_, data);
}

/**
 * Determines whether to not send a {@code CONFERENCE_LEFT} event to the native
 * counterpart of the External API.
 *
 * @param {Object} store - The redux store.
 * @param {Action} action - The redux action which is causing the sending of the
 * event.
 * @param {Object} data - The details/specifics of the event to send determined
 * by/associated with the specified {@code action}.
 * @returns {boolean} If the specified event is to not be sent, {@code true};
 * otherwise, {@code false}.
 */
function _swallowConferenceLeft({ getState }: IStore, action: AnyAction, { url }: { url: string; }) {
    // XXX Internally, we work with JitsiConference instances. Externally
    // though, we deal with URL strings. The relation between the two is many to
    // one so it's technically and practically possible (by externally loading
    // the same URL string multiple times) to try to send CONFERENCE_LEFT
    // externally for a URL string which identifies a JitsiConference that the
    // app is internally legitimately working with.
    let swallowConferenceLeft = false;

    url
        && forEachConference(getState, (conference, conferenceURL) => {
            if (conferenceURL && conferenceURL.toString() === url) {
                swallowConferenceLeft = true;
            }

            return !swallowConferenceLeft;
        });

    return swallowConferenceLeft;
}

/**
 * Determines whether to not send a specific event to the native counterpart of
 * the External API.
 *
 * @param {Object} store - The redux store.
 * @param {Action} action - The redux action which is causing the sending of the
 * event.
 * @param {Object} data - The details/specifics of the event to send determined
 * by/associated with the specified {@code action}.
 * @returns {boolean} If the specified event is to not be sent, {@code true};
 * otherwise, {@code false}.
 */
function _swallowEvent(store: IStore, action: AnyAction, data: any) {
    switch (action.type) {
    case CONFERENCE_LEFT:
        return _swallowConferenceLeft(store, action, data);

    default:
        return false;
    }
}


################################################################################

## File: .\jitsi-meet\react\features\mobile\external-api\reducer.ts

import ReducerRegistry from '../../base/redux/ReducerRegistry';

import { SCREEN_SHARE_PARTICIPANTS_UPDATED } from './actionTypes';

export interface IMobileExternalApiState {
    screenShares: string[];
}

const DEFAULT_STATE = {
    screenShares: []
};

ReducerRegistry.register<IMobileExternalApiState>('features/mobile/external-api',
(state = DEFAULT_STATE, action): IMobileExternalApiState => {
    switch (action.type) {
    case SCREEN_SHARE_PARTICIPANTS_UPDATED: {
        return {
            ...state,
            screenShares: action.participantIds
        };
    }
    }

    return state;
});


################################################################################

## File: .\jitsi-meet\react\features\mobile\full-screen\actions.ts

import { NativeEventSubscription } from 'react-native';

import { _SET_IMMERSIVE_SUBSCRIPTION } from './actionTypes';

/**
 * Sets the change event listener to be used with react-native-immersive's API.
 *
 * @param {Function} subscription - The function to be used with
 * react-native-immersive's API as the change event listener.
 * @protected
 * @returns {{
 *     type: _SET_IMMERSIVE_SUBSCRIPTION,
 *     subscription: ?NativeEventSubscription
 * }}
 */
export function _setImmersiveSubscription(subscription?: NativeEventSubscription) {
    return {
        type: _SET_IMMERSIVE_SUBSCRIPTION,
        subscription
    };
}


################################################################################

## File: .\jitsi-meet\react\features\mobile\full-screen\actionTypes.ts

/**
 * The type of (redux) action to set the react-native-immersive's change event
 * subscription.
 *
 * {
 *     type: _SET_IMMERSIVE_SUBSCRIPTION,
 *     subscription: Function
 * }
 *
 * @protected
 */
export const _SET_IMMERSIVE_SUBSCRIPTION = '_SET_IMMERSIVE_SUBSCRIPTION';


################################################################################

## File: .\jitsi-meet\react\features\mobile\full-screen\functions.ts

import { IReduxState } from '../../app/types';
import { getCurrentConference } from '../../base/conference/functions';
import { isAnyDialogOpen } from '../../base/dialog/functions';
import { FULLSCREEN_ENABLED } from '../../base/flags/constants';
import { getFeatureFlag } from '../../base/flags/functions';
import { isLocalVideoTrackDesktop } from '../../base/tracks/functions.any';

/**
 * Checks whether full-screen state should be used or not.
 *
 * @param {IReduxState} state - The redux state.
 * @returns {boolean} - Whether full-screen state shuld be used or not.
 */
export function shouldUseFullScreen(state: IReduxState) {
    const { enabled: audioOnly } = state['features/base/audio-only'];
    const conference = getCurrentConference(state);
    const dialogOpen = isAnyDialogOpen(state);
    const fullscreenEnabled = getFeatureFlag(state, FULLSCREEN_ENABLED, true);
    const isDesktopSharing = isLocalVideoTrackDesktop(state);

    return conference ? !audioOnly && !dialogOpen && !isDesktopSharing && fullscreenEnabled : false;
}


################################################################################

## File: .\jitsi-meet\react\features\mobile\full-screen\logger.ts

import { getLogger } from '../../base/logging/functions';

export default getLogger('features/full-screen');


################################################################################

## File: .\jitsi-meet\react\features\mobile\full-screen\middleware.ts

import ImmersiveMode from 'react-native-immersive-mode';

import { IStore } from '../../app/types';
import { APP_WILL_MOUNT, APP_WILL_UNMOUNT } from '../../base/app/actionTypes';
import MiddlewareRegistry from '../../base/redux/MiddlewareRegistry';
import StateListenerRegistry from '../../base/redux/StateListenerRegistry';

import { _setImmersiveSubscription } from './actions';
import { shouldUseFullScreen } from './functions';
import logger from './logger';

type BarVisibilityType = {
    navigationBottomBar: boolean;
    statusBar: boolean;
};

type ImmersiveListener = (visibility: BarVisibilityType) => void;

/**
 * Middleware that captures conference actions and activates or deactivates the
 * full screen mode. On iOS it hides the status bar, and on Android it uses the
 * immersive mode:
 * https://developer.android.com/training/system-ui/immersive.html
 * In immersive mode the status and navigation bars are hidden and thus the
 * entire screen will be covered by our application.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {
    switch (action.type) {
    case APP_WILL_MOUNT: {
        _setImmersiveListener(store, _onImmersiveChange.bind(undefined, store));

        break;
    }

    case APP_WILL_UNMOUNT:
        _setImmersiveListener(store, undefined);
        break;

    }

    return next(action);
});

StateListenerRegistry.register(
    /* selector */ shouldUseFullScreen,
    /* listener */ fullScreen => _setFullScreen(fullScreen)
);

/**
 * Handler for Immersive mode changes. This will be called when Android's
 * immersive mode changes. This can happen without us wanting, so re-evaluate if
 * immersive mode is desired and reactivate it if needed.
 *
 * @param {Object} store - The redux store.
 * @private
 * @returns {void}
 */
function _onImmersiveChange({ getState }: IStore) {
    const state = getState();
    const { appState } = state['features/background'];

    if (appState === 'active') {
        _setFullScreen(shouldUseFullScreen(state));
    }
}

/**
 * Activates/deactivates the full screen mode. On iOS it will hide the status
 * bar, and on Android it will turn immersive mode on.
 *
 * @param {boolean} fullScreen - True to set full screen mode, false to
 * deactivate it.
 * @private
 * @returns {void}
 */
function _setFullScreen(fullScreen: boolean) {
    logger.info(`Setting full-screen mode: ${fullScreen}`);
    ImmersiveMode.fullLayout(fullScreen);
    ImmersiveMode.setBarMode(fullScreen ? 'Full' : 'Normal');
}

/**
 * Notifies the feature filmstrip that the action
 * {@link _SET_IMMERSIVE_LISTENER} is being dispatched within a specific redux
 * store.
 *
 * @param {Store} store - The redux store in which the specified action is being
 * dispatched.
 * @param {Function} listener - Listener for immersive state.
 * @private
 * @returns {Object} The value returned by {@code next(action)}.
 */
function _setImmersiveListener({ dispatch, getState }: IStore, listener?: ImmersiveListener) {
    const { subscription } = getState()['features/full-screen'];

    subscription?.remove();

    dispatch(_setImmersiveSubscription(listener ? ImmersiveMode.addEventListener(listener) : undefined));
}


################################################################################

## File: .\jitsi-meet\react\features\mobile\full-screen\reducer.ts

import { NativeEventSubscription } from 'react-native';

import ReducerRegistry from '../../base/redux/ReducerRegistry';

import { _SET_IMMERSIVE_SUBSCRIPTION } from './actionTypes';

export interface IFullScreenState {
    subscription?: NativeEventSubscription;
}

ReducerRegistry.register<IFullScreenState>('features/full-screen', (state = {}, action): IFullScreenState => {
    switch (action.type) {
    case _SET_IMMERSIVE_SUBSCRIPTION:
        return {
            ...state,
            subscription: action.subscription
        };
    }

    return state;
});


################################################################################

## File: .\jitsi-meet\react\features\mobile\navigation\actionTypes.ts

export const _ROOT_NAVIGATION_READY = '_ROOT_NAVIGATION_READY';


################################################################################

## File: .\jitsi-meet\react\features\mobile\navigation\middleware.ts

import { AnyAction } from 'redux';

import { appNavigate } from '../../app/actions.native';
import { IStore } from '../../app/types';
import { CONFERENCE_FAILED } from '../../base/conference/actionTypes';
import { JitsiConferenceErrors } from '../../base/lib-jitsi-meet';
import MiddlewareRegistry from '../../base/redux/MiddlewareRegistry';

MiddlewareRegistry.register(store => next => action => {
    switch (action.type) {

    case CONFERENCE_FAILED:
        return _conferenceFailed(store, next, action);
    }

    return next(action);
});

/**
 * Function to handle the conference failed event and navigate the user to the lobby screen
 * based on the failure reason.
 *
 * @param {Object} store - The Redux store.
 * @param {Function} next - The Redux next function.
 * @param {Object} action - The Redux action.
 * @returns {Object}
 */
function _conferenceFailed({ dispatch }: IStore, next: Function, action: AnyAction) {
    const { error } = action;

    // We need to cover the case where knocking participant
    // is rejected from entering the conference
    if (error.name === JitsiConferenceErrors.CONFERENCE_ACCESS_DENIED) {
        dispatch(appNavigate(undefined));
    }

    return next(action);
}


################################################################################

## File: .\jitsi-meet\react\features\mobile\navigation\rootNavigationContainerRef.ts

import { NavigationContainerRef } from '@react-navigation/native';
import React from 'react';

import { IStore } from '../../app/types';
import { IStateful } from '../../base/app/types';
import { toState } from '../../base/redux/functions';
import { isWelcomePageEnabled } from '../../welcome/functions';
import { _sendReadyToClose } from '../external-api/functions';

import { screen } from './routes';

export const rootNavigationRef = React.createRef<NavigationContainerRef<any>>();


/**
 * User defined navigation action included inside the reference to the container.
 *
 * @param {string} name - Destination name of the route that has been defined somewhere.
 * @param {Object} params - Params to pass to the destination route.
 * @returns {Function}
 */
export function navigateRoot(name: string, params?: Object) {
    return rootNavigationRef.current?.navigate(name, params);
}

/**
 * User defined navigation action included inside the reference to the container.
 *
 * @returns {Function}
 */
export function goBack() {
    return rootNavigationRef.current?.goBack();
}

/**
 * Navigates back to Welcome page, if it's available.
 *
 * @param {Object|Function} stateful - Either the whole Redux state object or the Redux store's {@code getState} method.
 * @param {Function} dispatch - Redux dispatch function.
 * @returns {void}
 */
export function goBackToRoot(stateful: IStateful, dispatch: IStore['dispatch']) {
    const state = toState(stateful);

    if (isWelcomePageEnabled(state)) {
        navigateRoot(screen.welcome.main);
    } else {
        // For JitsiSDK, WelcomePage is not available
        _sendReadyToClose(dispatch);
    }
}


################################################################################

## File: .\jitsi-meet\react\features\mobile\navigation\routes.ts

export const screen = {
    conference: {
        breakoutRooms: 'Breakout Rooms',
        carmode: 'Car Mode',
        chat: 'Chat',
        chatandpolls: {
            main: 'Chat and Polls',
            tab: {
                chat: 'Chat',
                polls: 'Polls'
            }
        },
        container: 'Conference container',
        gifsMenu: 'GIPHY',
        invite: 'Invite',
        liveStream: 'Live stream',
        main: 'Conference',
        participants: 'Participants',
        root: 'Conference root',
        recording: 'Recording',
        salesforce: 'Link to Salesforce',
        security: 'Security Options',
        sharedDocument: 'Shared document',
        speakerStats: 'Speaker Stats',
        subtitles: 'Subtitles',
        whiteboard: 'Whiteboard'
    },
    connecting: 'Connecting',
    dialInSummary: 'Dial-In Info',
    preJoin: 'Pre-Join',
    lobby: {
        chat: 'Lobby chat',
        main: 'Lobby',
        root: 'Lobby root'
    },
    settings: {
        language: 'Language',
        links: {
            help: 'Help',
            privacy: 'Privacy',
            terms: 'Terms'
        },
        main: 'Settings',
        profile: 'Profile'
    },
    unsafeRoomWarning: 'Unsafe Room Warning',
    visitorsQueue: 'Visitors Queue',
    welcome: {
        main: 'Welcome',
        tabs: {
            calendar: 'Calendar',
            recent: 'Recent'
        }
    }
};


################################################################################

## File: .\jitsi-meet\react\features\mobile\navigation\screenOptions.ts

import { TransitionPresets } from '@react-navigation/stack';
import { Platform } from 'react-native';

import BaseTheme from '../../base/ui/components/BaseTheme.native';

import { goBack } from './components/conference/ConferenceNavigationContainerRef';
import { goBack as goBackToLobbyScreen } from './components/lobby/LobbyNavigationContainerRef';
import { lobbyScreenHeaderCloseButton, screenHeaderCloseButton } from './functions';
import { goBack as goBackToWelcomeScreen } from './rootNavigationContainerRef';


/**
 * Default modal transition for the current platform.
 */
export const modalPresentation = Platform.select({
    ios: TransitionPresets.ModalPresentationIOS,
    default: TransitionPresets.DefaultTransition
});

/**
 * Screen options and transition types.
 */
export const fullScreenOptions = {
    ...TransitionPresets.ModalTransition,
    gestureEnabled: false,
    headerShown: false
};

/**
 * Navigation container theme.
 */
export const navigationContainerTheme = {
    colors: {
        background: BaseTheme.palette.uiBackground
    }
};

/**
 * Screen options for welcome page.
 */
export const welcomeScreenOptions = {
    ...TransitionPresets.ModalTransition,
    gestureEnabled: false,
    headerShown: true,
    headerStyle: {
        backgroundColor: BaseTheme.palette.ui01
    },
    headerTitleStyle: {
        color: BaseTheme.palette.text01
    }
};

/**
 * Screen options for conference.
 */
export const conferenceScreenOptions = fullScreenOptions;

/**
 * Screen options for visitors queue.
 */
export const visitorsScreenOptions = fullScreenOptions;

/**
 * Tab bar options for chat screen.
 */
export const chatTabBarOptions = {
    swipeEnabled: false,
    tabBarIndicatorStyle: {
        backgroundColor: BaseTheme.palette.link01Active
    },
    tabBarStyle: {
        backgroundColor: BaseTheme.palette.ui01,
        borderBottomColor: BaseTheme.palette.ui06,
        borderBottomWidth: 0.4
    }
};

/**
 * Screen options for presentation type modals.
 */
export const presentationScreenOptions = {
    ...modalPresentation,
    headerBackTitleVisible: false,
    headerLeft: () => screenHeaderCloseButton(goBack),
    headerStatusBarHeight: 0,
    headerStyle: {
        backgroundColor: BaseTheme.palette.ui01
    },
    headerTitleStyle: {
        color: BaseTheme.palette.text01
    }
};

/**
 * Screen options for breakout rooms screen.
 */
export const breakoutRoomsScreenOptions = presentationScreenOptions;

/**
 * Screen options for car mode.
 */
export const carmodeScreenOptions = presentationScreenOptions;

/**
 * Screen options for chat.
 */
export const chatScreenOptions = presentationScreenOptions;

/**
 * Dial-IN Info screen options and transition types.
 */
export const dialInSummaryScreenOptions = {
    ...presentationScreenOptions,
    headerLeft: () => screenHeaderCloseButton(goBackToWelcomeScreen)
};

/**
 * Screen options for invite modal.
 */
export const inviteScreenOptions = presentationScreenOptions;

/**
 * Screen options for live stream modal.
 */
export const liveStreamScreenOptions = presentationScreenOptions;

/**
 * Screen options for participants modal.
 */
export const participantsScreenOptions = presentationScreenOptions;

/**
 * Screen options for speaker stats modal.
 */
export const speakerStatsScreenOptions = presentationScreenOptions;

/**
 * Screen options for security options modal.
 */
export const securityScreenOptions = presentationScreenOptions;

/**
 * Screen options for recording modal.
 */
export const recordingScreenOptions = presentationScreenOptions;

/**
 * Screen options for subtitles modal.
 */
export const subtitlesScreenOptions = presentationScreenOptions;

/**
 * Screen options for lobby modal.
 */
export const lobbyScreenOptions = {
    ...presentationScreenOptions,
    headerLeft: () => lobbyScreenHeaderCloseButton()
};

/**
 * Screen options for lobby chat modal.
 */
export const lobbyChatScreenOptions = {
    ...presentationScreenOptions,
    headerLeft: () => screenHeaderCloseButton(goBackToLobbyScreen)
};

/**
 * Screen options for salesforce link modal.
 */
export const salesforceScreenOptions = presentationScreenOptions;

/**
 * Screen options for GIPHY integration modal.
 */
export const gifsMenuOptions = presentationScreenOptions;

/**
 * Screen options for shared document.
 */
export const sharedDocumentScreenOptions = presentationScreenOptions;

/**
 * Screen options for settings modal.
 */
export const settingsScreenOptions = presentationScreenOptions;

/**
 * Screen options for connecting screen.
 */
export const connectingScreenOptions = {
    gestureEnabled: false,
    headerShown: false
};

/**
 * Screen options for the whiteboard screen.
 */
export const whiteboardScreenOptions = presentationScreenOptions;

/**
 * Screen options for pre-join screen.
 */
export const preJoinScreenOptions = {
    gestureEnabled: false,
    headerStyle: {
        backgroundColor: BaseTheme.palette.ui01
    },
    headerTitleStyle: {
        color: BaseTheme.palette.text01
    }
};

/**
 * Screen options for profile setting.
 */
export const profileSettingsScreenOptions = {
    headerStyle: {
        backgroundColor: BaseTheme.palette.ui01
    },
    headerTitleStyle: {
        color: BaseTheme.palette.text01
    },
    headerBackTitleVisible: false
};

/**
 * Screen options for language select screen.
 */
export const languageSelectScreenOptions = profileSettingsScreenOptions;

/**
 * Screen options for pre-join screen.
 */
export const unsafeMeetingScreenOptions = preJoinScreenOptions;

/**
 * Screen options for conference navigation container screen.
 */
export const conferenceNavigationContainerScreenOptions = {
    gestureEnabled: false,
    headerShown: false
};

/**
 * Screen options for lobby navigation container screen.
 */
export const lobbyNavigationContainerScreenOptions = {
    gestureEnabled: false,
    headerShown: false
};

/**
 * Screen options for settings navigation container screen.
 */
export const settingsNavigationContainerScreenOptions = {
    ...modalPresentation,
    gestureEnabled: true,
    headerShown: false
};


################################################################################

## File: .\jitsi-meet\react\features\mobile\navigation\components\styles.ts

import { BoxModel } from '../../../base/styles/components/styles/BoxModel';
import BaseTheme from '../../../base/ui/components/BaseTheme.native';


export const TEXT_COLOR = BaseTheme.palette.text01;

const unreadCounterDescription = {
    ...BaseTheme.typography.bodyShortBoldLarge,
    color: BaseTheme.palette.text03
};

const HEADER_ACTION_BUTTON_SIZE = 16;

const headerNavigationButtonLabel = {
    color: BaseTheme.palette.link01,
    fontSize: HEADER_ACTION_BUTTON_SIZE,
    lineHeight: BaseTheme.spacing[3]
};

const headerNavigationButton = {
    borderRadius: BaseTheme.shape.borderRadius,
    height: BaseTheme.spacing[6],
    marginLeft: BaseTheme.spacing[3]
};

/**
 * Styles of the navigation feature.
 */
export const navigationStyles = {

    connectingScreenContainer: {
        backgroundColor: BaseTheme.palette.uiBackground,
        flex: 1
    },

    connectingScreenContent: {
        alignItems: 'center',
        flex: 1,
        flexDirection: 'column',
        justifyContent: 'center'
    },

    connectingScreenIndicator: {
        margin: BoxModel.margin
    },

    connectingScreenText: {
        color: TEXT_COLOR
    },

    headerNavigationButton: {
        ...headerNavigationButton
    },

    headerNavigationButtonIcon: {
        ...headerNavigationButton,
        padding: BaseTheme.spacing[2]
    },

    headerNavigationButtonDisabled: {
        backgroundColor: 'transparent',
        marginLeft: BaseTheme.spacing[2]
    },

    headerNavigationButtonLabel: {
        ...headerNavigationButtonLabel
    },

    headerNavigationButtonLabelDisabled: {
        ...headerNavigationButtonLabel,
        color: BaseTheme.palette.text03
    },

    headerNavigationButtonLabelBold: {
        ...headerNavigationButtonLabel,
        ...BaseTheme.typography.bodyShortRegularLarge
    },

    headerNavigationButtonLabelBoldDisabled: {
        ...headerNavigationButtonLabel,
        ...BaseTheme.typography.bodyShortRegularLarge,
        color: BaseTheme.palette.text03
    },

    unreadCounterContainer: {
        alignItems: 'center',
        display: 'flex',
        flexDirection: 'row'
    },

    unreadCounterDescription: {
        ...unreadCounterDescription
    },

    unreadCounterDescriptionFocused: {
        ...unreadCounterDescription,
        color: BaseTheme.palette.text01
    },

    unreadCounterCircle: {
        backgroundColor: BaseTheme.palette.warning01,
        borderRadius: BaseTheme.spacing[4] / 2,
        height: BaseTheme.spacing[4],
        justifyContent: 'center',
        marginLeft: BaseTheme.spacing[2],
        width: BaseTheme.spacing[4]
    },

    unreadCounter: {
        ...BaseTheme.typography.bodyShortBold,
        alignSelf: 'center',
        color: BaseTheme.palette.text04
    }
};


################################################################################

## File: .\jitsi-meet\react\features\mobile\navigation\components\conference\ConferenceNavigationContainerRef.ts

import { NavigationContainerRef } from '@react-navigation/native';
import React from 'react';

export const conferenceNavigationRef = React.createRef<NavigationContainerRef<any>>();

/**
 * User defined navigation action included inside the reference to the container.
 *
 * @param {string} name - Destination name of the route that has been defined somewhere.
 * @param {Object} params - Params to pass to the destination route.
 * @returns {Function}
 */
export function navigate(name: string, params?: Object) {
    return conferenceNavigationRef.current?.navigate(name, params);
}

/**
 * User defined navigation action included inside the reference to the container.
 *
 * @returns {Function}
 */
export function goBack() {
    return conferenceNavigationRef.current?.goBack();
}

/**
 * User defined navigation action included inside the reference to the container.
 *
 * @param {Object} params - Params to pass to the destination route.
 * @returns {Function}
 */
export function setParams(params: Object) {
    return conferenceNavigationRef.current?.setParams(params);
}



################################################################################

## File: .\jitsi-meet\react\features\mobile\navigation\components\lobby\LobbyNavigationContainerRef.ts

import { NavigationContainerRef } from '@react-navigation/native';
import React from 'react';

export const lobbyNavigationContainerRef = React.createRef<NavigationContainerRef<any>>();

/**
 * User defined navigation action included inside the reference to the container.
 *
 * @param {string} name - Destination name of the route that has been defined somewhere.
 * @param {Object} params - Params to pass to the destination route.
 * @returns {Function}
 */
export function navigate(name: string, params?: Object) {
    return lobbyNavigationContainerRef.current?.navigate(name, params);
}

/**
 * User defined navigation action included inside the reference to the container.
 *
 * @returns {Function}
 */
export function goBack() {
    return lobbyNavigationContainerRef.current?.goBack();
}


################################################################################

## File: .\jitsi-meet\react\features\mobile\navigation\components\settings\SettingsNavigationContainerRef.ts

import { NavigationContainerRef } from '@react-navigation/native';
import React from 'react';

export const settingsNavigationContainerRef = React.createRef<NavigationContainerRef<any>>();

/**
 * User defined navigation action included inside the reference to the container.
 *
 * @param {string} name - Destination name of the route that has been defined somewhere.
 * @param {Object} params - Params to pass to the destination route.
 * @returns {Function}
 */
export function navigate(name: string, params?: Object) {
    return settingsNavigationContainerRef.current?.navigate(name, params);
}

/**
 * User defined navigation action included inside the reference to the container.
 *
 * @returns {Function}
 */
export function goBack() {
    return settingsNavigationContainerRef.current?.goBack();
}


################################################################################

## File: .\jitsi-meet\react\features\mobile\permissions\functions.ts

import { Alert, Linking, NativeModules } from 'react-native';

import Platform from '../../base/react/Platform.native';

/**
 * Opens the settings panel for the current platform.
 *
 * @private
 * @returns {void}
 */
export function openSettings() {
    switch (Platform.OS) {
    case 'android':
        NativeModules.AndroidSettings.open().catch(() => {
            Alert.alert(
                'Error opening settings',
                'Please open settings and grant the required permissions',
                [
                    { text: 'OK' }
                ]
            );
        });
        break;

    case 'ios':
        Linking.openURL('app-settings:');
        break;
    }
}


################################################################################

## File: .\jitsi-meet\react\features\mobile\permissions\middleware.ts

import { Alert } from 'react-native';

import { isRoomValid } from '../../base/conference/functions';
import i18next from '../../base/i18n/i18next';
import MiddlewareRegistry from '../../base/redux/MiddlewareRegistry';
import { TRACK_CREATE_ERROR } from '../../base/tracks/actionTypes';

import { openSettings } from './functions';

/**
 * Middleware that captures track permission errors and alerts the user so they
 * can enable the permission themselves.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {
    const result = next(action);

    switch (action.type) {
    case TRACK_CREATE_ERROR:
        // XXX We do not currently have user interface outside of a conference
        // which the user may tap and cause a permission-related error. If we
        // alert whenever we (intend to) ask for a permission, the scenario of
        // entering the WelcomePage, being asked for the camera permission, me
        // denying it, and being alerted that there is an error is overwhelming
        // me.
        if (action.permissionDenied
                && isRoomValid(
                        store.getState()['features/base/conference'].room)) {
            _alertPermissionErrorWithSettings(action.trackType);
        }
        break;
    }

    return result;
});

/**
 * Shows an alert panel which tells the user they have to manually grant some
 * permissions by opening Settings. A button which opens Settings is provided.
 *
 * @param {string} trackType - Type of track that failed with a permission
 * error.
 * @private
 * @returns {void}
 */
function _alertPermissionErrorWithSettings(trackType: string) {
    /* eslint-disable indent */
    const message = trackType === 'video'
        ? i18next.t('dialog.permissionCameraRequiredError')
        : i18next.t('dialog.permissionMicRequiredError');
    /* eslint-ensable indent */

    Alert.alert(
        i18next.t('dialog.permissionErrorTitle'),
        message,
        [
            { text: i18next.t('dialog.Cancel') },
            {
                onPress: openSettings,
                text: i18next.t('settings.title')
            }
        ],
        { cancelable: false });
}


################################################################################

## File: .\jitsi-meet\react\features\mobile\picture-in-picture\actions.ts

import { NativeModules } from 'react-native';

import { IStore } from '../../app/types';
import Platform from '../../base/react/Platform.native';

import { ENTER_PICTURE_IN_PICTURE } from './actionTypes';
import { isPipEnabled } from './functions';
import logger from './logger';

/**
 * Enters (or rather initiates entering) picture-in-picture.
 * Helper function to enter PiP mode. This is triggered by user request
 * (either pressing the button in the toolbox or the home button on Android)
 * and this triggers the PiP mode, iff it's available and we are in a
 * conference.
 *
 * @public
 * @returns {Function}
 */
export function enterPictureInPicture() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        // XXX At the time of this writing this action can only be dispatched by
        // the button which is on the conference view, which means that it's
        // fine to enter PiP mode.
        if (isPipEnabled(getState())) {
            const { PictureInPicture } = NativeModules;
            const p
                = Platform.OS === 'android'
                    ? PictureInPicture
                        ? PictureInPicture.enterPictureInPicture()
                        : Promise.reject(
                            new Error('Picture-in-Picture not supported'))
                    : Promise.resolve();

            p.catch((e: string) => logger.warn(`Error entering PiP mode: ${e}`));

            // We should still dispatch ENTER_PICTURE_IN_PICTURE for cases where
            // the external app needs to handle the event (ie. react-native-sdk)
            p.finally(() => dispatch({ type: ENTER_PICTURE_IN_PICTURE }));
        }
    };
}


################################################################################

## File: .\jitsi-meet\react\features\mobile\picture-in-picture\actionTypes.ts

/**
 * The type of redux action to enter (or rather initiate entering)
 * picture-in-picture.
 *
 * {
 *      type: ENTER_PICTURE_IN_PICTURE
 * }
 *
 * @public
 */
export const ENTER_PICTURE_IN_PICTURE = 'ENTER_PICTURE_IN_PICTURE';


################################################################################

## File: .\jitsi-meet\react\features\mobile\picture-in-picture\functions.ts

import { NativeModules, Platform } from 'react-native';

import { IReduxState } from '../../app/types';
import { PIP_ENABLED } from '../../base/flags/constants';
import { getFeatureFlag } from '../../base/flags/functions';

/**
 * Checks whether Picture-in-Picture is enabled.
 *
 * @param {Object} state - The Redux state.
 * @returns {boolean} Whether PiP is enabled or not.
 */
export function isPipEnabled(state: IReduxState) {
    let enabled = getFeatureFlag(state, PIP_ENABLED);

    // Override flag for Android, since it might be unsupported.
    if (Platform.OS === 'android' && (typeof enabled === 'undefined' || enabled)) {
        enabled = NativeModules.PictureInPicture.SUPPORTED;
    }

    return Boolean(enabled);
}

/**
 * Enabled/Disables the PictureInPicture mode in PiP native module.
 *
 * @param {boolean} enabled - Whether the PiP mode should be enabled.
 * @returns {void}
 */
export function setPictureInPictureEnabled(enabled: boolean) {
    const { PictureInPicture } = NativeModules;

    if (PictureInPicture) {
        PictureInPicture.setPictureInPictureEnabled(enabled);
    }
}


################################################################################

## File: .\jitsi-meet\react\features\mobile\picture-in-picture\logger.ts

import { getLogger } from '../../base/logging/functions';

export default getLogger('features/mobile/pip');


################################################################################

## File: .\jitsi-meet\react\features\mobile\picture-in-picture\components\PictureInPictureButton.ts

import { connect } from 'react-redux';

import { IReduxState } from '../../../app/types';
import { PIP_WHILE_SCREEN_SHARING_ENABLED } from '../../../base/flags/constants';
import { getFeatureFlag } from '../../../base/flags/functions';
import { translate } from '../../../base/i18n/functions';
import { IconArrowDown } from '../../../base/icons/svg';
import AbstractButton, { IProps as AbstractButtonProps } from '../../../base/toolbox/components/AbstractButton';
import { isLocalVideoTrackDesktop } from '../../../base/tracks/functions.native';
import { enterPictureInPicture } from '../actions';
import { isPipEnabled } from '../functions';

interface IProps extends AbstractButtonProps {

    /**
     * Whether Picture-in-Picture is enabled or not.
     */
    _enabled: boolean;
}

/**
 * An implementation of a button for entering Picture-in-Picture mode.
 */
class PictureInPictureButton extends AbstractButton<IProps> {
    accessibilityLabel = 'toolbar.accessibilityLabel.pip';
    icon = IconArrowDown;
    label = 'toolbar.pip';

    /**
     * Handles clicking / pressing the button.
     *
     * @protected
     * @returns {void}
     */
    _handleClick() {
        this.props.dispatch(enterPictureInPicture());
    }

    /**
     * Implements React's {@link Component#render()}.
     *
     * @inheritdoc
     * @returns {React$Node}
     */
    render() {
        return this.props._enabled ? super.render() : null;
    }
}

/**
 * Maps (parts of) the redux state to the associated props for the
 * {@code PictureInPictureButton} component.
 *
 * @param {Object} state - The Redux state.
 * @private
 * @returns {{
 *     _enabled: boolean
 * }}
 */
function _mapStateToProps(state: IReduxState) {
    const pipEnabled = isPipEnabled(state);
    const pipWhileScreenSharingEnabled = getFeatureFlag(state, PIP_WHILE_SCREEN_SHARING_ENABLED, false);
    const enabled = pipEnabled && (!isLocalVideoTrackDesktop(state) || pipWhileScreenSharingEnabled);

    return {
        _enabled: enabled
    };
}

export default translate(connect(_mapStateToProps)(PictureInPictureButton));


################################################################################

## File: .\jitsi-meet\react\features\mobile\polyfills\browser.js

import { DOMParser } from '@xmldom/xmldom';
import { atob, btoa } from 'abab';
import { Platform } from 'react-native';
import BackgroundTimer from 'react-native-background-timer';
import { TextDecoder, TextEncoder } from 'text-encoding';

import 'promise.allsettled/auto'; // Promise.allSettled.
import 'react-native-url-polyfill/auto'; // Complete URL polyfill.

import Storage from './Storage';

/**
 * Implements an absolute minimum of the common logic of
 * {@code Document.querySelector} and {@code Element.querySelector}. Implements
 * the most simple of selectors necessary to satisfy the call sites at the time
 * of this writing (i.e. Select by tagName).
 *
 * @param {Node} node - The Node which is the root of the tree to query.
 * @param {string} selectors - The group of CSS selectors to match on.
 * @returns {Element} - The first Element which is a descendant of the specified
 * node and matches the specified group of selectors.
 */
function _querySelector(node, selectors) {
    let element = null;

    node && _visitNode(node, n => {
        if (n.nodeType === 1 /* ELEMENT_NODE */
                && n.nodeName === selectors) {
            element = n;

            return true;
        }

        return false;
    });

    return element;
}

/**
 * Visits each Node in the tree of a specific root Node (using depth-first
 * traversal) and invokes a specific callback until the callback returns true.
 *
 * @param {Node} node - The root Node which represents the tree of Nodes to
 * visit.
 * @param {Function} callback - The callback to invoke with each visited Node.
 * @returns {boolean} - True if the specified callback returned true for a Node
 * (at which point the visiting stopped); otherwise, false.
 */
function _visitNode(node, callback) {
    if (callback(node)) {
        return true;
    }

    /* eslint-disable no-param-reassign, no-extra-parens */

    if ((node = node.firstChild)) {
        do {
            if (_visitNode(node, callback)) {
                return true;
            }
        } while ((node = node.nextSibling));
    }

    /* eslint-enable no-param-reassign, no-extra-parens */

    return false;
}

(global => {
    // DOMParser
    //
    // Required by:
    // - lib-jitsi-meet requires this if using WebSockets
    global.DOMParser = DOMParser;

    // addEventListener
    //
    // Required by:
    // - jQuery
    if (typeof global.addEventListener === 'undefined') {
        // eslint-disable-next-line no-empty-function
        global.addEventListener = () => {};
    }

    // removeEventListener
    //
    // Required by:
    // - features/base/conference/middleware
    if (typeof global.removeEventListener === 'undefined') {
        // eslint-disable-next-line no-empty-function
        global.removeEventListener = () => {};
    }

    // document
    //
    // Required by:
    // - jQuery
    // - Strophe
    if (typeof global.document === 'undefined') {
        const document
            = new DOMParser().parseFromString(
                '<html><head></head><body></body></html>',
                'text/xml');

        // document.addEventListener
        //
        // Required by:
        // - jQuery
        if (typeof document.addEventListener === 'undefined') {
            // eslint-disable-next-line no-empty-function
            document.addEventListener = () => {};
        }

        // document.cookie
        //
        // Required by:
        // - herment
        if (typeof document.cookie === 'undefined') {
            document.cookie = '';
        }

        // document.implementation.createHTMLDocument
        //
        // Required by:
        // - jQuery
        if (typeof document.implementation.createHTMLDocument === 'undefined') {
            document.implementation.createHTMLDocument = function(title = '') {
                const htmlDocument
                    = new DOMParser().parseFromString(
                        `<html>
                            <head><title>${title}</title></head>
                            <body></body>
                        </html>`,
                        'text/xml');

                Object.defineProperty(htmlDocument, 'body', {
                    get() {
                        return htmlDocument.getElementsByTagName('body')[0];
                    }
                });

                return htmlDocument;
            };
        }

        // Element.querySelector
        //
        // Required by:
        // - lib-jitsi-meet/modules/xmpp
        const elementPrototype
            = Object.getPrototypeOf(document.documentElement);

        if (elementPrototype) {
            if (typeof elementPrototype.querySelector === 'undefined') {
                elementPrototype.querySelector = function(selectors) {
                    return _querySelector(this, selectors);
                };
            }

            // Element.remove
            //
            // Required by:
            // - lib-jitsi-meet ChatRoom#onPresence parsing
            if (typeof elementPrototype.remove === 'undefined') {
                elementPrototype.remove = function() {
                    if (this.parentNode !== null) {
                        this.parentNode.removeChild(this);
                    }
                };
            }

            // Element.innerHTML
            //
            // Required by:
            // - jQuery's .append method
            if (!elementPrototype.hasOwnProperty('innerHTML')) {
                Object.defineProperty(elementPrototype, 'innerHTML', {
                    get() {
                        return this.childNodes.toString();
                    },

                    set(innerHTML) {
                        // MDN says: removes all of element's children, parses
                        // the content string and assigns the resulting nodes as
                        // children of the element.

                        // Remove all of element's children.
                        this.textContent = '';

                        // Parse the content string.
                        const d
                            = new DOMParser().parseFromString(
                                `<div>${innerHTML}</div>`,
                                'text/xml');

                        // Assign the resulting nodes as children of the
                        // element.
                        const documentElement = d.documentElement;
                        let child;

                        // eslint-disable-next-line no-cond-assign
                        while (child = documentElement.firstChild) {
                            this.appendChild(child);
                        }
                    }
                });
            }

            // Element.children
            //
            // Required by:
            // - lib-jitsi-meet ChatRoom#onPresence parsing
            if (!elementPrototype.hasOwnProperty('children')) {
                Object.defineProperty(elementPrototype, 'children', {
                    get() {
                        const nodes = this.childNodes;
                        const children = [];
                        let i = 0;
                        let node = nodes[i];

                        while (node) {
                            if (node.nodeType === 1) {
                                children.push(node);
                            }
                            i += 1;
                            node = nodes[i];
                        }

                        return children;
                    }
                });
            }
        }

        global.document = document;
    }

    // location
    if (typeof global.location === 'undefined') {
        global.location = {
            href: '',

            // Required by:
            // - lib-jitsi-meet/modules/xmpp/xmpp.js
            search: ''
        };
    }

    const { navigator } = global;

    if (navigator) {
        // userAgent
        //
        // Required by:
        // - lib-jitsi-meet/modules/browser/BrowserDetection.js
        let userAgent = navigator.userAgent || '';

        // react-native/version
        const { name, version } = require('react-native/package.json');
        let rn = name || 'react-native';

        version && (rn += `/${version}`);
        if (userAgent.indexOf(rn) === -1) {
            userAgent = userAgent ? `${rn} ${userAgent}` : rn;
        }

        // (OS version)
        const os = `(${Platform.OS} ${Platform.Version})`;

        if (userAgent.indexOf(os) === -1) {
            userAgent = userAgent ? `${userAgent} ${os}` : os;
        }

        navigator.userAgent = userAgent;
    }

    // WebRTC
    require('./webrtc');

    // Performance API

    // RN only provides the now() method, since the polyfill refers the global
    // performance object itself we extract it here to avoid infinite recursion.
    const performanceNow = global.performance.now;

    const perf = require('react-native-performance');

    global.performance = perf.default;
    global.performance.now = performanceNow;
    global.PerformanceObserver = perf.PerformanceObserver;

    // Timers
    //
    // React Native's timers won't run while the app is in the background, this
    // is a known limitation. Replace them with a background-friendly alternative.
    if (Platform.OS === 'android') {
        global.clearTimeout = BackgroundTimer.clearTimeout.bind(BackgroundTimer);
        global.clearInterval = BackgroundTimer.clearInterval.bind(BackgroundTimer);
        global.setInterval = BackgroundTimer.setInterval.bind(BackgroundTimer);
        global.setTimeout = (fn, ms = 0) => BackgroundTimer.setTimeout(fn, ms);
    }

    // localStorage
    if (typeof global.localStorage === 'undefined') {
        global.localStorage = new Storage('@jitsi-meet/');
    }

    // sessionStorage
    //
    // Required by:
    // - herment
    // - Strophe
    if (typeof global.sessionStorage === 'undefined') {
        global.sessionStorage = new Storage();
    }

    global.TextDecoder = TextDecoder;
    global.TextEncoder = TextEncoder;

    // atob
    //
    // Required by:
    // - Strophe
    if (typeof global.atob === 'undefined') {
        global.atob = atob;
    }

    // btoa
    //
    // Required by:
    // - Strophe
    if (typeof global.btoa === 'undefined') {
        global.btoa = btoa;
    }

})(global || window || this); // eslint-disable-line no-invalid-this


################################################################################

## File: .\jitsi-meet\react\features\mobile\polyfills\custom.js

import { NativeModules } from 'react-native';


global.JITSI_MEET_LITE_SDK = Boolean(NativeModules.AppInfo.isLiteSDK);


################################################################################

## File: .\jitsi-meet\react\features\mobile\polyfills\index.js

import './browser';
import './custom';


################################################################################

## File: .\jitsi-meet\react\features\mobile\polyfills\ipv6utils.js

import { NativeModules } from 'react-native';
import { RTCSessionDescription } from 'react-native-webrtc';

/**
 * Synthesizes IPv6 addresses on iOS in order to support IPv6 NAT64 networks.
 *
 * @param {RTCSessionDescription} sdp - The RTCSessionDescription which
 * specifies the configuration of the remote end of the connection.
 * @private
 * @returns {Promise}
 */
export function synthesizeIPv6Addresses(sdp) {
    return (
        new Promise(resolve => resolve(_synthesizeIPv6Addresses0(sdp)))
            .then(({ ips, lines }) =>
                Promise.all(Array.from(ips.values()))
                    .then(() => _synthesizeIPv6Addresses1(sdp, ips, lines))
            ));
}

/* eslint-disable max-depth */

/**
 * Synthesizes an IPv6 address from a specific IPv4 address.
 *
 * @param {string} ipv4 - The IPv4 address from which an IPv6 address is to be
 * synthesized.
 * @returns {Promise<?string>} A {@code Promise} which gets resolved with the
 * IPv6 address synthesized from the specified {@code ipv4} or a falsy value to
 * be treated as inability to synthesize an IPv6 address from the specified
 * {@code ipv4}.
 */
const _synthesizeIPv6FromIPv4Address = (function() {
    // POSIX.getaddrinfo
    const { POSIX } = NativeModules;

    if (POSIX) {
        const { getaddrinfo } = POSIX;

        if (typeof getaddrinfo === 'function') {
            return ipv4 =>
                getaddrinfo(/* hostname */ ipv4, /* servname */ undefined)
                    .then(([ { ai_addr: ipv6 } ]) => ipv6);
        }
    }

    // NAT64AddrInfo.getIPv6Address
    const { NAT64AddrInfo } = NativeModules;

    if (NAT64AddrInfo) {
        const { getIPv6Address } = NAT64AddrInfo;

        if (typeof getIPv6Address === 'function') {
            return getIPv6Address;
        }
    }

    // There's no POSIX.getaddrinfo or NAT64AddrInfo.getIPv6Address.
    return ip => Promise.resolve(ip);
})();

/**
 * Begins the asynchronous synthesis of IPv6 addresses.
 *
 * @param {RTCSessionDescription} sessionDescription - The RTCSessionDescription
 * for which IPv6 addresses will be synthesized.
 * @private
 * @returns {{
 *     ips: Map,
 *     lines: Array
 * }}
 */
function _synthesizeIPv6Addresses0(sessionDescription) {
    const sdp = sessionDescription.sdp;
    let start = 0;
    const lines = [];
    const ips = new Map();

    do {
        const end = sdp.indexOf('\r\n', start);
        let line;

        if (end === -1) {
            line = sdp.substring(start);

            // Break out of the loop at the end of the iteration.
            start = undefined;
        } else {
            line = sdp.substring(start, end);
            start = end + 2;
        }

        if (line.startsWith('a=candidate:')) {
            const candidate = line.split(' ');

            if (candidate.length >= 10 && candidate[6] === 'typ') {
                const ip4s = [ candidate[4] ];
                let abort = false;

                for (let i = 8; i < candidate.length; ++i) {
                    if (candidate[i] === 'raddr') {
                        ip4s.push(candidate[++i]);
                        break;
                    }
                }

                for (const ip of ip4s) {
                    if (ip.indexOf(':') === -1) {
                        ips.has(ip)
                            || ips.set(ip, new Promise((resolve, reject) => {
                                const v = ips.get(ip);

                                if (v && typeof v === 'string') {
                                    resolve(v);
                                } else {
                                    _synthesizeIPv6FromIPv4Address(ip).then(
                                        value => {
                                            if (!value
                                                    || value.indexOf(':') === -1
                                                    || value === ips.get(ip)) {
                                                ips.delete(ip);
                                            } else {
                                                ips.set(ip, value);
                                            }
                                            resolve(value);
                                        },
                                        reject);
                                }
                            }));
                    } else {
                        abort = true;
                        break;
                    }
                }
                if (abort) {
                    ips.clear();
                    break;
                }

                line = candidate;
            }
        }

        lines.push(line);
    } while (start);

    return {
        ips,
        lines
    };
}

/* eslint-enable max-depth */

/**
 * Completes the asynchronous synthesis of IPv6 addresses.
 *
 * @param {RTCSessionDescription} sessionDescription - The RTCSessionDescription
 * for which IPv6 addresses are being synthesized.
 * @param {Map} ips - A Map of IPv4 addresses found in the specified
 * sessionDescription to synthesized IPv6 addresses.
 * @param {Array} lines - The lines of the specified sessionDescription.
 * @private
 * @returns {RTCSessionDescription} A RTCSessionDescription that represents the
 * result of the synthesis of IPv6 addresses.
 */
function _synthesizeIPv6Addresses1(sessionDescription, ips, lines) {
    if (ips.size === 0) {
        return sessionDescription;
    }

    for (let l = 0; l < lines.length; ++l) {
        const candidate = lines[l];

        if (typeof candidate !== 'string') {
            let ip4 = candidate[4];
            let ip6 = ips.get(ip4);

            ip6 && (candidate[4] = ip6);

            for (let i = 8; i < candidate.length; ++i) {
                if (candidate[i] === 'raddr') {
                    ip4 = candidate[++i];
                    (ip6 = ips.get(ip4)) && (candidate[i] = ip6);
                    break;
                }
            }

            lines[l] = candidate.join(' ');
        }
    }

    return new RTCSessionDescription({
        sdp: lines.join('\r\n'),
        type: sessionDescription.type
    });
}


################################################################################

## File: .\jitsi-meet\react\features\mobile\polyfills\RTCPeerConnection.js

import { RTCPeerConnection as PC } from 'react-native-webrtc';

import { synthesizeIPv6Addresses } from './ipv6utils';

/**
 * Override PeerConnection to synthesize IPv6 addresses.
 */
export default class RTCPeerConnection extends PC {

    /**
     * Synthesize IPv6 addresses before calling the underlying setRemoteDescription.
     *
     * @param {Object} description - SDP.
     * @returns {Promise<undefined>} A promise which is resolved once the operation is complete.
     */
    async setRemoteDescription(description) {
        return super.setRemoteDescription(await synthesizeIPv6Addresses(description));
    }
}


################################################################################

## File: .\jitsi-meet\react\features\mobile\polyfills\Storage.js

import AsyncStorage from '@react-native-async-storage/async-storage';

/**
 * A Web Sorage API implementation used for polyfilling
 * {@code window.localStorage} and/or {@code window.sessionStorage}.
 * <p>
 * The Web Storage API is synchronous whereas React Native's builtin generic
 * storage API {@code AsyncStorage} is asynchronous so the implementation with
 * persistence is optimistic: it will first store the value locally in memory so
 * that results can be served synchronously and then persist the value
 * asynchronously. If an asynchronous operation produces an error, it's ignored.
 */
export default class Storage {
    /**
     * Initializes a new {@code Storage} instance. Loads all previously
     * persisted data items from React Native's {@code AsyncStorage} if
     * necessary.
     *
     * @param {string|undefined} keyPrefix - The prefix of the
     * {@code AsyncStorage} keys to be persisted by this storage.
     */
    constructor(keyPrefix) {
        /**
         * The prefix of the {@code AsyncStorage} keys persisted by this
         * storage. If {@code undefined}, then the data items stored in this
         * storage will not be persisted.
         *
         * @private
         * @type {string}
         */
        this._keyPrefix = keyPrefix;

        // Perform optional asynchronous initialization.
        const initializing = this._initializeAsync();

        if (initializing) {
            // Indicate that asynchronous initialization is under way.
            this._initializing = initializing;

            // When the asynchronous initialization completes, indicate its
            // completion.
            initializing.finally(() => {
                if (this._initializing === initializing) {
                    this._initializing = undefined;
                }
            });
        }
    }

    /**
     * Removes all keys from this storage.
     *
     * @returns {void}
     */
    clear() {
        for (const key of Object.keys(this)) {
            this.removeItem(key);
        }
    }

    /**
     * Returns the value associated with a specific key in this storage.
     *
     * @param {string} key - The name of the key to retrieve the value of.
     * @returns {string|null} The value associated with {@code key} or
     * {@code null}.
     */
    getItem(key) {
        return this.hasOwnProperty(key) ? this[key] : null;
    }

    /**
     * Returns the value associated with a specific key in this {@code Storage}
     * in an async manner. The method is required for the cases where we need
     * the stored data but we're not sure yet whether this {@code Storage} is
     * already initialized (e.g. On app start).
     *
     * @param {string} key - The name of the key to retrieve the value of.
     * @returns {Promise}
     */
    _getItemAsync(key) {
        return (
            (this._initializing || Promise.resolve())
                .catch(() => { /* _getItemAsync should always resolve! */ })
                .then(() => this.getItem(key)));
    }

    /**
     * Performs asynchronous initialization of this {@code Storage} instance
     * such as loading all keys from {@link AsyncStorage}.
     *
     * @private
     * @returns {Promise}
     */
    _initializeAsync() {
        if (typeof this._keyPrefix !== 'undefined') {
            // Load all previously persisted data items from React Native's
            // AsyncStorage.

            return new Promise(resolve => {
                AsyncStorage.getAllKeys().then((...getAllKeysCallbackArgs) => {
                    // XXX The keys argument of getAllKeys' callback may or may
                    // not be preceded by an error argument.
                    const keys
                        = getAllKeysCallbackArgs[
                            getAllKeysCallbackArgs.length - 1
                        ].filter(key => key.startsWith(this._keyPrefix));

                    AsyncStorage.multiGet(keys)
                    .then((...multiGetCallbackArgs) => {
                        // XXX The result argument of multiGet may or may not be
                        // preceded by an errors argument.
                        const result
                            = multiGetCallbackArgs[
                                multiGetCallbackArgs.length - 1
                            ];
                        const keyPrefixLength
                            = this._keyPrefix && this._keyPrefix.length;

                        // eslint-disable-next-line prefer-const
                        for (let [ key, value ] of result) {
                            key = key.substring(keyPrefixLength);

                            // XXX The loading of the previously persisted data
                            // items from AsyncStorage is asynchronous which
                            // means that it is technically possible to invoke
                            // setItem with a key before the key is loaded from
                            // AsyncStorage.
                            if (!this.hasOwnProperty(key)) {
                                this[key] = value;
                            }
                        }

                        resolve();
                    });
                });
            });
        }

        return undefined;
    }

    /**
     * Returns the name of the nth key in this storage.
     *
     * @param {number} n - The zero-based integer index of the key to get the
     * name of.
     * @returns {string} The name of the nth key in this storage.
     */
    key(n) {
        const keys = Object.keys(this);

        return n < keys.length ? keys[n] : null;
    }

    /**
     * Returns an integer representing the number of data items stored in this
     * storage.
     *
     * @returns {number}
     */
    get length() {
        return Object.keys(this).length;
    }

    /**
     * Removes a specific key from this storage.
     *
     * @param {string} key - The name of the key to remove.
     * @returns {void}
     */
    removeItem(key) {
        delete this[key];
        typeof this._keyPrefix === 'undefined'
            || AsyncStorage.removeItem(`${String(this._keyPrefix)}${key}`);
    }

    /**
     * Adds a specific key to this storage and associates it with a specific
     * value. If the key exists already, updates its value.
     *
     * @param {string} key - The name of the key to add/update.
     * @param {string} value - The value to associate with {@code key}.
     * @returns {void}
     */
    setItem(key, value) {
        value = String(value); // eslint-disable-line no-param-reassign
        this[key] = value;
        typeof this._keyPrefix === 'undefined'
            || AsyncStorage.setItem(`${String(this._keyPrefix)}${key}`, value);
    }
}


################################################################################

## File: .\jitsi-meet\react\features\mobile\polyfills\webrtc.js

import { registerGlobals } from 'react-native-webrtc';

import RTCPeerConnection from './RTCPeerConnection';

registerGlobals();

(global => {
    // Override with ours.
    // TODO: consider dropping our override.
    global.RTCPeerConnection = RTCPeerConnection;
})(global || window || this); // eslint-disable-line no-invalid-this


################################################################################

## File: .\jitsi-meet\react\features\mobile\proximity\middleware.ts

import { NativeModules } from 'react-native';

import { getCurrentConference } from '../../base/conference/functions';
import StateListenerRegistry from '../../base/redux/StateListenerRegistry';

/**
 * State listener which enables / disables the proximity sensor based on the
 * current conference state. If the proximity sensor is enabled, it will dim
 * the screen and disable touch controls when an object is nearby. The
 * functionality is  enabled when the current audio device is the earpiece.
 */
StateListenerRegistry.register(
    /* selector */ state => {
        const { devices } = state['features/mobile/audio-mode'];
        const selectedDevice = devices.filter(d => d.selected)[0];
        const conference = getCurrentConference(state);

        return Boolean(conference && selectedDevice?.type === 'EARPIECE');
    },
    /* listener */ proximityEnabled => _setProximityEnabled(proximityEnabled)
);

/**
 * Enables / disables the proximity sensor. If the proximity sensor is enabled,
 * it will dim the screen and disable touch controls when an object is nearby.
 *
 * @param {boolean} enabled - True to enable the proximity sensor or false to
 * disable it.
 * @private
 * @returns {void}
 */
function _setProximityEnabled(enabled: boolean) {
    NativeModules.Proximity.setEnabled(Boolean(enabled));
}


################################################################################

## File: .\jitsi-meet\react\features\mobile\react-native-sdk\functions.js

import { NativeModules } from 'react-native';


/**
 * Determines if the ExternalAPI native module is available.
 *
 * @returns {boolean} If yes {@code true} otherwise {@code false}.
 */
export function isExternalAPIAvailable() {
    const { ExternalAPI } = NativeModules;

    return ExternalAPI !== null;
}


################################################################################

## File: .\jitsi-meet\react\features\mobile\react-native-sdk\middleware.js

import { getAppProp } from '../../base/app/functions';
import {
    CONFERENCE_BLURRED,
    CONFERENCE_FOCUSED,
    CONFERENCE_JOINED,
    CONFERENCE_LEFT,
    CONFERENCE_WILL_JOIN,
    ENDPOINT_MESSAGE_RECEIVED
} from '../../base/conference/actionTypes';
import { SET_AUDIO_MUTED, SET_VIDEO_MUTED } from '../../base/media/actionTypes';
import { PARTICIPANT_JOINED, PARTICIPANT_LEFT } from '../../base/participants/actionTypes';
import MiddlewareRegistry from '../../base/redux/MiddlewareRegistry';
import { READY_TO_CLOSE } from '../external-api/actionTypes';
import { participantToParticipantInfo } from '../external-api/functions';
import { ENTER_PICTURE_IN_PICTURE } from '../picture-in-picture/actionTypes';

import { isExternalAPIAvailable } from './functions';

const externalAPIEnabled = isExternalAPIAvailable();


/**
 * Check if native modules are being used or not.
 * If not, then the init of middleware doesn't happen.
 */
!externalAPIEnabled && MiddlewareRegistry.register(store => next => action => {
    const result = next(action);
    const { type } = action;
    const rnSdkHandlers = getAppProp(store, 'rnSdkHandlers');

    switch (type) {
    case SET_AUDIO_MUTED:
        rnSdkHandlers?.onAudioMutedChanged?.(action.muted);
        break;
    case SET_VIDEO_MUTED:
        rnSdkHandlers?.onVideoMutedChanged?.(Boolean(action.muted));
        break;
    case CONFERENCE_BLURRED:
        rnSdkHandlers?.onConferenceBlurred?.();
        break;
    case CONFERENCE_FOCUSED:
        rnSdkHandlers?.onConferenceFocused?.();
        break;
    case CONFERENCE_JOINED:
        rnSdkHandlers?.onConferenceJoined?.();
        break;
    case CONFERENCE_LEFT:
        //  Props are torn down at this point, perhaps need to leave this one out
        break;
    case CONFERENCE_WILL_JOIN:
        rnSdkHandlers?.onConferenceWillJoin?.();
        break;
    case ENTER_PICTURE_IN_PICTURE:
        rnSdkHandlers?.onEnterPictureInPicture?.();
        break;
    case ENDPOINT_MESSAGE_RECEIVED: {
        const { data, participant } = action;

        rnSdkHandlers?.onEndpointMessageReceived?.({
            data,
            participant
        });
        break;
    }
    case PARTICIPANT_JOINED: {
        const { participant } = action;
        const participantInfo = participantToParticipantInfo(participant);

        rnSdkHandlers?.onParticipantJoined?.(participantInfo);
        break;
    }
    case PARTICIPANT_LEFT: {
        const { participant } = action;

        const { id } = participant ?? {};

        rnSdkHandlers?.onParticipantLeft?.({ id });
        break;
    }
    case READY_TO_CLOSE:
        rnSdkHandlers?.onReadyToClose?.();
        break;
    }

    return result;
});


################################################################################

## File: .\jitsi-meet\react\features\mobile\wake-lock\middleware.ts

import KeepAwake from 'react-native-keep-awake';

import { getCurrentConference } from '../../base/conference/functions';
import StateListenerRegistry from '../../base/redux/StateListenerRegistry';

/**
 * State listener that activates or deactivates the wake lock accordingly. If
 * the wake lock is active, it will prevent the screen from dimming.
 */
StateListenerRegistry.register(
    /* selector */ state => {
        const { enabled: audioOnly } = state['features/base/audio-only'];
        const conference = getCurrentConference(state);

        return Boolean(conference && !audioOnly);
    },
    /* listener */ wakeLock => _setWakeLock(wakeLock)
);

/**
 * Activates/deactivates the wake lock. If the wake lock is active, it will
 * prevent the screen from dimming.
 *
 * @param {boolean} wakeLock - True to active the wake lock or false to
 * deactivate it.
 * @private
 * @returns {void}
 */
function _setWakeLock(wakeLock: boolean) {
    if (wakeLock) {
        KeepAwake.activate();
    } else {
        KeepAwake.deactivate();
    }
}


################################################################################

## File: .\jitsi-meet\react\features\mobile\watchos\actions.ts

import { SET_CONFERENCE_TIMESTAMP, SET_SESSION_ID, SET_WATCH_REACHABLE } from './actionTypes';

/**
 * Stores a timestamp when the conference is joined, so that the watch counterpart can start counting from when
 * the meeting has really started.
 *
 * @param {number} conferenceTimestamp - A timestamp retrieved with {@code newDate.getTime()}.
 * @returns {{
 *      type: SET_CONFERENCE_TIMESTAMP,
 *      conferenceTimestamp: number
 * }}
 */
export function setConferenceTimestamp(conferenceTimestamp: number) {
    return {
        type: SET_CONFERENCE_TIMESTAMP,
        conferenceTimestamp
    };
}

/**
 * Updates the session ID which is sent to the Watch app and then used by the app to send commands. Commands from
 * the watch are accepted only if the 'sessionID' passed by the Watch matches the one currently stored in Redux. It is
 * supposed to prevent from processing outdated commands.
 *
 * @returns {{
 *     type: SET_SESSION_ID,
 *     sessionID: number
 * }}
 */
export function setSessionId() {
    return {
        type: SET_SESSION_ID,
        sessionID: new Date().getTime()
    };
}

/**
 * Updates the reachable status of the watch. It's used to get in sync with the watch counterpart when it gets
 * reconnected, but also to prevent from sending updates if the app is not installed at all (which would fail with
 * an error).
 *
 * @param {boolean} isReachable - Indicates whether the watch is currently reachable or not.
 * @returns {{
 *      type: SET_WATCH_REACHABLE,
 *      watchReachable: boolean
 * }}
 */
export function setWatchReachable(isReachable: boolean) {
    return {
        type: SET_WATCH_REACHABLE,
        watchReachable: isReachable
    };
}


################################################################################

## File: .\jitsi-meet\react\features\mobile\watchos\actionTypes.ts

/**
 * See {@link setConferenceTimestamp} for more details.
 * {
 *      type: SET_CONFERENCE_TIMESTAMP,
 *      conferenceTimestamp: number
 * }
 */
export const SET_CONFERENCE_TIMESTAMP = Symbol('WATCH_OS_SET_CONFERENCE_TIMESTAMP');

/**
 * See {@link setSessionId} action for more details.
 * {
 *     type: SET_SESSION_ID,
 *     sessionID: number
 * }
 */
export const SET_SESSION_ID = Symbol('WATCH_OS_SET_SESSION_ID');

/**
 * See {@link setWatchReachable} for more details.
 * {
 *     type: SET_WATCH_REACHABLE,
 *     watchReachable: boolean
 * }
 */
export const SET_WATCH_REACHABLE = Symbol('WATCH_OS_SET_WATCH_REACHABLE');


################################################################################

## File: .\jitsi-meet\react\features\mobile\watchos\constants.ts

// NOTE When changing any of the commands make sure to update JitsiMeetCommands enum in the WatchKit extension code.

export const CMD_HANG_UP = 'hangup';

export const CMD_JOIN_CONFERENCE = 'joinConference';

export const CMD_SET_MUTED = 'setMuted';

export const MAX_RECENT_URLS = 10;


################################################################################

## File: .\jitsi-meet\react\features\mobile\watchos\logger.ts

import { getLogger } from '../../base/logging/functions';

export default getLogger('features/mobile/watchos');


################################################################################

## File: .\jitsi-meet\react\features\mobile\watchos\middleware.ts

import { NativeModules, Platform } from 'react-native';
import { updateApplicationContext, watchEvents } from 'react-native-watch-connectivity';

import { appNavigate } from '../../app/actions';
import { IStore } from '../../app/types';
import { APP_WILL_MOUNT } from '../../base/app/actionTypes';
import { IStateful } from '../../base/app/types';
import { CONFERENCE_JOINED } from '../../base/conference/actionTypes';
import { getCurrentConferenceUrl } from '../../base/connection/functions';
import { setAudioMuted } from '../../base/media/actions';
import MiddlewareRegistry from '../../base/redux/MiddlewareRegistry';
import StateListenerRegistry from '../../base/redux/StateListenerRegistry';
import { toState } from '../../base/redux/functions';

import { setConferenceTimestamp, setSessionId, setWatchReachable } from './actions';
import { CMD_HANG_UP, CMD_JOIN_CONFERENCE, CMD_SET_MUTED, MAX_RECENT_URLS } from './constants';
import logger from './logger';

const { AppInfo } = NativeModules;
const watchOSEnabled = Platform.OS === 'ios' && !AppInfo.isLiteSDK;

// Handles the recent URLs state sent to the watch
watchOSEnabled && StateListenerRegistry.register(
    /* selector */ state => state['features/recent-list'],
    /* listener */ (recentListState, { getState }) => {
        _updateApplicationContext(getState);
    });

// Handles the mic muted state sent to the watch
watchOSEnabled && StateListenerRegistry.register(
    /* selector */ state => _isAudioMuted(state),
    /* listener */ (isAudioMuted, { getState }) => {
        _updateApplicationContext(getState);
    });

// Handles the conference URL state sent to the watch
watchOSEnabled && StateListenerRegistry.register(
    /* selector */ state => getCurrentConferenceUrl(state),
    /* listener */ (currentUrl, { dispatch, getState }) => {
        dispatch(setSessionId());
        _updateApplicationContext(getState);
    });

/**
 * Middleware that captures conference actions.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
watchOSEnabled && MiddlewareRegistry.register(store => next => action => {
    switch (action.type) {
    case APP_WILL_MOUNT:
        _appWillMount(store);
        break;
    case CONFERENCE_JOINED:
        store.dispatch(setConferenceTimestamp(new Date().getTime()));
        _updateApplicationContext(store.getState());
        break;
    }

    return next(action);
});

/**
 * Registers listeners to the react-native-watch-connectivity lib.
 *
 * @param {Store} store - The redux store.
 * @private
 * @returns {void}
 */
function _appWillMount({ dispatch, getState }: IStore) {
    watchEvents.addListener('reachability', reachable => {
        dispatch(setWatchReachable(reachable));
        _updateApplicationContext(getState);
    });

    watchEvents.addListener('message', message => {
        const {
            command,
            sessionID
        } = message;
        const currentSessionID = _getSessionId(getState());

        if (!sessionID || sessionID !== currentSessionID) {
            logger.warn(
                `Ignoring outdated watch command: ${message.command}`
                    + ` sessionID: ${sessionID} current session ID: ${currentSessionID}`);

            return;
        }

        switch (command) {
        case CMD_HANG_UP:
            if (typeof getCurrentConferenceUrl(getState()) !== 'undefined') {
                dispatch(appNavigate(undefined));
            }
            break;
        case CMD_JOIN_CONFERENCE: {
            const newConferenceURL: any = message.data;
            const oldConferenceURL = getCurrentConferenceUrl(getState());

            if (oldConferenceURL !== newConferenceURL) {
                dispatch(appNavigate(newConferenceURL));
            }
            break;
        }
        case CMD_SET_MUTED:
            dispatch(
                setAudioMuted(
                    message.muted === 'true',
                    /* ensureTrack */ true));
            break;
        }
    });
}

/**
 * Gets the current Apple Watch session's ID. A new session is started whenever the conference URL has changed. It is
 * used to filter out outdated commands which may arrive very later if the Apple Watch loses the connectivity.
 *
 * @param {Object|Function} stateful - Either the whole Redux state object or the Redux store's {@code getState} method.
 * @returns {number}
 * @private
 */
function _getSessionId(stateful: IStateful) {
    const state = toState(stateful);

    return state['features/mobile/watchos'].sessionID;
}

/**
 * Gets the list of recent URLs to be passed over to the Watch app.
 *
 * @param {Object|Function} stateful - Either the whole Redux state object or the Redux store's {@code getState} method.
 * @returns {Array<Object>}
 * @private
 */
function _getRecentUrls(stateful: IStateful) {
    const state = toState(stateful);
    const recentURLs = state['features/recent-list'];

    // Trim to MAX_RECENT_URLS and reverse the list
    const reversedList = recentURLs.slice(-MAX_RECENT_URLS);

    reversedList.reverse();

    return reversedList;
}

/**
 * Determines the audio muted state to be sent to the apple watch.
 *
 * @param {Object|Function} stateful - Either the whole Redux state object or the Redux store's {@code getState} method.
 * @returns {boolean}
 * @private
 */
function _isAudioMuted(stateful: IStateful) {
    const state = toState(stateful);
    const { audio } = state['features/base/media'];

    return audio.muted;
}

/**
 * Sends the context to the watch os app. At the time of this writing it's the entire state of
 * the 'features/mobile/watchos' reducer.
 *
 * @param {Object|Function} stateful - Either the whole Redux state object or the Redux store's {@code getState} method.
 * @private
 * @returns {void}
 */
function _updateApplicationContext(stateful: IStateful) {
    const state = toState(stateful);
    const { conferenceTimestamp, sessionID, watchReachable } = state['features/mobile/watchos'];

    if (!watchReachable) {
        return;
    }

    try {
        updateApplicationContext({
            conferenceTimestamp,
            conferenceURL: getCurrentConferenceUrl(state),
            micMuted: _isAudioMuted(state),
            recentURLs: _getRecentUrls(state),
            sessionID
        });
    } catch (error) {
        logger.error('Failed to stringify or send the context', error);
    }
}


################################################################################

## File: .\jitsi-meet\react\features\mobile\watchos\reducer.ts

import ReducerRegistry from '../../base/redux/ReducerRegistry';
import { assign } from '../../base/redux/functions';

import { SET_CONFERENCE_TIMESTAMP, SET_SESSION_ID, SET_WATCH_REACHABLE } from './actionTypes';

export interface IMobileWatchOSState {
    conferenceTimestamp?: number;
    sessionID: number;
    watchReachable?: boolean;
}

const INITIAL_STATE = {
    sessionID: new Date().getTime()
};

/**
 * Reduces the Redux actions of the feature features/mobile/watchos.
 */
ReducerRegistry.register<IMobileWatchOSState>('features/mobile/watchos',
(state = INITIAL_STATE, action): IMobileWatchOSState => {
    switch (action.type) {
    case SET_CONFERENCE_TIMESTAMP: {
        return assign(state, {
            conferenceTimestamp: action.conferenceTimestamp
        });
    }
    case SET_SESSION_ID: {
        return assign(state, {
            sessionID: action.sessionID,
            conferenceTimestamp: 0
        });
    }
    case SET_WATCH_REACHABLE: {
        return assign(state, {
            watchReachable: action.watchReachable
        });
    }
    default:
        return state;
    }
});


################################################################################

## File: .\jitsi-meet\react\features\no-audio-signal\actions.ts

import { SET_NO_AUDIO_SIGNAL_NOTIFICATION_UID } from './actionTypes';

/**
 * Sets UID of the the pending notification to use it when hiding
 * the notification is necessary, or unset it when undefined (or no param) is
 * passed.
 *
 * @param {?number} uid - The UID of the notification.
 * @returns {{
 *     type: SET_NO_AUDIO_SIGNAL_NOTIFICATION_UID,
 *     uid: number
 * }}
 */
export function setNoAudioSignalNotificationUid(uid?: string) {
    return {
        type: SET_NO_AUDIO_SIGNAL_NOTIFICATION_UID,
        uid
    };
}


################################################################################

## File: .\jitsi-meet\react\features\no-audio-signal\actionTypes.ts

/**
 * The type of Redux action which sets the pending notification UID
 * to use it when hiding the notification is necessary, or unset it when
 * undefined (or no param) is passed.
 *
 * {
 *     type: SET_CURRENT_NOTIFICATION_UID,
 *     uid: ?number
 * }
 */
export const SET_NO_AUDIO_SIGNAL_NOTIFICATION_UID = 'SET_NO_AUDIO_SIGNAL_NOTIFICATION_UID';


################################################################################

## File: .\jitsi-meet\react\features\no-audio-signal\constants.ts

/**
 * The identifier of the sound to be played when we got an event for no audio signal.
 *
 * @type {string}
 */
export const NO_AUDIO_SIGNAL_SOUND_ID = 'NO_AUDIO_SIGNAL_SOUND';


################################################################################

## File: .\jitsi-meet\react\features\no-audio-signal\reducer.ts

import ReducerRegistry from '../base/redux/ReducerRegistry';
import { set } from '../base/redux/functions';

import { SET_NO_AUDIO_SIGNAL_NOTIFICATION_UID } from './actionTypes';

export interface INoAudioSignalState {
    noAudioSignalNotificationUid?: string;
}

/**
 * Reduces the redux actions of the feature no audio signal.
 */
ReducerRegistry.register<INoAudioSignalState>('features/no-audio-signal', (state = {}, action): INoAudioSignalState => {
    switch (action.type) {
    case SET_NO_AUDIO_SIGNAL_NOTIFICATION_UID:
        return set(state, 'noAudioSignalNotificationUid', action.uid);
    }

    return state;
});


################################################################################

## File: .\jitsi-meet\react\features\no-audio-signal\sounds.ts

/**
 * The file used for the no audio signal sound notification.
 *
 * @type {string}
 */
export const NO_AUDIO_SIGNAL_SOUND_FILE = 'noAudioSignal.mp3';


################################################################################

## File: .\jitsi-meet\react\features\noise-detection\actions.ts

import { SET_NOISY_AUDIO_INPUT_NOTIFICATION_UID } from './actionTypes';

/**
 * Sets UID of the the pending notification to use it when hiding
 * the notification is necessary, or unset it when undefined (or no param) is
 * passed.
 *
 * @param {?number} uid - The UID of the notification.
 * @returns {{
 *     type: SET_NOISY_AUDIO_INPUT_NOTIFICATION_UID,
 *     uid: number
 * }}
 */
export function setNoisyAudioInputNotificationUid(uid?: string) {
    return {
        type: SET_NOISY_AUDIO_INPUT_NOTIFICATION_UID,
        uid
    };
}


################################################################################

## File: .\jitsi-meet\react\features\noise-detection\actionTypes.ts

/**
 * The type of Redux action which sets the pending notification UID
 * to use it when hiding the notification is necessary, or unset it when
 * undefined (or no param) is passed.
 *
 * {
 *     type: SET_NOISY_AUDIO_INPUT_NOTIFICATION_UID
 *     uid: ?number
 * }
 */
export const SET_NOISY_AUDIO_INPUT_NOTIFICATION_UID = 'SET_NOISY_AUDIO_INPUT_NOTIFICATION_UID';


################################################################################

## File: .\jitsi-meet\react\features\noise-detection\constants.ts

/**
 * The identifier of the sound to be played when we display a you are noisy notification.
 *
 * @type {string}
 */
export const NOISY_AUDIO_INPUT_SOUND_ID = 'NOISY_AUDIO_INPUT_SOUND';


################################################################################

## File: .\jitsi-meet\react\features\noise-detection\middleware.ts

import { APP_WILL_MOUNT, APP_WILL_UNMOUNT } from '../base/app/actionTypes';
import { CONFERENCE_JOINED } from '../base/conference/actionTypes';
import { JitsiConferenceEvents } from '../base/lib-jitsi-meet';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import { playSound, registerSound, unregisterSound } from '../base/sounds/actions';
import { hideNotification, showNotification } from '../notifications/actions';
import { NOTIFICATION_TIMEOUT_TYPE } from '../notifications/constants';

import { setNoisyAudioInputNotificationUid } from './actions';
import { NOISY_AUDIO_INPUT_SOUND_ID } from './constants';
import { NOISY_AUDIO_INPUT_SOUND_FILE } from './sounds';

MiddlewareRegistry.register(store => next => action => {
    const result = next(action);

    switch (action.type) {
    case APP_WILL_MOUNT:
        store.dispatch(registerSound(NOISY_AUDIO_INPUT_SOUND_ID, NOISY_AUDIO_INPUT_SOUND_FILE));
        break;
    case APP_WILL_UNMOUNT:
        store.dispatch(unregisterSound(NOISY_AUDIO_INPUT_SOUND_ID));
        break;
    case CONFERENCE_JOINED: {
        const { dispatch, getState } = store;
        const { conference } = action;

        conference.on(
            JitsiConferenceEvents.TRACK_MUTE_CHANGED,
            (track: any) => {
                const { noisyAudioInputNotificationUid } = getState()['features/noise-detection'];

                // Hide the notification in case the user mutes the microphone
                if (noisyAudioInputNotificationUid && track.isAudioTrack() && track.isLocal() && track.isMuted()) {
                    dispatch(hideNotification(noisyAudioInputNotificationUid));
                    dispatch(setNoisyAudioInputNotificationUid());
                }
            });
        conference.on(
            JitsiConferenceEvents.NOISY_MIC, () => {
                const notification = dispatch(showNotification({
                    titleKey: 'toolbar.noisyAudioInputTitle',
                    descriptionKey: 'toolbar.noisyAudioInputDesc'
                }, NOTIFICATION_TIMEOUT_TYPE.MEDIUM));

                dispatch(playSound(NOISY_AUDIO_INPUT_SOUND_ID));

                if (notification) {
                    // we store the last notification id so we can hide it if the mic is muted
                    dispatch(setNoisyAudioInputNotificationUid(notification.uid));
                }
            });
        break;
    }
    }

    return result;
});


################################################################################

## File: .\jitsi-meet\react\features\noise-detection\reducer.ts

import ReducerRegistry from '../base/redux/ReducerRegistry';
import { set } from '../base/redux/functions';

import { SET_NOISY_AUDIO_INPUT_NOTIFICATION_UID } from './actionTypes';

export interface INoiseDetectionState {
    noisyAudioInputNotificationUid?: string;
}

/**
 * Reduces the redux actions of noise detection feature.
 */
ReducerRegistry.register<INoiseDetectionState>('features/noise-detection',
(state = {}, action): INoiseDetectionState => {
    switch (action.type) {
    case SET_NOISY_AUDIO_INPUT_NOTIFICATION_UID:
        return set(state, 'noisyAudioInputNotificationUid', action.uid);
    }

    return state;
});


################################################################################

## File: .\jitsi-meet\react\features\noise-detection\sounds.ts

/**
 * The file used for the noisy audio input notification.
 *
 * @type {string}
 */
export const NOISY_AUDIO_INPUT_SOUND_FILE = 'noisyAudioInput.mp3';


################################################################################

## File: .\jitsi-meet\react\features\noise-suppression\actions.ts

import { IStore } from '../app/types';
import { getLocalJitsiAudioTrack } from '../base/tracks/functions';
import { showErrorNotification } from '../notifications/actions';
import { NOTIFICATION_TIMEOUT_TYPE } from '../notifications/constants';
import { NoiseSuppressionEffect } from '../stream-effects/noise-suppression/NoiseSuppressionEffect';

import { SET_NOISE_SUPPRESSION_ENABLED } from './actionTypes';
import { canEnableNoiseSuppression, isNoiseSuppressionEnabled } from './functions';
import logger from './logger';

/**
 * Updates the noise suppression active state.
 *
 * @param {boolean} enabled - Is noise suppression enabled.
 * @returns {{
 *      type: SET_NOISE_SUPPRESSION_STATE,
 *      enabled: boolean
 * }}
 */
export function setNoiseSuppressionEnabledState(enabled: boolean): any {
    return {
        type: SET_NOISE_SUPPRESSION_ENABLED,
        enabled
    };
}

/**
 *  Enabled/disable noise suppression depending on the current state.
 *
 * @returns {Function}
 */
export function toggleNoiseSuppression(): any {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        if (isNoiseSuppressionEnabled(getState())) {
            dispatch(setNoiseSuppressionEnabled(false));
        } else {
            dispatch(setNoiseSuppressionEnabled(true));
        }
    };
}

/**
 * Attempt to enable or disable noise suppression using the {@link NoiseSuppressionEffect}.
 *
 * @param {boolean} enabled - Enable or disable noise suppression.
 *
 * @returns {Function}
 */
export function setNoiseSuppressionEnabled(enabled: boolean): any {
    return async (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();

        const { noiseSuppression: nsOptions } = state['features/base/config'];
        const localAudio = getLocalJitsiAudioTrack(state);
        const noiseSuppressionEnabled = isNoiseSuppressionEnabled(state);

        logger.info(`Attempting to set noise suppression enabled state: ${enabled}`);

        if (enabled === noiseSuppressionEnabled) {
            logger.warn(`Noise suppression enabled state already: ${enabled}`);

            return;
        }

        // If there is no local audio, simply set the enabled state. Once an audio track is created
        // the effects list will be applied.
        if (!localAudio) {
            dispatch(setNoiseSuppressionEnabledState(enabled));

            return;
        }

        try {
            if (enabled) {
                if (!canEnableNoiseSuppression(state, dispatch, localAudio)) {
                    return;
                }

                await localAudio.setEffect(new NoiseSuppressionEffect(nsOptions));
                dispatch(setNoiseSuppressionEnabledState(true));
                logger.info('Noise suppression enabled.');

            } else {
                await localAudio.setEffect(undefined);
                dispatch(setNoiseSuppressionEnabledState(false));
                logger.info('Noise suppression disabled.');
            }
        } catch (error) {
            logger.error(
                `Failed to set noise suppression enabled to: ${enabled}`,
                error
            );

            dispatch(showErrorNotification({
                titleKey: 'notify.noiseSuppressionFailedTitle'
            }, NOTIFICATION_TIMEOUT_TYPE.MEDIUM));
        }
    };
}


################################################################################

## File: .\jitsi-meet\react\features\noise-suppression\actionTypes.ts

/**
 * Type of action which sets the current state of noise suppression.
 *
 * {
 *     type: SET_NOISE_SUPPRESSION_ENABLED,
 *     enabled: boolean
 * }
 */
export const SET_NOISE_SUPPRESSION_ENABLED = 'SET_NOISE_SUPPRESSION_ENABLED';


################################################################################

## File: .\jitsi-meet\react\features\noise-suppression\functions.ts

import { IReduxState, IStore } from '../app/types';
import { showWarningNotification } from '../notifications/actions';
import { NOTIFICATION_TIMEOUT_TYPE } from '../notifications/constants';
import { isScreenAudioShared } from '../screen-share/functions';

/**
 * Is noise suppression currently enabled.
 *
 * @param {IReduxState} state - The state of the application.
 * @returns {boolean}
 */
export function isNoiseSuppressionEnabled(state: IReduxState): boolean {
    return state['features/noise-suppression'].enabled;
}

/**
 * Verify if noise suppression can be enabled in the current state.
 *
 * @param {*} state - Redux state.
 * @param {*} dispatch - Redux dispatch.
 * @param {*} localAudio - Current local audio track.
 * @returns {boolean}
 */
export function canEnableNoiseSuppression(state: IReduxState, dispatch: IStore['dispatch'], localAudio: any): boolean {
    const { channelCount } = localAudio.track.getSettings();

    // Sharing screen audio implies an effect being applied to the local track, because currently we don't support
    // more then one effect at a time the user has to choose between sharing audio or having noise suppression active.
    if (isScreenAudioShared(state)) {
        dispatch(showWarningNotification({
            titleKey: 'notify.noiseSuppressionFailedTitle',
            descriptionKey: 'notify.noiseSuppressionDesktopAudioDescription'
        }, NOTIFICATION_TIMEOUT_TYPE.MEDIUM));

        return false;
    }

    // Stereo audio tracks aren't currently supported, make sure the current local track is mono
    if (channelCount > 1) {
        dispatch(showWarningNotification({
            titleKey: 'notify.noiseSuppressionFailedTitle',
            descriptionKey: 'notify.noiseSuppressionStereoDescription'
        }, NOTIFICATION_TIMEOUT_TYPE.MEDIUM));

        return false;
    }

    return true;
}


################################################################################

## File: .\jitsi-meet\react\features\noise-suppression\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/noise-suppression');


################################################################################

## File: .\jitsi-meet\react\features\noise-suppression\reducer.ts

import PersistenceRegistry from '../base/redux/PersistenceRegistry';
import ReducerRegistry from '../base/redux/ReducerRegistry';

import {
    SET_NOISE_SUPPRESSION_ENABLED
} from './actionTypes';

export interface INoiseSuppressionState {
    enabled: boolean;
}

const STORE_NAME = 'features/noise-suppression';

const DEFAULT_STATE = {
    enabled: false
};

PersistenceRegistry.register(STORE_NAME);

/**
 * Reduces the Redux actions of the feature features/noise-suppression.
 */
ReducerRegistry.register<INoiseSuppressionState>(STORE_NAME,
(state = DEFAULT_STATE, action): INoiseSuppressionState => {
    const { enabled } = action;

    switch (action.type) {
    case SET_NOISE_SUPPRESSION_ENABLED:
        return {
            ...state,
            enabled
        };
    default:
        return state;
    }
});


################################################################################

## File: .\jitsi-meet\react\features\notifications\actions.ts

import { throttle } from 'lodash-es';

import { IStore } from '../app/types';
import { NOTIFICATIONS_ENABLED } from '../base/flags/constants';
import { getFeatureFlag } from '../base/flags/functions';
import { getParticipantCount } from '../base/participants/functions';

import {
    CLEAR_NOTIFICATIONS,
    HIDE_NOTIFICATION,
    SET_NOTIFICATIONS_ENABLED,
    SHOW_NOTIFICATION
} from './actionTypes';
import {
    NOTIFICATION_ICON,
    NOTIFICATION_TIMEOUT,
    NOTIFICATION_TIMEOUT_TYPE,
    NOTIFICATION_TYPE,
    SILENT_JOIN_THRESHOLD,
    SILENT_LEFT_THRESHOLD
} from './constants';
import { INotificationProps } from './types';

/**
 * Function that returns notification timeout value based on notification timeout type.
 *
 * @param {string} type - Notification type.
 * @param {Object} notificationTimeouts - Config notification timeouts.
 * @returns {number}
 */
function getNotificationTimeout(type?: string, notificationTimeouts?: {
    long?: number;
    medium?: number;
    short?: number;
}) {
    if (type === NOTIFICATION_TIMEOUT_TYPE.SHORT) {
        return notificationTimeouts?.short ?? NOTIFICATION_TIMEOUT.SHORT;
    } else if (type === NOTIFICATION_TIMEOUT_TYPE.MEDIUM) {
        return notificationTimeouts?.medium ?? NOTIFICATION_TIMEOUT.MEDIUM;
    } else if (type === NOTIFICATION_TIMEOUT_TYPE.LONG) {
        return notificationTimeouts?.long ?? NOTIFICATION_TIMEOUT.LONG;
    }

    return NOTIFICATION_TIMEOUT.STICKY;
}

/**
 * Clears (removes) all the notifications.
 *
 * @returns {{
 *     type: CLEAR_NOTIFICATIONS
 * }}
 */
export function clearNotifications() {
    return {
        type: CLEAR_NOTIFICATIONS
    };
}

/**
 * Removes the notification with the passed in id.
 *
 * @param {string} uid - The unique identifier for the notification to be
 * removed.
 * @returns {{
 *     type: HIDE_NOTIFICATION,
 *     uid: string
 * }}
 */
export function hideNotification(uid: string) {
    return {
        type: HIDE_NOTIFICATION,
        uid
    };
}

/**
 * Stops notifications from being displayed.
 *
 * @param {boolean} enabled - Whether or not notifications should display.
 * @returns {{
 *     type: SET_NOTIFICATIONS_ENABLED,
 *     enabled: boolean
 * }}
 */
export function setNotificationsEnabled(enabled: boolean) {
    return {
        type: SET_NOTIFICATIONS_ENABLED,
        enabled
    };
}

/**
 * Queues an error notification for display.
 *
 * @param {Object} props - The props needed to show the notification component.
 * @param {string} type - Notification type.
 * @returns {Object}
 */
export function showErrorNotification(props: INotificationProps, type?: string) {
    return showNotification({
        ...props,
        appearance: NOTIFICATION_TYPE.ERROR
    }, type);
}

/**
 * Queues a success notification for display.
 *
 * @param {Object} props - The props needed to show the notification component.
 * @param {string} type - Notification type.
 * @returns {Object}
 */
export function showSuccessNotification(props: INotificationProps, type?: string) {
    return showNotification({
        ...props,
        appearance: NOTIFICATION_TYPE.SUCCESS
    }, type);
}

/**
 * Queues a notification for display.
 *
 * @param {Object} props - The props needed to show the notification component.
 * @param {string} type - Timeout type.
 * @returns {Function}
 */
export function showNotification(props: INotificationProps = {}, type?: string) {
    return function(dispatch: IStore['dispatch'], getState: IStore['getState']) {
        const { disabledNotifications = [], notifications, notificationTimeouts } = getState()['features/base/config'];
        const enabledFlag = getFeatureFlag(getState(), NOTIFICATIONS_ENABLED, true);

        const { descriptionKey, titleKey } = props;

        const shouldDisplay = enabledFlag
            && !(disabledNotifications.includes(descriptionKey ?? '')
                || disabledNotifications.includes(titleKey ?? ''))
            && (!notifications
                || notifications.includes(descriptionKey ?? '')
                || notifications.includes(titleKey ?? ''));

        if (typeof APP !== 'undefined') {
            APP.API.notifyNotificationTriggered(titleKey, descriptionKey);
        }

        if (shouldDisplay) {
            return dispatch({
                type: SHOW_NOTIFICATION,
                props,
                timeout: getNotificationTimeout(type, notificationTimeouts),
                uid: props.uid || Date.now().toString()
            });
        }
    };
}

/**
 * Queues a warning notification for display.
 *
 * @param {Object} props - The props needed to show the notification component.
 * @param {string} type - Notification type.
 * @returns {Object}
 */
export function showWarningNotification(props: INotificationProps, type?: string) {

    return showNotification({
        ...props,
        appearance: NOTIFICATION_TYPE.WARNING
    }, type);
}

/**
 * Queues a message notification for display.
 *
 * @param {Object} props - The props needed to show the notification component.
 * @param {string} type - Notification type.
 * @returns {Object}
 */
export function showMessageNotification(props: INotificationProps, type?: string) {
    return showNotification({
        ...props,
        concatText: true,
        titleKey: 'notify.chatMessages',
        appearance: NOTIFICATION_TYPE.NORMAL,
        icon: NOTIFICATION_ICON.MESSAGE
    }, type);
}

/**
 * An array of names of participants that have joined the conference. The array
 * is replaced with an empty array as notifications are displayed.
 *
 * @private
 * @type {string[]}
 */
let joinedParticipantsNames: string[] = [];

/**
 * A throttled internal function that takes the internal list of participant
 * names, {@code joinedParticipantsNames}, and triggers the display of a
 * notification informing of their joining.
 *
 * @private
 * @type {Function}
 */
const _throttledNotifyParticipantConnected = throttle((dispatch: IStore['dispatch'], getState: IStore['getState']) => {
    const participantCount = getParticipantCount(getState());

    // Skip join notifications altogether for large meetings.
    if (participantCount > SILENT_JOIN_THRESHOLD) {
        joinedParticipantsNames = [];

        return;
    }

    const joinedParticipantsCount = joinedParticipantsNames.length;

    let notificationProps;

    if (joinedParticipantsCount >= 3) {
        notificationProps = {
            titleArguments: {
                name: joinedParticipantsNames[0]
            },
            titleKey: 'notify.connectedThreePlusMembers'
        };
    } else if (joinedParticipantsCount === 2) {
        notificationProps = {
            titleArguments: {
                first: joinedParticipantsNames[0],
                second: joinedParticipantsNames[1]
            },
            titleKey: 'notify.connectedTwoMembers'
        };
    } else if (joinedParticipantsCount) {
        notificationProps = {
            titleArguments: {
                name: joinedParticipantsNames[0]
            },
            titleKey: 'notify.connectedOneMember'
        };
    }

    if (notificationProps) {
        dispatch(
            showNotification(notificationProps, NOTIFICATION_TIMEOUT_TYPE.SHORT));
    }

    joinedParticipantsNames = [];

}, 2000, { leading: false });

/**
 * An array of names of participants that have left the conference. The array
 * is replaced with an empty array as notifications are displayed.
 *
 * @private
 * @type {string[]}
 */
let leftParticipantsNames: string[] = [];

/**
 * A throttled internal function that takes the internal list of participant
 * names, {@code leftParticipantsNames}, and triggers the display of a
 * notification informing of their leaving.
 *
 * @private
 * @type {Function}
 */
const _throttledNotifyParticipantLeft = throttle((dispatch: IStore['dispatch'], getState: IStore['getState']) => {
    const participantCount = getParticipantCount(getState());

    // Skip left notifications altogether for large meetings.
    if (participantCount > SILENT_LEFT_THRESHOLD) {
        leftParticipantsNames = [];

        return;
    }

    const leftParticipantsCount = leftParticipantsNames.length;

    let notificationProps;

    if (leftParticipantsCount >= 3) {
        notificationProps = {
            titleArguments: {
                name: leftParticipantsNames[0]
            },
            titleKey: 'notify.leftThreePlusMembers'
        };
    } else if (leftParticipantsCount === 2) {
        notificationProps = {
            titleArguments: {
                first: leftParticipantsNames[0],
                second: leftParticipantsNames[1]
            },
            titleKey: 'notify.leftTwoMembers'
        };
    } else if (leftParticipantsCount) {
        notificationProps = {
            titleArguments: {
                name: leftParticipantsNames[0]
            },
            titleKey: 'notify.leftOneMember'
        };
    }

    if (notificationProps) {
        dispatch(
            showNotification(notificationProps, NOTIFICATION_TIMEOUT_TYPE.SHORT));
    }

    leftParticipantsNames = [];

}, 2000, { leading: false });

/**
 * Queues the display of a notification of a participant having connected to
 * the meeting. The notifications are batched so that quick consecutive
 * connection events are shown in one notification.
 *
 * @param {string} displayName - The name of the participant that connected.
 * @returns {Function}
 */
export function showParticipantJoinedNotification(displayName: string) {
    joinedParticipantsNames.push(displayName);

    return (dispatch: IStore['dispatch'], getState: IStore['getState']) =>
        _throttledNotifyParticipantConnected(dispatch, getState);
}

/**
 * Queues the display of a notification of a participant having left to
 * the meeting. The notifications are batched so that quick consecutive
 * connection events are shown in one notification.
 *
 * @param {string} displayName - The name of the participant that left.
 * @returns {Function}
 */
export function showParticipantLeftNotification(displayName: string) {
    leftParticipantsNames.push(displayName);

    return (dispatch: IStore['dispatch'], getState: IStore['getState']) =>
        _throttledNotifyParticipantLeft(dispatch, getState);
}


################################################################################

## File: .\jitsi-meet\react\features\notifications\actionTypes.ts

/**
 * The type of (redux) action which signals that all the stored notifications
 * need to be cleared.
 *
 * {
 *     type: CLEAR_NOTIFICATIONS
 * }
 */
export const CLEAR_NOTIFICATIONS = 'CLEAR_NOTIFICATIONS';

/**
 * The type of (redux) action which signals that a specific notification should
 * not be displayed anymore.
 *
 * {
 *     type: HIDE_NOTIFICATION,
 *     uid: string
 * }
 */
export const HIDE_NOTIFICATION = 'HIDE_NOTIFICATION';

/**
 * The type of (redux) action which signals that a notification component should
 * be displayed.
 *
 * {
 *     type: SHOW_NOTIFICATION,
 *     component: ReactComponent,
 *     props: Object,
 *     timeout: number,
 *     uid: string
 * }
 */
export const SHOW_NOTIFICATION = 'SHOW_NOTIFICATION';

/**
 * The type of (redux) action which signals that notifications should not
 * display.
 *
 * {
 *     type: SET_NOTIFICATIONS_ENABLED,
 *     enabled: Boolean
 * }
 */
export const SET_NOTIFICATIONS_ENABLED = 'SET_NOTIFICATIONS_ENABLED';


################################################################################

## File: .\jitsi-meet\react\features\notifications\constants.ts

/**
 * The standard time when auto-disappearing notifications should disappear.
 */
export const NOTIFICATION_TIMEOUT = {
    SHORT: 2500,
    MEDIUM: 5000,
    LONG: 10000,
    STICKY: false
};

/**
 * Notification timeout type.
 */
export enum NOTIFICATION_TIMEOUT_TYPE {
    LONG = 'long',
    MEDIUM = 'medium',
    SHORT = 'short',
    STICKY = 'sticky'
}

/**
 * The set of possible notification types.
 *
 * @enum {string}
 */
export const NOTIFICATION_TYPE = {
    ERROR: 'error',
    NORMAL: 'normal',
    SUCCESS: 'success',
    WARNING: 'warning'
};

/**
 * A mapping of notification type to priority of display.
 *
 * @enum {number}
 */
export const NOTIFICATION_TYPE_PRIORITIES = {
    [NOTIFICATION_TYPE.ERROR]: 5,
    [NOTIFICATION_TYPE.NORMAL]: 3,
    [NOTIFICATION_TYPE.SUCCESS]: 3,
    [NOTIFICATION_TYPE.WARNING]: 4
};

/**
 * The set of possible notification icons.
 *
 * @enum {string}
 */
export const NOTIFICATION_ICON = {
    ...NOTIFICATION_TYPE,
    MESSAGE: 'message',
    PARTICIPANT: 'participant',
    PARTICIPANTS: 'participants'
};

/**
 * The identifier of the calendar notification.
 *
 * @type {string}
 */
export const CALENDAR_NOTIFICATION_ID = 'CALENDAR_NOTIFICATION_ID';

/**
 * The identifier of the disable self view notification.
 *
 * @type {string}
 */
export const DATA_CHANNEL_CLOSED_NOTIFICATION_ID = 'DATA_CHANNEL_CLOSED_NOTIFICATION_ID';

/**
 * The identifier of the disable self view notification.
 *
 * @type {string}
 */
export const DISABLE_SELF_VIEW_NOTIFICATION_ID = 'DISABLE_SELF_VIEW_NOTIFICATION_ID';

/**
 * The identifier of the lobby notification.
 *
 * @type {string}
 */
export const LOBBY_NOTIFICATION_ID = 'LOBBY_NOTIFICATION';

/**
 * The identifier of the local recording notification.
 *
 * @type {string}
 */
export const LOCAL_RECORDING_NOTIFICATION_ID = 'LOCAL_RECORDING_NOTIFICATION_ID';

/**
 * The identifier of the raise hand notification.
 *
 * @type {string}
 */
export const RAISE_HAND_NOTIFICATION_ID = 'RAISE_HAND_NOTIFICATION';

/**
 * The identifier of the salesforce link notification.
 *
 * @type {string}
 */
export const SALESFORCE_LINK_NOTIFICATION_ID = 'SALESFORCE_LINK_NOTIFICATION';

/**
 * The identifier of the visitors promotion notification.
 *
 * @type {string}
 */
export const VISITORS_PROMOTION_NOTIFICATION_ID = 'VISITORS_PROMOTION_NOTIFICATION';

/**
 * The identifier of the visitors notification indicating the meeting is not live.
 *
 * @type {string}
 */
export const VISITORS_NOT_LIVE_NOTIFICATION_ID = 'VISITORS_NOT_LIVE_NOTIFICATION_ID';

/**
 * Amount of participants beyond which no join notification will be emitted.
 */
export const SILENT_JOIN_THRESHOLD = 30;

/**
 * Amount of participants beyond which no left notification will be emitted.
 */
export const SILENT_LEFT_THRESHOLD = 30;

/**
 * The identifier for the transcriber notifications.
 *
 * @type {string}
 */
export const TRANSCRIBING_NOTIFICATION_ID = 'TRANSCRIBING_NOTIFICATION';


################################################################################

## File: .\jitsi-meet\react\features\notifications\functions.ts

import { MODERATION_NOTIFICATIONS } from '../av-moderation/constants';
import { IStateful } from '../base/app/types';
import { MediaType } from '../base/media/constants';
import { toState } from '../base/redux/functions';

/**
 * Tells whether or not the notifications are enabled and if there are any
 * notifications to be displayed based on the current Redux state.
 *
 * @param {IStateful} stateful - The redux store state.
 * @returns {boolean}
 */
export function areThereNotifications(stateful: IStateful) {
    const state = toState(stateful);
    const { enabled, notifications } = state['features/notifications'];

    return enabled && notifications.length > 0;
}

/**
 * Tells whether join/leave notifications are enabled in interface_config.
 *
 * @returns {boolean}
 */
export function joinLeaveNotificationsDisabled() {
    return Boolean(typeof interfaceConfig !== 'undefined' && interfaceConfig?.DISABLE_JOIN_LEAVE_NOTIFICATIONS);
}

/**
 * Returns whether or not the moderation notification for the given type is displayed.
 *
 * @param {MEDIA_TYPE} mediaType - The media type to check.
 * @param {IStateful} stateful - The redux store state.
 * @returns {boolean}
 */
export function isModerationNotificationDisplayed(mediaType: MediaType, stateful: IStateful) {
    const state = toState(stateful);

    const { notifications } = state['features/notifications'];

    return Boolean(notifications.find(n => n.uid === MODERATION_NOTIFICATIONS[mediaType]));
}


################################################################################

## File: .\jitsi-meet\react\features\notifications\middleware.ts

import { IReduxState, IStore } from '../app/types';
import { getCurrentConference } from '../base/conference/functions';
import {
    PARTICIPANT_JOINED,
    PARTICIPANT_LEFT,
    PARTICIPANT_UPDATED
} from '../base/participants/actionTypes';
import { PARTICIPANT_ROLE } from '../base/participants/constants';
import {
    getLocalParticipant,
    getParticipantById,
    getParticipantDisplayName,
    isScreenShareParticipant,
    isWhiteboardParticipant
} from '../base/participants/functions';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import StateListenerRegistry from '../base/redux/StateListenerRegistry';
import { PARTICIPANTS_PANE_OPEN } from '../participants-pane/actionTypes';

import {
    CLEAR_NOTIFICATIONS,
    HIDE_NOTIFICATION,
    SHOW_NOTIFICATION
} from './actionTypes';
import {
    clearNotifications,
    hideNotification,
    showNotification,
    showParticipantJoinedNotification,
    showParticipantLeftNotification
} from './actions';
import {
    NOTIFICATION_TIMEOUT_TYPE,
    RAISE_HAND_NOTIFICATION_ID
} from './constants';
import { areThereNotifications, joinLeaveNotificationsDisabled } from './functions';

/**
 * Map of timers.
 *
 * @type {Map}
 */
const timers = new Map();

/**
 * Function that creates a timeout id for specific notification.
 *
 * @param {Object} notification - Notification for which we want to create a timeout.
 * @param {Function} dispatch - The Redux dispatch function.
 * @returns {void}
 */
const createTimeoutId = (notification: { timeout: number; uid: string; }, dispatch: IStore['dispatch']) => {
    const {
        timeout,
        uid
    } = notification;

    if (timeout) {
        const timerID = setTimeout(() => {
            dispatch(hideNotification(uid));
        }, timeout);

        timers.set(uid, timerID);
    }
};

/**
 * Returns notifications state.
 *
 * @param {Object} state - Global state.
 * @returns {Array<Object>} - Notifications state.
 */
const getNotifications = (state: IReduxState) => {
    const _visible = areThereNotifications(state);
    const { notifications } = state['features/notifications'];

    return _visible ? notifications : [];
};

/**
 * Middleware that captures actions to display notifications.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {
    const { dispatch, getState } = store;
    const state = getState();

    switch (action.type) {
    case CLEAR_NOTIFICATIONS: {
        const _notifications = getNotifications(state);

        for (const notification of _notifications) {
            if (timers.has(notification.uid)) {
                const timeout = timers.get(notification.uid);

                clearTimeout(timeout);
                timers.delete(notification.uid);
            }
        }
        timers.clear();
        break;
    }
    case SHOW_NOTIFICATION: {
        if (timers.has(action.uid)) {
            const timer = timers.get(action.uid);

            clearTimeout(timer);
            timers.delete(action.uid);
        }

        createTimeoutId(action, dispatch);
        break;
    }
    case HIDE_NOTIFICATION: {
        const timer = timers.get(action.uid);

        clearTimeout(timer);
        timers.delete(action.uid);
        break;
    }
    case PARTICIPANT_JOINED: {
        const result = next(action);
        const { participant: p } = action;
        const { conference } = state['features/base/conference'];

        // Do not display notifications for the virtual screenshare and whiteboard tiles.
        if (conference
            && !p.local
            && !isScreenShareParticipant(p)
            && !isWhiteboardParticipant(p)
            && !joinLeaveNotificationsDisabled()
            && !p.isReplacing) {
            dispatch(showParticipantJoinedNotification(
                getParticipantDisplayName(state, p.id)
            ));
        }

        return result;
    }
    case PARTICIPANT_LEFT: {
        if (!joinLeaveNotificationsDisabled()) {
            const participant = getParticipantById(
                store.getState(),
                action.participant.id
            );

            // Do not display notifications for the virtual screenshare tiles.
            if (participant
                && !participant.local
                && !isScreenShareParticipant(participant)
                && !isWhiteboardParticipant(participant)
                && !action.participant.isReplaced) {
                dispatch(showParticipantLeftNotification(
                    getParticipantDisplayName(state, participant.id)
                ));
            }
        }

        return next(action);
    }
    case PARTICIPANT_UPDATED: {
        const { disableModeratorIndicator } = state['features/base/config'];

        if (disableModeratorIndicator) {
            return next(action);
        }

        const { id, role } = action.participant;
        const localParticipant = getLocalParticipant(state);

        if (localParticipant?.id !== id) {
            return next(action);
        }

        const oldParticipant = getParticipantById(state, id);
        const oldRole = oldParticipant?.role;

        if (oldRole && oldRole !== role && role === PARTICIPANT_ROLE.MODERATOR) {

            store.dispatch(showNotification({
                titleKey: 'notify.moderator'
            },
            NOTIFICATION_TIMEOUT_TYPE.SHORT));
        }

        return next(action);
    }
    case PARTICIPANTS_PANE_OPEN: {
        store.dispatch(hideNotification(RAISE_HAND_NOTIFICATION_ID));
        break;
    }
    }

    return next(action);
});

/**
 * StateListenerRegistry provides a reliable way to detect the leaving of a
 * conference, where we need to clean up the notifications.
 */
StateListenerRegistry.register(
    /* selector */ state => getCurrentConference(state),
    /* listener */ (conference, { dispatch }) => {
        if (!conference) {
            dispatch(clearNotifications());
        }
    }
);


################################################################################

## File: .\jitsi-meet\react\features\notifications\reducer.ts

import ReducerRegistry from '../base/redux/ReducerRegistry';

import {
    CLEAR_NOTIFICATIONS,
    HIDE_NOTIFICATION,
    SET_NOTIFICATIONS_ENABLED,
    SHOW_NOTIFICATION
} from './actionTypes';
import { NOTIFICATION_TYPE_PRIORITIES } from './constants';

/**
 * The initial state of the feature notifications.
 *
 * @type {array}
 */
const DEFAULT_STATE = {
    enabled: true,
    notifications: []
};

interface INotification {
    component: Object;
    props: {
        appearance?: string;
        descriptionArguments?: Object;
        descriptionKey?: string;
        titleKey: string;
    };
    timeout: number;
    uid: string;
}

export interface INotificationsState {
    enabled: boolean;
    notifications: INotification[];
}

/**
 * Reduces redux actions which affect the display of notifications.
 *
 * @param {Object} state - The current redux state.
 * @param {Object} action - The redux action to reduce.
 * @returns {Object} The next redux state which is the result of reducing the
 * specified {@code action}.
 */
ReducerRegistry.register<INotificationsState>('features/notifications',
    (state = DEFAULT_STATE, action): INotificationsState => {
        switch (action.type) {
        case CLEAR_NOTIFICATIONS:
            return {
                ...state,
                notifications: []
            };
        case HIDE_NOTIFICATION:
            return {
                ...state,
                notifications: state.notifications.filter(
                    notification => notification.uid !== action.uid)
            };

        case SET_NOTIFICATIONS_ENABLED:
            return {
                ...state,
                enabled: action.enabled
            };

        case SHOW_NOTIFICATION:
            return {
                ...state,
                notifications:
                    _insertNotificationByPriority(state.notifications, {
                        component: action.component,
                        props: action.props,
                        timeout: action.timeout,
                        uid: action.uid
                    })
            };
        }

        return state;
    });

/**
 * Creates a new notification queue with the passed in notification placed at
 * the end of other notifications with higher or the same priority.
 *
 * @param {Object[]} notifications - The queue of notifications to be displayed.
 * @param {Object} notification - The new notification to add to the queue.
 * @private
 * @returns {Object[]} A new array with an updated order of the notification
 * queue.
 */
function _insertNotificationByPriority(notifications: INotification[], notification: INotification) {

    // Create a copy to avoid mutation.
    const copyOfNotifications = notifications.slice();

    // Get the index of any queued notification that has the same id as the new notification
    let insertAtLocation = copyOfNotifications.findIndex(
            (queuedNotification: INotification) =>
                queuedNotification?.uid === notification?.uid
    );

    if (insertAtLocation !== -1) {
        copyOfNotifications.splice(insertAtLocation, 1, notification);

        return copyOfNotifications;
    }

    const newNotificationPriority
        = NOTIFICATION_TYPE_PRIORITIES[notification.props.appearance ?? ''] || 0;

    // Find where to insert the new notification based on priority. Do not
    // insert at the front of the queue so that the user can finish acting on
    // any notification currently being read.
    for (let i = 1; i < notifications.length; i++) {
        const queuedNotification = notifications[i];
        const queuedNotificationPriority
            = NOTIFICATION_TYPE_PRIORITIES[queuedNotification.props.appearance ?? '']
            || 0;

        if (queuedNotificationPriority < newNotificationPriority) {
            insertAtLocation = i;
            break;
        }
    }

    copyOfNotifications.splice(insertAtLocation, 0, notification);

    return copyOfNotifications;
}


################################################################################

## File: .\jitsi-meet\react\features\notifications\types.ts

import React from 'react';

export interface INotificationProps {
    appearance?: string;
    concatText?: boolean;
    customActionHandler?: Function[];
    customActionNameKey?: string[];
    customActionType?: string[];
    description?: string | React.ReactNode;
    descriptionArguments?: Object;
    descriptionKey?: string;
    disableClosing?: boolean;
    hideErrorSupportLink?: boolean;
    icon?: string;
    maxLines?: number;
    sticky?: boolean;
    title?: string;
    titleArguments?: {
        [key: string]: string | number;
    };
    titleKey?: string;
    uid?: string;
}


################################################################################

## File: .\jitsi-meet\react\features\notifications\components\index.native.ts

export { default as NotificationsContainer } from './native/NotificationsContainer';


################################################################################

## File: .\jitsi-meet\react\features\notifications\components\index.web.ts

export { default as NotificationsContainer } from './web/NotificationsContainer';


################################################################################

## File: .\jitsi-meet\react\features\notifications\components\native\styles.ts

import BaseTheme from '../../../base/ui/components/BaseTheme.native';

const contentColumn = {
    flex: 1,
    flexDirection: 'column',
    paddingLeft: BaseTheme.spacing[2]
};

const notification = {
    backgroundColor: BaseTheme.palette.ui10,
    borderRadius: BaseTheme.shape.borderRadius,
    borderLeftColor: BaseTheme.palette.link01Active,
    borderLeftWidth: BaseTheme.spacing[1],
    display: 'flex',
    flexDirection: 'row',
    marginVertical: BaseTheme.spacing[1],
    maxWidth: 416,
    width: '100%'
};

/**
 * The styles of the React {@code Components} of the feature notifications.
 */
export default {

    /**
     * The content (left) column of the notification.
     */
    interactiveContentColumn: {
        ...contentColumn
    },

    contentColumn: {
        ...contentColumn,
        justifyContent: 'center'
    },

    /**
     * Test style of the notification.
     */

    contentContainer: {
        paddingHorizontal: BaseTheme.spacing[2]
    },

    contentText: {
        color: BaseTheme.palette.text04,
        paddingLeft: BaseTheme.spacing[5],
        paddingTop: BaseTheme.spacing[1]
    },

    contentTextTitle: {
        color: BaseTheme.palette.text04,
        fontWeight: 'bold',
        paddingLeft: BaseTheme.spacing[5],
        paddingTop: BaseTheme.spacing[2]
    },

    /**
     * Dismiss icon style.
     */
    dismissIcon: {
        color: BaseTheme.palette.icon04,
        fontSize: 20
    },

    notification: {
        ...notification
    },

    notificationWithDescription: {
        ...notification,
        paddingBottom: BaseTheme.spacing[2]
    },

    /**
     * Wrapper for the message.
     */
    notificationContent: {
        alignItems: 'center',
        flexDirection: 'row'
    },

    participantName: {
        color: BaseTheme.palette.text04,
        overflow: 'hidden'
    },

    iconContainer: {
        position: 'absolute',
        left: BaseTheme.spacing[2],
        top: 12
    },

    btn: {
        paddingLeft: BaseTheme.spacing[3]
    },

    btnContainer: {
        display: 'flex',
        flexDirection: 'row',
        paddingLeft: BaseTheme.spacing[4],
        paddingTop: BaseTheme.spacing[1]
    },

    withToolbox: {
        bottom: 56,
        position: 'absolute',
        width: '100%'
    },

    withToolboxTileView: {
        bottom: 56,
        position: 'absolute',
        width: '100%'
    },

    withoutToolbox: {
        position: 'absolute',
        width: '100%'
    },

    withoutToolboxTileView: {
        bottom: 0,
        position: 'absolute',
        width: '100%'
    }
};


################################################################################

## File: .\jitsi-meet\react\features\old-client-notification\functions.ts

import { browser } from '../base/lib-jitsi-meet';

/**
 * Returns true if Jitsi Meet is running in too old jitsi-meet-electron app and false otherwise.
 *
 * @returns {boolean} - True if Jitsi Meet is running in too old jitsi-meet-electron app and false otherwise.
 */
export function isOldJitsiMeetElectronApp() {
    if (!browser.isElectron()) {
        return false;
    }

    // @ts-ignore
    const match = navigator.userAgent.match(/(JitsiMeet)\s*\/\s*((\d+)\.[^\s]*)/);

    if (!Array.isArray(match) || match.length < 3) {
        return false;
    }

    const majorVersion = Number(match[3]);

    if (isNaN(majorVersion) || majorVersion >= 2022) {
        return false;
    }

    return true;
}


################################################################################

## File: .\jitsi-meet\react\features\overlay\actions.native.ts

import { ConnectionFailedError } from '../base/connection/types';
import { openDialog } from '../base/dialog/actions';
import PageReloadDialog from '../base/dialog/components/native/PageReloadDialog';


/**
 * Signals that the prompt for media permission is visible or not.
 *
 * @param {boolean} _isVisible - If the value is true - the prompt for media
 * permission is visible otherwise the value is false/undefined.
 * @param {string} _browser - The name of the current browser.
 * @public
 * @returns {{
 *     type: MEDIA_PERMISSION_PROMPT_VISIBILITY_CHANGED,
 *     browser: {string},
 *     isVisible: {boolean}
 * }}
 */
export function mediaPermissionPromptVisibilityChanged(_isVisible: boolean, _browser: string) {
    // Dummy.
}

/**
 * Opens {@link PageReloadDialog}.
 *
 * @param {Error} conferenceError - The conference error that caused the reload.
 * @param {Error} configError - The conference error that caused the reload.
 * @param {Error} connectionError - The conference error that caused the reload.
 * @returns {Function}
 */
export function openPageReloadDialog(
        conferenceError?: Error, configError?: Error, connectionError?: ConnectionFailedError) {
    return openDialog(PageReloadDialog, {
        conferenceError,
        configError,
        connectionError
    });
}


################################################################################

## File: .\jitsi-meet\react\features\overlay\actions.web.ts

import { MEDIA_PERMISSION_PROMPT_VISIBILITY_CHANGED } from './actionTypes';


/**
 * Signals that the prompt for media permission is visible or not.
 *
 * @param {boolean} isVisible - If the value is true - the prompt for media
 * permission is visible otherwise the value is false/undefined.
 * @param {string} browser - The name of the current browser.
 * @public
 * @returns {{
 *     type: MEDIA_PERMISSION_PROMPT_VISIBILITY_CHANGED,
 *     browser: {string},
 *     isVisible: {boolean}
 * }}
 */
export function mediaPermissionPromptVisibilityChanged(isVisible: boolean, browser: string) {
    return {
        type: MEDIA_PERMISSION_PROMPT_VISIBILITY_CHANGED,
        browser,
        isVisible
    };
}

/**
 * Opens {@link PageReloadDialog}.
 *
 * @param {any} _dummy1 - N/A for web.
 * @param {any} _dummy2 - N/A for web.
 * @param {any} _dummy3 - N/A for web.
 *
 * @returns {Function}
 */
export function openPageReloadDialog(_dummy1: any, _dummy2: any, _dummy3: any): any {
    // Dummy
}


################################################################################

## File: .\jitsi-meet\react\features\overlay\actionTypes.ts

/**
 * The type of the Redux action which signals that the prompt for media
 * permission is visible or not.
 *
 * {
 *     type: MEDIA_PERMISSION_PROMPT_VISIBILITY_CHANGED,
 *     isVisible: {boolean},
 *     browser: {string}
 * }
 * @public
 */
export const MEDIA_PERMISSION_PROMPT_VISIBILITY_CHANGED
    = 'MEDIA_PERMISSION_PROMPT_VISIBILITY_CHANGED';


################################################################################

## File: .\jitsi-meet\react\features\overlay\functions.web.ts

import { IReduxState } from '../app/types';

import PageReloadOverlay from './components/web/PageReloadOverlay';
import SuspendedOverlay from './components/web/SuspendedOverlay';
import UserMediaPermissionsOverlay from './components/web/UserMediaPermissionsOverlay';

/**
 * Returns the overlay to be currently rendered.
 *
 * @param {IReduxState} state - The Redux state.
 * @returns {?React$ComponentType<*>}
 */
export function getOverlayToRender(state: IReduxState) {
    const overlays = [
        PageReloadOverlay,
        SuspendedOverlay,
        UserMediaPermissionsOverlay
    ];

    for (const overlay of overlays) {
        // react-i18n / react-redux wrap components and thus we cannot access
        // the wrapped component's static methods directly.
        // @ts-ignore
        const component = overlay.WrappedComponent || overlay;

        if (component.needsRender(state)) {
            return overlay;
        }
    }

    return undefined;
}


################################################################################

## File: .\jitsi-meet\react\features\overlay\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/overlay');


################################################################################

## File: .\jitsi-meet\react\features\overlay\middleware.ts

import { IStore } from '../app/types';
import { JitsiConferenceErrors, JitsiConnectionErrors } from '../base/lib-jitsi-meet';
import {
    isFatalJitsiConferenceError,
    isFatalJitsiConnectionError
} from '../base/lib-jitsi-meet/functions.any';
import StateListenerRegistry from '../base/redux/StateListenerRegistry';

import { openPageReloadDialog } from './actions';
import logger from './logger';

/**
 * Error type. Basically like Error, but augmented with a recoverable property.
 */
type ErrorType = {

    /**
     * Error message.
     */
    message?: string;

    /**
     * Error name.
     */
    name: string;

    /**
     * Indicates whether this event is recoverable or not.
     */
    recoverable?: boolean;
};

/**
 * List of errors that are not fatal (or handled differently) so then the page reload dialog won't kick in.
 */
const RN_NO_RELOAD_DIALOG_ERRORS = [
    JitsiConnectionErrors.NOT_LIVE_ERROR,
    JitsiConferenceErrors.CONFERENCE_ACCESS_DENIED,
    JitsiConferenceErrors.CONFERENCE_DESTROYED,
    JitsiConferenceErrors.CONNECTION_ERROR,
    JitsiConferenceErrors.CONFERENCE_RESTARTED
];

const ERROR_TYPES = {
    CONFIG: 'CONFIG',
    CONNECTION: 'CONNECTION',
    CONFERENCE: 'CONFERENCE'
};

/**
 * Gets the error type and whether it's fatal or not.
 *
 * @param {Object} state - The redux state.
 * @param {Object|string} error - The error to process.
 * @returns {void}
 */
const getErrorExtraInfo = (state: any, error: ErrorType) => {
    const { error: conferenceError } = state['features/base/conference'];
    const { error: configError } = state['features/base/config'];
    const { error: connectionError } = state['features/base/connection'];

    if (error === conferenceError) {
        return {
            type: ERROR_TYPES.CONFERENCE, // @ts-ignore
            isFatal: isFatalJitsiConferenceError(error.name || error)
        };
    }

    if (error === configError) {
        return {
            type: ERROR_TYPES.CONFIG,
            isFatal: true
        };
    }

    if (error === connectionError) {
        return {
            type: ERROR_TYPES.CONNECTION, // @ts-ignore
            isFatal: isFatalJitsiConnectionError(error.name || error)
        };
    }
};

/**
 * State listener which emits the {@code fatalErrorOccurred} action which works
 * as a catch all for critical errors which have not been claimed by any other
 * feature for error recovery (the recoverable flag is not set).
 */
StateListenerRegistry.register(
    /* selector */ state => {
        const { error: conferenceError } = state['features/base/conference'];
        const { error: configError } = state['features/base/config'];
        const { error: connectionError } = state['features/base/connection'];

        return configError || connectionError || conferenceError;
    },
    /* listener */ (error: ErrorType, store: IStore) => {
        if (!error) {
            return;
        }

        const state = store.getState();

        // eslint-disable-next-line no-negated-condition
        if (typeof APP !== 'undefined') {
            APP.API.notifyError({
                ...error,
                ...getErrorExtraInfo(state, error)
            });
        } else if (RN_NO_RELOAD_DIALOG_ERRORS.indexOf(error.name) === -1 && typeof error.recoverable === 'undefined') {
            const { error: conferenceError } = state['features/base/conference'];
            const { error: configError } = state['features/base/config'];
            const { error: connectionError } = state['features/base/connection'];
            const conferenceState = state['features/base/conference'];

            if (conferenceState.leaving) {
                logger.info(`Ignoring ${error.name} while leaving conference`);

                return;
            }

            setTimeout(() => {
                logger.info(`Reloading due to error: ${error.name}`, error);

                store.dispatch(openPageReloadDialog(conferenceError, configError, connectionError));
            }, 500);
        }
    }
);


################################################################################

## File: .\jitsi-meet\react\features\overlay\reducer.ts

import ReducerRegistry from '../base/redux/ReducerRegistry';
import { assign } from '../base/redux/functions';

import { MEDIA_PERMISSION_PROMPT_VISIBILITY_CHANGED } from './actionTypes';


export interface IOverlayState {
    browser?: string;
    isMediaPermissionPromptVisible?: boolean;
}

/**
 * Reduces the redux actions of the feature overlay.
 *
 * FIXME: these pieces of state should probably be in a different place.
 */
ReducerRegistry.register<IOverlayState>('features/overlay', (state = {}, action): IOverlayState => {
    switch (action.type) {
    case MEDIA_PERMISSION_PROMPT_VISIBILITY_CHANGED:
        return _mediaPermissionPromptVisibilityChanged(state, action);
    }

    return state;
});

/**
 * Reduces a specific redux action MEDIA_PERMISSION_PROMPT_VISIBILITY_CHANGED of
 * the feature overlay.
 *
 * @param {Object} state - The redux state of the feature overlay.
 * @param {Action} action - The redux action to reduce.
 * @private
 * @returns {Object} The new state of the feature overlay after the reduction of
 * the specified action.
 */
function _mediaPermissionPromptVisibilityChanged(
        state: IOverlayState,
        { browser, isVisible }: { browser?: string; isVisible?: boolean; }) {
    return assign(state, {
        browser,
        isMediaPermissionPromptVisible: isVisible
    });
}


################################################################################

## File: .\jitsi-meet\react\features\overlay\components\web\AbstractSuspendedOverlay.ts

import { Component } from 'react';
import { WithTranslation } from 'react-i18next';

import { IReduxState } from '../../../app/types';

/**
 * Implements a React {@link Component} for suspended overlay. Shown when a
 * suspend is detected.
 */
export default class AbstractSuspendedOverlay extends Component<WithTranslation> {
    /**
     * Determines whether this overlay needs to be rendered (according to a
     * specific redux state). Called by {@link OverlayContainer}.
     *
     * @param {Object} state - The redux state.
     * @returns {boolean} - If this overlay needs to be rendered, {@code true};
     * {@code false}, otherwise.
     */
    static needsRender(state: IReduxState) {
        return state['features/power-monitor']?.suspendDetected;
    }
}


################################################################################

## File: .\jitsi-meet\react\features\overlay\components\web\AbstractUserMediaPermissionsOverlay.ts

import { Component } from 'react';
import { WithTranslation } from 'react-i18next';

import { IReduxState } from '../../../app/types';

/**
 * The type of the React {@code Component} props of
 * {@link AbstractUserMediaPermissionsOverlay}.
 */
interface IProps extends WithTranslation {

    _premeetingBackground?: any;

    /**
     * The browser which is used currently. The text is different for every
     * browser.
     */
    browser?: string;
}

/**
 * Implements a React {@link Component} for overlay with guidance how to proceed
 * with gUM prompt.
 */
export default class AbstractUserMediaPermissionsOverlay
    extends Component<IProps> {
    /**
     * Determines whether this overlay needs to be rendered (according to a
     * specific redux state). Called by {@link OverlayContainer}.
     *
     * @param {Object} state - The redux state.
     * @returns {boolean} - If this overlay needs to be rendered, {@code true};
     * {@code false}, otherwise.
     */
    static needsRender(state: IReduxState) {
        return state['features/overlay'].isMediaPermissionPromptVisible;
    }
}

/**
 * Maps (parts of) the redux state to the associated component's props.
 *
 * @param {Object} state - The redux state.
 * @protected
 * @returns {{
 *     browser: string
 * }}
 */
export function abstractMapStateToProps(state: IReduxState) {
    const { browser } = state['features/overlay'];

    return {
        browser
    };
}


################################################################################

## File: .\jitsi-meet\react\features\participants-pane\actions.any.ts

import { PARTICIPANTS_PANE_CLOSE } from './actionTypes';

/**
 * Action to close the participants pane.
 *
 * @returns {Object}
 */
export const close = () => {
    return {
        type: PARTICIPANTS_PANE_CLOSE
    };
};


################################################################################

## File: .\jitsi-meet\react\features\participants-pane\actions.native.ts

/* eslint-disable lines-around-comment */
import { IStore } from '../app/types';
import { openSheet } from '../base/dialog/actions';
import { navigate }
    from '../mobile/navigation/components/conference/ConferenceNavigationContainerRef';
import { screen } from '../mobile/navigation/routes';
import ConnectionStatusComponent
    from '../video-menu/components/native/ConnectionStatusComponent';
// @ts-ignore
import LocalVideoMenu from '../video-menu/components/native/LocalVideoMenu';
// @ts-ignore
import RemoteVideoMenu from '../video-menu/components/native/RemoteVideoMenu';
// @ts-ignore
import SharedVideoMenu from '../video-menu/components/native/SharedVideoMenu';

import { PARTICIPANTS_PANE_OPEN, SET_VOLUME } from './actionTypes';
import RoomParticipantMenu from './components/native/RoomParticipantMenu';

export * from './actions.any';

/**
 * Displays the connection status for the local meeting participant.
 *
 * @param {string} participantID - The selected meeting participant id.
 * @returns {Function}
 */
export function showConnectionStatus(participantID: string) {
    return openSheet(ConnectionStatusComponent, { participantID });
}

/**
 * Displays the context menu for the selected meeting participant.
 *
 * @param {string} participantId - The ID of the selected meeting participant.
 * @param {boolean} local - Whether the participant is local or not.
 * @returns {Function}
 */
export function showContextMenuDetails(participantId: string, local = false) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const { remoteVideoMenu } = getState()['features/base/config'];

        if (local) {
            dispatch(openSheet(LocalVideoMenu));
        } else if (!remoteVideoMenu?.disabled) {
            dispatch(openSheet(RemoteVideoMenu, { participantId }));
        }
    };
}

/**
 * Displays the shared video menu.
 *
 * @param {string} participantId - The ID of the selected meeting participant.
 * @returns {Function}
 */
export function showSharedVideoMenu(participantId: string) {
    return openSheet(SharedVideoMenu, { participantId });
}

/**
 * Sets the volume.
 *
 * @param {string} participantId - The participant ID associated with the audio.
 * @param {string} volume - The volume level.
 * @returns {{
 *     type: SET_VOLUME,
 *     participantId: string,
 *     volume: number
 * }}
 */
export function setVolume(participantId: string, volume: number) {
    return {
        type: SET_VOLUME,
        participantId,
        volume
    };
}

/**
 * Displays the breakout room participant menu.
 *
 * @param {Object} room - The room the participant is in.
 * @param {string} participantJid - The jid of the participant.
 * @param {string} participantName - The display name of the participant.
 * @returns {Function}
 */
export function showRoomParticipantMenu(room: Object, participantJid: string, participantName: string) {
    // @ts-ignore
    return openSheet(RoomParticipantMenu, { room,
        participantJid,
        participantName });
}

/**
 * Action to open the participants pane.
 *
 * @returns {Object}
 */
export const open = () => {
    navigate(screen.conference.participants);

    return {
        type: PARTICIPANTS_PANE_OPEN
    };
};


################################################################################

## File: .\jitsi-meet\react\features\participants-pane\actions.web.ts

import { PARTICIPANTS_PANE_OPEN } from './actionTypes';

export * from './actions.any';

/**
 * Action to open the participants pane.
 *
 * @returns {Object}
 */
export const open = () => {
    return {
        type: PARTICIPANTS_PANE_OPEN
    };
};


################################################################################

## File: .\jitsi-meet\react\features\participants-pane\actionTypes.ts

/**
 * Action type to signal the closing of the participants pane.
 */
export const PARTICIPANTS_PANE_CLOSE = 'PARTICIPANTS_PANE_CLOSE';

/**
 * Action type to signal the opening of the participants pane.
 */
export const PARTICIPANTS_PANE_OPEN = 'PARTICIPANTS_PANE_OPEN';

/**
 * Action type to set the volume of the participant.
 */
export const SET_VOLUME = 'SET_VOLUME';


################################################################################

## File: .\jitsi-meet\react\features\participants-pane\functions.ts

import { IReduxState } from '../app/types';
import {
    isEnabledFromState,
    isLocalParticipantApprovedFromState,
    isParticipantApproved,
    isSupported
} from '../av-moderation/functions';
import { IStateful } from '../base/app/types';
import { getCurrentConference } from '../base/conference/functions';
import { INVITE_ENABLED, PARTICIPANTS_ENABLED } from '../base/flags/constants';
import { getFeatureFlag } from '../base/flags/functions';
import { MEDIA_TYPE, type MediaType } from '../base/media/constants';
import {
    getDominantSpeakerParticipant,
    getLocalParticipant,
    getRaiseHandsQueue,
    getRemoteParticipantsSorted,
    isLocalParticipantModerator,
    isParticipantModerator
} from '../base/participants/functions';
import { IParticipant } from '../base/participants/types';
import { toState } from '../base/redux/functions';
import { normalizeAccents } from '../base/util/strings';
import { BREAKOUT_ROOMS_RENAME_FEATURE } from '../breakout-rooms/constants';
import { isInBreakoutRoom } from '../breakout-rooms/functions';

import { MEDIA_STATE, QUICK_ACTION_BUTTON, REDUCER_KEY } from './constants';

/**
 * Checks if a participant is force muted.
 *
 * @param {IParticipant|undefined} participant - The participant.
 * @param {MediaType} mediaType - The media type.
 * @param {IReduxState} state - The redux state.
 * @returns {MediaState}
 */
export function isForceMuted(participant: IParticipant | undefined, mediaType: MediaType, state: IReduxState) {
    if (isEnabledFromState(mediaType, state)) {
        if (participant?.local) {
            return !isLocalParticipantApprovedFromState(mediaType, state);
        }

        // moderators cannot be force muted
        if (isParticipantModerator(participant)) {
            return false;
        }

        return !isParticipantApproved(participant?.id ?? '', mediaType)(state);
    }

    return false;
}

/**
 * Determines the audio media state (the mic icon) for a participant.
 *
 * @param {IParticipant} participant - The participant.
 * @param {boolean} muted - The mute state of the participant.
 * @param {IReduxState} state - The redux state.
 * @returns {MediaState}
 */
export function getParticipantAudioMediaState(participant: IParticipant | undefined,
        muted: Boolean, state: IReduxState) {
    const dominantSpeaker = getDominantSpeakerParticipant(state);

    if (participant?.isSilent) {
        return MEDIA_STATE.NONE;
    }

    if (muted) {
        if (isForceMuted(participant, MEDIA_TYPE.AUDIO, state)) {
            return MEDIA_STATE.FORCE_MUTED;
        }

        return MEDIA_STATE.MUTED;
    }

    if (participant === dominantSpeaker) {
        return MEDIA_STATE.DOMINANT_SPEAKER;
    }

    return MEDIA_STATE.UNMUTED;
}

/**
 * Determines the video media state (the mic icon) for a participant.
 *
 * @param {IParticipant} participant - The participant.
 * @param {boolean} muted - The mute state of the participant.
 * @param {IReduxState} state - The redux state.
 * @returns {MediaState}
 */
export function getParticipantVideoMediaState(participant: IParticipant | undefined,
        muted: Boolean, state: IReduxState) {
    if (muted) {
        if (isForceMuted(participant, MEDIA_TYPE.VIDEO, state)) {
            return MEDIA_STATE.FORCE_MUTED;
        }

        return MEDIA_STATE.MUTED;
    }

    return MEDIA_STATE.UNMUTED;
}

/**
 * Returns this feature's root state.
 *
 * @param {IReduxState} state - Global state.
 * @returns {Object} Feature state.
 */
const getState = (state: IReduxState) => state[REDUCER_KEY];

/**
 * Returns the participants pane config.
 *
 * @param {IStateful} stateful - The redux store, the redux
 * {@code getState} function, or the redux state itself.
 * @returns {Object}
 */
export const getParticipantsPaneConfig = (stateful: IStateful) => {
    const state = toState(stateful);
    const { participantsPane = {} } = state['features/base/config'];

    return participantsPane;
};

/**
 * Is the participants pane open.
 *
 * @param {IReduxState} state - Global state.
 * @returns {boolean} Is the participants pane open.
 */
export const getParticipantsPaneOpen = (state: IReduxState) => Boolean(getState(state)?.isOpen);

/**
 * Returns the type of quick action button to be displayed for a participant.
 * The button is displayed when hovering a participant from the participant list.
 *
 * @param {IParticipant} participant - The participant.
 * @param {boolean} isAudioMuted - If audio is muted for the participant.
 * @param {boolean} isVideoMuted - If audio is muted for the participant.
 * @param {IReduxState} state - The redux state.
 * @returns {string} - The type of the quick action button.
 */
export function getQuickActionButtonType(
        participant: IParticipant | undefined,
        isAudioMuted: Boolean,
        isVideoMuted: Boolean,
        state: IReduxState) {
    // handled only by moderators
    const isVideoForceMuted = isForceMuted(participant, MEDIA_TYPE.VIDEO, state);
    const isParticipantSilent = participant?.isSilent || false;

    if (isLocalParticipantModerator(state)) {
        if (!isAudioMuted && !isParticipantSilent) {
            return QUICK_ACTION_BUTTON.MUTE;
        }
        if (!isVideoMuted) {
            return QUICK_ACTION_BUTTON.STOP_VIDEO;
        }
        if (isVideoForceMuted) {
            return QUICK_ACTION_BUTTON.ALLOW_VIDEO;
        }
        if (isSupported()(state) && !isParticipantSilent) {
            return QUICK_ACTION_BUTTON.ASK_TO_UNMUTE;
        }
    }

    return QUICK_ACTION_BUTTON.NONE;
}

/**
 * Returns true if the invite button should be rendered.
 *
 * @param {IReduxState} state - Global state.
 * @returns {boolean}
 */
export const shouldRenderInviteButton = (state: IReduxState) => {
    const { disableInviteFunctions } = toState(state)['features/base/config'];
    const flagEnabled = getFeatureFlag(state, INVITE_ENABLED, true);
    const inBreakoutRoom = isInBreakoutRoom(state);

    return flagEnabled && !disableInviteFunctions && !inBreakoutRoom;
};

/**
 * Selector for retrieving ids of participants in the order that they are displayed in the filmstrip (with the
 * exception of participants with raised hand). The participants are reordered as follows.
 * 1. Dominant speaker.
 * 2. Local participant.
 * 3. Participants with raised hand.
 * 4. Participants with screenshare sorted alphabetically by their display name.
 * 5. Shared video participants.
 * 6. Recent speakers sorted alphabetically by their display name.
 * 7. Rest of the participants sorted alphabetically by their display name.
 *
 * @param {IStateful} stateful - The (whole) redux state, or redux's
 * {@code getState} function to be used to retrieve the state features/base/participants.
 * @returns {Array<string>}
 */
export function getSortedParticipantIds(stateful: IStateful) {
    const id = getLocalParticipant(stateful)?.id;
    const remoteParticipants = getRemoteParticipantsSorted(stateful);
    const reorderedParticipants = new Set(remoteParticipants);
    const raisedHandParticipants = getRaiseHandsQueue(stateful).map(({ id: particId }) => particId);
    const remoteRaisedHandParticipants = new Set(raisedHandParticipants || []);
    const dominantSpeaker = getDominantSpeakerParticipant(stateful);

    for (const participant of remoteRaisedHandParticipants.keys()) {
        // Avoid duplicates.
        if (reorderedParticipants.has(participant)) {
            reorderedParticipants.delete(participant);
        }
    }

    const dominant = [];
    const dominantId = dominantSpeaker?.id;
    const local = remoteRaisedHandParticipants.has(id ?? '') ? [] : [ id ];

    // In case dominat speaker has raised hand, keep the order in the raised hand queue.
    // In case they don't have raised hand, goes first in the participants list.
    if (dominantId && dominantId !== id && !remoteRaisedHandParticipants.has(dominantId)) {
        reorderedParticipants.delete(dominantId);
        dominant.push(dominantId);
    }

    // Move self and participants with raised hand to the top of the list.
    return [
        ...dominant,
        ...local,
        ...Array.from(remoteRaisedHandParticipants.keys()),
        ...Array.from(reorderedParticipants.keys())
    ];
}

/**
 * Checks if a participant matches the search string.
 *
 * @param {Object} participant - The participant to be checked.
 * @param {string} searchString - The participants search string.
 * @returns {boolean}
 */
export function participantMatchesSearch(participant: IParticipant | undefined
    | { displayName?: string; name?: string; },
searchString: string) {
    if (searchString === '') {
        return true;
    }
    const participantName = normalizeAccents(participant?.name || participant?.displayName || '')
        .toLowerCase();
    const lowerCaseSearchString = searchString.trim().toLowerCase();

    return participantName.includes(lowerCaseSearchString);
}

/**
 * Returns whether the more actions button is visible.
 *
 * @param {IReduxState} state - Global state.
 * @returns {boolean}
 */
export const isMoreActionsVisible = (state: IReduxState) => {
    const isLocalModerator = isLocalParticipantModerator(state);
    const inBreakoutRoom = isInBreakoutRoom(state);
    const { hideMoreActionsButton } = getParticipantsPaneConfig(state);

    return inBreakoutRoom ? false : !hideMoreActionsButton && isLocalModerator;
};

/**
 * Returns whether the mute all button is visible.
 *
 * @param {IReduxState} state - Global state.
 * @returns {boolean}
 */
export const isMuteAllVisible = (state: IReduxState) => {
    const isLocalModerator = isLocalParticipantModerator(state);
    const inBreakoutRoom = isInBreakoutRoom(state);
    const { hideMuteAllButton } = getParticipantsPaneConfig(state);

    return inBreakoutRoom ? false : !hideMuteAllButton && isLocalModerator;
};

/**
 * Returns true if renaming the currently joined breakout room is allowed and false otherwise.
 *
 * @param {IReduxState} state - The redux state.
 * @returns {boolean} - True if reanming the currently joined breakout room is allowed and false otherwise.
 */
export function isCurrentRoomRenamable(state: IReduxState) {
    return isInBreakoutRoom(state) && isBreakoutRoomRenameAllowed(state);
}

/**
 * Returns true if renaming a breakout room is allowed and false otherwise.
 *
 * @param {IReduxState} state - The redux state.
 * @returns {boolean} - True if renaming a breakout room is allowed and false otherwise.
 */
export function isBreakoutRoomRenameAllowed(state: IReduxState) {
    const isLocalModerator = isLocalParticipantModerator(state);
    const conference = getCurrentConference(state);
    const isRenameBreakoutRoomsSupported
            = conference?.getBreakoutRooms()?.isFeatureSupported(BREAKOUT_ROOMS_RENAME_FEATURE) ?? false;

    return isLocalModerator && isRenameBreakoutRoomsSupported;
}

/**
 * Returns true if participants is enabled and false otherwise.
 *
 * @param {IStateful} stateful - The redux store, the redux
 * {@code getState} function, or the redux state itself.
 * @returns {boolean}
 */
export const isParticipantsPaneEnabled = (stateful: IStateful) => {
    const state = toState(stateful);
    const { enabled = true } = getParticipantsPaneConfig(state);

    return Boolean(getFeatureFlag(state, PARTICIPANTS_ENABLED, true) && enabled);
};


################################################################################

## File: .\jitsi-meet\react\features\participants-pane\hooks.web.ts

import { useCallback, useState } from 'react';
import { useDispatch, useSelector } from 'react-redux';

import { handleLobbyChatInitialized } from '../chat/actions.web';
import { approveKnockingParticipant, rejectKnockingParticipant } from '../lobby/actions.web';

import ParticipantsPaneButton from './components/web/ParticipantsPaneButton';
import { isParticipantsPaneEnabled } from './functions';

interface IDrawerParticipant {
    displayName?: string;
    participantID: string;
}

const participants = {
    key: 'participants-pane',
    Content: ParticipantsPaneButton,
    group: 2
};

/**
 * Hook used to create admit/reject lobby actions.
 *
 * @param {Object} participant - The participant for which the actions are created.
 * @param {Function} closeDrawer - Callback for closing the drawer.
 * @returns {Array<Function>}
 */
export function useLobbyActions(participant?: IDrawerParticipant | null, closeDrawer?: Function) {
    const dispatch = useDispatch();

    return [
        useCallback(e => {
            e.stopPropagation();
            dispatch(approveKnockingParticipant(participant?.participantID ?? ''));
            closeDrawer?.();
        }, [ dispatch, closeDrawer, participant?.participantID ]),

        useCallback(() => {
            dispatch(rejectKnockingParticipant(participant?.participantID ?? ''));
            closeDrawer?.();
        }, [ dispatch, closeDrawer, participant?.participantID ]),

        useCallback(() => {
            dispatch(handleLobbyChatInitialized(participant?.participantID ?? ''));
        }, [ dispatch, participant?.participantID ])
    ];
}

/**
 * Hook used to create actions & state for opening a drawer.
 *
 * @returns {Array<any>}
 */
export function useParticipantDrawer(): [
    IDrawerParticipant | null,
    () => void,
    (p: IDrawerParticipant | null) => void ] {
    const [ drawerParticipant, openDrawerForParticipant ] = useState<IDrawerParticipant | null>(null);
    const closeDrawer = useCallback(() => {
        openDrawerForParticipant(null);
    }, []);

    return [
        drawerParticipant,
        closeDrawer,
        openDrawerForParticipant
    ];
}

/**
 * A hook that returns the participants pane button if it is enabled and undefined otherwise.
 *
 *  @returns {Object | undefined}
 */
export function useParticipantPaneButton() {
    const participantsPaneEnabled = useSelector(isParticipantsPaneEnabled);

    if (participantsPaneEnabled) {
        return participants;
    }
}


################################################################################

## File: .\jitsi-meet\react\features\participants-pane\middleware.ts

import { AnyAction } from 'redux';

import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';

import { PARTICIPANTS_PANE_CLOSE, PARTICIPANTS_PANE_OPEN } from './actionTypes';

/**
 * Middleware which intercepts participants pane actions.
 *
 * @param {IStore} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(() => (next: Function) => (action: AnyAction) => {
    switch (action.type) {
    case PARTICIPANTS_PANE_OPEN:
        if (typeof APP !== 'undefined') {
            APP.API.notifyParticipantsPaneToggled(true);
        }
        break;
    case PARTICIPANTS_PANE_CLOSE:
        if (typeof APP !== 'undefined') {
            APP.API.notifyParticipantsPaneToggled(false);
        }
        break;
    }

    return next(action);
});


################################################################################

## File: .\jitsi-meet\react\features\participants-pane\reducer.ts

import ReducerRegistry from '../base/redux/ReducerRegistry';

import {
    PARTICIPANTS_PANE_CLOSE,
    PARTICIPANTS_PANE_OPEN,
    SET_VOLUME
} from './actionTypes';
import { REDUCER_KEY } from './constants';

export interface IParticipantsPaneState {
    isOpen: boolean;
    participantsVolume: {
        [participantId: string]: number;
    };
}

const DEFAULT_STATE = {
    isOpen: false,
    participantsVolume: {}
};

/**
 * Listen for actions that mutate the participants pane state.
 */
ReducerRegistry.register(
    REDUCER_KEY, (state: IParticipantsPaneState = DEFAULT_STATE, action) => {
        switch (action.type) {
        case PARTICIPANTS_PANE_CLOSE:
            return {
                ...state,
                isOpen: false
            };

        case PARTICIPANTS_PANE_OPEN:
            return {
                ...state,
                isOpen: true
            };

        case SET_VOLUME:
            return {
                ...state,
                participantsVolume: {
                    ...state.participantsVolume,

                    [action.participantId]: action.volume
                }
            };

        default:
            return state;
        }
    }
);


################################################################################

## File: .\jitsi-meet\react\features\participants-pane\types.ts

/**
 * The type of the React {@code Component} props of {@link BreakoutRoomNamePrompt}.
 */
export interface IBreakoutRoomNamePromptProps {

    /**
     * The jid of the breakout room to rename.
     */
    breakoutRoomJid: string;

    /**
     * The initial breakout room name.
     */
    initialRoomName: string;
}

/**
 * The available actions for breakout rooms context menu.
 */
export enum BREAKOUT_CONTEXT_MENU_ACTIONS {

    /**
     * Join breakout room.
     */
    JOIN = 1,

    /**
     * Rename breakout room.
     */
    RENAME = 2,

    /**
     * Remove breakout room.
     */
    REMOVE = 3
}


################################################################################

## File: .\jitsi-meet\react\features\participants-pane\components\native\styles.ts

import BaseTheme from '../../../base/ui/components/BaseTheme.native';

/**
 * The style for participant list description.
 */
const participantListDescription = {
    ...BaseTheme.typography.heading6,
    color: BaseTheme.palette.text01,
    fontSize: 15,
    fontWeight: 'bold',
    marginLeft: BaseTheme.spacing[2],
    paddingVertical: BaseTheme.spacing[2],
    position: 'relative',
    width: '70%'
};

/**
 * The style for content.
 */
const flexContent = {
    alignItems: 'center',
    color: BaseTheme.palette.icon01,
    display: 'flex',
    flex: 1
};

/**
 * The style for the context menu items text.
 */
const contextMenuItemText = {
    ...BaseTheme.typography.bodyShortRegularLarge,
    color: BaseTheme.palette.text01
};

/**
 * The style of the participants pane buttons.
 */
export const button = {
    display: 'flex',
    flexDirection: 'row',
    justifyContent: 'center'
};

/**
 * The style of the context menu pane items.
 */
const contextMenuItem = {
    alignItems: 'center',
    display: 'flex',
    flexDirection: 'row',
    height: BaseTheme.spacing[7],
    marginLeft: BaseTheme.spacing[3]
};

const participantNameContainer = {
    display: 'flex',
    flexDirection: 'row',
    overflow: 'hidden',
    paddingLeft: BaseTheme.spacing[3]
};

/**
 * The styles of the native components of the feature {@code participants}.
 */
export default {

    participantsBadge: {
        backgroundColor: BaseTheme.palette.ui03,
        borderRadius: BaseTheme.spacing[2],
        borderColor: 'white',
        overflow: 'hidden',
        height: BaseTheme.spacing[3],
        minWidth: BaseTheme.spacing[3],
        color: BaseTheme.palette.text01,
        ...BaseTheme.typography.labelBold,
        position: 'absolute',
        right: -3,
        top: -3,
        textAlign: 'center',
        paddingHorizontal: 2
    },

    participantsButtonBadge: {
        display: 'flex',
        position: 'relative'
    },

    participantContainer: {
        alignItems: 'center',
        display: 'flex',
        flexDirection: 'row',
        height: BaseTheme.spacing[9],
        paddingLeft: BaseTheme.spacing[3],
        paddingRight: BaseTheme.spacing[3],
        width: '100%'
    },

    participantContent: {
        alignItems: 'center',
        borderBottomColor: BaseTheme.palette.ui02,
        borderBottomWidth: 2.4,
        display: 'flex',
        flexDirection: 'row',
        height: '100%',
        overflow: 'hidden',
        width: '100%'
    },

    participantDetailsContainer: {
        display: 'flex',
        flexDirection: 'column',
        width: '73%'
    },

    participantDetailsContainerRaisedHand: {
        width: '65%'
    },

    participantNameContainer: {
        ...participantNameContainer,
        width: '100%'
    },

    lobbyParticipantNameContainer: {
        ...participantNameContainer,
        width: '40%'
    },

    participantName: {
        color: BaseTheme.palette.text01,
        overflow: 'hidden'
    },

    moderatorLabel: {
        color: BaseTheme.palette.text03,
        alignSelf: 'flex-start',
        paddingLeft: BaseTheme.spacing[3],
        paddingTop: BaseTheme.spacing[1]
    },

    participantStatesContainer: {
        display: 'flex',
        flexDirection: 'row',
        marginLeft: 'auto',
        width: '15%'
    },

    participantStateVideo: {
        paddingRight: BaseTheme.spacing[3]
    },

    raisedHandIndicator: {
        backgroundColor: BaseTheme.palette.warning02,
        borderRadius: BaseTheme.shape.borderRadius / 2,
        height: BaseTheme.spacing[4],
        width: BaseTheme.spacing[4],
        marginLeft: 'auto',
        marginRight: BaseTheme.spacing[2]
    },

    raisedHandIcon: {
        ...flexContent,
        top: BaseTheme.spacing[1],
        color: BaseTheme.palette.uiBackground
    },

    buttonAdmit: {
        position: 'absolute',
        right: 16
    },

    buttonReject: {
        position: 'absolute',
        right: 112
    },

    lobbyListDescription: {
        ...participantListDescription
    },

    listDetails: {
        alignItems: 'center',
        display: 'flex',
        flexDirection: 'row',
        justifyContent: 'space-between'
    },

    meetingListContainer: {
        paddingHorizontal: BaseTheme.spacing[3]
    },

    meetingListDescription: {
        ...participantListDescription
    },

    participantsPaneContainer: {
        backgroundColor: BaseTheme.palette.ui01,
        flex: 1,
        flexDirection: 'column',
        paddingVertical: BaseTheme.spacing[2]
    },

    participantsPaneFooterContainer: {
        alignItems: 'center',
        bottom: 0,
        height: 128,
        left: 0,
        paddingHorizontal: BaseTheme.spacing[4],
        right: 0
    },

    participantsPaneFooter: {
        display: 'flex',
        flexDirection: 'row',
        justifyContent: 'flex-end',
        paddingBottom: BaseTheme.spacing[3],
        width: '100%'
    },

    inviteButton: {
        marginLeft: BaseTheme.spacing[3],
        marginRight: BaseTheme.spacing[3],
        marginVertical: BaseTheme.spacing[2]
    },

    breakoutRoomsButton: {
        marginBottom: BaseTheme.spacing[2],
        width: '100%'
    },

    moreButton: {
        marginLeft: BaseTheme.spacing[2]
    },

    contextMenuItem: {
        ...contextMenuItem
    },

    contextMenuItemSection: {
        ...contextMenuItem
    },

    contextMenuItemSectionAvatar: {
        alignItems: 'center',
        backgroundColor: BaseTheme.palette.ui01,
        borderBottomColor: BaseTheme.palette.ui07,
        borderBottomWidth: 1,
        borderTopLeftRadius: BaseTheme.spacing[3],
        borderTopRightRadius: BaseTheme.spacing[3],
        flexDirection: 'row',
        height: BaseTheme.spacing[7],
        paddingLeft: BaseTheme.spacing[3]
    },

    contextMenuItemText: {
        ...contextMenuItemText,
        marginLeft: BaseTheme.spacing[3]
    },

    contextMenuItemTextNoIcon: {
        ...contextMenuItemText,
        marginLeft: BaseTheme.spacing[6]
    },

    contextMenuItemName: {
        color: BaseTheme.palette.text04,
        flexShrink: 1,
        fontSize: BaseTheme.spacing[3],
        marginLeft: BaseTheme.spacing[3],
        opacity: 0.90
    },

    divider: {
        backgroundColor: BaseTheme.palette.ui07
    },

    inputContainer: {
        marginLeft: BaseTheme.spacing[3],
        marginRight: BaseTheme.spacing[3],
        marginBottom: BaseTheme.spacing[4]
    },

    centerInput: {
        paddingRight: BaseTheme.spacing[3],
        textAlign: 'center'
    },

    visitorsLabel: {
        ...BaseTheme.typography.heading6,
        color: BaseTheme.palette.warning02,
        marginLeft: BaseTheme.spacing[2]
    }
};


################################################################################

## File: .\jitsi-meet\react\features\polls\actions.ts

import {
    CHANGE_VOTE,
    CLEAR_POLLS,
    EDIT_POLL,
    RECEIVE_ANSWER,
    RECEIVE_POLL,
    REGISTER_VOTE,
    REMOVE_POLL,
    RESET_NB_UNREAD_POLLS,
    SAVE_POLL
} from './actionTypes';
import { IAnswer, IPoll } from './types';

/**
 * Action to signal that existing polls needs to be cleared from state.
 *
 * @returns {{
 *     type: CLEAR_POLLS
 * }}
 */
export const clearPolls = () => {
    return {
        type: CLEAR_POLLS
    };
};

/**
 * Action to signal that a poll's vote will be changed.
 *
 * @param {string} pollId - The id of the incoming poll.
 * @param {boolean} value - The value of the 'changing' state.

 * @returns {{
 *     type: CHANGE_VOTE,
 *     pollId: string,
 *     value: boolean
 * }}
 */
export const setVoteChanging = (pollId: string, value: boolean) => {
    return {
        type: CHANGE_VOTE,
        pollId,
        value
    };
};

/**
 * Action to signal that a new poll was received.
 *
 * @param {string} pollId - The id of the incoming poll.
 * @param {IPoll} poll - The incoming Poll object.
 * @param {boolean} notify - Whether to send or not a notification.
 * @returns {{
 *     type: RECEIVE_POLL,
 *     pollId: string,
 *     poll: IPoll,
 *     notify: boolean
 * }}
 */
export const receivePoll = (pollId: string, poll: IPoll, notify: boolean) => {
    return {
        type: RECEIVE_POLL,
        pollId,
        poll,
        notify
    };
};

/**
 * Action to signal that a new answer was received.
 *
 * @param {string} pollId - The id of the incoming poll.
 * @param {IAnswer} answer - The incoming Answer object.
 * @returns {{
 *     type: RECEIVE_ANSWER,
 *     pollId: string,
 *     answer: IAnswer
 * }}
 */
export const receiveAnswer = (pollId: string, answer: IAnswer) => {
    return {
        type: RECEIVE_ANSWER,
        pollId,
        answer
    };
};

/**
 * Action to register a vote on a poll.
 *
 * @param {string} pollId - The id of the poll.
 * @param {?Array<boolean>} answers - The new answers.
 * @returns {{
 *     type: REGISTER_VOTE,
 *     pollId: string,
 *     answers: ?Array<boolean>
 * }}
 */
export const registerVote = (pollId: string, answers: Array<boolean> | null) => {
    return {
        type: REGISTER_VOTE,
        pollId,
        answers
    };
};

/**
 * Action to signal the number reset of unread polls.
 *
 * @returns {{
 *     type: RESET_NB_UNREAD_POLLS
 * }}
 */
export function resetNbUnreadPollsMessages() {
    return {
        type: RESET_NB_UNREAD_POLLS
    };
}

/**
 * Action to signal saving a poll.
 *
 * @param {string} pollId - The id of the poll that gets to be saved.
 * @param {IPoll} poll - The Poll object that gets to be saved.
 * @returns {{
 *     type: SAVE_POLL,
 *     meetingId: string,
 *     pollId: string,
 *     poll: IPoll
 * }}
 */
export function savePoll(pollId: string, poll: IPoll) {
    return {
        type: SAVE_POLL,
        pollId,
        poll
    };
}

/**
 * Action to signal editing a poll.
 *
 * @param {string} pollId - The id of the poll that gets to be edited.
 * @param {boolean} editing - Whether the poll is in edit mode or not.
 * @returns {{
 *     type: EDIT_POLL,
 *     pollId: string,
 *     editing: boolean
 * }}
 */
export function editPoll(pollId: string, editing: boolean) {
    return {
        type: EDIT_POLL,
        pollId,
        editing
    };
}

/**
 * Action to signal that existing polls needs to be removed.
 *
 * @param {string} pollId - The id of the poll that gets to be removed.
 * @param {IPoll} poll - The incoming Poll object.
 * @returns {{
 *     type: REMOVE_POLL,
 *     pollId: string,
 *     poll: IPoll
 * }}
 */
export const removePoll = (pollId: string, poll: IPoll) => {
    return {
        type: REMOVE_POLL,
        pollId,
        poll
    };
};


################################################################################

## File: .\jitsi-meet\react\features\polls\actionTypes.ts

/**
 * The type of the action which signals that a Poll will be changed
 *
 * {
 *     type: CHANGE_VOTE,
 * }
 *
 */
export const CHANGE_VOTE = 'CHANGE_VOTE';

/**
 * The type of the action which signals that we need to clear all polls from the state.
 * For example, we are moving to another conference.
 *
 * {
 *     type: CLEAR_POLLS
 * }
 */
export const CLEAR_POLLS = 'CLEAR_POLLS';

/**
 * The type of the action triggered when the poll is editing.
 *
 * {
 *     type: EDIT_POLL,
 *     pollId: string,
 *     editing: boolean
 * }
 */
export const EDIT_POLL = 'EDIT_POLL';

/**
 * The type of the action which signals that a new Poll was received.
 *
 * {
 *     type: RECEIVE_POLL,
 *     poll: Poll,
 *     pollId: string,
 *     notify: boolean
 * }
 *
 */
export const RECEIVE_POLL = 'RECEIVE_POLL';

/**
 * The type of the action which signals that a new Answer was received.
 *
 * {
 *     type: RECEIVE_ANSWER,
 *     answer: Answer,
 *     pollId: string,
 * }
 */
export const RECEIVE_ANSWER = 'RECEIVE_ANSWER';

/**
 * The type of the action which registers a vote.
 *
 * {
 *     type: REGISTER_VOTE,
 *     answers: Array<boolean> | null,
 *     pollId: string
 * }
 */
export const REGISTER_VOTE = 'REGISTER_VOTE';

/**
 * The type of the action which signals that we need to remove poll.
 *
 * {
 *     type: REMOVE_POLL,
 *     pollId: string,
 *     poll: IPoll
 * }
 */
export const REMOVE_POLL = 'REMOVE_POLL';

/**
 * The type of the action triggered when the poll tab in chat pane is closed
 *
 * {
 *     type: RESET_NB_UNREAD_POLLS,
 * }
 */
export const RESET_NB_UNREAD_POLLS = 'RESET_NB_UNREAD_POLLS';

/**
 * The type of the action triggered when the poll is saved.
 *
 * {
 *     type: SAVE_POLL,
 *     poll: Poll,
 *     pollId: string,
 *     saved: boolean
 * }
 */
export const SAVE_POLL = 'SAVE_POLL';


################################################################################

## File: .\jitsi-meet\react\features\polls\constants.ts

export const COMMAND_NEW_POLL = 'new-poll';
export const COMMAND_ANSWER_POLL = 'answer-poll';
export const COMMAND_OLD_POLLS = 'old-polls';

export const CHAR_LIMIT = 500;
export const ANSWERS_LIMIT = 255;


################################################################################

## File: .\jitsi-meet\react\features\polls\functions.ts

import { IReduxState } from '../app/types';

import { IAnswerData } from './types';

/**
 * Selector creator for determining if poll results should be displayed or not.
 *
 * @param {string} id - Id of the poll.
 * @returns {Function}
 */
export function shouldShowResults(id: string) {
    return function(state: IReduxState) {
        return Boolean(state['features/polls']?.polls[id].showResults);
    };
}

/**
 * Selector creator for polls.
 *
 * @param {string} pollId - Id of the poll to get.
 * @returns {Function}
 */
export function getPoll(pollId: string) {
    return function(state: IReduxState) {
        return state['features/polls'].polls[pollId];
    };
}

/**
 * Selector for calculating the number of unread poll messages.
 *
 * @param {IReduxState} state - The redux state.
 * @returns {number} The number of unread messages.
 */
export function getUnreadPollCount(state: IReduxState) {
    const { nbUnreadPolls } = state['features/polls'];

    return nbUnreadPolls;
}

/**
 * Determines if the submit poll answer button should be disabled.
 *
 * @param {Array<boolean>} checkBoxStates - The states of the checkboxes.
 * @returns {boolean}
 */
export function isSubmitAnswerDisabled(checkBoxStates: Array<boolean>) {
    return !checkBoxStates.find(checked => checked);
}

/**
 * Check if the input array has identical answers.
 *
 * @param {Array<IAnswerData>} currentAnswers - The array of current answers to compare.
 * @returns {boolean} - Returns true if the answers are identical.
 */
export function hasIdenticalAnswers(currentAnswers: Array<IAnswerData>): boolean {

    const nonEmptyCurrentAnswers = currentAnswers.filter((answer): boolean => answer.name !== '');

    const currentAnswersSet = new Set(nonEmptyCurrentAnswers.map(answer => answer.name));

    return currentAnswersSet.size !== nonEmptyCurrentAnswers.length;
}


################################################################################

## File: .\jitsi-meet\react\features\polls\middleware.ts

import { IStore } from '../app/types';
import { ENDPOINT_MESSAGE_RECEIVED, NON_PARTICIPANT_MESSAGE_RECEIVED } from '../base/conference/actionTypes';
import { getCurrentConference } from '../base/conference/functions';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import StateListenerRegistry from '../base/redux/StateListenerRegistry';
import { playSound } from '../base/sounds/actions';
import { INCOMING_MSG_SOUND_ID } from '../chat/constants';
import { arePollsDisabled } from '../conference/functions.any';
import { showNotification } from '../notifications/actions';
import { NOTIFICATION_TIMEOUT_TYPE, NOTIFICATION_TYPE } from '../notifications/constants';

import { RECEIVE_POLL } from './actionTypes';
import { clearPolls, receiveAnswer, receivePoll } from './actions';
import {
    COMMAND_ANSWER_POLL,
    COMMAND_NEW_POLL,
    COMMAND_OLD_POLLS
} from './constants';
import { IAnswer, IPoll, IPollData } from './types';

/**
 * Set up state change listener to perform maintenance tasks when the conference
 * is left or failed, e.g. Clear messages or close the chat modal if it's left
 * open.
 */
StateListenerRegistry.register(
    state => getCurrentConference(state),
    (conference, { dispatch }, previousConference): void => {
        if (conference !== previousConference) {
            dispatch(clearPolls());
        }
    });

const parsePollData = (pollData: IPollData): IPoll | null => {
    if (typeof pollData !== 'object' || pollData === null) {
        return null;
    }
    const { id, senderId, question, answers } = pollData;

    if (typeof id !== 'string' || typeof senderId !== 'string'
        || typeof question !== 'string' || !(answers instanceof Array)) {
        return null;
    }

    return {
        changingVote: false,
        senderId,
        question,
        showResults: true,
        lastVote: null,
        answers,
        saved: false,
        editing: false
    };
};

MiddlewareRegistry.register(({ dispatch, getState }) => next => action => {
    const result = next(action);

    switch (action.type) {
    case ENDPOINT_MESSAGE_RECEIVED: {
        const { participant, data } = action;
        const isNewPoll = data.type === COMMAND_NEW_POLL;

        _handleReceivePollsMessage({
            ...data,
            senderId: isNewPoll ? participant.getId() : undefined,
            voterId: isNewPoll ? undefined : participant.getId()
        }, dispatch, getState);

        break;
    }

    case NON_PARTICIPANT_MESSAGE_RECEIVED: {
        const { id, json: data } = action;
        const isNewPoll = data.type === COMMAND_NEW_POLL;

        _handleReceivePollsMessage({
            ...data,
            senderId: isNewPoll ? id : undefined,
            voterId: isNewPoll ? undefined : id
        }, dispatch, getState);
        break;
    }

    case RECEIVE_POLL: {
        const state = getState();

        if (arePollsDisabled(state)) {
            break;
        }

        const isChatOpen: boolean = state['features/chat'].isOpen;
        const isPollsTabFocused: boolean = state['features/chat'].isPollsTabFocused;

        // Finally, we notify user they received a new poll if their pane is not opened
        if (action.notify && (!isChatOpen || !isPollsTabFocused)) {
            dispatch(playSound(INCOMING_MSG_SOUND_ID));
        }
        break;
    }
    }

    return result;
});

/**
 * Handles receiving of polls message command.
 *
 * @param {Object} data - The json data carried by the polls message.
 * @param {Function} dispatch - The dispatch function.
 * @param {Function} getState - The getState function.
 *
 * @returns {void}
 */
function _handleReceivePollsMessage(data: any, dispatch: IStore['dispatch'], getState: IStore['getState']) {
    if (arePollsDisabled(getState())) {
        return;
    }

    switch (data.type) {

    case COMMAND_NEW_POLL: {
        const { pollId, answers, senderId, question } = data;

        const poll = {
            changingVote: false,
            senderId,
            showResults: false,
            lastVote: null,
            question,
            answers: answers.map((answer: string) => {
                return {
                    name: answer,
                    voters: []
                };
            }),
            saved: false,
            editing: false
        };

        dispatch(receivePoll(pollId, poll, true));
        dispatch(showNotification({
            appearance: NOTIFICATION_TYPE.NORMAL,
            titleKey: 'polls.notification.title',
            descriptionKey: 'polls.notification.description'
        }, NOTIFICATION_TIMEOUT_TYPE.MEDIUM));
        break;

    }

    case COMMAND_ANSWER_POLL: {
        const { pollId, answers, voterId } = data;

        const receivedAnswer: IAnswer = {
            voterId,
            pollId,
            answers
        };

        dispatch(receiveAnswer(pollId, receivedAnswer));
        break;

    }

    case COMMAND_OLD_POLLS: {
        const { polls } = data;

        for (const pollData of polls) {
            const poll = parsePollData(pollData);

            if (poll === null) {
                console.warn('[features/polls] Invalid old poll data');
            } else {
                dispatch(receivePoll(pollData.id, poll, false));
            }
        }
        break;
    }
    }
}


################################################################################

## File: .\jitsi-meet\react\features\polls\reducer.ts

import ReducerRegistry from '../base/redux/ReducerRegistry';

import {
    CHANGE_VOTE,
    CLEAR_POLLS,
    EDIT_POLL,
    RECEIVE_ANSWER,
    RECEIVE_POLL,
    REGISTER_VOTE,
    REMOVE_POLL,
    RESET_NB_UNREAD_POLLS,
    SAVE_POLL
} from './actionTypes';
import { IAnswer, IPoll } from './types';

const INITIAL_STATE = {
    polls: {},

    // Number of not read message
    nbUnreadPolls: 0
};

export interface IPollsState {
    nbUnreadPolls: number;
    polls: {
        [pollId: string]: IPoll;
    };
}

const STORE_NAME = 'features/polls';

ReducerRegistry.register<IPollsState>(STORE_NAME, (state = INITIAL_STATE, action): IPollsState => {
    switch (action.type) {

    case CHANGE_VOTE: {
        const { pollId, value } = action;

        return {
            ...state,
            polls: {
                ...state.polls,
                [pollId]: {
                    ...state.polls[pollId],
                    changingVote: value,
                    showResults: !value
                }
            }
        };
    }

    case CLEAR_POLLS: {
        return {
            ...state,
            ...INITIAL_STATE
        };
    }

    // Reducer triggered when a poll is received or saved.
    case RECEIVE_POLL: {
        return {
            ...state,
            polls: {
                ...state.polls,
                [action.pollId]: action.poll
            },
            nbUnreadPolls: state.nbUnreadPolls + 1
        };
    }

    case SAVE_POLL: {
        return {
            ...state,
            polls: {
                ...state.polls,
                [action.pollId]: action.poll
            }
        };
    }

    // Reducer triggered when an answer is received
    // The answer is added  to an existing poll
    case RECEIVE_ANSWER: {

        const { pollId, answer }: { answer: IAnswer; pollId: string; } = action;

        // if the poll doesn't exist
        if (!(pollId in state.polls)) {
            console.warn('requested poll does not exist: pollId ', pollId);

            return state;
        }

        // if the poll exists, we update it with the incoming answer
        const newAnswers = state.polls[pollId].answers
            .map(_answer => {
                // checking if the voters is an array for supporting old structure model
                const answerVoters = _answer.voters
                    ? _answer.voters.length
                        ? [ ..._answer.voters ] : Object.keys(_answer.voters) : [];

                return {
                    name: _answer.name,
                    voters: answerVoters
                };
            });


        for (let i = 0; i < newAnswers.length; i++) {
            // if the answer was chosen, we add the senderId to the array of voters of this answer
            const voters = newAnswers[i].voters as any;

            const index = voters.indexOf(answer.voterId);

            if (answer.answers[i]) {
                if (index === -1) {
                    voters.push(answer.voterId);
                }
            } else if (index > -1) {
                voters.splice(index, 1);
            }
        }

        // finally we update the state by returning the updated poll
        return {
            ...state,
            polls: {
                ...state.polls,
                [pollId]: {
                    ...state.polls[pollId],
                    answers: newAnswers
                }
            }
        };
    }

    case REGISTER_VOTE: {
        const { answers, pollId }: { answers: Array<boolean> | null; pollId: string; } = action;

        return {
            ...state,
            polls: {
                ...state.polls,
                [pollId]: {
                    ...state.polls[pollId],
                    changingVote: false,
                    lastVote: answers,
                    showResults: true
                }
            }
        };
    }

    case RESET_NB_UNREAD_POLLS: {
        return {
            ...state,
            nbUnreadPolls: 0
        };
    }

    case EDIT_POLL: {
        return {
            ...state,
            polls: {
                ...state.polls,
                [action.pollId]: {
                    ...state.polls[action.pollId],
                    editing: action.editing
                }
            }
        };
    }

    case REMOVE_POLL: {
        if (Object.keys(state.polls ?? {})?.length === 1) {
            return {
                ...state,
                ...INITIAL_STATE
            };
        }

        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const { [action.pollId]: _removedPoll, ...newState } = state.polls;

        return {
            ...state,
            polls: {
                ...newState
            }
        };
    }

    default:
        return state;
    }
});


################################################################################

## File: .\jitsi-meet\react\features\polls\types.ts

export interface IAnswer {

    /**
     * An array of boolean: true if the answer was chosen by the responder, else false.
     */
    answers: Array<boolean>;

    /**
     * ID of the parent Poll of this answer.
     */
    pollId: string;

    /**
     * ID of the voter for this answer.
     */
    voterId: string;

    /**
     * Name of the voter for this answer.
     */
    voterName?: string;
}

export interface IPoll {

    /**
     * An array of answers:
     * the name of the answer name and a map of ids and names of voters voting for this option.
     */
    answers: Array<IAnswerData>;

    /**
     * Whether the poll vote is being edited/changed.
     */
    changingVote: boolean;

    /**
     * Whether poll is in edit mode or not?.
     */
    editing: boolean;

    /**
     * The last sent votes for this poll, or null if voting was skipped
     * Note: This is reset when voting/skipping, not when clicking "Change vote".
     */
    lastVote: Array<boolean> | null;

    /**
     * The question asked by this poll.
     */
    question: string;

    /**
     * Whether poll is saved or not?.
     */
    saved: boolean;

    /**
     * ID of the sender of this poll.
     */
    senderId: string | undefined;

    /**
     * Whether the results should be shown instead of the answer form.
     */
    showResults: boolean;
}

export interface IPollData extends IPoll {
    id: string;
}

export interface IAnswerData {

    /**
     * The answer name chosen for the poll.
     */
    name: string;

    /**
     * An array of voters.
     */
    voters: Array<string>;
}


################################################################################

## File: .\jitsi-meet\react\features\polls\components\native\styles.ts

import { createStyleSheet } from '../../../base/styles/functions.native';
import BaseTheme from '../../../base/ui/components/BaseTheme.native';


export const dialogStyles = createStyleSheet({

    headerContainer: {
        display: 'flex',
        flexDirection: 'row',
        justifyContent: 'space-between'
    },

    customContainer: {
        marginBottom: BaseTheme.spacing[3],
        marginHorizontal: BaseTheme.spacing[3],
        marginTop: BaseTheme.spacing[2]
    },

    questionText: {
        ...BaseTheme.typography.bodyShortBold,
        color: BaseTheme.palette.text01,
        marginLeft: BaseTheme.spacing[1]
    },

    questionOwnerText: {
        ...BaseTheme.typography.bodyShortBold,
        color: BaseTheme.palette.text03,
        marginBottom: BaseTheme.spacing[2],
        marginLeft: BaseTheme.spacing[1]
    },

    optionContainer: {
        flexDirection: 'column',
        marginTop: BaseTheme.spacing[3],
        marginHorizontal: BaseTheme.spacing[3]
    },

    optionRemoveButton: {
        width: 128
    },

    optionRemoveButtonText: {
        color: BaseTheme.palette.link01
    },

    field: {
        borderWidth: 1,
        borderColor: BaseTheme.palette.ui06,
        borderRadius: BaseTheme.shape.borderRadius,
        color: BaseTheme.palette.text01,
        fontSize: 14,
        paddingBottom: BaseTheme.spacing[2],
        paddingLeft: BaseTheme.spacing[3],
        paddingRight: BaseTheme.spacing[3],
        paddingTop: BaseTheme.spacing[2]
    }
});

export const resultsStyles = createStyleSheet({

    title: {
        fontSize: 24,
        fontWeight: 'bold'
    },

    barContainer: {
        backgroundColor: '#ccc',
        borderRadius: 3,
        width: '100%',
        height: 6,
        marginTop: 2
    },

    bar: {
        backgroundColor: BaseTheme.palette.action01,
        borderRadius: BaseTheme.shape.borderRadius,
        height: 6
    },

    voters: {
        backgroundColor: BaseTheme.palette.ui04,
        borderColor: BaseTheme.palette.ui03,
        borderRadius: BaseTheme.shape.borderRadius,
        borderWidth: 1,
        padding: BaseTheme.spacing[2],
        marginTop: BaseTheme.spacing[2]
    },

    voter: {
        color: BaseTheme.palette.text01
    },

    answerContainer: {
        marginHorizontal: BaseTheme.spacing[1],
        marginVertical: BaseTheme.spacing[3],
        maxWidth: '100%'
    },

    answerHeader: {
        flexDirection: 'row',
        justifyContent: 'space-between'
    },

    answer: {
        color: BaseTheme.palette.text01,
        flexShrink: 1
    },

    answerVoteCount: {
        paddingLeft: 10
    },

    chatQuestion: {
        fontWeight: 'bold'
    }
});

export const pollsStyles = createStyleSheet({

    noPollContent: {
        alignItems: 'center',
        justifyContent: 'center',
        position: 'absolute',
        bottom: 0,
        left: 0,
        right: 0,
        top: '25%'
    },

    noPollText: {
        flex: 1,
        color: BaseTheme.palette.text03,
        textAlign: 'center',
        maxWidth: '70%'
    },

    pollItemContainer: {
        backgroundColor: BaseTheme.palette.uiBackground,
        borderColor: BaseTheme.palette.ui06,
        borderRadius: BaseTheme.shape.borderRadius,
        boxShadow: BaseTheme.shape.boxShadow,
        borderWidth: 1,
        padding: BaseTheme.spacing[2],
        margin: BaseTheme.spacing[3]
    },

    pollCreateContainer: {
        flex: 1
    },

    pollCreateSubContainer: {
        flex: 1,
        marginTop: BaseTheme.spacing[3]
    },

    pollCreateButtonsContainerAndroid: {
        marginBottom: BaseTheme.spacing[8],
        marginHorizontal: BaseTheme.spacing[3]
    },

    pollCreateButtonsContainerIos: {
        marginBottom: BaseTheme.spacing[5],
        marginHorizontal: BaseTheme.spacing[3]
    },

    pollSendLabel: {
        color: BaseTheme.palette.text01,
        textTransform: 'capitalize'
    },

    pollSendDisabledLabel: {
        color: BaseTheme.palette.text03,
        textTransform: 'capitalize'
    },

    buttonRow: {
        flexDirection: 'row',
        justifyContent: 'space-between'
    },

    answerContent: {
        marginBottom: BaseTheme.spacing[2]
    },

    switchRow: {
        alignItems: 'center',
        flexDirection: 'row',
        padding: BaseTheme.spacing[2]
    },

    switchLabel: {
        color: BaseTheme.palette.text01,
        marginLeft: BaseTheme.spacing[2]
    },

    pollCreateAddButton: {
        marginHorizontal: BaseTheme.spacing[1],
        marginVertical: BaseTheme.spacing[2]
    },

    pollCreateButton: {
        marginHorizontal: BaseTheme.spacing[1],
        flex: 1
    },

    toggleText: {
        color: BaseTheme.palette.action01
    },

    createPollButtonIos: {
        marginHorizontal: 20,
        marginVertical: BaseTheme.spacing[5]
    },

    createPollButtonAndroid: {
        marginHorizontal: 20,
        marginVertical: BaseTheme.spacing[5]
    },

    pollPane: {
        flex: 1,
        padding: BaseTheme.spacing[2]
    },

    pollPaneContainer: {
        backgroundColor: BaseTheme.palette.ui01,
        flex: 1
    },

    bottomLinks: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        marginHorizontal: BaseTheme.spacing[1]
    },

    fieldSeparator: {
        borderBottomWidth: 1,
        borderColor: BaseTheme.palette.ui05,
        marginTop: BaseTheme.spacing[3]
    }
});


################################################################################

## File: .\jitsi-meet\react\features\polls-history\actions.ts

import { IPoll } from '../polls/types';

import { REMOVE_POLL_FROM_HISTORY, SAVE_POLL_IN_HISTORY } from './actionTypes';

/**
 * Action to signal saving a poll in history(local storage).
 *
 * @param {string} meetingId - The id of the meeting in which polls get to be saved.
 * @param {string} pollId - The id of the poll that gets to be saved.
 * @param {IPoll} poll - The Poll object that gets to be saved.
 * @returns {{
 *     type: SAVE_POLL_IN_HISTORY,
 *     meetingId: string,
 *     pollId: string,
 *     poll: IPoll
 * }}
 */
export function savePollInHistory(meetingId: string | undefined, pollId: string, poll: IPoll) {
    return {
        type: SAVE_POLL_IN_HISTORY,
        meetingId,
        pollId,
        poll
    };
}

/**
 * Action to signal that existing poll needs to be deleted from history(local storage).
 *
 * @param {string} meetingId - The id of the meeting in which poll gets to be removed.
 * @param {string} pollId - The id of the poll that gets to be removed.
 * @param {IPoll} poll - The incoming IPoll object.
 * @returns {{
 *     type: REMOVE_POLL_FROM_HISTORY,
 *     meetingId: string,
 *     pollId: string,
 *     poll: IPoll
 * }}
 */
export const removePollFromHistory = (meetingId: string | undefined, pollId: string, poll: IPoll) => {
    return {
        type: REMOVE_POLL_FROM_HISTORY,
        meetingId,
        pollId,
        poll
    };
};


################################################################################

## File: .\jitsi-meet\react\features\polls-history\actionTypes.ts

/**
 * The type of the action which signals that we need to remove poll from the history(local storage).
 *
 * {
 *     type: REMOVE_POLL_FROM_HISTORY,
 *     meetingId: string,
 *     pollId: string,
 *     poll: IPoll
 * }
 */
export const REMOVE_POLL_FROM_HISTORY = 'REMOVE_POLL_FROM_HISTORY';

/**
 * The type of the action triggered when the poll is saved in history(local storage).
 *
 * {
 *     type: SAVE_POLL_IN_HISTORY,
 *     poll: Poll,
 *     pollId: string,
 *     saved: boolean
 * }
 */
export const SAVE_POLL_IN_HISTORY = 'SAVE_POLL_IN_HISTORY';


################################################################################

## File: .\jitsi-meet\react\features\polls-history\middleware.ts

import { CONFERENCE_JOINED } from '../base/conference/actionTypes';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import { REMOVE_POLL, SAVE_POLL } from '../polls/actionTypes';
import { savePoll } from '../polls/actions';

import { removePollFromHistory, savePollInHistory } from './actions';

MiddlewareRegistry.register(({ dispatch, getState }) => next => action => {
    const result = next(action);
    const { room: meetingId } = getState()['features/base/conference'];

    switch (action.type) {

    case CONFERENCE_JOINED: {
        const state = getState();
        const pollsHistory = meetingId && state['features/polls-history'].polls?.[meetingId];

        if (!pollsHistory) {
            return null;
        }

        for (const key in pollsHistory) {
            if (pollsHistory.hasOwnProperty(key) && pollsHistory[key].saved) {
                dispatch(savePoll(key, pollsHistory[key]));
            }
        }
        break;
    }

    case REMOVE_POLL: {
        const { poll, pollId } = action;

        dispatch(removePollFromHistory(meetingId, pollId, poll));
        break;
    }

    case SAVE_POLL: {
        const { poll, pollId } = action;

        dispatch(savePollInHistory(meetingId, pollId, poll));
        break;
    }
    }

    return result;
});


################################################################################

## File: .\jitsi-meet\react\features\polls-history\reducer.ts

import PersistenceRegistry from '../base/redux/PersistenceRegistry';
import ReducerRegistry from '../base/redux/ReducerRegistry';
import { IPoll } from '../polls/types';

import { REMOVE_POLL_FROM_HISTORY, SAVE_POLL_IN_HISTORY } from './actionTypes';

const INITIAL_STATE = {
    polls: {}
};

export interface IPollsHistoryState {
    polls: {
        [meetingId: string]: {
            [pollId: string]: IPoll;
        };
    };
}

const STORE_NAME = 'features/polls-history';

PersistenceRegistry.register(STORE_NAME, INITIAL_STATE);

ReducerRegistry.register<IPollsHistoryState>(STORE_NAME, (state = INITIAL_STATE, action): IPollsHistoryState => {
    switch (action.type) {

    case REMOVE_POLL_FROM_HISTORY: {
        if (Object.keys(state.polls[action.meetingId] ?? {})?.length === 1) {
            delete state.polls[action.meetingId];
        } else {
            delete state.polls[action.meetingId]?.[action.pollId];
        }

        return state;
    }

    case SAVE_POLL_IN_HISTORY: {
        return {
            ...state,
            polls: {
                ...state.polls,
                [action.meetingId]: {
                    ...state.polls[action.meetingId],
                    [action.pollId]: action.poll
                }
            }
        };
    }

    default:
        return state;
    }
});


################################################################################

## File: .\jitsi-meet\react\features\power-monitor\actions.ts

// @ts-expect-error
import { Transport } from '../../../modules/transport';

import {
    SET_TRANSPORT,
    SUSPEND_DETECTED
} from './actionTypes';

/**
 * Signals that suspend was detected.
 *
 * @public
 * @returns {{
 *     type: SUSPEND_DETECTED
 * }}
 */
export function suspendDetected() {
    return {
        type: SUSPEND_DETECTED
    };
}

/**
 * Signals setting of a transport.
 *
 * @param {Transport} transport - The transport to save in the state.
 * @returns {{
 *      transport: Transport,
 *      type: string
 *  }}
 */
export function setTransport(transport?: Transport) {
    return {
        type: SET_TRANSPORT,
        transport
    };
}


################################################################################

## File: .\jitsi-meet\react\features\power-monitor\actionTypes.ts

/**
 * The type of the Redux action which signals that a suspend was detected.
 *
 * {
 *     type: SUSPEND_DETECTED
 * }
 * @public
 */
export const SUSPEND_DETECTED = 'SUSPEND_DETECTED';

/**
 * The type of the Redux action which signals that a transport needs to be stored.
 *
 * {
 *     type: SET_TRANSPORT
 * }
 * @public
 */
export const SET_TRANSPORT = 'SET_TRANSPORT';


################################################################################

## File: .\jitsi-meet\react\features\power-monitor\middleware.ts

// @ts-expect-error
import { PostMessageTransportBackend, Transport } from '../../../modules/transport';
import {
    CONFERENCE_JOINED,
    CONFERENCE_LEFT
} from '../base/conference/actionTypes';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import { destroyLocalTracks } from '../base/tracks/actions';

import { SUSPEND_DETECTED } from './actionTypes';
import {
    setTransport,
    suspendDetected
} from './actions';

MiddlewareRegistry.register(store => next => action => {
    const result = next(action);
    const { dispatch, getState } = store;

    switch (action.type) {
    case CONFERENCE_JOINED: {

        // listens for messages about suspend from power-monitor
        const transport = new Transport({
            backend: new PostMessageTransportBackend({
                postisOptions: { scope: 'jitsi-power-monitor' }
            })
        });

        transport.on('event', (event: { event: string; name: string; }) => {
            if (event && event.name === 'power-monitor' && event.event === 'suspend') {

                dispatch(suspendDetected());

                return true;
            }

            return false;
        });

        dispatch(setTransport(transport));
        break;
    }

    case CONFERENCE_LEFT: {
        const { transport } = getState()['features/power-monitor'];

        if (transport) {
            transport.dispose();
        }

        dispatch(setTransport());
        break;
    }

    case SUSPEND_DETECTED: {
        dispatch(destroyLocalTracks());

        // FIXME: when refactoring conference.js
        APP.conference.onSuspendDetected();

        APP.API.notifySuspendDetected();
        break;
    }
    }

    return result;
});


################################################################################

## File: .\jitsi-meet\react\features\power-monitor\reducer.ts

// @ts-expect-error
import { Transport } from '../../../modules/transport';
import ReducerRegistry from '../base/redux/ReducerRegistry';
import { set } from '../base/redux/functions';

import {
    SET_TRANSPORT,
    SUSPEND_DETECTED
} from './actionTypes';

export interface IPowerMonitorState {
    suspendDetected?: boolean;
    transport?: Transport;
}

/**
 * Reduces the redux actions of the feature power monitor.
 */
ReducerRegistry.register<IPowerMonitorState>('features/power-monitor', (state = {}, action): IPowerMonitorState => {
    switch (action.type) {
    case SET_TRANSPORT:
        return _setTransport(state, action.transport);

    case SUSPEND_DETECTED:
        return _suspendDetected(state);

    }

    return state;
});

/**
 * Reduces a specific redux action SET_TRANSPORT of the feature power monitor.
 *
 * @param {Object} state - The redux state of the feature power monitor.
 * @param {?Transport} transport - The transport to store in state.
 * @private
 * @returns {Object} The new state of the feature power monitor after the reduction of
 * the specified action.
 */
function _setTransport(state: IPowerMonitorState, transport?: Transport) {
    return set(state, 'transport', transport);
}

/**
 * Reduces a specific redux action SUSPEND_DETECTED of the feature overlay.
 *
 * @param {Object} state - The redux state of the feature overlay.
 * @private
 * @returns {Object} The new state of the feature overlay after the reduction of
 * the specified action.
 */
function _suspendDetected(state: IPowerMonitorState) {
    return set(state, 'suspendDetected', true);
}



################################################################################

## File: .\jitsi-meet\react\features\prejoin\actions.native.ts

import { IStore } from '../app/types';
import { connect } from '../base/connection/actions.native';
import { navigateRoot } from '../mobile/navigation/rootNavigationContainerRef';
import { screen } from '../mobile/navigation/routes';
import { showVisitorsQueue } from '../visitors/functions';

/**
 * Action used to start the conference.
 *
 * @param {Object} options - The config options that override the default ones (if any).
 * @param {boolean} _ignoreJoiningInProgress - If true we won't check the joiningInProgress flag.
 * @returns {Function}
 */
export function joinConference(options?: Object, _ignoreJoiningInProgress = false) {
    return async function(dispatch: IStore['dispatch'], getState: IStore['getState']) {
        const _showVisitorsQueue = showVisitorsQueue(getState);

        if (_showVisitorsQueue) {
            dispatch(connect());
            navigateRoot(screen.conference.root);
        }
    };
}


################################################################################

## File: .\jitsi-meet\react\features\prejoin\actions.web.ts

import { v4 as uuidv4 } from 'uuid';

import { IStore } from '../app/types';
import { updateConfig } from '../base/config/actions';
import { getDialOutStatusUrl, getDialOutUrl } from '../base/config/functions';
import { connect } from '../base/connection/actions';
import { createLocalTrack } from '../base/lib-jitsi-meet/functions';
import { isVideoMutedByUser } from '../base/media/functions';
import { updateSettings } from '../base/settings/actions';
import { replaceLocalTrack } from '../base/tracks/actions';
import {
    createLocalTracksF,
    getLocalAudioTrack,
    getLocalVideoTrack
} from '../base/tracks/functions';
import { openURLInBrowser } from '../base/util/openURLInBrowser';
import { executeDialOutRequest, executeDialOutStatusRequest, getDialInfoPageURL } from '../invite/functions';
import { showErrorNotification } from '../notifications/actions';
import { NOTIFICATION_TIMEOUT_TYPE } from '../notifications/constants';
import { INotificationProps } from '../notifications/types';

import {
    PREJOIN_JOINING_IN_PROGRESS,
    SET_DEVICE_STATUS,
    SET_DIALOUT_COUNTRY,
    SET_DIALOUT_NUMBER,
    SET_DIALOUT_STATUS,
    SET_JOIN_BY_PHONE_DIALOG_VISIBLITY,
    SET_PREJOIN_DEVICE_ERRORS,
    SET_PREJOIN_PAGE_VISIBILITY,
    SET_SKIP_PREJOIN_RELOAD
} from './actionTypes';
import {
    getDialOutConferenceUrl,
    getDialOutCountry,
    getFullDialOutNumber,
    isJoinByPhoneDialogVisible
} from './functions.any';
import logger from './logger';

const dialOutStatusToKeyMap = {
    INITIATED: 'presenceStatus.calling',
    RINGING: 'presenceStatus.ringing'
};

const DIAL_OUT_STATUS = {
    INITIATED: 'INITIATED',
    RINGING: 'RINGING',
    CONNECTED: 'CONNECTED',
    DISCONNECTED: 'DISCONNECTED',
    FAILED: 'FAILED'
};

/**
 * The time interval used between requests while polling for dial out status.
 */
const STATUS_REQ_FREQUENCY = 2000;

/**
 * The maximum number of retries while polling for dial out status.
 */
const STATUS_REQ_CAP = 45;

/**
 * Polls for status change after dial out.
 * Changes dialog message based on response, closes the dialog if there is an error,
 * joins the meeting when CONNECTED.
 *
 * @param {string} reqId - The request id used to correlate the dial out request with this one.
 * @param {Function} onSuccess - Success handler.
 * @param {Function} onFail - Fail handler.
 * @param {number} count - The number of retried calls. When it hits STATUS_REQ_CAP it should no longer make requests.
 * @returns {Function}
 */
function pollForStatus(
        reqId: string,
        onSuccess: Function,
        onFail: Function,
        count = 0) {
    return async function(dispatch: IStore['dispatch'], getState: IStore['getState']) {
        const state = getState();

        try {
            if (!isJoinByPhoneDialogVisible(state)) {
                return;
            }

            const res = await executeDialOutStatusRequest(getDialOutStatusUrl(state) ?? '', reqId);

            switch (res) {
            case DIAL_OUT_STATUS.INITIATED:
            case DIAL_OUT_STATUS.RINGING: {
                dispatch(setDialOutStatus(dialOutStatusToKeyMap[res as keyof typeof dialOutStatusToKeyMap]));

                if (count < STATUS_REQ_CAP) {
                    return setTimeout(() => {
                        dispatch(pollForStatus(reqId, onSuccess, onFail, count + 1));
                    }, STATUS_REQ_FREQUENCY);
                }

                return onFail();
            }

            case DIAL_OUT_STATUS.CONNECTED: {
                return onSuccess();
            }

            case DIAL_OUT_STATUS.DISCONNECTED: {
                dispatch(showErrorNotification({
                    titleKey: 'prejoin.errorDialOutDisconnected'
                }, NOTIFICATION_TIMEOUT_TYPE.LONG));

                return onFail();
            }

            case DIAL_OUT_STATUS.FAILED: {
                dispatch(showErrorNotification({
                    titleKey: 'prejoin.errorDialOutFailed'
                }, NOTIFICATION_TIMEOUT_TYPE.LONG));

                return onFail();
            }
            }
        } catch (err) {
            dispatch(showErrorNotification({
                titleKey: 'prejoin.errorDialOutStatus'
            }, NOTIFICATION_TIMEOUT_TYPE.LONG));
            logger.error('Error getting dial out status', err);
            onFail();
        }
    };
}


/**
 * Action used for joining the meeting with phone audio.
 * A dial out connection is tried and a polling mechanism is used for getting the status.
 * If the connection succeeds the `onSuccess` callback is executed.
 * If the phone connection fails or the number is invalid the `onFail` callback is executed.
 *
 * @param {Function} onSuccess - Success handler.
 * @param {Function} onFail - Fail handler.
 * @returns {Function}
 */
export function dialOut(onSuccess: Function, onFail: Function) {
    return async function(dispatch: IStore['dispatch'], getState: IStore['getState']) {
        const state = getState();
        const reqId = uuidv4();
        const url = getDialOutUrl(state) ?? '';
        const conferenceUrl = getDialOutConferenceUrl(state);
        const phoneNumber = getFullDialOutNumber(state);
        const countryCode = getDialOutCountry(state).code.toUpperCase();

        const body = {
            conferenceUrl,
            countryCode,
            name: phoneNumber,
            phoneNumber
        };

        try {
            await executeDialOutRequest(url, body, reqId);

            dispatch(pollForStatus(reqId, onSuccess, onFail));
        } catch (err: any) {
            const notification: INotificationProps = {
                titleKey: 'prejoin.errorDialOut',
                titleArguments: undefined
            };

            if (err.status) {
                if (err.messageKey === 'validation.failed') {
                    notification.titleKey = 'prejoin.errorValidation';
                } else {
                    notification.titleKey = 'prejoin.errorStatusCode';
                    notification.titleArguments = { status: err.status };
                }
            }

            dispatch(showErrorNotification(notification, NOTIFICATION_TIMEOUT_TYPE.LONG));
            logger.error('Error dialing out', err);
            onFail();
        }
    };
}

/**
 * Action used to start the conference.
 *
 * @param {Object} options - The config options that override the default ones (if any).
 * @param {boolean} ignoreJoiningInProgress - If true we won't check the joiningInProgress flag.
 * @param {string?} jid - The XMPP user's ID (e.g. {@code user@server.com}).
 * @param {string?} password - The XMPP user's password.
 * @returns {Function}
 */
export function joinConference(options?: Object, ignoreJoiningInProgress = false,
        jid?: string, password?: string) {
    return function(dispatch: IStore['dispatch'], getState: IStore['getState']) {
        if (!ignoreJoiningInProgress) {
            const state = getState();
            const { joiningInProgress } = state['features/prejoin'];

            if (joiningInProgress) {
                return;
            }

            dispatch(setJoiningInProgress(true));
        }

        options && dispatch(updateConfig(options));

        logger.info('Dispatching connect from joinConference.');
        dispatch(connect(jid, password))
        .catch(() => {
            // There is nothing to do here. This is handled and dispatched in base/connection/actions.
        });
    };
}


/**
 * Action used to set the flag for joining operation in progress.
 *
 * @param {boolean} value - The config options that override the default ones (if any).
 * @returns {Function}
 */
export function setJoiningInProgress(value: boolean) {
    return {
        type: PREJOIN_JOINING_IN_PROGRESS,
        value
    };
}


/**
 * Joins the conference without audio.
 *
 * @returns {Function}
 */
export function joinConferenceWithoutAudio() {
    return async function(dispatch: IStore['dispatch'], getState: IStore['getState']) {
        const state = getState();
        const { joiningInProgress } = state['features/prejoin'];

        if (joiningInProgress) {
            return;
        }

        dispatch(setJoiningInProgress(true));
        const tracks = state['features/base/tracks'];
        const audioTrack = getLocalAudioTrack(tracks)?.jitsiTrack;

        if (audioTrack) {
            try {
                await dispatch(replaceLocalTrack(audioTrack, null));
            } catch (error) {
                logger.error(`Failed to replace local audio with null: ${error}`);
            }
        }

        logger.info('Dispatching joinConference action with startSilent=true from joinConferenceWithoutAudio.');

        dispatch(joinConference({
            startSilent: true
        }, true));
    };
}

/**
 * Opens an external page with all the dial in numbers.
 *
 * @returns {Function}
 */
export function openDialInPage() {
    return function(dispatch: IStore['dispatch'], getState: IStore['getState']) {
        const dialInPage = getDialInfoPageURL(getState());

        openURLInBrowser(dialInPage, true);
    };
}

/**
 * Creates a new audio track based on a device id and replaces the current one.
 *
 * @param {string} deviceId - The deviceId of the microphone.
 * @returns {Function}
 */
export function replaceAudioTrackById(deviceId: string) {
    return async (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        try {
            const tracks = getState()['features/base/tracks'];
            const newTrack = await createLocalTrack('audio', deviceId);
            const oldTrack = getLocalAudioTrack(tracks)?.jitsiTrack;
            const micDeviceId = newTrack.getDeviceId();

            logger.info(`Switching audio input device to ${micDeviceId}`);
            dispatch(replaceLocalTrack(oldTrack, newTrack)).then(() => {
                dispatch(updateSettings({
                    micDeviceId
                }));
            });
        } catch (err) {
            dispatch(setDeviceStatusWarning('prejoin.audioTrackError'));
            logger.log('Error replacing audio track', err);
        }
    };
}

/**
 * Creates a new video track based on a device id and replaces the current one.
 *
 * @param {string} deviceId - The deviceId of the camera.
 * @returns {Function}
 */
export function replaceVideoTrackById(deviceId: string) {
    return async (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        try {
            const tracks = getState()['features/base/tracks'];
            const wasVideoMuted = isVideoMutedByUser(getState());
            const [ newTrack ] = await createLocalTracksF(
                { cameraDeviceId: deviceId,
                    devices: [ 'video' ] },
                { dispatch,
                    getState }
            );
            const oldTrack = getLocalVideoTrack(tracks)?.jitsiTrack;
            const cameraDeviceId = newTrack.getDeviceId();

            logger.info(`Switching camera to ${cameraDeviceId}`);
            dispatch(replaceLocalTrack(oldTrack, newTrack)).then(() => {
                dispatch(updateSettings({
                    cameraDeviceId
                }));
            });
            wasVideoMuted && newTrack.mute();
        } catch (err) {
            dispatch(setDeviceStatusWarning('prejoin.videoTrackError'));
            logger.log('Error replacing video track', err);
        }
    };
}

/**
 * Sets the device status as OK with the corresponding text.
 *
 * @param {string} deviceStatusText - The text to be set.
 * @returns {Object}
 */
export function setDeviceStatusOk(deviceStatusText: string) {
    return {
        type: SET_DEVICE_STATUS,
        value: {
            deviceStatusText,
            deviceStatusType: 'ok'
        }
    };
}

/**
 * Sets the device status as 'warning' with the corresponding text.
 *
 * @param {string} deviceStatusText - The text to be set.
 * @returns {Object}
 */
export function setDeviceStatusWarning(deviceStatusText: string) {
    return {
        type: SET_DEVICE_STATUS,
        value: {
            deviceStatusText,
            deviceStatusType: 'warning'
        }
    };
}

/**
 * Action used to set the dial out status.
 *
 * @param {string} value - The status.
 * @returns {Object}
 */
function setDialOutStatus(value: string) {
    return {
        type: SET_DIALOUT_STATUS,
        value
    };
}

/**
 * Action used to set the dial out country.
 *
 * @param {{ name: string, dialCode: string, code: string }} value - The country.
 * @returns {Object}
 */
export function setDialOutCountry(value: Object) {
    return {
        type: SET_DIALOUT_COUNTRY,
        value
    };
}

/**
 * Action used to set the dial out number.
 *
 * @param {string} value - The dial out number.
 * @returns {Object}
 */
export function setDialOutNumber(value: string) {
    return {
        type: SET_DIALOUT_NUMBER,
        value
    };
}

/**
 * Sets the visibility of the prejoin page when a client reload
 * is triggered as a result of call migration initiated by Jicofo.
 *
 * @param {boolean} value - The visibility value.
 * @returns {Object}
 */
export function setSkipPrejoinOnReload(value: boolean) {
    return {
        type: SET_SKIP_PREJOIN_RELOAD,
        value
    };
}

/**
 * Action used to set the visiblitiy of the 'JoinByPhoneDialog'.
 *
 * @param {boolean} value - The value.
 * @returns {Object}
 */
export function setJoinByPhoneDialogVisiblity(value: boolean) {
    return {
        type: SET_JOIN_BY_PHONE_DIALOG_VISIBLITY,
        value
    };
}

/**
 * Action used to set the initial errors after creating the tracks.
 *
 * @param {Object} value - The track errors.
 * @returns {Object}
 */
export function setPrejoinDeviceErrors(value: Object) {
    return {
        type: SET_PREJOIN_DEVICE_ERRORS,
        value
    };
}

/**
 * Action used to set the visibility of the prejoin page.
 *
 * @param {boolean} value - The value.
 * @returns {Object}
 */
export function setPrejoinPageVisibility(value: boolean) {
    return {
        type: SET_PREJOIN_PAGE_VISIBILITY,
        value
    };
}


################################################################################

## File: .\jitsi-meet\react\features\prejoin\actionTypes.ts


/**
 * Action type to signal that joining is in progress.
 */
export const PREJOIN_JOINING_IN_PROGRESS = 'PREJOIN_JOINING_IN_PROGRESS';

/**
 * Action type to signal that prejoin page was initialized.
 */
export const PREJOIN_INITIALIZED = 'PREJOIN_INITIALIZED';

/**
 * Action type to set the status of the device.
 */
export const SET_DEVICE_STATUS = 'SET_DEVICE_STATUS';

/**
 * Action type to set the visibility of the prejoin page when client is forcefully reloaded.
 */
export const SET_SKIP_PREJOIN_RELOAD = 'SET_SKIP_PREJOIN_RELOAD';

/**
 * Action type to set the country to dial out to.
 */
export const SET_DIALOUT_COUNTRY = 'SET_DIALOUT_COUNTRY';

/**
 * Action type to set the dial out number.
 */
export const SET_DIALOUT_NUMBER = 'SET_DIALOUT_NUMBER';

/**
 * Action type to set the dial out status while dialing.
 */
export const SET_DIALOUT_STATUS = 'SET_DIALOUT_STATUS';

/**
 * Action type to set the visibility of the 'JoinByPhone' dialog.
 */
export const SET_JOIN_BY_PHONE_DIALOG_VISIBLITY = 'SET_JOIN_BY_PHONE_DIALOG_VISIBLITY';

/**
 * Action type to disable the audio while on prejoin page.
 */
export const SET_PREJOIN_AUDIO_DISABLED = 'SET_PREJOIN_AUDIO_DISABLED';

/**
 * Action type to mute/unmute the audio while on prejoin page.
 */
export const SET_PREJOIN_AUDIO_MUTED = 'SET_PREJOIN_AUDIO_MUTED';

/**
 * Action type to set the errors while creating the prejoin streams.
 */
export const SET_PREJOIN_DEVICE_ERRORS = 'SET_PREJOIN_DEVICE_ERRORS';

/**
 * Action type to set the visibility of the prejoin page.
 */
export const SET_PREJOIN_PAGE_VISIBILITY = 'SET_PREJOIN_PAGE_VISIBILITY';


################################################################################

## File: .\jitsi-meet\react\features\prejoin\functions.any.ts

import { IReduxState } from '../app/types';
import { getRoomName } from '../base/conference/functions';
import { getDialOutStatusUrl, getDialOutUrl } from '../base/config/functions.any';
import {
    MEETING_NAME_ENABLED,
    UNSAFE_ROOM_WARNING
} from '../base/flags/constants';
import { getFeatureFlag } from '../base/flags/functions';
import { isAudioMuted, isVideoMutedByUser } from '../base/media/functions';
import { getLobbyConfig } from '../lobby/functions';


/**
 * Selector for the visibility of the 'join by phone' button.
 *
 * @param {IReduxState} state - The state of the app.
 * @returns {boolean}
 */
export function isJoinByPhoneButtonVisible(state: IReduxState): boolean {
    return Boolean(getDialOutUrl(state) && getDialOutStatusUrl(state));
}

/**
 * Selector for determining if the device status strip is visible or not.
 *
 * @param {IReduxState} state - The state of the app.
 * @returns {boolean}
 */
export function isDeviceStatusVisible(state: IReduxState): boolean {
    return !(isAudioMuted(state) && isVideoMutedByUser(state))
    && !state['features/base/config'].startSilent;
}

/**
 * Selector for determining if the display name is mandatory.
 *
 * @param {IReduxState} state - The state of the app.
 * @returns {boolean}
 */
export function isDisplayNameRequired(state: IReduxState): boolean {
    return Boolean(state['features/lobby']?.isDisplayNameRequiredError
        || state['features/base/config']?.requireDisplayName);
}

/**
 * Selector for determining if the prejoin page is enabled in config. Defaults to `true`.
 *
 * @param {IReduxState} state - The state of the app.
 * @returns {boolean}
 */
export function isPrejoinEnabledInConfig(state: IReduxState): boolean {
    return state['features/base/config'].prejoinConfig?.enabled ?? true;
}

/**
 * Selector for determining if the prejoin display name field is visible.
 *
 * @param {IReduxState} state - The state of the app.
 * @returns {boolean}
 */
export function isPrejoinDisplayNameVisible(state: IReduxState): boolean {
    return !state['features/base/config'].prejoinConfig?.hideDisplayName;
}

/**
 * Returns the text for the prejoin status bar.
 *
 * @param {IReduxState} state - The state of the app.
 * @returns {string}
 */
export function getDeviceStatusText(state: IReduxState): string {
    return state['features/prejoin']?.deviceStatusText;
}

/**
 * Returns the type of the prejoin status bar: 'ok'|'warning'.
 *
 * @param {IReduxState} state - The state of the app.
 * @returns {string}
 */
export function getDeviceStatusType(state: IReduxState): string {
    return state['features/prejoin']?.deviceStatusType;
}

/**
 * Returns the 'conferenceUrl' used for dialing out.
 *
 * @param {IReduxState} state - The state of the app.
 * @returns {string}
 */
export function getDialOutConferenceUrl(state: IReduxState): string {
    return `${getRoomName(state)}@${state['features/base/config'].hosts?.muc}`;
}

/**
 * Selector for getting the dial out country.
 *
 * @param {IReduxState} state - The state of the app.
 * @returns {Object}
 */
export function getDialOutCountry(state: IReduxState) {
    return state['features/prejoin'].dialOutCountry;
}

/**
 * Selector for getting the dial out number (without prefix).
 *
 * @param {IReduxState} state - The state of the app.
 * @returns {string}
 */
export function getDialOutNumber(state: IReduxState): string {
    return state['features/prejoin'].dialOutNumber;
}

/**
 * Selector for getting the dial out status while calling.
 *
 * @param {IReduxState} state - The state of the app.
 * @returns {string}
 */
export function getDialOutStatus(state: IReduxState): string {
    return state['features/prejoin'].dialOutStatus;
}

/**
 * Returns the full dial out number (containing country code and +).
 *
 * @param {IReduxState} state - The state of the app.
 * @returns {string}
 */
export function getFullDialOutNumber(state: IReduxState): string {
    const dialOutNumber = getDialOutNumber(state);
    const country = getDialOutCountry(state);

    return `+${country.dialCode}${dialOutNumber}`;
}

/**
 * Selector for getting the error if any while creating streams.
 *
 * @param {IReduxState} state - The state of the app.
 * @returns {string}
 */
export function getRawError(state: IReduxState): string {
    return state['features/prejoin']?.rawError;
}

/**
 * Selector for getting the visibility state for the 'JoinByPhoneDialog'.
 *
 * @param {IReduxState} state - The state of the app.
 * @returns {boolean}
 */
export function isJoinByPhoneDialogVisible(state: IReduxState): boolean {
    return state['features/prejoin']?.showJoinByPhoneDialog;
}

/**
 * Returns true if the prejoin page is enabled and no flag
 * to bypass showing the page is present.
 *
 * @param {IReduxState} state - The state of the app.
 * @returns {boolean}
 */
export function isPrejoinPageVisible(state: IReduxState): boolean {
    return Boolean(navigator.product !== 'ReactNative'
        && isPrejoinEnabledInConfig(state)
        && state['features/prejoin']?.showPrejoin
        && !(state['features/base/config'].enableForcedReload && state['features/prejoin'].skipPrejoinOnReload));
}

/**
 * Returns true if we should auto-knock in case lobby is enabled for the room.
 *
 * @param {IReduxState} state - The state of the app.
 * @returns {boolean}
 */
export function shouldAutoKnock(state: IReduxState): boolean {
    const { iAmRecorder, iAmSipGateway } = state['features/base/config'];
    const { userSelectedSkipPrejoin } = state['features/base/settings'];
    const { autoKnock } = getLobbyConfig(state);

    return Boolean(((isPrejoinEnabledInConfig(state) && !userSelectedSkipPrejoin)
            || autoKnock || (iAmRecorder && iAmSipGateway))
        && !state['features/lobby'].knocking);
}

/**
 * Returns true if the unsafe room warning flag is enabled.
 *
 * @param {IReduxState} state - The state of the app.
 * @returns {boolean}
 */
export function isUnsafeRoomWarningEnabled(state: IReduxState): boolean {
    const { enableInsecureRoomNameWarning = false } = state['features/base/config'];

    return getFeatureFlag(state, UNSAFE_ROOM_WARNING, enableInsecureRoomNameWarning);
}

/**
 * Returns true if the room name is enabled.
 *
 * @param {IReduxState} state - The state of the app.
 * @returns {boolean}
 */
export function isRoomNameEnabled(state: IReduxState): boolean {
    const { hideConferenceSubject = false } = state['features/base/config'];

    return getFeatureFlag(state, MEETING_NAME_ENABLED, true)
        && !hideConferenceSubject;
}


################################################################################

## File: .\jitsi-meet\react\features\prejoin\functions.native.ts

export * from './functions.any';


################################################################################

## File: .\jitsi-meet\react\features\prejoin\functions.web.ts

import { batch } from 'react-redux';

import { IStore } from '../app/types';
import { trackAdded } from '../base/tracks/actions.any';

import { PREJOIN_INITIALIZED } from './actionTypes';
import { setPrejoinDeviceErrors } from './actions.web';

export * from './functions.any';

/**
 * Adds all the newly created tracks to store on init.
 *
 * @param {Object[]} tracks - The newly created tracks.
 * @param {Object} errors - The errors from creating the tracks.
 * @param {Function} dispatch - The redux dispatch function.
 * @returns {void}
 */
export function initPrejoin(tracks: Object[], errors: Object, dispatch?: IStore['dispatch']) {
    if (!dispatch) {
        return;
    }

    batch(() => {
        dispatch(setPrejoinDeviceErrors(errors));
        dispatch({
            type: PREJOIN_INITIALIZED
        });

        tracks.forEach(track => dispatch(trackAdded(track)));
    });
}


################################################################################

## File: .\jitsi-meet\react\features\prejoin\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/prejoin');


################################################################################

## File: .\jitsi-meet\react\features\prejoin\middleware.web.ts

import { AnyAction } from 'redux';

import { IStore } from '../app/types';
import { CONFERENCE_FAILED, CONFERENCE_JOINED } from '../base/conference/actionTypes';
import { CONNECTION_FAILED } from '../base/connection/actionTypes';
import { SET_AUDIO_MUTED, SET_VIDEO_MUTED } from '../base/media/actionTypes';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import { updateSettings } from '../base/settings/actions';
import {
    TRACK_ADDED,
    TRACK_NO_DATA_FROM_SOURCE
} from '../base/tracks/actionTypes';

import {
    setDeviceStatusOk,
    setDeviceStatusWarning,
    setJoiningInProgress
} from './actions';
import { isPrejoinPageVisible } from './functions.any';

/**
 * The redux middleware for {@link PrejoinPage}.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {
    switch (action.type) {
    case SET_AUDIO_MUTED: {
        if (isPrejoinPageVisible(store.getState())) {
            store.dispatch(updateSettings({
                startWithAudioMuted: Boolean(action.muted)
            }));
        }
        break;
    }

    case SET_VIDEO_MUTED: {
        if (isPrejoinPageVisible(store.getState())) {
            store.dispatch(updateSettings({
                startWithVideoMuted: Boolean(action.muted)
            }));
        }
        break;
    }

    case TRACK_ADDED:
    case TRACK_NO_DATA_FROM_SOURCE: {
        const state = store.getState();

        if (isPrejoinPageVisible(state)) {
            const { track: { jitsiTrack: track } } = action;
            const { deviceStatusType, deviceStatusText } = state['features/prejoin'];

            if (!track.isAudioTrack()) {
                break;
            }

            if (track.isReceivingData()) {
                if (deviceStatusType === 'warning'
                    && deviceStatusText === 'prejoin.audioDeviceProblem') {
                    store.dispatch(setDeviceStatusOk('prejoin.lookGood'));
                }
            } else if (deviceStatusType === 'ok') {
                store.dispatch(setDeviceStatusWarning('prejoin.audioDeviceProblem'));
            }
        }
        break;
    }
    case CONFERENCE_FAILED:
    case CONNECTION_FAILED:
        store.dispatch(setJoiningInProgress(false));
        break;
    case CONFERENCE_JOINED:
        return _conferenceJoined(store, next, action);
    }

    return next(action);
});

/**
 * Handles cleanup of prejoin state when a conference is joined.
 *
 * @param {Object} store - The Redux store.
 * @param {Function} next - The Redux next function.
 * @param {Object} action - The Redux action.
 * @returns {Object}
 */
function _conferenceJoined({ dispatch }: IStore, next: Function, action: AnyAction) {
    dispatch(setJoiningInProgress(false));

    return next(action);
}


################################################################################

## File: .\jitsi-meet\react\features\prejoin\reducer.ts

import PersistenceRegistry from '../base/redux/PersistenceRegistry';
import ReducerRegistry from '../base/redux/ReducerRegistry';

import {
    PREJOIN_JOINING_IN_PROGRESS,
    SET_DEVICE_STATUS,
    SET_DIALOUT_COUNTRY,
    SET_DIALOUT_NUMBER,
    SET_DIALOUT_STATUS,
    SET_JOIN_BY_PHONE_DIALOG_VISIBLITY,
    SET_PREJOIN_DEVICE_ERRORS,
    SET_PREJOIN_PAGE_VISIBILITY,
    SET_SKIP_PREJOIN_RELOAD
} from './actionTypes';

const DEFAULT_STATE = {
    country: '',
    deviceStatusText: 'prejoin.configuringDevices',
    deviceStatusType: 'ok',
    dialOutCountry: {
        name: 'United States',
        dialCode: '1',
        code: 'us'
    },
    dialOutNumber: '',
    dialOutStatus: 'prejoin.dialing',
    name: '',
    rawError: '',
    showPrejoin: true,
    skipPrejoinOnReload: false,
    showJoinByPhoneDialog: false
};

export interface IPrejoinState {
    country: string;
    deviceStatusText: string;
    deviceStatusType: string;
    dialOutCountry: {
        code: string;
        dialCode: string;
        name: string;
    };
    dialOutNumber: string;
    dialOutStatus: string;
    joiningInProgress?: boolean;
    name: string;
    rawError: string;
    showJoinByPhoneDialog: boolean;
    showPrejoin: boolean;
    skipPrejoinOnReload: boolean;
}

/**
 * Sets up the persistence of the feature {@code prejoin}.
 */
PersistenceRegistry.register('features/prejoin', {
    skipPrejoinOnReload: true
}, DEFAULT_STATE);

/**
 * Listen for actions that mutate the prejoin state.
 */
ReducerRegistry.register<IPrejoinState>(
    'features/prejoin', (state = DEFAULT_STATE, action): IPrejoinState => {
        switch (action.type) {
        case PREJOIN_JOINING_IN_PROGRESS:
            return {
                ...state,
                joiningInProgress: action.value
            };
        case SET_SKIP_PREJOIN_RELOAD: {
            return {
                ...state,
                skipPrejoinOnReload: action.value
            };
        }

        case SET_PREJOIN_PAGE_VISIBILITY:
            return {
                ...state,
                showPrejoin: action.value
            };

        case SET_PREJOIN_DEVICE_ERRORS: {
            const status = getStatusFromErrors(action.value);

            return {
                ...state,
                ...status
            };
        }

        case SET_DEVICE_STATUS: {
            const { deviceStatusType, deviceStatusText } = action.value;

            return {
                ...state,
                deviceStatusText,
                deviceStatusType
            };
        }

        case SET_DIALOUT_NUMBER: {
            return {
                ...state,
                dialOutNumber: action.value
            };
        }

        case SET_DIALOUT_COUNTRY: {
            return {
                ...state,
                dialOutCountry: action.value
            };
        }

        case SET_DIALOUT_STATUS: {
            return {
                ...state,
                dialOutStatus: action.value
            };
        }

        case SET_JOIN_BY_PHONE_DIALOG_VISIBLITY: {
            return {
                ...state,
                showJoinByPhoneDialog: action.value
            };
        }

        default:
            return state;
        }
    }
);

/**
 * Returns a suitable error object based on the track errors.
 *
 * @param {Object} errors - The errors got while creating local tracks.
 * @returns {Object}
 */
function getStatusFromErrors(errors: {
    audioAndVideoError?: { message: string; };
    audioOnlyError?: { message: string; };
    videoOnlyError?: { message: string; }; }
) {
    const { audioOnlyError, videoOnlyError, audioAndVideoError } = errors;

    if (audioAndVideoError) {
        return {
            deviceStatusType: 'warning',
            deviceStatusText: 'prejoin.audioAndVideoError',
            rawError: audioAndVideoError.message
        };
    }

    if (audioOnlyError) {
        return {
            deviceStatusType: 'warning',
            deviceStatusText: 'prejoin.audioOnlyError',
            rawError: audioOnlyError.message
        };
    }

    if (videoOnlyError) {
        return {
            deviceStatusType: 'warning',
            deviceStatusText: 'prejoin.videoOnlyError',
            rawError: videoOnlyError.message
        };
    }

    return {
        deviceStatusType: 'ok',
        deviceStatusText: 'prejoin.lookGood',
        rawError: ''
    };
}


################################################################################

## File: .\jitsi-meet\react\features\prejoin\types.ts

export interface IPrejoinProps {
    navigation: any;
}


################################################################################

## File: .\jitsi-meet\react\features\prejoin\utils.ts

export const countries = [
    { name: 'Afghanistan',
        dialCode: '93',
        code: 'af' },
    { name: 'Aland Islands',
        dialCode: '358',
        code: 'ax' },
    { name: 'Albania',
        dialCode: '355',
        code: 'al' },
    { name: 'Algeria',
        dialCode: '213',
        code: 'dz' },
    { name: 'AmericanSamoa',
        dialCode: '1684',
        code: 'as' },
    { name: 'Andorra',
        dialCode: '376',
        code: 'ad' },
    { name: 'Angola',
        dialCode: '244',
        code: 'ao' },
    { name: 'Anguilla',
        dialCode: '1264',
        code: 'ai' },
    { name: 'Antarctica',
        dialCode: '672',
        code: 'aq' },
    { name: 'Antigua and Barbuda',
        dialCode: '1268',
        code: 'ag' },
    { name: 'Argentina',
        dialCode: '54',
        code: 'ar' },
    { name: 'Armenia',
        dialCode: '374',
        code: 'am' },
    { name: 'Aruba',
        dialCode: '297',
        code: 'aw' },
    { name: 'Australia',
        dialCode: '61',
        code: 'au' },
    { name: 'Austria',
        dialCode: '43',
        code: 'at' },
    { name: 'Azerbaijan',
        dialCode: '994',
        code: 'az' },
    { name: 'Bahamas',
        dialCode: '1242',
        code: 'bs' },
    { name: 'Bahrain',
        dialCode: '973',
        code: 'bh' },
    { name: 'Bangladesh',
        dialCode: '880',
        code: 'bd' },
    { name: 'Barbados',
        dialCode: '1246',
        code: 'bb' },
    { name: 'Belarus',
        dialCode: '375',
        code: 'by' },
    { name: 'Belgium',
        dialCode: '32',
        code: 'be' },
    { name: 'Belize',
        dialCode: '501',
        code: 'bz' },
    { name: 'Benin',
        dialCode: '229',
        code: 'bj' },
    { name: 'Bermuda',
        dialCode: '1441',
        code: 'bm' },
    { name: 'Bhutan',
        dialCode: '975',
        code: 'bt' },
    { name: 'Bolivia, Plurinational State of',
        dialCode: '591',
        code: 'bo' },
    { name: 'Bosnia and Herzegovina',
        dialCode: '387',
        code: 'ba' },
    { name: 'Botswana',
        dialCode: '267',
        code: 'bw' },
    { name: 'Brazil',
        dialCode: '55',
        code: 'br' },
    { name: 'British Indian Ocean Territory',
        dialCode: '246',
        code: 'io' },
    { name: 'Brunei Darussalam',
        dialCode: '673',
        code: 'bn' },
    { name: 'Bulgaria',
        dialCode: '359',
        code: 'bg' },
    { name: 'Burkina Faso',
        dialCode: '226',
        code: 'bf' },
    { name: 'Burundi',
        dialCode: '257',
        code: 'bi' },
    { name: 'Cambodia',
        dialCode: '855',
        code: 'kh' },
    { name: 'Cameroon',
        dialCode: '237',
        code: 'cm' },
    { name: 'Canada',
        dialCode: '1',
        code: 'ca' },
    { name: 'Cape Verde',
        dialCode: '238',
        code: 'cv' },
    { name: 'Cayman Islands',
        dialCode: ' 345',
        code: 'ky' },
    { name: 'Central African Republic',
        dialCode: '236',
        code: 'cf' },
    { name: 'Chad',
        dialCode: '235',
        code: 'td' },
    { name: 'Chile',
        dialCode: '56',
        code: 'cl' },
    { name: 'China',
        dialCode: '86',
        code: 'cn' },
    { name: 'Christmas Island',
        dialCode: '61',
        code: 'cx' },
    { name: 'Cocos (Keeling) Islands',
        dialCode: '61',
        code: 'cc' },
    { name: 'Colombia',
        dialCode: '57',
        code: 'co' },
    { name: 'Comoros',
        dialCode: '269',
        code: 'km' },
    { name: 'Congo',
        dialCode: '242',
        code: 'cg' },
    {
        name: 'Congo, The Democratic Republic of the Congo',
        dialCode: '243',
        code: 'cd'
    },
    { name: 'Cook Islands',
        dialCode: '682',
        code: 'ck' },
    { name: 'Costa Rica',
        dialCode: '506',
        code: 'cr' },
    { name: 'Cote d\'Ivoire',
        dialCode: '225',
        code: 'ci' },
    { name: 'Croatia',
        dialCode: '385',
        code: 'hr' },
    { name: 'Cuba',
        dialCode: '53',
        code: 'cu' },
    { name: 'Cyprus',
        dialCode: '357',
        code: 'cy' },
    { name: 'Czech Republic',
        dialCode: '420',
        code: 'cz' },
    { name: 'Denmark',
        dialCode: '45',
        code: 'dk' },
    { name: 'Djibouti',
        dialCode: '253',
        code: 'dj' },
    { name: 'Dominica',
        dialCode: '1767',
        code: 'dm' },
    { name: 'Dominican Republic',
        dialCode: '1849',
        code: 'do' },
    { name: 'Ecuador',
        dialCode: '593',
        code: 'ec' },
    { name: 'Egypt',
        dialCode: '20',
        code: 'eg' },
    { name: 'El Salvador',
        dialCode: '503',
        code: 'sv' },
    { name: 'Equatorial Guinea',
        dialCode: '240',
        code: 'gq' },
    { name: 'Eritrea',
        dialCode: '291',
        code: 'er' },
    { name: 'Estonia',
        dialCode: '372',
        code: 'ee' },
    { name: 'Ethiopia',
        dialCode: '251',
        code: 'et' },
    { name: 'Falkland Islands (Malvinas)',
        dialCode: '500',
        code: 'fk' },
    { name: 'Faroe Islands',
        dialCode: '298',
        code: 'fo' },
    { name: 'Fiji',
        dialCode: '679',
        code: 'fj' },
    { name: 'Finland',
        dialCode: '358',
        code: 'fi' },
    { name: 'France',
        dialCode: '33',
        code: 'fr' },
    { name: 'French Guiana',
        dialCode: '594',
        code: 'gf' },
    { name: 'French Polynesia',
        dialCode: '689',
        code: 'pf' },
    { name: 'Gabon',
        dialCode: '241',
        code: 'ga' },
    { name: 'Gambia',
        dialCode: '220',
        code: 'gm' },
    { name: 'Georgia',
        dialCode: '995',
        code: 'ge' },
    { name: 'Germany',
        dialCode: '49',
        code: 'de' },
    { name: 'Ghana',
        dialCode: '233',
        code: 'gh' },
    { name: 'Gibraltar',
        dialCode: '350',
        code: 'gi' },
    { name: 'Greece',
        dialCode: '30',
        code: 'gr' },
    { name: 'Greenland',
        dialCode: '299',
        code: 'gl' },
    { name: 'Grenada',
        dialCode: '1473',
        code: 'gd' },
    { name: 'Guadeloupe',
        dialCode: '590',
        code: 'gp' },
    { name: 'Guam',
        dialCode: '1671',
        code: 'gu' },
    { name: 'Guatemala',
        dialCode: '502',
        code: 'gt' },
    { name: 'Guernsey',
        dialCode: '44',
        code: 'gg' },
    { name: 'Guinea',
        dialCode: '224',
        code: 'gn' },
    { name: 'Guinea-Bissau',
        dialCode: '245',
        code: 'gw' },
    { name: 'Guyana',
        dialCode: '595',
        code: 'gy' },
    { name: 'Haiti',
        dialCode: '509',
        code: 'ht' },
    { name: 'Holy See (Vatican City State)',
        dialCode: '379',
        code: 'va' },
    { name: 'Honduras',
        dialCode: '504',
        code: 'hn' },
    { name: 'Hong Kong',
        dialCode: '852',
        code: 'hk' },
    { name: 'Hungary',
        dialCode: '36',
        code: 'hu' },
    { name: 'Iceland',
        dialCode: '354',
        code: 'is' },
    { name: 'India',
        dialCode: '91',
        code: 'in' },
    { name: 'Indonesia',
        dialCode: '62',
        code: 'id' },
    {
        name: 'Iran, Islamic Republic of Persian Gulf',
        dialCode: '98',
        code: 'ir'
    },
    { name: 'Iraq',
        dialCode: '964',
        code: 'iq' },
    { name: 'Ireland',
        dialCode: '353',
        code: 'ie' },
    { name: 'Isle of Man',
        dialCode: '44',
        code: 'im' },
    { name: 'Israel',
        dialCode: '972',
        code: 'il' },
    { name: 'Italy',
        dialCode: '39',
        code: 'it' },
    { name: 'Jamaica',
        dialCode: '1876',
        code: 'jm' },
    { name: 'Japan',
        dialCode: '81',
        code: 'jp' },
    { name: 'Jersey',
        dialCode: '44',
        code: 'je' },
    { name: 'Jordan',
        dialCode: '962',
        code: 'jo' },
    { name: 'Kazakhstan',
        dialCode: '77',
        code: 'kz' },
    { name: 'Kenya',
        dialCode: '254',
        code: 'ke' },
    { name: 'Kiribati',
        dialCode: '686',
        code: 'ki' },
    {
        name: 'Korea, Democratic People\'s Republic of Korea',
        dialCode: '850',
        code: 'kp'
    },
    { name: 'Korea, Republic of South Korea',
        dialCode: '82',
        code: 'kr' },
    { name: 'Kuwait',
        dialCode: '965',
        code: 'kw' },
    { name: 'Kyrgyzstan',
        dialCode: '996',
        code: 'kg' },
    { name: 'Laos',
        dialCode: '856',
        code: 'la' },
    { name: 'Latvia',
        dialCode: '371',
        code: 'lv' },
    { name: 'Lebanon',
        dialCode: '961',
        code: 'lb' },
    { name: 'Lesotho',
        dialCode: '266',
        code: 'ls' },
    { name: 'Liberia',
        dialCode: '231',
        code: 'lr' },
    { name: 'Libyan Arab Jamahiriya',
        dialCode: '218',
        code: 'ly' },
    { name: 'Liechtenstein',
        dialCode: '423',
        code: 'li' },
    { name: 'Lithuania',
        dialCode: '370',
        code: 'lt' },
    { name: 'Luxembourg',
        dialCode: '352',
        code: 'lu' },
    { name: 'Macao',
        dialCode: '853',
        code: 'mo' },
    { name: 'Macedonia',
        dialCode: '389',
        code: 'mk' },
    { name: 'Madagascar',
        dialCode: '261',
        code: 'mg' },
    { name: 'Malawi',
        dialCode: '265',
        code: 'mw' },
    { name: 'Malaysia',
        dialCode: '60',
        code: 'my' },
    { name: 'Maldives',
        dialCode: '960',
        code: 'mv' },
    { name: 'Mali',
        dialCode: '223',
        code: 'ml' },
    { name: 'Malta',
        dialCode: '356',
        code: 'mt' },
    { name: 'Marshall Islands',
        dialCode: '692',
        code: 'mh' },
    { name: 'Martinique',
        dialCode: '596',
        code: 'mq' },
    { name: 'Mauritania',
        dialCode: '222',
        code: 'mr' },
    { name: 'Mauritius',
        dialCode: '230',
        code: 'mu' },
    { name: 'Mayotte',
        dialCode: '262',
        code: 'yt' },
    { name: 'Mexico',
        dialCode: '52',
        code: 'mx' },
    {
        name: 'Micronesia, Federated States of Micronesia',
        dialCode: '691',
        code: 'fm'
    },
    { name: 'Moldova',
        dialCode: '373',
        code: 'md' },
    { name: 'Monaco',
        dialCode: '377',
        code: 'mc' },
    { name: 'Mongolia',
        dialCode: '976',
        code: 'mn' },
    { name: 'Montenegro',
        dialCode: '382',
        code: 'me' },
    { name: 'Montserrat',
        dialCode: '1664',
        code: 'ms' },
    { name: 'Morocco',
        dialCode: '212',
        code: 'ma' },
    { name: 'Mozambique',
        dialCode: '258',
        code: 'mz' },
    { name: 'Myanmar',
        dialCode: '95',
        code: 'mm' },
    { name: 'Namibia',
        dialCode: '264',
        code: 'na' },
    { name: 'Nauru',
        dialCode: '674',
        code: 'nr' },
    { name: 'Nepal',
        dialCode: '977',
        code: 'np' },
    { name: 'Netherlands',
        dialCode: '31',
        code: 'nl' },
    { name: 'Netherlands Antilles',
        dialCode: '599',
        code: 'an' },
    { name: 'New Caledonia',
        dialCode: '687',
        code: 'nc' },
    { name: 'New Zealand',
        dialCode: '64',
        code: 'nz' },
    { name: 'Nicaragua',
        dialCode: '505',
        code: 'ni' },
    { name: 'Niger',
        dialCode: '227',
        code: 'ne' },
    { name: 'Nigeria',
        dialCode: '234',
        code: 'ng' },
    { name: 'Niue',
        dialCode: '683',
        code: 'nu' },
    { name: 'Norfolk Island',
        dialCode: '672',
        code: 'nf' },
    { name: 'Northern Mariana Islands',
        dialCode: '1670',
        code: 'mp' },
    { name: 'Norway',
        dialCode: '47',
        code: 'no' },
    { name: 'Oman',
        dialCode: '968',
        code: 'om' },
    { name: 'Pakistan',
        dialCode: '92',
        code: 'pk' },
    { name: 'Palau',
        dialCode: '680',
        code: 'pw' },
    { name: 'Palestinian Territory, Occupied',
        dialCode: '970',
        code: 'ps' },
    { name: 'Panama',
        dialCode: '507',
        code: 'pa' },
    { name: 'Papua New Guinea',
        dialCode: '675',
        code: 'pg' },
    { name: 'Paraguay',
        dialCode: '595',
        code: 'py' },
    { name: 'Peru',
        dialCode: '51',
        code: 'pe' },
    { name: 'Philippines',
        dialCode: '63',
        code: 'ph' },
    { name: 'Pitcairn',
        dialCode: '872',
        code: 'pn' },
    { name: 'Poland',
        dialCode: '48',
        code: 'pl' },
    { name: 'Portugal',
        dialCode: '351',
        code: 'pt' },
    { name: 'Puerto Rico',
        dialCode: '1939',
        code: 'pr' },
    { name: 'Qatar',
        dialCode: '974',
        code: 'qa' },
    { name: 'Romania',
        dialCode: '40',
        code: 'ro' },
    { name: 'Russia',
        dialCode: '7',
        code: 'ru' },
    { name: 'Rwanda',
        dialCode: '250',
        code: 'rw' },
    { name: 'Reunion',
        dialCode: '262',
        code: 're' },
    { name: 'Saint Barthelemy',
        dialCode: '590',
        code: 'bl' },
    {
        name: 'Saint Helena, Ascension and Tristan Da Cunha',
        dialCode: '290',
        code: 'sh'
    },
    { name: 'Saint Kitts and Nevis',
        dialCode: '1869',
        code: 'kn' },
    { name: 'Saint Lucia',
        dialCode: '1758',
        code: 'lc' },
    { name: 'Saint Martin',
        dialCode: '590',
        code: 'mf' },
    { name: 'Saint Pierre and Miquelon',
        dialCode: '508',
        code: 'pm' },
    { name: 'Saint Vincent and the Grenadines',
        dialCode: '1784',
        code: 'vc' },
    { name: 'Samoa',
        dialCode: '685',
        code: 'ws' },
    { name: 'San Marino',
        dialCode: '378',
        code: 'sm' },
    { name: 'Sao Tome and Principe',
        dialCode: '239',
        code: 'st' },
    { name: 'Saudi Arabia',
        dialCode: '966',
        code: 'sa' },
    { name: 'Senegal',
        dialCode: '221',
        code: 'sn' },
    { name: 'Serbia',
        dialCode: '381',
        code: 'rs' },
    { name: 'Seychelles',
        dialCode: '248',
        code: 'sc' },
    { name: 'Sierra Leone',
        dialCode: '232',
        code: 'sl' },
    { name: 'Singapore',
        dialCode: '65',
        code: 'sg' },
    { name: 'Slovakia',
        dialCode: '421',
        code: 'sk' },
    { name: 'Slovenia',
        dialCode: '386',
        code: 'si' },
    { name: 'Solomon Islands',
        dialCode: '677',
        code: 'sb' },
    { name: 'Somalia',
        dialCode: '252',
        code: 'so' },
    { name: 'South Africa',
        dialCode: '27',
        code: 'za' },
    { name: 'South Sudan',
        dialCode: '211',
        code: 'ss' },
    {
        name: 'South Georgia and the South Sandwich Islands',
        dialCode: '500',
        code: 'gs'
    },
    { name: 'Spain',
        dialCode: '34',
        code: 'es' },
    { name: 'Sri Lanka',
        dialCode: '94',
        code: 'lk' },
    { name: 'Sudan',
        dialCode: '249',
        code: 'sd' },
    { name: 'Suriname',
        dialCode: '597',
        code: 'sr' },
    { name: 'Svalbard and Jan Mayen',
        dialCode: '47',
        code: 'sj' },
    { name: 'Swaziland',
        dialCode: '268',
        code: 'sz' },
    { name: 'Sweden',
        dialCode: '46',
        code: 'se' },
    { name: 'Switzerland',
        dialCode: '41',
        code: 'ch' },
    { name: 'Syrian Arab Republic',
        dialCode: '963',
        code: 'sy' },
    { name: 'Taiwan',
        dialCode: '886',
        code: 'tw' },
    { name: 'Tajikistan',
        dialCode: '992',
        code: 'tj' },
    {
        name: 'Tanzania, United Republic of Tanzania',
        dialCode: '255',
        code: 'tz'
    },
    { name: 'Thailand',
        dialCode: '66',
        code: 'th' },
    { name: 'Timor-Leste',
        dialCode: '670',
        code: 'tl' },
    { name: 'Togo',
        dialCode: '228',
        code: 'tg' },
    { name: 'Tokelau',
        dialCode: '690',
        code: 'tk' },
    { name: 'Tonga',
        dialCode: '676',
        code: 'to' },
    { name: 'Trinidad and Tobago',
        dialCode: '1868',
        code: 'tt' },
    { name: 'Tunisia',
        dialCode: '216',
        code: 'tn' },
    { name: 'Turkey',
        dialCode: '90',
        code: 'tr' },
    { name: 'Turkmenistan',
        dialCode: '993',
        code: 'tm' },
    { name: 'Turks and Caicos Islands',
        dialCode: '1649',
        code: 'tc' },
    { name: 'Tuvalu',
        dialCode: '688',
        code: 'tv' },
    { name: 'Uganda',
        dialCode: '256',
        code: 'ug' },
    { name: 'Ukraine',
        dialCode: '380',
        code: 'ua' },
    { name: 'United Arab Emirates',
        dialCode: '971',
        code: 'ae' },
    { name: 'United Kingdom',
        dialCode: '44',
        code: 'gb' },
    { name: 'United States',
        dialCode: '1',
        code: 'us' },
    { name: 'Uruguay',
        dialCode: '598',
        code: 'uy' },
    { name: 'Uzbekistan',
        dialCode: '998',
        code: 'uz' },
    { name: 'Vanuatu',
        dialCode: '678',
        code: 'vu' },
    {
        name: 'Venezuela, Bolivarian Republic of Venezuela',
        dialCode: '58',
        code: 've'
    },
    { name: 'Vietnam',
        dialCode: '84',
        code: 'vn' },
    { name: 'Virgin Islands, British',
        dialCode: '1284',
        code: 'vg' },
    { name: 'Virgin Islands, U.S.',
        dialCode: '1340',
        code: 'vi' },
    { name: 'Wallis and Futuna',
        dialCode: '681',
        code: 'wf' },
    { name: 'Yemen',
        dialCode: '967',
        code: 'ye' },
    { name: 'Zambia',
        dialCode: '260',
        code: 'zm' },
    { name: 'Zimbabwe',
        dialCode: '263',
        code: 'zw' }
];

const countriesByCodeMap = countries.reduce<any>((result, country) => {
    result[country.dialCode] = country;

    return result;
}, {});

/**
 * Map between country dial codes and country objects.
 *
 */
const codesByNumbersMap = countries.reduce<any>((result, country) => {
    result[country.dialCode] = country.code;

    return result;
}, {});

/**
 * Returns the corresponding country code from a phone number.
 *
 * @param {string} phoneNumber - The phone number.
 * @returns {string}
 */
export function getCountryCodeFromPhone(phoneNumber: string): string {
    const number = phoneNumber.replace(/[+.\s]/g, '');


    for (let i = 4; i > 0; i--) {
        const prefix = number.slice(0, i);

        if (codesByNumbersMap[prefix]) {
            return codesByNumbersMap[prefix];
        }
    }

    return '';
}

/**
 * Returns the corresponding country for a text starting with the dial code.
 *
 * @param {string} text - The text containing the dial code.
 * @returns {Object}
 */
export function getCountryFromDialCodeText(text: string) {
    return (
        countriesByCodeMap[text.slice(0, 4)]
        || countriesByCodeMap[text.slice(0, 3)]
        || countriesByCodeMap[text.slice(0, 2)]
        || countriesByCodeMap[text.slice(0, 1)]
        || null
    );
}

/**
 * Returns whether the display name is present.
 *
 * @param {string} value - The display name.
 * @returns {boolean}
 */
export const hasDisplayName = (value: string): boolean => Boolean(value) && value.trim() !== '';


################################################################################

## File: .\jitsi-meet\react\features\prejoin\components\native\styles.ts

import BaseTheme from '../../../base/ui/components/BaseTheme.native';

export const preJoinStyles = {

    joinButton: {
        marginTop: BaseTheme.spacing[3],
        width: 352
    },

    buttonStylesBorderless: {
        iconStyle: {
            color: BaseTheme.palette.icon01,
            fontSize: 24
        },
        style: {
            flexDirection: 'row',
            justifyContent: 'center',
            margin: BaseTheme.spacing[3],
            height: 24,
            width: 24
        },
        underlayColor: 'transparent'
    },

    contentWrapper: {
        flex: 1,
        flexDirection: 'row'
    },

    contentWrapperWide: {
        flex: 1,
        flexDirection: 'row'
    },

    largeVideoContainer: {
        height: '60%'
    },

    largeVideoContainerWide: {
        height: '100%',
        marginRight: 'auto',
        position: 'absolute',
        width: '50%'
    },

    contentContainer: {
        alignItems: 'center',
        backgroundColor: BaseTheme.palette.uiBackground,
        bottom: 0,
        display: 'flex',
        height: 280,
        justifyContent: 'center',
        position: 'absolute',
        width: '100%',
        zIndex: 1
    },

    contentContainerWide: {
        alignItems: 'center',
        height: '100%',
        justifyContent: 'center',
        left: '50%',
        padding: BaseTheme.spacing[3],
        position: 'absolute',
        width: '50%'
    },

    toolboxContainer: {
        alignItems: 'center',
        backgroundColor: BaseTheme.palette.ui01,
        borderRadius: BaseTheme.shape.borderRadius,
        display: 'flex',
        flexDirection: 'row',
        height: 60,
        justifyContent: 'space-between',
        marginBottom: BaseTheme.spacing[3],
        paddingHorizontal: BaseTheme.spacing[2],
        width: 148
    },

    customInput: {
        textAlign: 'center',
        width: 352
    },

    errorContainer: {
        backgroundColor: BaseTheme.palette.actionDanger,
        borderBottomRightRadius: BaseTheme.shape.borderRadius,
        borderBottomLeftRadius: BaseTheme.shape.borderRadius,
        boxSizing: 'border-box',
        marginTop: -BaseTheme.spacing[2],
        overflow: 'visible',
        wordBreak: 'normal',
        width: 352
    },

    error: {
        padding: BaseTheme.spacing[1],
        color: BaseTheme.palette.text01,
        textAlign: 'center'
    },

    preJoinRoomName: {
        ...BaseTheme.typography.heading5,
        color: BaseTheme.palette.text01,
        textAlign: 'center'
    },

    conferenceInfo: {
        alignSelf: 'center',
        marginTop: BaseTheme.spacing[3],
        paddingHorizontal: BaseTheme.spacing[3],
        paddingVertical: BaseTheme.spacing[1],
        position: 'absolute',
        maxWidth: 273,
        zIndex: 1
    },
    displayRoomNameBackdrop: {
        backgroundColor: BaseTheme.palette.uiBackground,
        borderRadius: BaseTheme.shape.borderRadius,
        opacity: 0.7,
        paddingHorizontal: BaseTheme.spacing[3],
        paddingVertical: BaseTheme.spacing[1]
    },
    recordingWarning: {
        display: 'flex',
        justifyContent: 'center',
        lineHeight: 22,
        marginBottom: BaseTheme.spacing[2],
        marginTop: BaseTheme.spacing[1],
        width: 'auto'
    },
    recordingWarningText: {
        color: BaseTheme.palette.text03
    },
    unsafeRoomWarningContainer: {
        height: '100%',
        width: '100%',
        backgroundColor: BaseTheme.palette.ui01,
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        color: 'white'
    },
    unsafeRoomContentContainer: {
        justifySelf: 'center',
        height: '100%',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        paddingHorizontal: BaseTheme.spacing[4]
    },

    unsafeRoomContentContainerWide: {
        alignItems: 'center',
        justifySelf: 'center',
        height: '100%',
        display: 'flex',
        justifyContent: 'center',
        marginLeft: BaseTheme.spacing[7],
        paddingHorizontal: BaseTheme.spacing[6]
    },

    warningText: {
        ...BaseTheme.typography.bodyLongRegularLarge,
        color: BaseTheme.palette.text01,
        textAlign: 'center',
        marginBottom: BaseTheme.spacing[4]
    },
    warningIconWrapper: {
        backgroundColor: BaseTheme.palette.warning01,
        borderRadius: BaseTheme.shape.circleRadius,
        padding: BaseTheme.spacing[4],
        marginBottom: BaseTheme.spacing[4],
        zIndex: 0

    },
    warningIcon: {
        color: BaseTheme.palette.ui01,
        fontSize: 40
    }
};


################################################################################

## File: .\jitsi-meet\react\features\presence-status\constants.ts

// User invite statuses

/**
 * Тhe status for a participant when it's invited to a conference.
 *
 * @type {string}
 */
export const INVITED = 'Invited';

/**
 * Тhe status for a participant when a call has been initiated.
 *
 * @type {string}
 */
export const CALLING = 'calling';

/**
 * Тhe status for a participant when the invite is received and its device(s)
 * are ringing.
 *
 * @type {string}
 */
export const RINGING = 'ringing';

/**
 * A status for a participant that indicates the call is connected.
 *
 * @type {string}
 */
export const CONNECTED_USER = 'connected';

/**
 * The status for a participant when the invitation is received but the user
 * has responded with busy message.
 *
 * @type {string}
 */
export const BUSY = 'busy';

/**
 * The status for a participant when the invitation is rejected.
 *
 * @type {string}
 */
export const REJECTED = 'rejected';

/**
 * The status for a participant when the invitation is ignored.
 *
 * @type {string}
 */
export const IGNORED = 'ignored';

/**
  * The status for a participant when the invitation is expired.
 *
 * @type {string}
 */
export const EXPIRED = 'expired';

// Phone call statuses

/**
 * A status for a participant that indicates the call is in process of
 * initialization.
 * NOTE: Currently used for phone numbers only.
 *
 * @type {string}
 */
export const INITIALIZING_CALL = 'Initializing Call';

/**
 * A status for a participant that indicates the call is in process of
 * connecting.
 * NOTE: Currently used for phone numbers only.
 *
 * @type {string}
 */
export const CONNECTING = 'Connecting';

/**
 * A status for a participant that indicates the call is in process of
 * connecting.
 * NOTE: Currently used for phone numbers only.
 *
 * @type {string}
 */
export const CONNECTING2 = 'Connecting*';


/**
 * A status for a phone number participant that indicates the call is connected.
 *
 * @type {string}
 */
export const CONNECTED_PHONE_NUMBER = 'Connected';


/**
 * A status for a participant that indicates the call is disconnected.
 * NOTE: Currently used for phone numbers only.
 *
 * @type {string}
 */
export const DISCONNECTED = 'Disconnected';

/**
 * Maps the presence status values to i18n translation keys.
 *
 * @type {Object<String, String>}
 */
export const STATUS_TO_I18N_KEY = {
    [INVITED]: 'presenceStatus.invited',
    [RINGING]: 'presenceStatus.ringing',
    [CALLING]: 'presenceStatus.calling',
    [BUSY]: 'presenceStatus.busy',
    [REJECTED]: 'presenceStatus.rejected',
    [IGNORED]: 'presenceStatus.ignored',
    [EXPIRED]: 'presenceStatus.expired',

    [INITIALIZING_CALL]: 'presenceStatus.initializingCall',
    [CONNECTING]: 'presenceStatus.connecting',
    [CONNECTING2]: 'presenceStatus.connecting2',
    [CONNECTED_PHONE_NUMBER]: 'presenceStatus.connected',
    [CONNECTED_USER]: 'presenceStatus.connected',
    [DISCONNECTED]: 'presenceStatus.disconnected'
};


################################################################################

## File: .\jitsi-meet\react\features\presence-status\functions.ts

/**
 * Tells whether presence status should be displayed.
 *
 * @returns {boolean}
 */
export function presenceStatusDisabled() {
    return Boolean(typeof interfaceConfig !== 'undefined' && interfaceConfig?.DISABLE_PRESENCE_STATUS);
}


################################################################################

## File: .\jitsi-meet\react\features\reactions\actions.any.ts

import { IStore } from '../app/types';

import {
    ADD_REACTION_BUFFER,
    ADD_REACTION_MESSAGE,
    FLUSH_REACTION_BUFFER,
    PUSH_REACTIONS,
    SEND_REACTIONS,
    SET_REACTION_QUEUE,
    SHOW_SOUNDS_NOTIFICATION
} from './actionTypes';
import { IReactionEmojiProps } from './constants';
import { IReactionsAction } from './reducer';

/**
 * Sets the reaction queue.
 *
 * @param {Array} queue - The new queue.
 * @returns {IReactionsAction}
 */
export function setReactionQueue(queue: Array<IReactionEmojiProps>): IReactionsAction {
    return {
        type: SET_REACTION_QUEUE,
        queue
    };
}


/**
 * Removes a reaction from the queue.
 *
 * @param {string} uid - Id of the reaction to be removed.
 * @returns {Function}
 */
export function removeReaction(uid: string): any {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const queue = getState()['features/reactions'].queue;

        dispatch(setReactionQueue(queue.filter((reaction: IReactionEmojiProps) => reaction.uid !== uid)));
    };
}


/**
 * Sends the reactions buffer to everyone in the conference.
 *
 * @returns {IReactionsAction}
 */
export function sendReactions(): IReactionsAction {
    return {
        type: SEND_REACTIONS
    };
}

/**
 * Adds a reaction to the local buffer.
 *
 * @param {string} reaction - The reaction to be added.
 * @returns {IReactionsAction}
 */
export function addReactionToBuffer(reaction: string): IReactionsAction {
    return {
        type: ADD_REACTION_BUFFER,
        reaction
    };
}

/**
 * Clears the reaction buffer.
 *
 * @returns {IReactionsAction}
 */
export function flushReactionBuffer(): IReactionsAction {
    return {
        type: FLUSH_REACTION_BUFFER
    };
}

/**
 * Adds a reaction message to the chat.
 *
 * @param {string} message - The reaction message.
 * @returns {IReactionsAction}
 */
export function addReactionsToChat(message: string): IReactionsAction {
    return {
        type: ADD_REACTION_MESSAGE,
        message
    };
}

/**
 * Adds reactions to the animation queue.
 *
 * @param {Array} reactions - The reactions to be animated.
 * @returns {IReactionsAction}
 */
export function pushReactions(reactions: Array<string>): IReactionsAction {
    return {
        type: PUSH_REACTIONS,
        reactions
    };
}

/**
 * Displays the disable sounds notification.
 *
 * @returns {void}
 */
export function displayReactionSoundsNotification(): IReactionsAction {
    return {
        type: SHOW_SOUNDS_NOTIFICATION
    };
}


################################################################################

## File: .\jitsi-meet\react\features\reactions\actions.native.ts

export * from './actions.any';


################################################################################

## File: .\jitsi-meet\react\features\reactions\actions.web.ts

import {
    TOGGLE_REACTIONS_VISIBLE
} from './actionTypes';
import { IReactionsAction } from './reducer';

export * from './actions.any';

/**
 * Toggles the visibility of the reactions menu.
 *
 * @returns {void}
 */
export function toggleReactionsMenuVisibility(): IReactionsAction {
    return {
        type: TOGGLE_REACTIONS_VISIBLE
    };
}


################################################################################

## File: .\jitsi-meet\react\features\reactions\actionTypes.ts

/**
 * The type of the (redux) action which shows/hides the reactions menu.
 *
 * {
 *     type: TOGGLE_REACTIONS_VISIBLE,
 *     visible: boolean
 * }
 */
export const TOGGLE_REACTIONS_VISIBLE = 'TOGGLE_REACTIONS_VISIBLE';

/**
 * The type of the action which adds a new reaction to the reactions message and sets
 * a new timeout.
 *
 * {
 *     type: ADD_REACTION_BUFFER,
 *     message: string,
 *     timeoutID: number
 * }
 */
export const ADD_REACTION_BUFFER = 'ADD_REACTION_BUFFER';

/**
 * The type of the action which sends the reaction buffer and resets it.
 *
 * {
 *     type: FLUSH_REACTION_BUFFER
 * }
 */
export const FLUSH_REACTION_BUFFER = 'FLUSH_REACTION_BUFFER';

/**
 * The type of the action which adds a new reaction message to the chat.
 *
 * {
 *     type: ADD_REACTION_MESSAGE,
 *     message: string,
 * }
 */
export const ADD_REACTION_MESSAGE = 'ADD_REACTION_MESSAGE';

/**
 * The type of the action which sets the reactions queue.
 *
 * {
 *     type: SET_REACTION_QUEUE,
 *     value: Array
 * }
 */
export const SET_REACTION_QUEUE = 'SET_REACTION_QUEUE';

/**
 * The type of the action which signals a send reaction to everyone in the conference.
 */
export const SEND_REACTIONS = 'SEND_REACTIONS';

/**
 * The type of action to adds reactions to the queue.
 */
export const PUSH_REACTIONS = 'PUSH_REACTIONS';

/**
 * The type of action to display disable notification sounds.
 */
export const SHOW_SOUNDS_NOTIFICATION = 'SHOW_SOUNDS_NOTIFICATION';


################################################################################

## File: .\jitsi-meet\react\features\reactions\constants.ts

import {
    BOO_SOUND_FILES,
    CLAP_SOUND_FILES,
    LAUGH_SOUND_FILES,
    LIKE_SOUND_FILES,
    SILENCE_SOUND_FILES,
    SURPRISE_SOUND_FILES
} from './sounds';

/**
 * The height of the raise hand row in the reactions menu.
 */
export const RAISE_HAND_ROW_HEIGHT = 54;

/**
 * The height of the gifs menu when displayed as part of the overflow menu.
 */
export const GIFS_MENU_HEIGHT_IN_OVERFLOW_MENU = 200;

/**
 * Reactions menu height when displayed as part of drawer.
 */
export const REACTIONS_MENU_HEIGHT_DRAWER = 144;

/**
 * Reactions menu height when displayed as part of overflow menu.
 */
export const REACTIONS_MENU_HEIGHT_IN_OVERFLOW_MENU = 106;

/**
 * The payload name for the datachannel/endpoint reaction event.
 */
export const ENDPOINT_REACTION_NAME = 'endpoint-reaction';

/**
 * The (name of the) command which transports the state (represented by
 * {State} for the local state at the time of this writing) of a {MuteReactions}
 * (instance) between moderator and participants.
 */
export const MUTE_REACTIONS_COMMAND = 'mute-reactions';

/**
 * The prefix for all reaction sound IDs. Also the ID used in config to disable reaction sounds.
 */
export const REACTION_SOUND = 'REACTION_SOUND';

/**
 * The audio ID prefix of the audio element for which the {@link playAudio} action is
 * triggered when a new laugh reaction is received.
 *
 * @type { string }
 */
export const LAUGH_SOUND_ID = `${REACTION_SOUND}_LAUGH_`;

/**
 * The audio ID prefix of the audio element for which the {@link playAudio} action is
 * triggered when a new clap reaction is received.
 *
 * @type {string}
 */
export const CLAP_SOUND_ID = `${REACTION_SOUND}_CLAP_`;

/**
 * The audio ID prefix of the audio element for which the {@link playAudio} action is
 * triggered when a new like reaction is received.
 *
 * @type {string}
 */
export const LIKE_SOUND_ID = `${REACTION_SOUND}_LIKE_`;

/**
 * The audio ID prefix of the audio element for which the {@link playAudio} action is
 * triggered when a new boo reaction is received.
 *
 * @type {string}
 */
export const BOO_SOUND_ID = `${REACTION_SOUND}_BOO_`;

/**
 * The audio ID prefix of the audio element for which the {@link playAudio} action is
 * triggered when a new surprised reaction is received.
 *
 * @type {string}
 */
export const SURPRISE_SOUND_ID = `${REACTION_SOUND}_SURPRISE_`;

/**
 * The audio ID prefix of the audio element for which the {@link playAudio} action is
 * triggered when a new silence reaction is received.
 *
 * @type {string}
 */
export const SILENCE_SOUND_ID = `${REACTION_SOUND}_SILENCE_`;

/**
 * The audio ID of the audio element for which the {@link playAudio} action is
 * triggered when a new raise hand event is received.
 *
 * @type {string}
 */
export const RAISE_HAND_SOUND_ID = 'RAISE_HAND_SOUND';

export interface IReactionEmojiProps {

    /**
     * Reaction to be displayed.
     */
    reaction: string;

    /**
     * Id of the reaction.
     */
    uid: string;
}

export const SOUNDS_THRESHOLDS = [ 1, 4, 10 ];

interface IReactions {
    [key: string]: {
        emoji: string;
        message: string;
        shortcutChar: string;
        soundFiles: string[];
        soundId: string;
    };
}

export const REACTIONS: IReactions = {
    like: {
        message: ':thumbs_up:',
        emoji: '👍',
        shortcutChar: 'T',
        soundId: LIKE_SOUND_ID,
        soundFiles: LIKE_SOUND_FILES
    },
    clap: {
        message: ':clap:',
        emoji: '👏',
        shortcutChar: 'C',
        soundId: CLAP_SOUND_ID,
        soundFiles: CLAP_SOUND_FILES
    },
    laugh: {
        message: ':grinning_face:',
        emoji: '😀',
        shortcutChar: 'L',
        soundId: LAUGH_SOUND_ID,
        soundFiles: LAUGH_SOUND_FILES
    },
    surprised: {
        message: ':face_with_open_mouth:',
        emoji: '😮',
        shortcutChar: 'O',
        soundId: SURPRISE_SOUND_ID,
        soundFiles: SURPRISE_SOUND_FILES
    },
    boo: {
        message: ':slightly_frowning_face:',
        emoji: '🙁',
        shortcutChar: 'B',
        soundId: BOO_SOUND_ID,
        soundFiles: BOO_SOUND_FILES
    },
    silence: {
        message: ':face_without_mouth:',
        emoji: '😶',
        shortcutChar: 'S',
        soundId: SILENCE_SOUND_ID,
        soundFiles: SILENCE_SOUND_FILES
    }
};

export type ReactionThreshold = {
    reaction: string;
    threshold: number;
};

export interface IMuteCommandAttributes {
    startReactionsMuted?: string;
}


################################################################################

## File: .\jitsi-meet\react\features\reactions\functions.any.ts

import { v4 as uuidv4 } from 'uuid';

import { IReduxState } from '../app/types';
import { REACTIONS_ENABLED } from '../base/flags/constants';
import { getFeatureFlag } from '../base/flags/functions';
import { getLocalParticipant } from '../base/participants/functions';
import { extractFqnFromPath } from '../dynamic-branding/functions.any';
import { iAmVisitor } from '../visitors/functions';

import { IReactionEmojiProps, REACTIONS, ReactionThreshold, SOUNDS_THRESHOLDS } from './constants';
import logger from './logger';

/**
 * Returns the queue of reactions.
 *
 * @param {Object} state - The state of the application.
 * @returns {Array}
 */
export function getReactionsQueue(state: IReduxState): Array<IReactionEmojiProps> {
    return state['features/reactions'].queue;
}

/**
 * Returns chat message from reactions buffer.
 *
 * @param {Array} buffer - The reactions buffer.
 * @returns {string}
 */
export function getReactionMessageFromBuffer(buffer: Array<string>): string {
    return buffer.map<string>(reaction => REACTIONS[reaction].message).reduce((acc, val) => `${acc}${val}`);
}

/**
 * Returns reactions array with uid.
 *
 * @param {Array} buffer - The reactions buffer.
 * @returns {Array}
 */
export function getReactionsWithId(buffer: Array<string>): Array<IReactionEmojiProps> {
    return buffer.map<IReactionEmojiProps>(reaction => {
        return {
            reaction,
            uid: uuidv4()
        };
    });
}

/**
 * Sends reactions to the backend.
 *
 * @param {Object} state - The redux state object.
 * @param {Array} reactions - Reactions array to be sent.
 * @returns {void}
 */
export async function sendReactionsWebhook(state: IReduxState, reactions: Array<string>) {
    const { webhookProxyUrl: url } = state['features/base/config'];
    const { conference } = state['features/base/conference'];
    const { jwt } = state['features/base/jwt'];
    const { connection } = state['features/base/connection'];
    const jid = connection?.getJid();
    const localParticipant = getLocalParticipant(state);

    const headers = {
        ...jwt ? { 'Authorization': `Bearer ${jwt}` } : {},
        'Content-Type': 'application/json'
    };


    const reqBody = {
        meetingFqn: extractFqnFromPath(),
        sessionId: conference?.sessionId,
        submitted: Date.now(),
        reactions,
        participantId: localParticipant?.jwtId,
        participantName: localParticipant?.name,
        participantJid: jid
    };

    if (url) {
        try {
            const res = await fetch(`${url}/reactions`, {
                method: 'POST',
                headers,
                body: JSON.stringify(reqBody)
            });

            if (!res.ok) {
                logger.error('Status error:', res.status);
            }
        } catch (err) {
            logger.error('Could not send request', err);
        }
    }
}

/**
 * Returns unique reactions from the reactions buffer.
 *
 * @param {Array} reactions - The reactions buffer.
 * @returns {Array}
 */
function getUniqueReactions(reactions: Array<string>): Array<string> {
    return [ ...new Set(reactions) ];
}

/**
 * Returns frequency of given reaction in array.
 *
 * @param {Array} reactions - Array of reactions.
 * @param {string} reaction - Reaction to get frequency for.
 * @returns {number}
 */
function getReactionFrequency(reactions: Array<string>, reaction: string): number {
    return reactions.filter(r => r === reaction).length;
}

/**
 * Returns the threshold number for a given frequency.
 *
 * @param {number} frequency - Frequency of reaction.
 * @returns {number}
 */
function getSoundThresholdByFrequency(frequency: number): number {
    for (const i of SOUNDS_THRESHOLDS) {
        if (frequency <= i) {
            return i;
        }
    }

    return SOUNDS_THRESHOLDS[SOUNDS_THRESHOLDS.length - 1];
}

/**
 * Returns unique reactions with threshold.
 *
 * @param {Array} reactions - The reactions buffer.
 * @returns {Array}
 */
export function getReactionsSoundsThresholds(reactions: Array<string>): Array<ReactionThreshold> {
    const unique = getUniqueReactions(reactions);

    return unique.map<ReactionThreshold>(reaction => {
        return {
            reaction,
            threshold: getSoundThresholdByFrequency(getReactionFrequency(reactions, reaction))
        };
    });
}

/**
 * Whether or not the reactions are enabled.
 *
 * @param {Object} state - The Redux state object.
 * @returns {boolean}
 */
export function isReactionsEnabled(state: IReduxState): boolean {
    const { disableReactions } = state['features/base/config'];

    if (navigator.product === 'ReactNative') {
        return !disableReactions && getFeatureFlag(state, REACTIONS_ENABLED, true);
    }

    return !disableReactions;
}

/**
 * Returns true if the reactions buttons should be displayed anywhere on the page and false otherwise.
 *
 * @param {IReduxState} state - The redux state.
 * @returns {boolean}
 */
export function shouldDisplayReactionsButtons(state: IReduxState): boolean {
    return isReactionsEnabled(state) && !iAmVisitor(state);
}


################################################################################

## File: .\jitsi-meet\react\features\reactions\functions.native.ts

export * from './functions.any';


################################################################################

## File: .\jitsi-meet\react\features\reactions\functions.web.ts

import { IReduxState } from '../app/types';

import { isReactionsEnabled } from './functions.any';

export * from './functions.any';

/**
 * Returns the visibility state of the reactions menu.
 *
 * @param {Object} state - The state of the application.
 * @returns {boolean}
 */
export function getReactionsMenuVisibility(state: IReduxState): boolean {
    return state['features/reactions'].visible;
}

/**
 * Whether or not the reactions button is enabled.
 *
 * @param {Object} state - The Redux state object.
 * @returns {boolean}
 */
export function isReactionsButtonEnabled(state: IReduxState) {
    const { toolbarButtons } = state['features/toolbox'];

    return Boolean(toolbarButtons?.includes('reactions')) && isReactionsEnabled(state);
}


################################################################################

## File: .\jitsi-meet\react\features\reactions\hooks.web.ts

import { useSelector } from 'react-redux';

import ReactionsMenuButton from './components/web/ReactionsMenuButton';
import { isReactionsButtonEnabled } from './functions';

const reactions = {
    key: 'reactions',
    Content: ReactionsMenuButton,
    group: 2
};

/**
 * A hook that returns the reactions button if it is enabled and undefined otherwise.
 *
 *  @returns {Object | undefined}
 */
export function useReactionsButton() {
    const reactionsButtonEnabled = useSelector(isReactionsButtonEnabled);

    if (reactionsButtonEnabled) {
        return reactions;
    }
}


################################################################################

## File: .\jitsi-meet\react\features\reactions\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/base/reactions');


################################################################################

## File: .\jitsi-meet\react\features\reactions\middleware.ts

import { batch } from 'react-redux';
import { AnyAction } from 'redux';

import { createReactionSoundsDisabledEvent } from '../analytics/AnalyticsEvents';
import { sendAnalytics } from '../analytics/functions';
import { IStore } from '../app/types';
import { APP_WILL_MOUNT, APP_WILL_UNMOUNT } from '../base/app/actionTypes';
import { CONFERENCE_JOIN_IN_PROGRESS, SET_START_REACTIONS_MUTED } from '../base/conference/actionTypes';
import { setStartReactionsMuted } from '../base/conference/actions';
import {
    getParticipantById,
    getParticipantCount,
    isLocalParticipantModerator
} from '../base/participants/functions';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import { SETTINGS_UPDATED } from '../base/settings/actionTypes';
import { updateSettings } from '../base/settings/actions';
import { playSound, registerSound, unregisterSound } from '../base/sounds/actions';
import { getDisabledSounds } from '../base/sounds/functions.any';
import { showNotification } from '../notifications/actions';
import { NOTIFICATION_TIMEOUT_TYPE } from '../notifications/constants';

import {
    ADD_REACTION_BUFFER,
    FLUSH_REACTION_BUFFER,
    PUSH_REACTIONS,
    SEND_REACTIONS,
    SHOW_SOUNDS_NOTIFICATION
} from './actionTypes';
import {
    addReactionsToChat,
    displayReactionSoundsNotification,
    flushReactionBuffer,
    pushReactions,
    sendReactions,
    setReactionQueue
} from './actions';
import {
    ENDPOINT_REACTION_NAME,
    IMuteCommandAttributes,
    MUTE_REACTIONS_COMMAND,
    RAISE_HAND_SOUND_ID,
    REACTIONS,
    REACTION_SOUND,
    SOUNDS_THRESHOLDS
} from './constants';
import {
    getReactionMessageFromBuffer,
    getReactionsSoundsThresholds,
    getReactionsWithId,
    sendReactionsWebhook
} from './functions.any';
import logger from './logger';
import { RAISE_HAND_SOUND_FILE } from './sounds';

/**
 * Middleware which intercepts Reactions actions to handle changes to the
 * visibility timeout of the Reactions.
 *
 * @param {IStore} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register((store: IStore) => (next: Function) => (action: AnyAction) => {
    const { dispatch, getState } = store;

    switch (action.type) {
    case APP_WILL_MOUNT:
        batch(() => {
            Object.keys(REACTIONS).forEach(key => {
                for (let i = 0; i < SOUNDS_THRESHOLDS.length; i++) {
                    dispatch(registerSound(
                        `${REACTIONS[key].soundId}${SOUNDS_THRESHOLDS[i]}`,
                        REACTIONS[key].soundFiles[i]
                    )
                    );
                }
            }
            );
            dispatch(registerSound(RAISE_HAND_SOUND_ID, RAISE_HAND_SOUND_FILE));
        });
        break;

    case APP_WILL_UNMOUNT:
        batch(() => {
            Object.keys(REACTIONS).forEach(key => {
                for (let i = 0; i < SOUNDS_THRESHOLDS.length; i++) {
                    dispatch(unregisterSound(`${REACTIONS[key].soundId}${SOUNDS_THRESHOLDS[i]}`));
                }
            });
            dispatch(unregisterSound(RAISE_HAND_SOUND_ID));
        });
        break;

    case ADD_REACTION_BUFFER: {
        const { timeoutID, buffer } = getState()['features/reactions'];
        const { reaction } = action;

        clearTimeout(timeoutID ?? 0);
        buffer.push(reaction);
        action.buffer = buffer;
        action.timeoutID = setTimeout(() => {
            dispatch(flushReactionBuffer());
        }, 500);

        break;
    }
    case CONFERENCE_JOIN_IN_PROGRESS: {
        const { conference } = action;

        conference.addCommandListener(
            MUTE_REACTIONS_COMMAND, ({ attributes }: { attributes: IMuteCommandAttributes; }, id: any) => {
                _onMuteReactionsCommand(attributes, id, store);
            });
        break;
    }
    case FLUSH_REACTION_BUFFER: {
        const state = getState();
        const { buffer } = state['features/reactions'];
        const participantCount = getParticipantCount(state);

        batch(() => {
            if (participantCount > 1) {
                dispatch(sendReactions());
            }
            dispatch(addReactionsToChat(getReactionMessageFromBuffer(buffer)));
            dispatch(pushReactions(buffer));
        });

        sendReactionsWebhook(state, buffer);

        break;
    }

    case PUSH_REACTIONS: {
        const state = getState();
        const { queue, notificationDisplayed } = state['features/reactions'];
        const { soundsReactions } = state['features/base/settings'];
        const disabledSounds = getDisabledSounds(state);
        const reactions = action.reactions;

        batch(() => {
            if (!notificationDisplayed && soundsReactions && !disabledSounds.includes(REACTION_SOUND)
                && displayReactionSoundsNotification) {
                dispatch(displayReactionSoundsNotification());
            }
            if (soundsReactions) {
                const reactionSoundsThresholds = getReactionsSoundsThresholds(reactions);

                reactionSoundsThresholds.forEach(reaction =>
                    dispatch(playSound(`${REACTIONS[reaction.reaction].soundId}${reaction.threshold}`))
                );
            }
            dispatch(setReactionQueue([ ...queue, ...getReactionsWithId(reactions) ]));
        });
        break;
    }

    case SEND_REACTIONS: {
        const state = getState();
        const { buffer } = state['features/reactions'];
        const { conference } = state['features/base/conference'];

        if (conference) {
            conference.sendEndpointMessage('', {
                name: ENDPOINT_REACTION_NAME,
                reactions: buffer,
                timestamp: Date.now()
            });
        }
        break;
    }

    // Settings changed for mute reactions in the meeting
    case SET_START_REACTIONS_MUTED: {
        const state = getState();
        const { conference } = state['features/base/conference'];
        const { muted, updateBackend } = action;

        if (conference && isLocalParticipantModerator(state) && updateBackend) {
            conference.sendCommand(MUTE_REACTIONS_COMMAND, { attributes: { startReactionsMuted: Boolean(muted) } });
        }
        break;
    }

    case SETTINGS_UPDATED: {
        const { soundsReactions } = getState()['features/base/settings'];

        if (action.settings.soundsReactions === false && soundsReactions === true) {
            sendAnalytics(createReactionSoundsDisabledEvent());
        }
        break;
    }

    case SHOW_SOUNDS_NOTIFICATION: {
        const state = getState();
        const isModerator = isLocalParticipantModerator(state);
        const { disableReactionsModeration } = state['features/base/config'];

        const customActions = [ 'notify.reactionSounds' ];
        const customFunctions: Function[] = [ () => dispatch(updateSettings({
            soundsReactions: false
        })) ];

        if (isModerator && !disableReactionsModeration) {
            customActions.push('notify.reactionSoundsForAll');
            customFunctions.push(() => batch(() => {
                dispatch(setStartReactionsMuted(true));
                dispatch(updateSettings({ soundsReactions: false }));
            }));
        }

        dispatch(showNotification({
            titleKey: 'toolbar.disableReactionSounds',
            customActionNameKey: customActions,
            customActionHandler: customFunctions
        }, NOTIFICATION_TIMEOUT_TYPE.MEDIUM));
        break;
    }
    }

    return next(action);
});

/**
 * Notifies this instance about a "Mute Reaction Sounds" command received by the Jitsi
 * conference.
 *
 * @param {Object} attributes - The attributes carried by the command.
 * @param {string} id - The identifier of the participant who issuing the
 * command. A notable idiosyncrasy to be mindful of here is that the command
 * may be issued by the local participant.
 * @param {Object} store - The redux store. Used to calculate and dispatch
 * updates.
 * @private
 * @returns {void}
 */
function _onMuteReactionsCommand(attributes: IMuteCommandAttributes = {}, id: string, store: IStore) {
    const state = store.getState();

    // We require to know who issued the command because (1) only a
    // moderator is allowed to send commands and (2) a command MUST be
    // issued by a defined commander.
    if (typeof id === 'undefined') {
        return;
    }

    const participantSendingCommand = getParticipantById(state, id);

    // The Command(s) API will send us our own commands and we don't want
    // to act upon them.
    if (participantSendingCommand?.local) {
        return;
    }

    if (participantSendingCommand?.role !== 'moderator') {
        logger.warn('Received mute-reactions command not from moderator');

        return;
    }

    const oldState = Boolean(state['features/base/conference'].startReactionsMuted);

    const newState = attributes.startReactionsMuted === 'true';

    if (oldState !== newState) {
        batch(() => {
            store.dispatch(setStartReactionsMuted(newState));
            store.dispatch(updateSettings({ soundsReactions: !newState }));
        });
    }
}


################################################################################

## File: .\jitsi-meet\react\features\reactions\reducer.ts

import ReducerRegistry from '../base/redux/ReducerRegistry';

import {
    ADD_REACTION_BUFFER,
    FLUSH_REACTION_BUFFER,
    SET_REACTION_QUEUE,
    SHOW_SOUNDS_NOTIFICATION,
    TOGGLE_REACTIONS_VISIBLE
} from './actionTypes';
import { IReactionEmojiProps } from './constants';

export interface IReactionsState {

    /**
     * An array that contains the reactions buffer to be sent.
     */
    buffer: Array<string>;

    /**
     * Whether or not the disable reaction sounds notification was shown.
     */
    notificationDisplayed: boolean;

    /**
    * The array of reactions to animate.
    */
    queue: Array<IReactionEmojiProps>;

    /**
     * A number, non-zero value which identifies the timer created by a call
     * to setTimeout().
     */
    timeoutID: number | null;

    /**
     * The indicator that determines whether the reactions menu is visible.
     */
    visible: boolean;
}

export interface IReactionsAction extends Partial<IReactionsState> {

    /**
     * The message to be added to the chat.
     */
    message?: string;

    /**
     * The reaction to be added to buffer.
     */
    reaction?: string;

    /**
     * The reactions to be added to the animation queue.
     */
    reactions?: Array<string>;

    /**
     * The action type.
     */
    type: string;
}

/**
 * Returns initial state for reactions' part of Redux store.
 *
 * @private
 * @returns {IReactionsState}
 */
function _getInitialState(): IReactionsState {
    return {
        visible: false,
        buffer: [],
        timeoutID: null,
        queue: [],
        notificationDisplayed: false
    };
}

ReducerRegistry.register<IReactionsState>(
    'features/reactions',
    (state = _getInitialState(), action: IReactionsAction): IReactionsState => {
        switch (action.type) {

        case TOGGLE_REACTIONS_VISIBLE:
            return {
                ...state,
                visible: !state.visible
            };

        case ADD_REACTION_BUFFER:
            return {
                ...state,
                buffer: action.buffer ?? [],
                timeoutID: action.timeoutID ?? null
            };

        case FLUSH_REACTION_BUFFER:
            return {
                ...state,
                buffer: [],
                timeoutID: null
            };

        case SET_REACTION_QUEUE: {
            return {
                ...state,
                queue: action.queue ?? []
            };
        }

        case SHOW_SOUNDS_NOTIFICATION: {
            return {
                ...state,
                notificationDisplayed: true
            };
        }
        }

        return state;
    });


################################################################################

## File: .\jitsi-meet\react\features\reactions\sounds.ts

/**
 * The name of the bundled audio files which will be played for the laugh reaction sound.
 *
 * @type {Array<string>}
 */
export const LAUGH_SOUND_FILES = new Array(3).fill('reactions-laughter.mp3');

/**
 * The name of the bundled audio file which will be played for the clap reaction sound.
 *
 * @type {Array<string>}
 */
export const CLAP_SOUND_FILES = new Array(3).fill('reactions-applause.mp3');

/**
 * The name of the bundled audio file which will be played for the like reaction sound.
 *
 * @type {Array<string>}
 */
export const LIKE_SOUND_FILES = new Array(3).fill('reactions-thumbs-up.mp3');

/**
 * The name of the bundled audio file which will be played for the boo reaction sound.
 *
 * @type {Array<string>}
 */
export const BOO_SOUND_FILES = new Array(3).fill('reactions-boo.mp3');

/**
 * The name of the bundled audio file which will be played for the surprised reaction sound.
 *
 * @type {Array<string>}
 */
export const SURPRISE_SOUND_FILES = new Array(3).fill('reactions-surprise.mp3');

/**
 * The name of the bundled audio file which will be played for the silence reaction sound.
 *
 * @type {Array<string>}
 */
export const SILENCE_SOUND_FILES = new Array(3).fill('reactions-crickets.mp3');

/**
 * The name of the bundled audio file which will be played for the raise hand sound.
 *
 * @type {string}
 */
export const RAISE_HAND_SOUND_FILE = 'reactions-raised-hand.mp3';


################################################################################

## File: .\jitsi-meet\react\features\reactions\types.ts

export enum IReactionsMenuParent {
    Button = 1,
    OverflowMenu = 2,
    OverflowDrawer = 3
}


################################################################################

## File: .\jitsi-meet\react\features\reactions\components\native\ReactionsMenuButton.ts

import { connect } from 'react-redux';

import { IReduxState } from '../../../app/types';
import { openDialog } from '../../../base/dialog/actions';
import { isDialogOpen } from '../../../base/dialog/functions';
import { RAISE_HAND_ENABLED } from '../../../base/flags/constants';
import { getFeatureFlag } from '../../../base/flags/functions';
import { translate } from '../../../base/i18n/functions';
import { IconRaiseHand } from '../../../base/icons/svg';
import {
    getLocalParticipant, hasRaisedHand
} from '../../../base/participants/functions';
import AbstractButton, { IProps as AbstractButtonProps } from '../../../base/toolbox/components/AbstractButton';

import ReactionMenuDialog from './ReactionMenuDialog';

/**
 * The type of the React {@code Component} props of {@link ReactionsMenuButton}.
 */
interface IProps extends AbstractButtonProps {

    /**
     * Whether the participant raised their hand or not.
     */
    _raisedHand: boolean;

    /**
     * Whether or not the reactions menu is open.
     */
    _reactionsOpen: boolean;
}

/**
 * An implementation of a button to raise or lower hand.
 */
class ReactionsMenuButton extends AbstractButton<IProps> {
    accessibilityLabel = 'toolbar.accessibilityLabel.reactionsMenu';
    icon = IconRaiseHand;
    label = 'toolbar.openReactionsMenu';
    toggledLabel = 'toolbar.closeReactionsMenu';

    /**
     * Handles clicking / pressing the button.
     *
     * @override
     * @protected
     * @returns {void}
     */
    _handleClick() {
        this.props.dispatch(openDialog(ReactionMenuDialog));
    }

    /**
     * Indicates whether this button is in toggled state or not.
     *
     * @override
     * @protected
     * @returns {boolean}
     */
    _isToggled() {
        return this.props._raisedHand || this.props._reactionsOpen;
    }
}

/**
 * Maps part of the Redux state to the props of this component.
 *
 * @param {Object} state - The Redux state.
 * @param {Object} ownProps - The properties explicitly passed to the component instance.
 * @private
 * @returns {IProps}
 */
function _mapStateToProps(state: IReduxState, ownProps: any) {
    const _localParticipant = getLocalParticipant(state);
    const enabled = getFeatureFlag(state, RAISE_HAND_ENABLED, true);
    const { visible = enabled } = ownProps;

    return {
        _raisedHand: hasRaisedHand(_localParticipant),
        _reactionsOpen: isDialogOpen(state, ReactionMenuDialog),
        visible
    };
}

export default translate(connect(_mapStateToProps)(ReactionsMenuButton));


################################################################################

## File: .\jitsi-meet\react\features\reactions\components\native\styles.ts

import BaseTheme from '../../../base/ui/components/BaseTheme.native';

/**
 * The styles of the native components of the feature {@code reactions}.
 */
export default {
    raiseHandButton: {
        marginVertical: BaseTheme.spacing[3],
        width: 240
    }
};


################################################################################

## File: .\jitsi-meet\react\features\reactions\components\web\RaiseHandButton.ts

import { connect } from 'react-redux';

import { createToolbarEvent } from '../../../analytics/AnalyticsEvents';
import { sendAnalytics } from '../../../analytics/functions';
import { IReduxState, IStore } from '../../../app/types';
import { translate } from '../../../base/i18n/functions';
import { IconRaiseHand } from '../../../base/icons/svg';
import { raiseHand } from '../../../base/participants/actions';
import { getLocalParticipant, hasRaisedHand } from '../../../base/participants/functions';
import AbstractButton, { IProps as AbstractButtonProps } from '../../../base/toolbox/components/AbstractButton';


/**
 * The type of the React {@code Component} props of {@link RaiseHandButton}.
 */
interface IProps extends AbstractButtonProps {

    /**
     * Whether or not the click is disabled.
     */
    disableClick?: boolean;

    /**
     * Redux dispatch function.
     */
    dispatch: IStore['dispatch'];

    /**
     * Whether or not the hand is raised.
     */
    raisedHand: boolean;
}

/**
 * Implementation of a button for raising hand.
 */
class RaiseHandButton extends AbstractButton<IProps> {
    accessibilityLabel = 'toolbar.accessibilityLabel.raiseHand';
    toggledAccessibilityLabel = 'toolbar.accessibilityLabel.lowerHand';
    icon = IconRaiseHand;
    label = 'toolbar.raiseHand';
    toggledLabel = 'toolbar.lowerYourHand';
    tooltip = 'toolbar.raiseHand';
    toggledTooltip = 'toolbar.lowerYourHand';

    /**
     * Indicates whether this button is in toggled state or not.
     *
     * @override
     * @protected
     * @returns {boolean}
     */
    _isToggled() {
        return this.props.raisedHand;
    }

    /**
     * Handles clicking the button, and toggles the raise hand.
     *
     * @private
     * @returns {void}
     */
    _handleClick() {
        const { disableClick, dispatch, raisedHand } = this.props;

        if (disableClick) {
            return;
        }

        sendAnalytics(createToolbarEvent(
            'raise.hand',
            { enable: !raisedHand }));

        dispatch(raiseHand(!raisedHand));
    }
}


/**
 * Function that maps parts of Redux state tree into component props.
 *
 * @param {Object} state - Redux state.
 * @returns {Object}
 */
const mapStateToProps = (state: IReduxState) => {
    const localParticipant = getLocalParticipant(state);

    return {
        raisedHand: hasRaisedHand(localParticipant)
    };
};

export { RaiseHandButton };

export default translate(connect(mapStateToProps)(RaiseHandButton));


################################################################################

## File: .\jitsi-meet\react\features\recent-list\actions.ts

import {
    DELETE_RECENT_LIST_ENTRY,
    _STORE_CURRENT_CONFERENCE,
    _UPDATE_CONFERENCE_DURATION
} from './actionTypes';

/**
 * Deletes a recent list entry based on url and date.
 *
 * @param {Object} entryId - An object constructed of the url and the date of
 * the entry for easy identification.
 * @returns {{
 *     type: DELETE_RECENT_LIST_ENTRY,
 *     entryId: Object
 * }}
 */
export function deleteRecentListEntry(entryId: Object) {
    return {
        type: DELETE_RECENT_LIST_ENTRY,
        entryId
    };
}

/**
 * Action to initiate a new addition to the list.
 *
 * @param {Object} locationURL - The current location URL.
 * @protected
 * @returns {{
 *     type: _STORE_CURRENT_CONFERENCE,
 *     locationURL: Object
 * }}
 */
export function _storeCurrentConference(locationURL: Object) {
    return {
        type: _STORE_CURRENT_CONFERENCE,
        locationURL
    };
}

/**
 * Action to initiate the update of the duration of the last conference.
 *
 * @param {Object} locationURL - The current location URL.
 * @protected
 * @returns {{
 *     type: _UPDATE_CONFERENCE_DURATION,
 *     locationURL: Object
 * }}
 */
export function _updateConferenceDuration(locationURL: Object) {
    return {
        type: _UPDATE_CONFERENCE_DURATION,
        locationURL
    };
}


################################################################################

## File: .\jitsi-meet\react\features\recent-list\actionTypes.ts

/**
 * Action type to signal the deletion of a list entry.
 *
 * {
 *     type: DELETE_RECENT_LIST_ENTRY,
 *     entryId: Object
 * }
 */
export const DELETE_RECENT_LIST_ENTRY = 'DELETE_RECENT_LIST_ENTRY';

/**
 * Action type to signal a new addition to the list.
 *
 * {
 *     type: _STORE_CURRENT_CONFERENCE,
 *     locationURL: Object
 * }
 *
 * @protected
 */
export const _STORE_CURRENT_CONFERENCE = '_STORE_CURRENT_CONFERENCE';

/**
 * Action type to signal that a new conference duration info is available.
 *
 * {
 *     type: _UPDATE_CONFERENCE_DURATION,
 *     locationURL: Object
 * }
 *
 * @protected
 */
export const _UPDATE_CONFERENCE_DURATION
    = '_UPDATE_CONFERENCE_DURATION';


################################################################################

## File: .\jitsi-meet\react\features\recent-list\functions.native.ts

import {
    getLocalizedDateFormatter,
    getLocalizedDurationFormatter
} from '../base/i18n/dateUtil';
import NavigateSectionList from '../base/react/components/native/NavigateSectionList';
import { parseURIString, safeDecodeURIComponent } from '../base/util/uri';

import { IRecentItem } from './types';

/**
 * Creates a displayable list item of a recent list entry.
 *
 * @private
 * @param {Object} item - The recent list entry.
 * @param {string} defaultServerURL - The default server URL.
 * @param {Function} t - The translate function.
 * @returns {Object}
 */
function toDisplayableItem(item: IRecentItem,
        defaultServerURL: string, t: Function) {
    const location = parseURIString(item.conference);
    const baseURL = `${location.protocol}//${location.host}`;
    const serverName = baseURL === defaultServerURL ? null : location.host;

    return {
        colorBase: serverName,
        id: {
            date: item.date,
            url: item.conference
        },
        key: `key-${item.conference}-${item.date}`,
        lines: [
            _toDateString(item.date, t),
            _toDurationString(item.duration),
            serverName
        ],
        title: safeDecodeURIComponent(location.room),
        url: item.conference
    };
}

/**
 * Generates a duration string for the item.
 *
 * @private
 * @param {number} duration - The item's duration.
 * @returns {string}
 */
function _toDurationString(duration: number) {
    if (duration) {
        return getLocalizedDurationFormatter(duration);
    }

    return null;
}

/**
 * Generates a date string for the item.
 *
 * @private
 * @param {number} itemDate - The item's timestamp.
 * @param {Function} t - The translate function.
 * @returns {string}
 */
function _toDateString(itemDate: number, t: Function) {
    const m = getLocalizedDateFormatter(itemDate);
    const date = new Date(itemDate);
    const dateInMs = date.getTime();
    const now = new Date();
    const todayInMs = new Date().setHours(0, 0, 0, 0);
    const yesterdayInMs = todayInMs - 86400000; // 1 day = 86400000ms

    if (dateInMs >= todayInMs) {
        return m.fromNow();
    } else if (dateInMs >= yesterdayInMs) {
        return t('dateUtils.yesterday');
    } else if (date.getFullYear() !== now.getFullYear()) {
        // We only want to include the year in the date if its not the current
        // year.
        return m.format('ddd, MMMM DD h:mm A, gggg');
    }

    return m.format('ddd, MMMM DD h:mm A');
}

/**
 * Transforms the history list to a displayable list
 * with sections.
 *
 * @private
 * @param {Array<Object>} recentList - The recent list form the redux store.
 * @param {Function} t - The translate function.
 * @param {string} defaultServerURL - The default server URL.
 * @returns {Array<Object>}
 */
export function toDisplayableList(recentList: IRecentItem[],
        t: Function, defaultServerURL: string) {
    const { createSection } = NavigateSectionList;
    const todaySection = createSection(t('dateUtils.today'), 'today');
    const yesterdaySection
        = createSection(t('dateUtils.yesterday'), 'yesterday');
    const earlierSection
        = createSection(t('dateUtils.earlier'), 'earlier');
    const today = new Date();
    const todayString = today.toDateString();
    const yesterday = new Date();

    yesterday.setDate(yesterday.getDate() - 1);
    const yesterdayString = yesterday.toDateString();

    for (const item of recentList) {
        const itemDateString = new Date(item.date).toDateString();
        const displayableItem = toDisplayableItem(item, defaultServerURL, t);

        if (itemDateString === todayString) {
            todaySection.data.push(displayableItem);
        } else if (itemDateString === yesterdayString) {
            yesterdaySection.data.push(displayableItem);
        } else {
            earlierSection.data.push(displayableItem);
        }
    }
    const displayableList = [];

    // the recent list in the redux store has the latest date in the last index
    // therefore all the sectionLists' data that was created by parsing through
    // the recent list is in reverse order and must be reversed for the most
    // item to show first
    if (todaySection.data.length) {
        todaySection.data.reverse();
        displayableList.push(todaySection);
    }
    if (yesterdaySection.data.length) {
        yesterdaySection.data.reverse();
        displayableList.push(yesterdaySection);
    }
    if (earlierSection.data.length) {
        earlierSection.data.reverse();
        displayableList.push(earlierSection);
    }

    return displayableList;
}

/**
 * Returns <tt>true</tt> if recent list is enabled and <tt>false</tt> otherwise.
 *
 * @returns {boolean} <tt>true</tt> if recent list is enabled and <tt>false</tt>
 * otherwise.
 */
export function isRecentListEnabled() {
    return true;
}


################################################################################

## File: .\jitsi-meet\react\features\recent-list\functions.web.ts

import { parseURIString, safeDecodeURIComponent } from '../base/util/uri';


/**
 * Transforms the history list to a displayable list.
 *
 * @private
 * @param {Array<Object>} recentList - The recent list form the redux store.
 * @returns {Array<Object>}
 */
export function toDisplayableList(recentList: Array<{ conference: string; date: Date; duration: number; }>) {
    return (
        [ ...recentList ].reverse()
            .map(item => {
                return {
                    date: item.date,
                    duration: item.duration,
                    time: [ item.date ],
                    title: safeDecodeURIComponent(parseURIString(item.conference).room),
                    url: item.conference
                };
            }));
}

/**
 * Returns <tt>true</tt> if recent list is enabled and <tt>false</tt> otherwise.
 *
 * @returns {boolean} <tt>true</tt> if recent list is enabled and <tt>false</tt>
 * otherwise.
 */
export function isRecentListEnabled() {
    return interfaceConfig.RECENT_LIST_ENABLED;
}


################################################################################

## File: .\jitsi-meet\react\features\recent-list\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/recent-list');


################################################################################

## File: .\jitsi-meet\react\features\recent-list\middleware.ts

import { AnyAction } from 'redux';

import { IStore } from '../app/types';
import { APP_WILL_MOUNT } from '../base/app/actionTypes';
import { CONFERENCE_WILL_LEAVE, SET_ROOM } from '../base/conference/actionTypes';
import { JITSI_CONFERENCE_URL_KEY } from '../base/conference/constants';
import { addKnownDomains } from '../base/known-domains/actions';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import { inIframe } from '../base/util/iframeUtils';
import { parseURIString } from '../base/util/uri';

import { _storeCurrentConference, _updateConferenceDuration } from './actions';
import { isRecentListEnabled } from './functions';

/**
 * Middleware that captures joined rooms so they can be saved into
 * {@code window.localStorage}.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {
    if (isRecentListEnabled()) {
        switch (action.type) {
        case APP_WILL_MOUNT:
            return _appWillMount(store, next, action);

        case CONFERENCE_WILL_LEAVE:
            return _conferenceWillLeave(store, next, action);

        case SET_ROOM:
            return _setRoom(store, next, action);
        }
    }

    return next(action);
});

/**
 * Notifies the feature recent-list that the redux action {@link APP_WILL_MOUNT}
 * is being dispatched in a specific redux store.
 *
 * @param {Store} store - The redux store in which the specified action is being
 * dispatched.
 * @param {Dispatch} next - The redux {@code dispatch} function to dispatch the
 * specified action to the specified store.
 * @param {Action} action - The redux action {@code APP_WILL_MOUNT} which is
 * being dispatched in the specified redux store.
 * @private
 * @returns {*} The result returned by {@code next(action)}.
 */
function _appWillMount({ dispatch, getState }: IStore, next: Function, action: AnyAction) {
    const result = next(action);

    // It's an opportune time to transfer the feature recent-list's knowledge
    // about "known domains" (which is local to the feature) to the feature
    // base/known-domains (which is global to the app).
    //
    // XXX Since the feature recent-list predates the feature calendar-sync and,
    // consequently, the feature known-domains, it's possible for the feature
    // known-list to know of domains which the feature known-domains is yet to
    // discover.
    const knownDomains = [];

    for (const { conference } of getState()['features/recent-list']) {
        const uri = parseURIString(conference);
        let host;

        uri && (host = uri.host) && knownDomains.push(host);
    }
    knownDomains.length && dispatch(addKnownDomains(knownDomains));

    return result;
}

/**
 * Updates the duration of the last conference stored in the list.
 *
 * @param {Store} store - The redux store.
 * @param {Dispatch} next - The redux {@code dispatch} function.
 * @param {Action} action - The redux action {@link CONFERENCE_WILL_LEAVE}.
 * @private
 * @returns {*} The result returned by {@code next(action)}.
 */
function _conferenceWillLeave({ dispatch, getState }: IStore, next: Function, action: AnyAction) {
    const state = getState();
    const { doNotStoreRoom } = state['features/base/config'];

    if (!doNotStoreRoom && !inIframe()) {
        let locationURL;

        /**
         * FIXME:
         * It is better to use action.conference[JITSI_CONFERENCE_URL_KEY]
         * in order to make sure we get the url the conference is leaving
         * from (i.e. The room we are leaving from) because if the order of events
         * is different, we cannot be guaranteed that the location URL in base
         * connection is the url we are leaving from... Not the one we are going to
         * (the latter happens on mobile -- if we use the web implementation);
         * however, the conference object on web does not have
         * JITSI_CONFERENCE_URL_KEY so we cannot call it and must use the other way.
         */
        if (typeof APP === 'undefined') {
            const { conference } = action;

            // eslint-disable-next-line @typescript-eslint/prefer-optional-chain
            locationURL = conference && conference[JITSI_CONFERENCE_URL_KEY];
        } else {
            locationURL = state['features/base/connection'].locationURL;
        }
        dispatch(
            _updateConferenceDuration(
                locationURL
            ));
    }

    return next(action);
}

/**
 * Checks if there is a current conference (upon SET_ROOM action), and saves it
 * if necessary.
 *
 * @param {Store} store - The redux store.
 * @param {Dispatch} next - The redux {@code dispatch} function.
 * @param {Action} action - The redux action {@link SET_ROOM}.
 * @private
 * @returns {*} The result returned by {@code next(action)}.
 */
function _setRoom({ dispatch, getState }: IStore, next: Function, action: AnyAction) {
    const { doNotStoreRoom } = getState()['features/base/config'];

    if (!doNotStoreRoom && !inIframe() && action.room) {
        const { locationURL } = getState()['features/base/connection'];

        if (locationURL) {
            dispatch(_storeCurrentConference(locationURL));

            // Whatever domain the feature recent-list knows about, the app as a
            // whole should know about.
            //
            // XXX Technically, _storeCurrentConference could be turned into an
            // asynchronous action creator which dispatches both
            // _STORE_CURRENT_CONFERENCE and addKnownDomains but...
            dispatch(addKnownDomains(locationURL.host));
        }
    }

    return next(action);
}


################################################################################

## File: .\jitsi-meet\react\features\recent-list\reducer.ts

import { getURLWithoutParamsNormalized } from '../base/connection/utils';
import PersistenceRegistry from '../base/redux/PersistenceRegistry';
import ReducerRegistry from '../base/redux/ReducerRegistry';

import {
    DELETE_RECENT_LIST_ENTRY,
    _STORE_CURRENT_CONFERENCE,
    _UPDATE_CONFERENCE_DURATION
} from './actionTypes';
import { isRecentListEnabled } from './functions';

interface IRecent {
    conference: string;
    date: number;
    duration: number;
}

export type IRecentListState = IRecent[];

/**
 * The default/initial redux state of the feature {@code recent-list}.
 *
 * @type {IRecentListState}
 */
const DEFAULT_STATE: IRecentListState = [];

/**
 * The max size of the list.
 *
 * @type {number}
 */
export const MAX_LIST_SIZE = 30;

/**
 * The redux subtree of this feature.
 */
const STORE_NAME = 'features/recent-list';

/**
 * Sets up the persistence of the feature {@code recent-list}.
 */
PersistenceRegistry.register(STORE_NAME);

/**
 * Reduces redux actions for the purposes of the feature {@code recent-list}.
 */
ReducerRegistry.register<IRecentListState>(STORE_NAME, (state = DEFAULT_STATE, action): IRecentListState => {
    if (isRecentListEnabled()) {
        switch (action.type) {
        case DELETE_RECENT_LIST_ENTRY:
            return _deleteRecentListEntry(state, action.entryId);
        case _STORE_CURRENT_CONFERENCE:
            return _storeCurrentConference(state, action);
        case _UPDATE_CONFERENCE_DURATION:
            return _updateConferenceDuration(state, action);
        default:
            return state;
        }
    }

    return state;
});

/**
 * Deletes a recent list entry based on the url and date of the item.
 *
 * @param {IRecentListState} state - The Redux state.
 * @param {Object} entryId - The ID object of the entry.
 * @returns {IRecentListState}
 */
function _deleteRecentListEntry(
        state: Array<IRecent>, entryId: { date: number; url: string; }): Array<IRecent> {
    return state.filter(entry =>
        entry.conference !== entryId.url || entry.date !== entryId.date);
}

/**
 * Adds a new list entry to the redux store.
 *
 * @param {IRecentListState} state - The redux state of the feature {@code recent-list}.
 * @param {Object} action - The redux action.
 * @returns {Object}
 */
function _storeCurrentConference(state: IRecentListState, { locationURL }: { locationURL: { href: string; }; }) {
    const conference = getURLWithoutParamsNormalized(new URL(locationURL.href));

    // If the current conference is already in the list, we remove it to re-add
    // it to the top.
    const nextState
        = state.filter(e => !_urlStringEquals(e.conference, conference));

    // The list is a reverse-sorted (i.e. the newer elements are at the end).
    nextState.push({
        conference,
        date: Date.now(),
        duration: 0 // We don't have the duration yet!
    });

    // Ensure the list doesn't exceed a/the maximum size.
    nextState.splice(0, nextState.length - MAX_LIST_SIZE);

    return nextState;
}

/**
 * Updates the conference length when left.
 *
 * @param {IRecentListState} state - The redux state of the feature {@code recent-list}.
 * @param {Object} action - The redux action.
 * @returns {Object} The next redux state of the feature {@code recent-list}.
 */
function _updateConferenceDuration(state: IRecentListState, { locationURL }: { locationURL: { href: string; }; }) {
    if (locationURL?.href && state.length) {
        const mostRecentIndex = state.length - 1;
        const mostRecent = state[mostRecentIndex];

        if (_urlStringEquals(mostRecent.conference, locationURL.href)) {
            // The last conference start was stored so we need to update the
            // length.
            const nextMostRecent = {
                ...mostRecent,
                duration: Date.now() - mostRecent.date
            };

            // Shallow copy to avoid in-place modification.
            const nextState = state.slice();

            nextState[mostRecentIndex] = nextMostRecent;

            return nextState;
        }
    }

    return state;
}

/**
 * Determines whether two specific URL {@code strings} are equal in the sense
 * that they identify one and the same conference resource (irrespective of
 * time) for the purposes of the feature {@code recent-list}.
 *
 * @param {string} a - The URL {@code string} to test for equality to {@code b}.
 * @param {string} b - The URL {@code string} to test for equality to {@code a}.
 * @returns {boolean}
 */
function _urlStringEquals(a: string, b: string) {
    const aHref = getURLWithoutParamsNormalized(new URL(a));
    const bHref = getURLWithoutParamsNormalized(new URL(b));

    return aHref === bHref;
}


################################################################################

## File: .\jitsi-meet\react\features\recent-list\types.ts

export interface IRecentItem {
    conference: string;
    date: number;
    duration: number;
}


################################################################################

## File: .\jitsi-meet\react\features\recent-list\components\DeleteItemButton.native.ts

import { connect } from 'react-redux';

import { translate } from '../../base/i18n/functions';
import { IconTrash } from '../../base/icons/svg';
import AbstractButton, { IProps as AbstractButtonProps } from '../../base/toolbox/components/AbstractButton';
import { deleteRecentListEntry } from '../actions';

export interface IProps extends AbstractButtonProps {

    /**
     * The ID of the entry to be deleted.
     */
    itemId: Object;
}

/**
 * A recent list menu button which deletes the selected entry.
 */
class DeleteItemButton extends AbstractButton<IProps> {
    accessibilityLabel = 'welcomepage.recentListDelete';
    icon = IconTrash;
    label = 'welcomepage.recentListDelete';

    /**
     * Handles clicking / pressing the button.
     *
     * @private
     * @returns {void}
     */
    _handleClick() {
        const { dispatch, itemId } = this.props;

        dispatch(deleteRecentListEntry(itemId));
    }
}

export default translate(connect()(DeleteItemButton));


################################################################################

## File: .\jitsi-meet\react\features\recent-list\components\styles.native.ts

import { ColorPalette } from '../../base/styles/components/styles/ColorPalette';
import { createStyleSheet } from '../../base/styles/functions.native';

/**
 * The styles of the React {@code Component}s of the feature recent-list i.e.
 * {@code CalendarList}.
 */
export default createStyleSheet({

    /**
     * Text style of the empty recent list message.
     */
    emptyListText: {
        backgroundColor: 'transparent',
        color: 'rgba(255, 255, 255, 0.6)',
        textAlign: 'center'
    },

    /**
     * The style of the empty recent list container.
     */
    emptyListContainer: {
        alignItems: 'center',
        justifyContent: 'center',
        padding: 20
    },

    entryNameContainer: {
        alignItems: 'center',
        borderBottomColor: ColorPalette.lightGrey,
        borderBottomWidth: 1,
        borderTopLeftRadius: 16,
        borderTopRightRadius: 16,
        flexDirection: 'row',
        justifyContent: 'center',
        height: 48
    },

    entryNameLabel: {
        color: ColorPalette.lightGrey,
        flexShrink: 1,
        fontSize: 16,
        opacity: 0.90
    }
});


################################################################################

## File: .\jitsi-meet\react\features\recent-list\components\styles.web.ts

export default {
    emptyListContainer: {},
    emptyListText: {}
};


################################################################################

## File: .\jitsi-meet\react\features\recording\actions.any.ts

import { IStore } from '../app/types';
import { getMeetingRegion, getRecordingSharingUrl } from '../base/config/functions';
import { isJwtFeatureEnabled } from '../base/jwt/functions';
import JitsiMeetJS, { JitsiRecordingConstants } from '../base/lib-jitsi-meet';
import {
    getLocalParticipant,
    getParticipantDisplayName,
    isLocalParticipantModerator
} from '../base/participants/functions';
import { BUTTON_TYPES } from '../base/ui/constants.any';
import { copyText } from '../base/util/copyText';
import { getVpaasTenant, isVpaasMeeting } from '../jaas/functions';
import {
    hideNotification,
    showErrorNotification,
    showNotification,
    showWarningNotification
} from '../notifications/actions';
import { NOTIFICATION_TIMEOUT_TYPE, NOTIFICATION_TYPE } from '../notifications/constants';
import { INotificationProps } from '../notifications/types';
import { setRequestingSubtitles } from '../subtitles/actions.any';
import { isRecorderTranscriptionsRunning } from '../transcribing/functions';

import {
    CLEAR_RECORDING_SESSIONS,
    RECORDING_SESSION_UPDATED,
    SET_MEETING_HIGHLIGHT_BUTTON_STATE,
    SET_PENDING_RECORDING_NOTIFICATION_UID,
    SET_SELECTED_RECORDING_SERVICE,
    SET_START_RECORDING_NOTIFICATION_SHOWN,
    SET_STREAM_KEY,
    START_LOCAL_RECORDING,
    STOP_LOCAL_RECORDING
} from './actionTypes';
import {
    RECORDING_METADATA_ID,
    START_RECORDING_NOTIFICATION_ID
} from './constants';
import {
    getRecordButtonProps,
    getRecordingLink,
    getResourceId,
    isRecordingRunning,
    isRecordingSharingEnabled,
    isSavingRecordingOnDropbox,
    sendMeetingHighlight,
    shouldAutoTranscribeOnRecord
} from './functions';
import logger from './logger';


/**
 * Clears the data of every recording sessions.
 *
 * @returns {{
 *     type: CLEAR_RECORDING_SESSIONS
 * }}
 */
export function clearRecordingSessions() {
    return {
        type: CLEAR_RECORDING_SESSIONS
    };
}


/**
 * Marks the start recording notification as shown.
 *
 * @returns {{
 *      type: SET_START_RECORDING_NOTIFICATION_SHOWN
 * }}
 */
export function setStartRecordingNotificationShown() {
    return {
        type: SET_START_RECORDING_NOTIFICATION_SHOWN
    };
}

/**
 * Sets the meeting highlight button disable state.
 *
 * @param {boolean} disabled - The disabled state value.
 * @returns {{
 *     type: CLEAR_RECORDING_SESSIONS
 * }}
 */
export function setHighlightMomentButtonState(disabled: boolean) {
    return {
        type: SET_MEETING_HIGHLIGHT_BUTTON_STATE,
        disabled
    };
}

/**
 * Signals that the pending recording notification should be removed from the
 * screen.
 *
 * @param {string} streamType - The type of the stream ({@code 'file'} or
 * {@code 'stream'}).
 * @returns {Function}
 */
export function hidePendingRecordingNotification(streamType: string) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const { pendingNotificationUids } = getState()['features/recording'];
        const pendingNotificationUid = pendingNotificationUids[streamType];

        if (pendingNotificationUid) {
            dispatch(hideNotification(pendingNotificationUid));
            dispatch(
                _setPendingRecordingNotificationUid(
                    undefined, streamType));
        }
    };
}

/**
 * Sets the stream key last used by the user for later reuse.
 *
 * @param {string} streamKey - The stream key to set.
 * @returns {{
 *     type: SET_STREAM_KEY,
 *     streamKey: string
 * }}
 */
export function setLiveStreamKey(streamKey: string) {
    return {
        type: SET_STREAM_KEY,
        streamKey
    };
}

/**
 * Signals that the pending recording notification should be shown on the
 * screen.
 *
 * @param {string} streamType - The type of the stream ({@code file} or
 * {@code stream}).
 * @returns {Function}
 */
export function showPendingRecordingNotification(streamType: string) {
    return (dispatch: IStore['dispatch']) => {
        const isLiveStreaming
            = streamType === JitsiMeetJS.constants.recording.mode.STREAM;
        const dialogProps = isLiveStreaming ? {
            descriptionKey: 'liveStreaming.pending',
            titleKey: 'dialog.liveStreaming'
        } : {
            descriptionKey: 'recording.pending',
            titleKey: 'dialog.recording'
        };
        const notification = dispatch(showNotification({
            ...dialogProps
        }, NOTIFICATION_TIMEOUT_TYPE.MEDIUM));

        if (notification) {
            dispatch(_setPendingRecordingNotificationUid(notification.uid, streamType));
        }
    };
}

/**
 * Highlights a meeting moment.
 *
 * {@code stream}).
 *
 * @returns {Function}
 */
export function highlightMeetingMoment() {
    return async (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        dispatch(setHighlightMomentButtonState(true));

        const success = await sendMeetingHighlight(getState());

        if (success) {
            dispatch(showNotification({
                descriptionKey: 'recording.highlightMomentSucessDescription',
                titleKey: 'recording.highlightMomentSuccess'
            }, NOTIFICATION_TIMEOUT_TYPE.SHORT));
        }

        dispatch(setHighlightMomentButtonState(false));
    };
}

/**
 * Signals that the recording error notification should be shown.
 *
 * @param {Object} props - The Props needed to render the notification.
 * @returns {showErrorNotification}
 */
export function showRecordingError(props: Object) {
    return showErrorNotification(props, NOTIFICATION_TIMEOUT_TYPE.LONG);
}

/**
 * Signals that the recording warning notification should be shown.
 *
 * @param {Object} props - The Props needed to render the notification.
 * @returns {showWarningNotification}
 */
export function showRecordingWarning(props: Object) {
    return showWarningNotification(props);
}

/**
 * Signals that the stopped recording notification should be shown on the
 * screen for a given period.
 *
 * @param {string} streamType - The type of the stream ({@code file} or
 * {@code stream}).
 * @param {string?} participantName - The participant name stopping the recording.
 * @returns {showNotification}
 */
export function showStoppedRecordingNotification(streamType: string, participantName?: string) {
    const isLiveStreaming
        = streamType === JitsiMeetJS.constants.recording.mode.STREAM;
    const descriptionArguments = { name: participantName };
    const dialogProps = isLiveStreaming ? {
        descriptionKey: participantName ? 'liveStreaming.offBy' : 'liveStreaming.off',
        descriptionArguments,
        titleKey: 'dialog.liveStreaming'
    } : {
        descriptionKey: participantName ? 'recording.offBy' : 'recording.off',
        descriptionArguments,
        titleKey: 'dialog.recording'
    };

    return showNotification(dialogProps, NOTIFICATION_TIMEOUT_TYPE.SHORT);
}

/**
 * Signals that a started recording notification should be shown on the
 * screen for a given period.
 *
 * @param {string} mode - The type of the recording: Stream of File.
 * @param {string | Object } initiator - The participant who started recording.
 * @param {string} sessionId - The recording session id.
 * @returns {Function}
 */
export function showStartedRecordingNotification(
        mode: string,
        initiator: { getId: Function; } | string,
        sessionId: string) {
    return async (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const initiatorId = getResourceId(initiator);
        const participantName = getParticipantDisplayName(state, initiatorId);
        const notifyProps: {
            dialogProps: INotificationProps;
            type: string;
        } = {
            dialogProps: {
                descriptionKey: participantName ? 'liveStreaming.onBy' : 'liveStreaming.on',
                descriptionArguments: { name: participantName },
                titleKey: 'dialog.liveStreaming'
            },
            type: NOTIFICATION_TIMEOUT_TYPE.SHORT
        };

        if (mode !== JitsiMeetJS.constants.recording.mode.STREAM) {
            const recordingSharingUrl = getRecordingSharingUrl(state);
            const iAmRecordingInitiator = getLocalParticipant(state)?.id === initiatorId;

            notifyProps.dialogProps = {
                customActionHandler: undefined,
                customActionNameKey: undefined,
                descriptionKey: participantName ? 'recording.onBy' : 'recording.on',
                descriptionArguments: { name: participantName },
                titleKey: 'dialog.recording'
            };

            // fetch the recording link from the server for recording initiators in jaas meetings
            if (recordingSharingUrl
                && isVpaasMeeting(state)
                && iAmRecordingInitiator
                && !isSavingRecordingOnDropbox(state)) {
                const region = getMeetingRegion(state);
                const tenant = getVpaasTenant(state);

                try {
                    const response = await getRecordingLink(recordingSharingUrl, sessionId, region, tenant);
                    const { url: link, urlExpirationTimeMillis: ttl } = response;

                    if (typeof APP === 'object') {
                        APP.API.notifyRecordingLinkAvailable(link, ttl);
                    }

                    // add the option to copy recording link
                    notifyProps.dialogProps = {
                        ...notifyProps.dialogProps,
                        customActionNameKey: [ 'recording.copyLink' ],
                        customActionHandler: [ () => copyText(link) ],
                        titleKey: 'recording.on',
                        descriptionKey: 'recording.linkGenerated'
                    };

                    notifyProps.type = NOTIFICATION_TIMEOUT_TYPE.STICKY;
                } catch (err) {
                    dispatch(showErrorNotification({
                        titleKey: 'recording.errorFetchingLink'
                    }, NOTIFICATION_TIMEOUT_TYPE.MEDIUM));

                    return logger.error('Could not fetch recording link', err);
                }
            }
        }

        dispatch(showNotification(notifyProps.dialogProps, notifyProps.type));
    };
}

/**
 * Updates the known state for a given recording session.
 *
 * @param {Object} session - The new state to merge with the existing state in
 * redux.
 * @returns {{
 *     type: RECORDING_SESSION_UPDATED,
 *     sessionData: Object
 * }}
 */
export function updateRecordingSessionData(session: any) {
    const status = session.getStatus();
    const timestamp
        = status === JitsiRecordingConstants.status.ON
            ? Date.now() / 1000
            : undefined;

    return {
        type: RECORDING_SESSION_UPDATED,
        sessionData: {
            error: session.getError(),
            id: session.getID(),
            initiator: session.getInitiator(),
            liveStreamViewURL: session.getLiveStreamViewURL(),
            mode: session.getMode(),
            status,
            terminator: session.getTerminator(),
            timestamp
        }
    };
}

/**
 * Sets the selected recording service.
 *
 * @param {string} selectedRecordingService - The new selected recording service.
 * @returns {Object}
 */
export function setSelectedRecordingService(selectedRecordingService: string) {
    return {
        type: SET_SELECTED_RECORDING_SERVICE,
        selectedRecordingService
    };
}

/**
 * Sets UID of the the pending streaming notification to use it when hinding
 * the notification is necessary, or unsets it when undefined (or no param) is
 * passed.
 *
 * @param {?number} uid - The UID of the notification.
 * @param {string} streamType - The type of the stream ({@code file} or
 * {@code stream}).
 * @returns {{
 *     type: SET_PENDING_RECORDING_NOTIFICATION_UID,
 *     streamType: string,
 *     uid: number
 * }}
 */
function _setPendingRecordingNotificationUid(uid: string | undefined, streamType: string) {
    return {
        type: SET_PENDING_RECORDING_NOTIFICATION_UID,
        streamType,
        uid
    };
}

/**
 * Starts local recording.
 *
 * @param {boolean} onlySelf - Whether to only record the local streams.
 * @returns {Object}
 */
export function startLocalVideoRecording(onlySelf?: boolean) {
    return {
        type: START_LOCAL_RECORDING,
        onlySelf
    };
}

/**
 * Stops local recording.
 *
 * @returns {Object}
 */
export function stopLocalVideoRecording() {
    return {
        type: STOP_LOCAL_RECORDING
    };
}

/**
 * Displays the notification suggesting to start the recording.
 *
 * @param {Function} openRecordingDialog - The callback to open the recording dialog.
 * @returns {void}
 */
export function showStartRecordingNotificationWithCallback(openRecordingDialog: Function) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        let state = getState();
        const { recordings } = state['features/base/config'];
        const { suggestRecording } = recordings || {};
        const recordButtonProps = getRecordButtonProps(state);
        const isAlreadyRecording = isRecordingRunning(state) || isRecorderTranscriptionsRunning(state);
        const wasNotificationShown = state['features/recording'].wasStartRecordingSuggested;

        if (!suggestRecording
            || isAlreadyRecording
            || !recordButtonProps.visible
            || recordButtonProps.disabled
            || wasNotificationShown) {
            return;
        }

        dispatch(setStartRecordingNotificationShown());
        dispatch(showNotification({
            titleKey: 'notify.suggestRecordingTitle',
            descriptionKey: 'notify.suggestRecordingDescription',
            uid: START_RECORDING_NOTIFICATION_ID,
            customActionType: [ BUTTON_TYPES.PRIMARY ],
            customActionNameKey: [ 'notify.suggestRecordingAction' ],
            customActionHandler: [ () => {
                state = getState();
                const isModerator = isLocalParticipantModerator(state);
                const { recordingService } = state['features/base/config'];
                const canBypassDialog = recordingService?.enabled
                    && isJwtFeatureEnabled(state, 'recording', isModerator, false);

                if (canBypassDialog) {
                    const options = {
                        'file_recording_metadata': {
                            share: isRecordingSharingEnabled(state)
                        }
                    };

                    const { conference } = state['features/base/conference'];
                    const autoTranscribeOnRecord = shouldAutoTranscribeOnRecord(state);

                    conference?.startRecording({
                        mode: JitsiRecordingConstants.mode.FILE,
                        appData: JSON.stringify(options)
                    });

                    if (autoTranscribeOnRecord) {
                        conference?.getMetadataHandler().setMetadata(RECORDING_METADATA_ID, {
                            isTranscribingEnabled: true
                        });
                        dispatch(setRequestingSubtitles(true, false, null));
                    }
                } else {
                    openRecordingDialog();
                }

                dispatch(hideNotification(START_RECORDING_NOTIFICATION_ID));
            } ],
            appearance: NOTIFICATION_TYPE.NORMAL
        }, NOTIFICATION_TIMEOUT_TYPE.LONG));
    };
}


################################################################################

## File: .\jitsi-meet\react\features\recording\actions.native.ts

import { IStore } from '../app/types';
import { openSheet } from '../base/dialog/actions';
import JitsiMeetJS from '../base/lib-jitsi-meet';
import { navigate } from '../mobile/navigation/components/conference/ConferenceNavigationContainerRef';
import { screen } from '../mobile/navigation/routes';
import { showNotification } from '../notifications/actions';
import { NOTIFICATION_TIMEOUT_TYPE } from '../notifications/constants';

import { showStartRecordingNotificationWithCallback } from './actions.any';
import HighlightDialog from './components/Recording/native/HighlightDialog';

export * from './actions.any';

/**
 * Opens the highlight dialog.
 *
 * @returns {Function}
 */
export function openHighlightDialog() {
    return (dispatch: IStore['dispatch']) => {
        dispatch(openSheet(HighlightDialog));
    };
}

/**
 * Signals that a started recording notification should be shown on the
 * screen for a given period.
 *
 * @param {string} streamType - The type of the stream ({@code file} or
 * {@code stream}).
 * @returns {showNotification}
 */
export function showRecordingLimitNotification(streamType: string) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const isLiveStreaming = streamType === JitsiMeetJS.constants.recording.mode.STREAM;
        let descriptionKey, titleKey;

        if (isLiveStreaming) {
            descriptionKey = 'liveStreaming.limitNotificationDescriptionNative';
            titleKey = 'dialog.liveStreaming';
        } else {
            descriptionKey = 'recording.limitNotificationDescriptionNative';
            titleKey = 'dialog.recording';
        }

        const { recordingLimit = {} } = getState()['features/base/config'];
        const { limit, appName } = recordingLimit;

        return dispatch(showNotification({
            descriptionArguments: {
                limit,
                app: appName
            },
            descriptionKey,
            titleKey,
            maxLines: 2
        }, NOTIFICATION_TIMEOUT_TYPE.LONG));
    };
}

/**
 * Displays the notification suggesting to start the recording.
 *
 * @returns {void}
 */
export function showStartRecordingNotification() {
    return (dispatch: IStore['dispatch']) => {
        const openDialogCallback = () => navigate(screen.conference.recording);

        dispatch(showStartRecordingNotificationWithCallback(openDialogCallback));
    };
}


################################################################################

## File: .\jitsi-meet\react\features\recording\actionTypes.ts

/**
 * The type of Redux action which clears all the data of every sessions.
 *
 * {
 *     type: CLEAR_RECORDING_SESSIONS
 * }
 * @public
 */
export const CLEAR_RECORDING_SESSIONS = 'CLEAR_RECORDING_SESSIONS';

/**
 * The type of Redux action which updates the current known state of a recording
 * session.
 *
 * {
 *     type: RECORDING_SESSION_UPDATED,
 *     sessionData: Object
 * }
 * @public
 */
export const RECORDING_SESSION_UPDATED = 'RECORDING_SESSION_UPDATED';

/**
 * The type of Redux action which sets the pending recording notification UID to
 * use it for when hiding the notification is necessary, or unsets it when
 * undefined (or no param) is passed.
 *
 * {
 *     type: SET_PENDING_RECORDING_NOTIFICATION_UID,
 *     streamType: string,
 *     uid: ?number
 * }
 * @public
 */
export const SET_PENDING_RECORDING_NOTIFICATION_UID
    = 'SET_PENDING_RECORDING_NOTIFICATION_UID';

/**
 * The type of Redux action which sets the selected recording service.
 *
 * {
 *     type: SET_SELECTED_RECORDING_SERVICE
 * }
 * @public
 */
export const SET_SELECTED_RECORDING_SERVICE = 'SET_SELECTED_RECORDING_SERVICE';

/**
 * Sets the stream key last used by the user for later reuse.
 *
 * {
 *     type: SET_STREAM_KEY,
 *     streamKey: string
 * }
 */
export const SET_STREAM_KEY = 'SET_STREAM_KEY';

/**
 * Sets the enable state of the meeting highlight button.
 *
 * {
 *     type: SET_MEETING_HIGHLIGHT_BUTTON_STATE,
 *     disabled: boolean
 * }
 */
export const SET_MEETING_HIGHLIGHT_BUTTON_STATE = 'SET_MEETING_HIGHLIGHT_BUTTON_STATE';

/**
 * Attempts to start the local recording.
 *
 * {
 *     type: START_LOCAL_RECORDING,
 *     onlySelf: boolean
 * }
 */
export const START_LOCAL_RECORDING = 'START_LOCAL_RECORDING';

/**
 * Stops local recording.
 *
 * {
 *     type: STOP_LOCAL_RECORDING
 * }
 */
export const STOP_LOCAL_RECORDING = 'STOP_LOCAL_RECORDING';

/**
 * Indicates that the start recording notification has been shown.
 *
 * {
 *    type: SET_START_RECORDING_NOTIFICATION_SHOWN
 * }
 */
export const SET_START_RECORDING_NOTIFICATION_SHOWN = 'SET_START_RECORDING_NOTIFICATION_SHOWN';


################################################################################

## File: .\jitsi-meet\react\features\recording\constants.ts

import { JitsiRecordingConstants } from '../base/lib-jitsi-meet';


/**
 * The identifier of the sound to be played when a live streaming session is stopped.
 *
 * @type {string}
 */
export const LIVE_STREAMING_OFF_SOUND_ID = 'LIVE_STREAMING_OFF_SOUND';

/**
 * The identifier of the sound to be played when a live streaming session is started.
 *
 * @type {string}
 */
export const LIVE_STREAMING_ON_SOUND_ID = 'LIVE_STREAMING_ON_SOUND';

/**
 * The identifier of the prompt to start recording notification.
 *
 * @type {string}
 */
export const PROMPT_RECORDING_NOTIFICATION_ID = 'PROMPT_RECORDING_NOTIFICATION_ID';

/**
 * The identifier of the sound to be played when a recording session is stopped.
 *
 * @type {string}
 */
export const RECORDING_OFF_SOUND_ID = 'RECORDING_OFF_SOUND';

/**
 * The identifier of the sound to be played when a recording session is started.
 *
 * @type {string}
 */
export const RECORDING_ON_SOUND_ID = 'RECORDING_ON_SOUND';

/**
 * Expected supported recording types.
 *
 * @enum {string}
 */
export const RECORDING_TYPES = {
    JITSI_REC_SERVICE: 'recording-service',
    DROPBOX: 'dropbox',
    LOCAL: 'local'
};

/**
 * An array defining the priorities of the recording (or live streaming)
 * statuses, where the index of the array is the priority itself.
 *
 * @type {Array<string>}
 */
export const RECORDING_STATUS_PRIORITIES = [
    JitsiRecordingConstants.status.OFF,
    JitsiRecordingConstants.status.PENDING,
    JitsiRecordingConstants.status.ON
];

export const START_RECORDING_NOTIFICATION_ID = 'START_RECORDING_NOTIFICATION_ID';

export const RECORDING_METADATA_ID = 'recording';


################################################################################

## File: .\jitsi-meet\react\features\recording\functions.ts

import i18next from 'i18next';

import { IReduxState, IStore } from '../app/types';
import { isMobileBrowser } from '../base/environment/utils';
import { isJwtFeatureEnabled } from '../base/jwt/functions';
import { JitsiRecordingConstants, browser } from '../base/lib-jitsi-meet';
import { getSoundFileSrc } from '../base/media/functions';
import {
    getLocalParticipant,
    getRemoteParticipants,
    isLocalParticipantModerator
} from '../base/participants/functions';
import { registerSound, unregisterSound } from '../base/sounds/actions';
import { isInBreakoutRoom as isInBreakoutRoomF } from '../breakout-rooms/functions';
import { isEnabled as isDropboxEnabled } from '../dropbox/functions';
import { extractFqnFromPath } from '../dynamic-branding/functions.any';
import { canAddTranscriber, isRecorderTranscriptionsRunning } from '../transcribing/functions';

import LocalRecordingManager from './components/Recording/LocalRecordingManager';
import {
    LIVE_STREAMING_OFF_SOUND_ID,
    LIVE_STREAMING_ON_SOUND_ID,
    RECORDING_OFF_SOUND_ID,
    RECORDING_ON_SOUND_ID,
    RECORDING_STATUS_PRIORITIES,
    RECORDING_TYPES
} from './constants';
import logger from './logger';
import {
    LIVE_STREAMING_OFF_SOUND_FILE,
    LIVE_STREAMING_ON_SOUND_FILE,
    RECORDING_OFF_SOUND_FILE,
    RECORDING_ON_SOUND_FILE
} from './sounds';

/**
 * Searches in the passed in redux state for an active recording session of the
 * passed in mode.
 *
 * @param {Object} state - The redux state to search in.
 * @param {string} mode - Find an active recording session of the given mode.
 * @returns {Object|undefined}
 */
export function getActiveSession(state: IReduxState, mode: string) {
    const { sessionDatas } = state['features/recording'];
    const { status: statusConstants } = JitsiRecordingConstants;

    return sessionDatas.find(sessionData => sessionData.mode === mode
        && (sessionData.status === statusConstants.ON
            || sessionData.status === statusConstants.PENDING));
}

/**
 * Returns an estimated recording duration based on the size of the video file
 * in MB. The estimate is calculated under the assumption that 1 min of recorded
 * video needs 10MB of storage on average.
 *
 * @param {number} size - The size in MB of the recorded video.
 * @returns {number} - The estimated duration in minutes.
 */
export function getRecordingDurationEstimation(size?: number | null) {
    return Math.floor((size || 0) / 10);
}

/**
 * Searches in the passed in redux state for a recording session that matches
 * the passed in recording session ID.
 *
 * @param {Object} state - The redux state to search in.
 * @param {string} id - The ID of the recording session to find.
 * @returns {Object|undefined}
 */
export function getSessionById(state: IReduxState, id: string) {
    return state['features/recording'].sessionDatas.find(
        sessionData => sessionData.id === id);
}

/**
 * Fetches the recording link from the server.
 *
 * @param {string} url - The base url.
 * @param {string} recordingSessionId - The ID of the recording session to find.
 * @param {string} region - The meeting region.
 * @param {string} tenant - The meeting tenant.
 * @returns {Promise<any>}
 */
export async function getRecordingLink(url: string, recordingSessionId: string, region: string, tenant: string) {
    const fullUrl = `${url}?recordingSessionId=${recordingSessionId}&region=${region}&tenant=${tenant}`;
    const res = await fetch(fullUrl, {
        headers: {
            'Content-Type': 'application/json'
        }
    });
    const json = await res.json();

    return res.ok ? json : Promise.reject(json);
}

/**
 * Selector used for determining if recording is saved on dropbox.
 *
 * @param {Object} state - The redux state to search in.
 * @returns {string}
 */
export function isSavingRecordingOnDropbox(state: IReduxState) {
    return isDropboxEnabled(state)
        && state['features/recording'].selectedRecordingService === RECORDING_TYPES.DROPBOX;
}

/**
 * Selector used for determining disable state for the meeting highlight button.
 *
 * @param {Object} state - The redux state to search in.
 * @returns {string}
 */
export function isHighlightMeetingMomentDisabled(state: IReduxState) {
    return state['features/recording'].disableHighlightMeetingMoment;
}

/**
 * Returns the recording session status that is to be shown in a label. E.g. If
 * there is a session with the status OFF and one with PENDING, then the PENDING
 * one will be shown, because that is likely more important for the user to see.
 *
 * @param {Object} state - The redux state to search in.
 * @param {string} mode - The recording mode to get status for.
 * @returns {string|undefined}
 */
export function getSessionStatusToShow(state: IReduxState, mode: string): string | undefined {
    const recordingSessions = state['features/recording'].sessionDatas;
    let status;

    if (Array.isArray(recordingSessions)) {
        for (const session of recordingSessions) {
            if (session.mode === mode
                    && (!status
                        || (RECORDING_STATUS_PRIORITIES.indexOf(session.status)
                            > RECORDING_STATUS_PRIORITIES.indexOf(status)))) {
                status = session.status;
            }
        }
    }
    if (!status && mode === JitsiRecordingConstants.mode.FILE
            && (LocalRecordingManager.isRecordingLocally() || isRemoteParticipantRecordingLocally(state))) {
        status = JitsiRecordingConstants.status.ON;
    }

    return status;
}

/**
 * Check if local recording is supported.
 *
 * @returns {boolean} - Whether local recording is supported or not.
 */
export function supportsLocalRecording() {
    return browser.isChromiumBased() && !browser.isElectron() && !isMobileBrowser()
        && navigator.product !== 'ReactNative';
}

/**
 * Returns true if there is a cloud recording running.
 *
 * @param {IReduxState} state - The redux state to search in.
 * @returns {boolean}
 */
export function isCloudRecordingRunning(state: IReduxState) {
    return Boolean(getActiveSession(state, JitsiRecordingConstants.mode.FILE));
}

/**
 * Returns true if there is a live streaming running.
 *
 * @param {IReduxState} state - The redux state to search in.
 * @returns {boolean}
 */
export function isLiveStreamingRunning(state: IReduxState) {
    return Boolean(getActiveSession(state, JitsiRecordingConstants.mode.STREAM));
}

/**
 * Returns true if there is a recording session running.
 *
 * @param {Object} state - The redux state to search in.
 * @returns {boolean}
 */
export function isRecordingRunning(state: IReduxState) {
    return (
        isCloudRecordingRunning(state)
        || LocalRecordingManager.isRecordingLocally()
    );
}

/**
 * Returns true if the participant can stop recording.
 *
 * @param {Object} state - The redux state to search in.
 * @returns {boolean}
 */
export function canStopRecording(state: IReduxState) {
    if (LocalRecordingManager.isRecordingLocally()) {
        return true;
    }

    if (isCloudRecordingRunning(state) || isRecorderTranscriptionsRunning(state)) {
        const isModerator = isLocalParticipantModerator(state);

        return isJwtFeatureEnabled(state, 'recording', isModerator, false);
    }

    return false;
}

/**
 * Returns whether the transcription should start automatically when recording starts.
 *
 * @param {Object} state - The redux state to search in.
 * @returns {boolean}
 */
export function shouldAutoTranscribeOnRecord(state: IReduxState) {
    const { transcription } = state['features/base/config'];

    return (transcription?.autoTranscribeOnRecord ?? true) && canAddTranscriber(state);
}

/**
 * Returns whether the recording should be shared.
 *
 * @param {Object} state - The redux state to search in.
 * @returns {boolean}
 */
export function isRecordingSharingEnabled(state: IReduxState) {
    const { recordingService } = state['features/base/config'];

    return recordingService?.sharingEnabled ?? false;
}

/**
 * Returns the recording button props.
 *
 * @param {Object} state - The redux state to search in.
 *
 * @returns {{
 *    disabled: boolean,
 *    tooltip: string,
 *    visible: boolean
 * }}
 */
export function getRecordButtonProps(state: IReduxState) {
    let visible;

    // a button can be disabled/enabled if enableFeaturesBasedOnToken
    // is on or if the livestreaming is running.
    let disabled = false;
    let tooltip = '';

    // If the containing component provides the visible prop, that is one
    // above all, but if not, the button should be autonomus and decide on
    // its own to be visible or not.
    const isModerator = isLocalParticipantModerator(state);
    const {
        recordingService,
        localRecording
    } = state['features/base/config'];
    const localRecordingEnabled = !localRecording?.disable && supportsLocalRecording();

    const dropboxEnabled = isDropboxEnabled(state);
    const recordingEnabled = recordingService?.enabled || dropboxEnabled;

    if (localRecordingEnabled) {
        visible = true;
    } else if (isJwtFeatureEnabled(state, 'recording', isModerator, false)) {
        visible = recordingEnabled;
    }

    // disable the button if the livestreaming is running.
    if (visible && isLiveStreamingRunning(state)) {
        disabled = true;
        tooltip = 'dialog.recordingDisabledBecauseOfActiveLiveStreamingTooltip';
    }

    // disable the button if we are in a breakout room.
    if (isInBreakoutRoomF(state)) {
        disabled = true;
        visible = false;
    }

    return {
        disabled,
        tooltip,
        visible
    };
}

/**
 * Returns the resource id.
 *
 * @param {Object | string} recorder - A participant or it's resource.
 * @returns {string|undefined}
 */
export function getResourceId(recorder: string | { getId: Function; }) {
    if (recorder) {
        return typeof recorder === 'string'
            ? recorder
            : recorder.getId();
    }
}

/**
 * Sends a meeting highlight to backend.
 *
 * @param  {Object} state - Redux state.
 * @returns {boolean} - True if sent, false otherwise.
 */
export async function sendMeetingHighlight(state: IReduxState) {
    const { webhookProxyUrl: url } = state['features/base/config'];
    const { conference } = state['features/base/conference'];
    const { jwt } = state['features/base/jwt'];
    const { connection } = state['features/base/connection'];
    const jid = connection?.getJid();
    const localParticipant = getLocalParticipant(state);

    const headers = {
        ...jwt ? { 'Authorization': `Bearer ${jwt}` } : {},
        'Content-Type': 'application/json'
    };

    const reqBody = {
        meetingFqn: extractFqnFromPath(state),
        sessionId: conference?.getMeetingUniqueId(),
        submitted: Date.now(),
        participantId: localParticipant?.jwtId,
        participantName: localParticipant?.name,
        participantJid: jid
    };

    if (url) {
        try {
            const res = await fetch(`${url}/v2/highlights`, {
                method: 'POST',
                headers,
                body: JSON.stringify(reqBody)
            });

            if (res.ok) {
                return true;
            }
            logger.error('Status error:', res.status);
        } catch (err) {
            logger.error('Could not send request', err);
        }
    }

    return false;
}

/**
 * Whether a remote participant is recording locally or not.
 *
 * @param {Object} state - Redux state.
 * @returns {boolean}
 */
export function isRemoteParticipantRecordingLocally(state: IReduxState) {
    const participants = getRemoteParticipants(state);

    // eslint-disable-next-line prefer-const
    for (let value of participants.values()) {
        if (value.localRecording) {
            return true;
        }
    }

    return false;
}

/**
 * Unregisters the audio files based on locale.
 *
 * @param {Dispatch<any>} dispatch - The redux dispatch function.
 * @returns {void}
 */
export function unregisterRecordingAudioFiles(dispatch: IStore['dispatch']) {
    dispatch(unregisterSound(LIVE_STREAMING_OFF_SOUND_FILE));
    dispatch(unregisterSound(LIVE_STREAMING_ON_SOUND_FILE));
    dispatch(unregisterSound(RECORDING_OFF_SOUND_FILE));
    dispatch(unregisterSound(RECORDING_ON_SOUND_FILE));
}

/**
 * Registers the audio files based on locale.
 *
 * @param {Dispatch<any>} dispatch - The redux dispatch function.
 * @param {boolean|undefined} shouldUnregister - Whether the sounds should be unregistered.
 * @returns {void}
 */
export function registerRecordingAudioFiles(dispatch: IStore['dispatch'], shouldUnregister?: boolean) {
    const language = i18next.language;

    if (shouldUnregister) {
        unregisterRecordingAudioFiles(dispatch);
    }

    dispatch(registerSound(
        LIVE_STREAMING_OFF_SOUND_ID,
        getSoundFileSrc(LIVE_STREAMING_OFF_SOUND_FILE, language)));

    dispatch(registerSound(
        LIVE_STREAMING_ON_SOUND_ID,
        getSoundFileSrc(LIVE_STREAMING_ON_SOUND_FILE, language)));

    dispatch(registerSound(
        RECORDING_OFF_SOUND_ID,
        getSoundFileSrc(RECORDING_OFF_SOUND_FILE, language)));

    dispatch(registerSound(
        RECORDING_ON_SOUND_ID,
        getSoundFileSrc(RECORDING_ON_SOUND_FILE, language)));
}

/**
 * Returns true if the live-streaming button should be visible.
 *
 * @param {boolean} liveStreamingEnabled - True if the live-streaming is enabled.
 * @param {boolean} liveStreamingAllowed - True if the live-streaming feature is enabled in JWT
 *                                         or is a moderator if JWT is missing or features are missing in JWT.
 * @param {boolean} isInBreakoutRoom - True if in breakout room.
 * @returns {boolean}
 */
export function isLiveStreamingButtonVisible({
    liveStreamingAllowed,
    liveStreamingEnabled,
    isInBreakoutRoom
}: {
    isInBreakoutRoom: boolean;
    liveStreamingAllowed: boolean;
    liveStreamingEnabled: boolean;
}) {
    return !isInBreakoutRoom && liveStreamingEnabled && liveStreamingAllowed;
}


################################################################################

## File: .\jitsi-meet\react\features\recording\hooks.web.ts

import { useSelector } from 'react-redux';

import { IReduxState } from '../app/types';
import { isJwtFeatureEnabled } from '../base/jwt/functions';
import { isLocalParticipantModerator } from '../base/participants/functions';
import { isInBreakoutRoom } from '../breakout-rooms/functions';

import { getLiveStreaming } from './components/LiveStream/functions';
import LiveStreamButton from './components/LiveStream/web/LiveStreamButton';
import RecordButton from './components/Recording/web/RecordButton';
import { getRecordButtonProps, isLiveStreamingButtonVisible } from './functions';


const recording = {
    key: 'recording',
    Content: RecordButton,
    group: 2
};

const livestreaming = {
    key: 'livestreaming',
    Content: LiveStreamButton,
    group: 2
};

/**
 * A hook that returns the recording button if it is enabled and undefined otherwise.
 *
 *  @returns {Object | undefined}
 */
export function useRecordingButton() {
    const recordingProps = useSelector(getRecordButtonProps);
    const toolbarButtons = useSelector((state: IReduxState) => state['features/toolbox'].toolbarButtons);

    if (toolbarButtons?.includes('recording') && recordingProps.visible) {
        return recording;
    }

}

/**
 * A hook that returns the livestreaming button if it is enabled and undefined otherwise.
 *
 *  @returns {Object | undefined}
 */
export function useLiveStreamingButton() {
    const toolbarButtons = useSelector((state: IReduxState) => state['features/toolbox'].toolbarButtons);
    const localParticipantIsModerator = useSelector(isLocalParticipantModerator);
    const liveStreaming = useSelector(getLiveStreaming);
    const liveStreamingAllowed = useSelector((state: IReduxState) =>
        isJwtFeatureEnabled(state, 'livestreaming', localParticipantIsModerator, false));
    const _isInBreakoutRoom = useSelector(isInBreakoutRoom);

    if (toolbarButtons?.includes('recording')
            && isLiveStreamingButtonVisible({
                liveStreamingAllowed,
                liveStreamingEnabled: liveStreaming?.enabled,
                isInBreakoutRoom: _isInBreakoutRoom
            })) {
        return livestreaming;
    }
}


################################################################################

## File: .\jitsi-meet\react\features\recording\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/recording');


################################################################################

## File: .\jitsi-meet\react\features\recording\middleware.ts

import { createRecordingEvent } from '../analytics/AnalyticsEvents';
import { sendAnalytics } from '../analytics/functions';
import { IStore } from '../app/types';
import { APP_WILL_MOUNT, APP_WILL_UNMOUNT } from '../base/app/actionTypes';
import { CONFERENCE_JOIN_IN_PROGRESS } from '../base/conference/actionTypes';
import { getCurrentConference } from '../base/conference/functions';
import JitsiMeetJS, {
    JitsiConferenceEvents,
    JitsiRecordingConstants
} from '../base/lib-jitsi-meet';
import { MEDIA_TYPE } from '../base/media/constants';
import { PARTICIPANT_UPDATED } from '../base/participants/actionTypes';
import { updateLocalRecordingStatus } from '../base/participants/actions';
import { PARTICIPANT_ROLE } from '../base/participants/constants';
import { getLocalParticipant, getParticipantDisplayName } from '../base/participants/functions';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import StateListenerRegistry from '../base/redux/StateListenerRegistry';
import {
    playSound,
    stopSound
} from '../base/sounds/actions';
import { TRACK_ADDED } from '../base/tracks/actionTypes';
import { hideNotification, showErrorNotification, showNotification } from '../notifications/actions';
import { NOTIFICATION_TIMEOUT_TYPE } from '../notifications/constants';
import { isRecorderTranscriptionsRunning } from '../transcribing/functions';

import { RECORDING_SESSION_UPDATED, START_LOCAL_RECORDING, STOP_LOCAL_RECORDING } from './actionTypes';
import {
    clearRecordingSessions,
    hidePendingRecordingNotification,
    showPendingRecordingNotification,
    showRecordingError,
    showRecordingLimitNotification,
    showRecordingWarning,
    showStartRecordingNotification,
    showStartedRecordingNotification,
    showStoppedRecordingNotification,
    updateRecordingSessionData
} from './actions';
import LocalRecordingManager from './components/Recording/LocalRecordingManager';
import {
    LIVE_STREAMING_OFF_SOUND_ID,
    LIVE_STREAMING_ON_SOUND_ID,
    RECORDING_OFF_SOUND_ID,
    RECORDING_ON_SOUND_ID,
    START_RECORDING_NOTIFICATION_ID
} from './constants';
import {
    getResourceId,
    getSessionById,
    registerRecordingAudioFiles,
    unregisterRecordingAudioFiles
} from './functions';
import logger from './logger';

/**
 * StateListenerRegistry provides a reliable way to detect the leaving of a
 * conference, where we need to clean up the recording sessions.
 */
StateListenerRegistry.register(
    /* selector */ state => getCurrentConference(state),
    /* listener */ (conference, { dispatch }) => {
        if (!conference) {
            dispatch(clearRecordingSessions());
        }
    }
);

/**
 * The redux middleware to handle the recorder updates in a React way.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(({ dispatch, getState }) => next => action => {
    let oldSessionData;

    if (action.type === RECORDING_SESSION_UPDATED) {
        oldSessionData
            = getSessionById(getState(), action.sessionData.id);
    }

    const result = next(action);

    switch (action.type) {
    case APP_WILL_MOUNT:
        registerRecordingAudioFiles(dispatch);

        break;

    case APP_WILL_UNMOUNT:
        unregisterRecordingAudioFiles(dispatch);

        break;

    case CONFERENCE_JOIN_IN_PROGRESS: {
        const { conference } = action;

        conference.on(
            JitsiConferenceEvents.RECORDER_STATE_CHANGED,
            (recorderSession: any) => {
                if (recorderSession) {
                    recorderSession.getID() && dispatch(updateRecordingSessionData(recorderSession));
                    recorderSession.getError() && _showRecordingErrorNotification(recorderSession, dispatch, getState);
                }

                return;
            });

        break;
    }

    case START_LOCAL_RECORDING: {
        const { localRecording } = getState()['features/base/config'];
        const { onlySelf } = action;

        LocalRecordingManager.startLocalRecording({
            dispatch,
            getState
        }, action.onlySelf)
        .then(() => {
            const props = {
                descriptionKey: 'recording.on',
                titleKey: 'dialog.recording'
            };

            if (localRecording?.notifyAllParticipants && !onlySelf) {
                dispatch(playSound(RECORDING_ON_SOUND_ID));
            }
            dispatch(showNotification(props, NOTIFICATION_TIMEOUT_TYPE.MEDIUM));
            dispatch(showNotification({
                titleKey: 'recording.localRecordingStartWarningTitle',
                descriptionKey: 'recording.localRecordingStartWarning'
            }, NOTIFICATION_TIMEOUT_TYPE.STICKY));
            dispatch(updateLocalRecordingStatus(true, onlySelf));
            sendAnalytics(createRecordingEvent('started', `local${onlySelf ? '.self' : ''}`));
            if (typeof APP !== 'undefined') {
                APP.API.notifyRecordingStatusChanged(
                    true, 'local', undefined, isRecorderTranscriptionsRunning(getState()));
            }
        })
        .catch(err => {
            logger.error('Capture failed', err);

            let descriptionKey = 'recording.error';

            if (err.message === 'WrongSurfaceSelected') {
                descriptionKey = 'recording.surfaceError';

            } else if (err.message === 'NoLocalStreams') {
                descriptionKey = 'recording.noStreams';
            } else if (err.message === 'NoMicTrack') {
                descriptionKey = 'recording.noMicPermission';
            }
            const props = {
                descriptionKey,
                titleKey: 'recording.failedToStart'
            };

            if (typeof APP !== 'undefined') {
                APP.API.notifyRecordingStatusChanged(
                    false, 'local', err.message, isRecorderTranscriptionsRunning(getState()));
            }

            dispatch(showErrorNotification(props, NOTIFICATION_TIMEOUT_TYPE.MEDIUM));
        });
        break;
    }

    case STOP_LOCAL_RECORDING: {
        const { localRecording } = getState()['features/base/config'];

        if (LocalRecordingManager.isRecordingLocally()) {
            LocalRecordingManager.stopLocalRecording();
            dispatch(updateLocalRecordingStatus(false));
            if (localRecording?.notifyAllParticipants && !LocalRecordingManager.selfRecording) {
                dispatch(playSound(RECORDING_OFF_SOUND_ID));
            }
            if (typeof APP !== 'undefined') {
                APP.API.notifyRecordingStatusChanged(
                    false, 'local', undefined, isRecorderTranscriptionsRunning(getState()));
            }
        }
        break;
    }

    case RECORDING_SESSION_UPDATED: {
        const state = getState();

        // When in recorder mode no notifications are shown
        // or extra sounds are also not desired
        // but we want to indicate those in case of sip gateway
        const {
            iAmRecorder,
            iAmSipGateway,
            recordingLimit
        } = state['features/base/config'];

        if (iAmRecorder && !iAmSipGateway) {
            break;
        }

        const updatedSessionData
            = getSessionById(state, action.sessionData.id);
        const { initiator, mode = '', terminator } = updatedSessionData ?? {};
        const { PENDING, OFF, ON } = JitsiRecordingConstants.status;

        if (updatedSessionData?.status === PENDING && oldSessionData?.status !== PENDING) {
            dispatch(showPendingRecordingNotification(mode));
            dispatch(hideNotification(START_RECORDING_NOTIFICATION_ID));
            break;
        }

        dispatch(hidePendingRecordingNotification(mode));

        if (updatedSessionData?.status === ON) {

            // We receive 2 updates of the session status ON. The first one is from jibri when it joins.
            // The second one is from jicofo which will deliever the initiator value. Since the start
            // recording notification uses the initiator value we skip the jibri update and show the
            // notification on the update from jicofo.
            // FIXE: simplify checks when the backend start sending only one status ON update containing the
            // initiator.
            if (initiator && !oldSessionData?.initiator) {
                if (typeof recordingLimit === 'object') {
                    dispatch(showRecordingLimitNotification(mode));
                } else {
                    dispatch(showStartedRecordingNotification(mode, initiator, action.sessionData.id));
                }
            }

            if (oldSessionData?.status !== ON) {
                sendAnalytics(createRecordingEvent('start', mode));

                let soundID;

                if (mode === JitsiRecordingConstants.mode.FILE && !isRecorderTranscriptionsRunning(state)) {
                    soundID = RECORDING_ON_SOUND_ID;
                } else if (mode === JitsiRecordingConstants.mode.STREAM) {
                    soundID = LIVE_STREAMING_ON_SOUND_ID;
                }

                if (soundID) {
                    dispatch(playSound(soundID));
                }

                if (typeof APP !== 'undefined') {
                    APP.API.notifyRecordingStatusChanged(
                        true, mode, undefined, isRecorderTranscriptionsRunning(state));
                }
            }
        } else if (updatedSessionData?.status === OFF && oldSessionData?.status !== OFF) {
            if (terminator) {
                dispatch(
                    showStoppedRecordingNotification(
                        mode, getParticipantDisplayName(state, getResourceId(terminator))));
            }

            let duration = 0, soundOff, soundOn;

            if (oldSessionData?.timestamp) {
                duration
                    = (Date.now() / 1000) - oldSessionData.timestamp;
            }
            sendAnalytics(createRecordingEvent('stop', mode, duration));

            if (mode === JitsiRecordingConstants.mode.FILE && !isRecorderTranscriptionsRunning(state)) {
                soundOff = RECORDING_OFF_SOUND_ID;
                soundOn = RECORDING_ON_SOUND_ID;
            } else if (mode === JitsiRecordingConstants.mode.STREAM) {
                soundOff = LIVE_STREAMING_OFF_SOUND_ID;
                soundOn = LIVE_STREAMING_ON_SOUND_ID;
            }

            if (soundOff && soundOn) {
                dispatch(stopSound(soundOn));
                dispatch(playSound(soundOff));
            }

            if (typeof APP !== 'undefined') {
                APP.API.notifyRecordingStatusChanged(
                    false, mode, undefined, isRecorderTranscriptionsRunning(state));
            }
        }

        break;
    }
    case TRACK_ADDED: {
        const { track } = action;

        if (LocalRecordingManager.isRecordingLocally() && track.mediaType === MEDIA_TYPE.AUDIO) {
            const audioTrack = track.jitsiTrack.track;

            LocalRecordingManager.addAudioTrackToLocalRecording(audioTrack);
        }
        break;
    }
    case PARTICIPANT_UPDATED: {
        const { id, role } = action.participant;
        const state = getState();
        const localParticipant = getLocalParticipant(state);

        if (localParticipant?.id !== id) {
            return next(action);
        }

        if (role === PARTICIPANT_ROLE.MODERATOR) {
            dispatch(showStartRecordingNotification());
        }

        return next(action);
    }
    }

    return result;
});

/**
 * Shows a notification about an error in the recording session. A
 * default notification will display if no error is specified in the passed
 * in recording session.
 *
 * @private
 * @param {Object} session - The recorder session model from the
 * lib.
 * @param {Dispatch} dispatch - The Redux Dispatch function.
 * @param {Function} getState - The Redux getState function.
 * @returns {void}
 */
function _showRecordingErrorNotification(session: any, dispatch: IStore['dispatch'], getState: IStore['getState']) {
    const mode = session.getMode();
    const error = session.getError();
    const isStreamMode = mode === JitsiMeetJS.constants.recording.mode.STREAM;

    switch (error) {
    case JitsiMeetJS.constants.recording.error.SERVICE_UNAVAILABLE:
        dispatch(showRecordingError({
            descriptionKey: 'recording.unavailable',
            descriptionArguments: {
                serviceName: isStreamMode
                    ? '$t(liveStreaming.serviceName)'
                    : '$t(recording.serviceName)'
            },
            titleKey: isStreamMode
                ? 'liveStreaming.unavailableTitle'
                : 'recording.unavailableTitle'
        }));
        break;
    case JitsiMeetJS.constants.recording.error.RESOURCE_CONSTRAINT:
        dispatch(showRecordingError({
            descriptionKey: isStreamMode
                ? 'liveStreaming.busy'
                : 'recording.busy',
            titleKey: isStreamMode
                ? 'liveStreaming.busyTitle'
                : 'recording.busyTitle'
        }));
        break;
    case JitsiMeetJS.constants.recording.error.UNEXPECTED_REQUEST:
        dispatch(showRecordingWarning({
            descriptionKey: isStreamMode
                ? 'liveStreaming.sessionAlreadyActive'
                : 'recording.sessionAlreadyActive',
            titleKey: isStreamMode ? 'liveStreaming.inProgress' : 'recording.inProgress'
        }));
        break;
    default:
        dispatch(showRecordingError({
            descriptionKey: isStreamMode
                ? 'liveStreaming.error'
                : 'recording.error',
            titleKey: isStreamMode
                ? 'liveStreaming.failedToStart'
                : 'recording.failedToStart'
        }));
        break;
    }

    if (typeof APP !== 'undefined') {
        APP.API.notifyRecordingStatusChanged(false, mode, error, isRecorderTranscriptionsRunning(getState()));
    }
}


################################################################################

## File: .\jitsi-meet\react\features\recording\reducer.ts

import ReducerRegistry from '../base/redux/ReducerRegistry';

import {
    CLEAR_RECORDING_SESSIONS,
    RECORDING_SESSION_UPDATED,
    SET_MEETING_HIGHLIGHT_BUTTON_STATE,
    SET_PENDING_RECORDING_NOTIFICATION_UID,
    SET_SELECTED_RECORDING_SERVICE,
    SET_START_RECORDING_NOTIFICATION_SHOWN,
    SET_STREAM_KEY
} from './actionTypes';

const DEFAULT_STATE = {
    disableHighlightMeetingMoment: false,
    pendingNotificationUids: {},
    selectedRecordingService: '',
    sessionDatas: []
};

export interface ISessionData {
    error?: Error;
    id?: string;
    initiator?: { getId: Function; };
    liveStreamViewURL?: string;
    mode?: string;
    status?: string;
    terminator?: { getId: Function; };
    timestamp?: number;
}

export interface IRecordingState {
    disableHighlightMeetingMoment: boolean;
    pendingNotificationUids: {
        [key: string]: string | undefined;
    };
    selectedRecordingService: string;
    sessionDatas: Array<ISessionData>;
    streamKey?: string;
    wasStartRecordingSuggested?: boolean;
}

/**
 * The name of the Redux store this feature stores its state in.
 */
const STORE_NAME = 'features/recording';

/**
 * Reduces the Redux actions of the feature features/recording.
 */
ReducerRegistry.register<IRecordingState>(STORE_NAME,
    (state = DEFAULT_STATE, action): IRecordingState => {
        switch (action.type) {

        case CLEAR_RECORDING_SESSIONS:
            return {
                ...state,
                sessionDatas: []
            };

        case RECORDING_SESSION_UPDATED:
            return {
                ...state,
                sessionDatas:
                    _updateSessionDatas(state.sessionDatas, action.sessionData)
            };

        case SET_PENDING_RECORDING_NOTIFICATION_UID: {
            const pendingNotificationUids = {
                ...state.pendingNotificationUids
            };

            pendingNotificationUids[action.streamType] = action.uid;

            return {
                ...state,
                pendingNotificationUids
            };
        }

        case SET_SELECTED_RECORDING_SERVICE: {
            return {
                ...state,
                selectedRecordingService: action.selectedRecordingService
            };
        }

        case SET_STREAM_KEY:
            return {
                ...state,
                streamKey: action.streamKey
            };

        case SET_MEETING_HIGHLIGHT_BUTTON_STATE:
            return {
                ...state,
                disableHighlightMeetingMoment: action.disabled
            };

        case SET_START_RECORDING_NOTIFICATION_SHOWN:
            return {
                ...state,
                wasStartRecordingSuggested: true
            };

        default:
            return state;
        }
    });

/**
 * Updates the known information on recording sessions.
 *
 * @param {Array} sessionDatas - The current sessions in the redux store.
 * @param {Object} newSessionData - The updated session data.
 * @private
 * @returns {Array} The session datas with the updated session data added.
 */
function _updateSessionDatas(sessionDatas: ISessionData[], newSessionData: ISessionData) {
    const hasExistingSessionData = sessionDatas.find(
        sessionData => sessionData.id === newSessionData.id);
    let newSessionDatas;

    if (hasExistingSessionData) {
        newSessionDatas = sessionDatas.map(sessionData => {
            if (sessionData.id === newSessionData.id) {
                return {
                    ...newSessionData
                };
            }

            // Nothing to update for this session data so pass it back in.
            return sessionData;
        });
    } else {
        // If the session data is not present, then there is nothing to update
        // and instead it needs to be added to the known session datas.
        newSessionDatas = [
            ...sessionDatas,
            { ...newSessionData }
        ];
    }

    return newSessionDatas;
}


################################################################################

## File: .\jitsi-meet\react\features\recording\sounds.ts

/**
 * The name of the bundled audio file which will be played for when live streaming is stopped.
 *
 * @type {string}
 */
export const LIVE_STREAMING_OFF_SOUND_FILE = 'liveStreamingOff.mp3';

/**
 * The name of the bundled audio file which will be played for when a live streaming is started.
 *
 * @type {string}
 */
export const LIVE_STREAMING_ON_SOUND_FILE = 'liveStreamingOn.mp3';

/**
 * The name of the bundled audio file which will be played for when a recording is stopped.
 *
 * @type {string}
 */
export const RECORDING_OFF_SOUND_FILE = 'recordingOff.mp3';

/**
 * The name of the bundled audio file which will be played for when a recording is started.
 *
 * @type {string}
 */
export const RECORDING_ON_SOUND_FILE = 'recordingOn.mp3';


################################################################################

## File: .\jitsi-meet\react\features\recording\components\AbstractRecordingLabel.ts

import React, { Component } from 'react';
import { WithTranslation } from 'react-i18next';

import { IReduxState } from '../../app/types';
import { JitsiRecordingConstants } from '../../base/lib-jitsi-meet';
import { isRecorderTranscriptionsRunning } from '../../transcribing/functions';
import {
    getSessionStatusToShow,
    isLiveStreamingRunning,
    isRecordingRunning,
    isRemoteParticipantRecordingLocally
} from '../functions';

export interface IProps extends WithTranslation {

    /**
     * Whether this is the Jibri recorder participant.
     */
    _iAmRecorder: boolean;


    /**
     * Whether this meeting is being transcribed.
    */
   _isTranscribing: boolean;

   /**
    * Whether the recording/livestreaming/transcriber is currently running.
    */
   _isVisible: boolean;

    /**
     * The status of the higher priority session.
     */
    _status?: string;

    /**
     * The recording mode this indicator should display.
     */
    mode: string;
}

/**
 * Abstract class for the {@code RecordingLabel} component.
 */
export default class AbstractRecordingLabel<P extends IProps = IProps> extends Component<P> {
    /**
     * Implements React {@code Component}'s render.
     *
     * @inheritdoc
     */
    render() {
        const { _iAmRecorder, _isVisible } = this.props;

        return _isVisible && !_iAmRecorder ? this._renderLabel() : null;
    }

    /**
     * Renders the platform specific label component.
     *
     * @protected
     * @returns {React$Element}
     */
    _renderLabel(): React.ReactNode | null {
        return null;
    }
}

/**
 * Maps (parts of) the Redux state to the associated
 * {@code AbstractRecordingLabel}'s props.
 *
 * @param {Object} state - The Redux state.
 * @param {IProps} ownProps - The component's own props.
 * @private
 * @returns {{
 *     _status: ?string
 * }}
 */
export function _mapStateToProps(state: IReduxState, ownProps: any) {
    const { mode } = ownProps;
    const isLiveStreamingLabel = mode === JitsiRecordingConstants.mode.STREAM;
    const _isTranscribing = isRecorderTranscriptionsRunning(state);
    const _isLivestreamingRunning = isLiveStreamingRunning(state);
    const _isVisible = isLiveStreamingLabel
        ? _isLivestreamingRunning // this is the livestreaming label
        : isRecordingRunning(state) || isRemoteParticipantRecordingLocally(state)
            || _isTranscribing; // this is the recording label

    return {
        _isVisible,
        _iAmRecorder: Boolean(state['features/base/config'].iAmRecorder),
        _isTranscribing,
        _status: getSessionStatusToShow(state, mode)
    };
}


################################################################################

## File: .\jitsi-meet\react\features\recording\components\LiveStream\AbstractLiveStreamButton.ts

import { IReduxState } from '../../../app/types';
import { IconSites } from '../../../base/icons/svg';
import { MEET_FEATURES } from '../../../base/jwt/constants';
import { isJwtFeatureEnabled } from '../../../base/jwt/functions';
import { isLocalParticipantModerator } from '../../../base/participants/functions';
import AbstractButton, { IProps as AbstractButtonProps } from '../../../base/toolbox/components/AbstractButton';
import { isInBreakoutRoom } from '../../../breakout-rooms/functions';
import { maybeShowPremiumFeatureDialog } from '../../../jaas/actions';
import { isRecorderTranscriptionsRunning } from '../../../transcribing/functions';
import { isCloudRecordingRunning, isLiveStreamingButtonVisible, isLiveStreamingRunning } from '../../functions';

import { getLiveStreaming } from './functions';


/**
 * The type of the React {@code Component} props of
 * {@link AbstractLiveStreamButton}.
 */
export interface IProps extends AbstractButtonProps {

    /**
     * True if the button needs to be disabled.
     */
    _disabled: boolean;

    /**
     * True if there is a running active live stream, false otherwise.
     */
    _isLiveStreamRunning: boolean;

    /**
     * The tooltip to display when hovering over the button.
     */
    _tooltip?: string;
}

/**
 * An abstract class of a button for starting and stopping live streaming.
 */
export default class AbstractLiveStreamButton<P extends IProps> extends AbstractButton<P> {
    accessibilityLabel = 'dialog.startLiveStreaming';
    toggledAccessibilityLabel = 'dialog.stopLiveStreaming';
    icon = IconSites;
    label = 'dialog.startLiveStreaming';
    toggledLabel = 'dialog.stopLiveStreaming';

    /**
     * Returns the tooltip that should be displayed when the button is disabled.
     *
     * @private
     * @returns {string}
     */
    _getTooltip() {
        return this.props._tooltip ?? '';
    }

    /**
     * Helper function to be implemented by subclasses, which should be used
     * to handle the live stream button being clicked / pressed.
     *
     * @protected
     * @returns {void}
     */
    _onHandleClick() {
        // To be implemented by subclass.
    }

    /**
     * Handles clicking / pressing the button.
     *
     * @override
     * @protected
     * @returns {void}
     */
    _handleClick() {
        const { dispatch } = this.props;

        const dialogShown = dispatch(maybeShowPremiumFeatureDialog(MEET_FEATURES.RECORDING));

        if (!dialogShown) {
            this._onHandleClick();
        }
    }

    /**
     * Returns a boolean value indicating if this button is disabled or not.
     *
     * @protected
     * @returns {boolean}
     */
    _isDisabled() {
        return this.props._disabled;
    }

    /**
     * Indicates whether this button is in toggled state or not.
     *
     * @override
     * @protected
     * @returns {boolean}
     */
    _isToggled() {
        return this.props._isLiveStreamRunning;
    }
}

/**
 * Maps (parts of) the redux state to the associated props for the
 * {@code AbstractLiveStreamButton} component.
 *
 * @param {Object} state - The Redux state.
 * @param {IProps} ownProps - The own props of the Component.
 * @private
 * @returns {{
 *     _disabled: boolean,
 *     _isLiveStreamRunning: boolean,
 *     visible: boolean
 * }}
 */
export function _mapStateToProps(state: IReduxState, ownProps: IProps) {
    let { visible } = ownProps;

    // A button can be disabled/enabled only if enableFeaturesBasedOnToken
    // is on or if the recording is running.
    let _disabled = false;
    let _tooltip = '';

    if (typeof visible === 'undefined') {
        // If the containing component provides the visible prop, that is one
        // above all, but if not, the button should be autonomous and decide on
        // its own to be visible or not.
        const isModerator = isLocalParticipantModerator(state);
        const liveStreaming = getLiveStreaming(state);

        visible = isLiveStreamingButtonVisible({
            liveStreamingAllowed: isJwtFeatureEnabled(state, 'livestreaming', isModerator, false),
            liveStreamingEnabled: liveStreaming?.enabled,
            isInBreakoutRoom: isInBreakoutRoom(state)
        });
    }

    // disable the button if the recording is running.
    if (visible && (isCloudRecordingRunning(state) || isRecorderTranscriptionsRunning(state))) {
        _disabled = true;
        _tooltip = 'dialog.liveStreamingDisabledBecauseOfActiveRecordingTooltip';
    }

    // disable the button if we are in a breakout room.
    if (isInBreakoutRoom(state)) {
        _disabled = true;
    }

    return {
        _disabled,
        _isLiveStreamRunning: isLiveStreamingRunning(state),
        _tooltip,
        visible
    };
}


################################################################################

## File: .\jitsi-meet\react\features\recording\components\LiveStream\AbstractStartLiveStreamDialog.ts

import { Component } from 'react';
import { WithTranslation } from 'react-i18next';

import { createLiveStreamingDialogEvent } from '../../../analytics/AnalyticsEvents';
import { sendAnalytics } from '../../../analytics/functions';
import { IReduxState, IStore } from '../../../app/types';
import { IJitsiConference } from '../../../base/conference/reducer';
import { JitsiRecordingConstants } from '../../../base/lib-jitsi-meet';

/**
 * The type of the React {@code Component} props of
 * {@link AbstractStartLiveStreamDialog}.
 */
export interface IProps extends WithTranslation {

    /**
     * The {@code JitsiConference} for the current conference.
     */
    _conference?: IJitsiConference;

    /**
     * The current state of interactions with the Google API. Determines what
     * Google related UI should display.
     */
    _googleAPIState: number;

    /**
     * The email of the user currently logged in to the Google web client
     * application.
     */
    _googleProfileEmail: string;

    /**
     * The live stream key that was used before.
     */
    _streamKey?: string;

    /**
     * The Redux dispatch function.
     */
    dispatch: IStore['dispatch'];

    navigation?: any;
}

/**
 * The type of the React {@code Component} state of
 * {@link AbstractStartLiveStreamDialog}.
 */
export interface IState {

    /**
     * Details about the broadcasts available for use for the logged in Google
     * user's YouTube account.
     */
    broadcasts?: Array<any>;

    /**
     * The error type, as provided by Google, for the most recent error
     * encountered by the Google API.
     */
    errorType?: string;

    /**
     * The boundStreamID of the broadcast currently selected in the broadcast
     * dropdown.
     */
    selectedBoundStreamID?: string;

    /**
     * The selected or entered stream key to use for YouTube live streaming.
     */
    streamKey?: string;
}

/**
 * Implements an abstract class for the StartLiveStreamDialog on both platforms.
 *
 * NOTE: Google log-in is not supported for mobile yet for later implementation
 * but the abstraction of its properties are already present in this abstract
 * class.
 */
export default class AbstractStartLiveStreamDialog<P extends IProps>
    extends Component<P, IState> {
    _isMounted: boolean;

    /**
     * Constructor of the component.
     *
     * @inheritdoc
     */
    constructor(props: P) {
        super(props);

        this.state = {
            broadcasts: undefined,
            errorType: undefined,
            selectedBoundStreamID: undefined,
            streamKey: ''
        };

        /**
         * Instance variable used to flag whether the component is or is not
         * mounted. Used as a hack to avoid setting state on an unmounted
         * component.
         *
         * @private
         * @type {boolean}
         */
        this._isMounted = false;

        this._onCancel = this._onCancel.bind(this);
        this._onStreamKeyChange = this._onStreamKeyChange.bind(this);
        this._onSubmit = this._onSubmit.bind(this);
    }

    /**
     * Implements {@link Component#componentDidMount()}. Invoked immediately
     * after this component is mounted.
     *
     * @inheritdoc
     * @returns {void}
     */
    componentDidMount() {
        this._isMounted = true;
    }

    /**
     * Implements React's {@link Component#componentWillUnmount()}. Invoked
     * immediately before this component is unmounted and destroyed.
     *
     * @inheritdoc
     */
    componentWillUnmount() {
        this._isMounted = false;
    }

    /**
     * Invokes the passed in {@link onCancel} callback and closes
     * {@code StartLiveStreamDialog}.
     *
     * @private
     * @returns {boolean} True is returned to close the modal.
     */
    _onCancel() {
        sendAnalytics(createLiveStreamingDialogEvent('start', 'cancel.button'));

        return true;
    }

    /**
     * Asks the user to sign in, if not already signed in, and then requests a
     * list of the user's YouTube broadcasts.
     *
     * NOTE: To be implemented by platforms.
     *
     * @private
     * @returns {Promise}
     */
    _onGetYouTubeBroadcasts(): Promise<any> | void {
        // to be overwritten by child classes.
    }

    /**
     * Callback invoked to update the {@code StartLiveStreamDialog} component's
     * display of the entered YouTube stream key.
     *
     * @param {string} streamKey - The stream key entered in the field.
     * @private
     * @returns {void}
     */
    _onStreamKeyChange(streamKey: string) {
        this._setStateIfMounted({
            streamKey,
            selectedBoundStreamID: undefined
        });
    }

    /**
     * Invokes the passed in {@link onSubmit} callback with the entered stream
     * key, and then closes {@code StartLiveStreamDialog}.
     *
     * @private
     * @returns {boolean} False if no stream key is entered to preventing
     * closing, true to close the modal.
     */
    _onSubmit() {
        const { broadcasts, selectedBoundStreamID } = this.state;
        const key
            = (this.state.streamKey || this.props._streamKey || '').trim();

        if (!key) {
            return false;
        }

        let selectedBroadcastID = null;

        if (selectedBoundStreamID) {
            const selectedBroadcast = broadcasts?.find(
                broadcast => broadcast.boundStreamID === selectedBoundStreamID);

            selectedBroadcastID = selectedBroadcast?.id;
        }

        sendAnalytics(
            createLiveStreamingDialogEvent('start', 'confirm.button'));

        this.props._conference?.startRecording({
            broadcastId: selectedBroadcastID,
            mode: JitsiRecordingConstants.mode.STREAM,
            streamId: key
        });

        return true;
    }

    /**
     * Updates the internal state if the component is still mounted. This is a
     * workaround for all the state setting that occurs after ajax.
     *
     * @param {Object} newState - The new state to merge into the existing
     * state.
     * @private
     * @returns {void}
     */
    _setStateIfMounted(newState: IState) {
        if (this._isMounted) {
            this.setState(newState);
        }
    }
}

/**
 * Maps part of the Redux state to the component's props.
 *
 * @param {Object} state - The Redux state.
 * @returns {{
 *     _conference: Object,
 *     _googleAPIState: number,
 *     _googleProfileEmail: string,
 *     _streamKey: string
 * }}
 */
export function _mapStateToProps(state: IReduxState) {
    return {
        _conference: state['features/base/conference'].conference,
        _googleAPIState: state['features/google-api'].googleAPIState,
        _googleProfileEmail: state['features/google-api'].profileEmail,
        _streamKey: state['features/recording'].streamKey
    };
}


################################################################################

## File: .\jitsi-meet\react\features\recording\components\LiveStream\AbstractStopLiveStreamDialog.ts

import { Component } from 'react';
import { WithTranslation } from 'react-i18next';

import { createLiveStreamingDialogEvent } from '../../../analytics/AnalyticsEvents';
import { sendAnalytics } from '../../../analytics/functions';
import { IReduxState } from '../../../app/types';
import { IJitsiConference } from '../../../base/conference/reducer';
import { JitsiRecordingConstants } from '../../../base/lib-jitsi-meet';
import { getActiveSession } from '../../functions';
import { ISessionData } from '../../reducer';

/**
 * The type of the React {@code Component} props of
 * {@link StopLiveStreamDialog}.
 */
interface IProps extends WithTranslation {

    /**
     * The {@code JitsiConference} for the current conference.
     */
    _conference?: IJitsiConference;

    /**
     * The redux representation of the live streaming to be stopped.
     */
    _session?: ISessionData;
}

/**
 * A React Component for confirming the participant wishes to stop the currently
 * active live stream of the conference.
 *
 * @augments Component
 */
export default class AbstractStopLiveStreamDialog extends Component<IProps> {
    /**
     * Initializes a new {@code StopLiveStreamDialog} instance.
     *
     * @param {Object} props - The read-only properties with which the new
     * instance is to be initialized.
     */
    constructor(props: IProps) {
        super(props);

        // Bind event handler so it is only bound once for every instance.
        this._onSubmit = this._onSubmit.bind(this);
    }

    /**
     * Callback invoked when stopping of live streaming is confirmed.
     *
     * @private
     * @returns {boolean} True to close the modal.
     */
    _onSubmit() {
        sendAnalytics(createLiveStreamingDialogEvent('stop', 'confirm.button'));

        const { _session } = this.props;

        if (_session) {
            this.props._conference?.stopRecording(_session.id);
        }

        return true;
    }
}

/**
 * Maps (parts of) the redux state to the React {@code Component} props of
 * {@code StopLiveStreamDialog}.
 *
 * @param {Object} state - The redux state.
 * @private
 * @returns {{
 *     _conference: Object,
 *     _session: Object
 * }}
 */
export function _mapStateToProps(state: IReduxState) {
    return {
        _conference: state['features/base/conference'].conference,
        _session: getActiveSession(state, JitsiRecordingConstants.mode.STREAM)
    };
}


################################################################################

## File: .\jitsi-meet\react\features\recording\components\LiveStream\AbstractStreamKeyForm.ts

import { debounce } from 'lodash-es';
import type { DebouncedFunc } from 'lodash-es';
import { Component } from 'react';
import { WithTranslation } from 'react-i18next';

import { IReduxState } from '../../../app/types';

import { getLiveStreaming } from './functions';


export type LiveStreaming = {

    // Terms link
    dataPrivacyLink: string;
    enabled: boolean;
    helpLink: string;

    // Documentation reference for the live streaming feature.
    termsLink: string; // Data privacy link
    validatorRegExpString: string; // RegExp string that validates the stream key input field
};

export type LiveStreamingProps = {
    dataPrivacyURL?: string;
    enabled: boolean;
    helpURL?: string;
    streamLinkRegexp: RegExp;
    termsURL?: string;
};

/**
 * The props of the component.
 */
export interface IProps extends WithTranslation {

    /**
     * The live streaming dialog properties.
     */
    _liveStreaming: LiveStreamingProps;

    /**
     * Callback invoked when the entered stream key has changed.
     */
    onChange: Function;

    /**
     * The stream key value to display as having been entered so far.
     */
    value: string;
}

/**
 * The state of the component.
 */
interface IState {

    /**
     * Whether or not to show the warnings that the passed in value seems like
     * an improperly formatted stream key.
     */
    showValidationError: boolean;
}

/**
 * An abstract React Component for entering a key for starting a YouTube live
 * stream.
 *
 * @augments Component
 */
export default class AbstractStreamKeyForm<P extends IProps>
    extends Component<P, IState> {

    _debouncedUpdateValidationErrorVisibility: DebouncedFunc<() => void>;

    /**
     * Constructor for the component.
     *
     * @inheritdoc
     */
    constructor(props: P) {
        super(props);

        this.state = {
            showValidationError: Boolean(this.props.value)
                && !this._validateStreamKey(this.props.value)
        };

        this._debouncedUpdateValidationErrorVisibility = debounce(
            this._updateValidationErrorVisibility.bind(this),
            800,
            { leading: false }
        );

        // Bind event handlers so they are only bound once per instance.
        this._onInputChange = this._onInputChange.bind(this);
    }

    /**
     * Implements React Component's componentDidUpdate.
     *
     * @inheritdoc
     */
    componentDidUpdate(prevProps: P) {
        if (this.props.value !== prevProps.value) {
            this._debouncedUpdateValidationErrorVisibility();
        }
    }

    /**
     * Implements React Component's componentWillUnmount.
     *
     * @inheritdoc
     */
    componentWillUnmount() {
        this._debouncedUpdateValidationErrorVisibility.cancel();
    }

    /**
     * Callback invoked when the value of the input field has updated through
     * user input. This forwards the value (string only, even if it was a dom
     * event) to the onChange prop provided to the component.
     *
     * @param {Object | string} change - DOM Event for value change or the
     * changed text.
     * @private
     * @returns {void}
     */
    _onInputChange(change: any) {
        const value = typeof change === 'object' ? change.target.value : change;

        this.props.onChange(value);
    }

    /**
     * Checks if the stream key value seems like a valid stream key and sets the
     * state for showing or hiding the notification about the stream key seeming
     * invalid.
     *
     * @private
     * @returns {boolean}
     */
    _updateValidationErrorVisibility() {
        const newShowValidationError = Boolean(this.props.value)
            && !this._validateStreamKey(this.props.value);

        if (newShowValidationError !== this.state.showValidationError) {
            this.setState({
                showValidationError: newShowValidationError
            });
        }
    }

    /**
     * Checks if a passed in stream key appears to be in a valid format.
     *
     * @param {string} streamKey - The stream key to check for valid formatting.
     * @returns {void}
     * @returns {boolean}
     */
    _validateStreamKey(streamKey = '') {
        const trimmedKey = streamKey.trim();
        const match = this.props._liveStreaming.streamLinkRegexp.exec(trimmedKey);

        return Boolean(match);
    }
}

/**
 * Maps part of the Redux state to the component's props.
 *
 * @param {Object} state - The Redux state.
 * @returns {{
 *     _liveStreaming: LiveStreamingProps
 * }}
 */
export function _mapStateToProps(state: IReduxState) {
    return {
        _liveStreaming: getLiveStreaming(state)
    };
}


################################################################################

## File: .\jitsi-meet\react\features\recording\components\LiveStream\constants.ts

/**
 * The URL for Google Privacy Policy.
 */
export const GOOGLE_PRIVACY_POLICY = 'https://policies.google.com/privacy';

/**
 * The URL that is the main landing page for YouTube live streaming and should
 * have a user's live stream key.
 */
export const YOUTUBE_LIVE_DASHBOARD_URL = 'https://www.youtube.com/live_dashboard';

/**
 * The URL for YouTube terms and conditions.
 */
export const YOUTUBE_TERMS_URL = 'https://www.youtube.com/t/terms';

/**
 * The live streaming help link to display.
 */
export const JITSI_LIVE_STREAMING_HELP_LINK = 'https://jitsi.org/live';

/**
 *  The YouTube stream link RegExp.
 */
export const FOUR_GROUPS_DASH_SEPARATED = /^(?:[a-zA-Z0-9]{4}(?:-(?!$)|$)){4}/;



################################################################################

## File: .\jitsi-meet\react\features\recording\components\LiveStream\functions.ts

import { IReduxState } from '../../../app/types';
import { sanitizeUrl } from '../../../base/util/uri';

import {
    FOUR_GROUPS_DASH_SEPARATED,
    GOOGLE_PRIVACY_POLICY,
    JITSI_LIVE_STREAMING_HELP_LINK,
    YOUTUBE_TERMS_URL
} from './constants';

/**
 * Get the live streaming options.
 *
 * @param {Object} state - The global state.
 * @returns {LiveStreaming}
 */
export function getLiveStreaming(state: IReduxState) {
    const { liveStreaming = {} } = state['features/base/config'];
    const regexp = liveStreaming.validatorRegExpString && new RegExp(liveStreaming.validatorRegExpString);

    return {
        enabled: Boolean(liveStreaming.enabled),
        helpURL: sanitizeUrl(liveStreaming.helpLink || JITSI_LIVE_STREAMING_HELP_LINK)?.toString(),
        termsURL: sanitizeUrl(liveStreaming.termsLink || YOUTUBE_TERMS_URL)?.toString(),
        dataPrivacyURL: sanitizeUrl(liveStreaming.dataPrivacyLink || GOOGLE_PRIVACY_POLICY)?.toString(),
        streamLinkRegexp: regexp || FOUR_GROUPS_DASH_SEPARATED
    };
}


################################################################################

## File: .\jitsi-meet\react\features\recording\components\LiveStream\native\LiveStreamButton.ts

import { connect } from 'react-redux';

import { IReduxState } from '../../../../app/types';
import { openDialog } from '../../../../base/dialog/actions';
import { LIVE_STREAMING_ENABLED } from '../../../../base/flags/constants';
import { getFeatureFlag } from '../../../../base/flags/functions';
import { translate } from '../../../../base/i18n/functions';
import { navigate }
    from '../../../../mobile/navigation/components/conference/ConferenceNavigationContainerRef';
import { screen } from '../../../../mobile/navigation/routes';
import AbstractLiveStreamButton, {
    IProps as AbstractProps,
    _mapStateToProps as _abstractMapStateToProps
} from '../AbstractLiveStreamButton';
import { IProps } from '../AbstractStartLiveStreamDialog';

import StopLiveStreamDialog from './StopLiveStreamDialog';

type Props = IProps & AbstractProps;

/**
 * Button for opening the live stream settings screen.
 */
class LiveStreamButton extends AbstractLiveStreamButton<Props> {

    /**
     * Handles clicking / pressing the button.
     *
     * @override
     * @protected
     * @returns {void}
     */
    _onHandleClick() {
        const { _isLiveStreamRunning, dispatch } = this.props;

        if (_isLiveStreamRunning) {
            dispatch(openDialog(StopLiveStreamDialog));
        } else {
            navigate(screen.conference.liveStream);
        }
    }
}

/**
 * Maps (parts of) the redux state to the associated props for this component.
 *
 * @param {Object} state - The redux state.
 * @param {Object} ownProps - The properties explicitly passed to the component
 * instance.
 * @private
 * @returns {Props}
 */
export function mapStateToProps(state: IReduxState, ownProps: any) {
    const enabled = getFeatureFlag(state, LIVE_STREAMING_ENABLED, true);
    const abstractProps = _abstractMapStateToProps(state, ownProps);

    return {
        ...abstractProps,
        visible: enabled && abstractProps.visible
    };
}

export default translate(connect(mapStateToProps)(LiveStreamButton));


################################################################################

## File: .\jitsi-meet\react\features\recording\components\LiveStream\native\styles.ts

import { createStyleSheet } from '../../../../base/styles/functions.native';
import BaseTheme from '../../../../base/ui/components/BaseTheme.native';

/**
 * Opacity of the TouchableHighlight.
 */
export const ACTIVE_OPACITY = 0.3;

/**
 * Underlay of the TouchableHighlight.
 */
export const TOUCHABLE_UNDERLAY = BaseTheme.palette.ui06;

/**
 * The styles of the React {@code Components} of LiveStream.
 */
export default createStyleSheet({

    /**
     * Generic component to wrap form sections into achieving a unified look.
     */
    formWrapper: {
        alignItems: 'stretch',
        flexDirection: 'column',
        paddingHorizontal: BaseTheme.spacing[2]
    },

    formValidationItem: {
        alignSelf: 'flex-start',
        flexDirection: 'row',
        height: BaseTheme.spacing[4],
        marginTop: BaseTheme.spacing[2]
    },

    formButtonsWrapper: {
        alignSelf: 'center',
        display: 'flex',
        maxWidth: 200
    },

    buttonLabelStyle: {
        color: BaseTheme.palette.link01
    },

    /**
     * Explaining text on the top of the sign in form.
     */
    helpText: {
        marginBottom: BaseTheme.spacing[2]
    },

    /**
     * Container for the live stream screen.
     */
    startLiveStreamContainer: {
        backgroundColor: BaseTheme.palette.ui01,
        display: 'flex',
        flex: 1,
        flexDirection: 'column',
        justifyContent: 'center',
        paddingHorizontal: BaseTheme.spacing[2],
        paddingVertical: BaseTheme.spacing[3]
    },

    /**
     * Helper link text.
     */
    streamKeyHelp: {
        alignSelf: 'flex-end'
    },

    /**
     * Input field to manually enter stream key.
     */
    streamKeyInput: {
        alignSelf: 'stretch',
        color: BaseTheme.palette.text01,
        textAlign: 'left'
    },

    streamKeyContainer: {
        marginTop: BaseTheme.spacing[3]
    },

    /**
     * Custom component to pick a broadcast from the list fetched from Google.
     */
    streamKeyPicker: {
        alignSelf: 'stretch',
        flex: 1,
        height: 40,
        marginHorizontal: BaseTheme.spacing[1],
        width: 300
    },

    /**
     * CTA (label) of the picker.
     */
    streamKeyPickerCta: {
        marginBottom: BaseTheme.spacing[2]
    },

    /**
     * Style of a single item in the list.
     */
    streamKeyPickerItem: {
        padding: BaseTheme.spacing[1]
    },

    /**
     * Additional style for the selected item.
     */
    streamKeyPickerItemHighlight: {
        backgroundColor: BaseTheme.palette.ui04
    },

    /**
     * Overall wrapper for the picker.
     */
    streamKeyPickerWrapper: {
        borderColor: BaseTheme.palette.ui07,
        borderRadius: BaseTheme.shape.borderRadius,
        borderWidth: 1,
        flexDirection: 'column'
    },

    /**
     * Terms and Conditions texts.
     */
    tcText: {
        textAlign: 'right'
    },

    text: {
        color: BaseTheme.palette.text01,
        fontSize: 14,
        textAlign: 'left'
    },

    /**
     * A different colored text to indicate information needing attention.
     */
    warningText: {
        color: BaseTheme.palette.warning02
    }
});


################################################################################

## File: .\jitsi-meet\react\features\recording\components\LiveStream\web\LiveStreamButton.ts

import { connect } from 'react-redux';

import { IReduxState } from '../../../../app/types';
import { openDialog } from '../../../../base/dialog/actions';
import { translate } from '../../../../base/i18n/functions';
import AbstractLiveStreamButton, {
    IProps,
    _mapStateToProps as _abstractMapStateToProps
} from '../AbstractLiveStreamButton';

import StartLiveStreamDialog from './StartLiveStreamDialog';
import StopLiveStreamDialog from './StopLiveStreamDialog';


/**
 * Button for opening the live stream settings dialog.
 */
class LiveStreamButton extends AbstractLiveStreamButton<IProps> {

    /**
     * Handles clicking / pressing the button.
     *
     * @override
     * @protected
     * @returns {void}
     */
    _onHandleClick() {
        const { _isLiveStreamRunning, dispatch } = this.props;

        dispatch(openDialog(
            _isLiveStreamRunning ? StopLiveStreamDialog : StartLiveStreamDialog
        ));
    }
}

/**
 * Maps (parts of) the redux state to the associated props for the
 * {@code LiveStreamButton} component.
 *
 * @param {Object} state - The Redux state.
 * @param {IProps} ownProps - The own props of the Component.
 * @private
 * @returns {{
 *     _conference: Object,
 *     _isLiveStreamRunning: boolean,
 *     _disabled: boolean,
 *     visible: boolean
 * }}
 */
function _mapStateToProps(state: IReduxState, ownProps: any) {
    const abstractProps = _abstractMapStateToProps(state, ownProps);
    const { toolbarButtons } = state['features/toolbox'];
    let { visible } = ownProps;

    if (typeof visible === 'undefined') {
        visible = Boolean(toolbarButtons?.includes('livestreaming') && abstractProps.visible);
    }

    return {
        ...abstractProps,
        visible
    };
}

export default translate(connect(_mapStateToProps)(LiveStreamButton));


################################################################################

## File: .\jitsi-meet\react\features\recording\components\native\RecordingExpandedLabel.ts

import { connect } from 'react-redux';

import { IReduxState } from '../../../app/types';
import { translate } from '../../../base/i18n/functions';
import ExpandedLabel, { IProps as AbstractProps } from '../../../base/label/components/native/ExpandedLabel';
import { JitsiRecordingConstants } from '../../../base/lib-jitsi-meet';
import { isRecorderTranscriptionsRunning } from '../../../transcribing/functions';
import { getSessionStatusToShow } from '../../functions';

interface IProps extends AbstractProps {

    /**
     * Whether this meeting is being transcribed.
     */
    _isTranscribing: boolean;

    /**
     * The status of the highermost priority session.
     */
    _status?: string;

    /**
     * The recording mode this indicator should display.
     */
    mode: string;

    /**
     * Function to be used to translate i18n labels.
     */
    t: Function;
}

/**
 * A react {@code Component} that implements an expanded label as tooltip-like
 * component to explain the meaning of the {@code RecordingLabel}.
 */
class RecordingExpandedLabel extends ExpandedLabel<IProps> {

    /**
     * Returns the label specific text of this {@code ExpandedLabel}.
     *
     * @returns {string}
     */
    _getLabel() {
        const { _status, mode, t } = this.props;
        let postfix = 'expandedOn', prefix = 'recording'; // Default values.

        switch (mode) {
        case JitsiRecordingConstants.mode.STREAM:
            prefix = 'liveStreaming';
            break;
        case JitsiRecordingConstants.mode.FILE:
            prefix = 'recording';
            break;
        }

        switch (_status) {
        case JitsiRecordingConstants.status.OFF:
            postfix = 'expandedOff';
            break;
        case JitsiRecordingConstants.status.PENDING:
            postfix = 'expandedPending';
            break;
        case JitsiRecordingConstants.status.ON:
            postfix = 'expandedOn';
            break;
        }

        let content = t(`${prefix}.${postfix}`);

        if (_status === JitsiRecordingConstants.status.ON && this.props._isTranscribing) {
            content += ` \u00B7 ${t('transcribing.labelToolTip')}`;
        }

        return content;
    }
}

/**
 * Maps (parts of) the Redux state to the associated
 * {@code RecordingExpandedLabel}'s props.
 *
 * @param {Object} state - The Redux state.
 * @param {IProps} ownProps - The component's own props.
 * @private
 * @returns {{
 *     _status: ?string
 * }}
 */
function _mapStateToProps(state: IReduxState, ownProps: any) {
    const { mode } = ownProps;

    return {
        _isTranscribing: isRecorderTranscriptionsRunning(state),
        _status: getSessionStatusToShow(state, mode)
    };
}

export default translate(connect(_mapStateToProps)(RecordingExpandedLabel));


################################################################################

## File: .\jitsi-meet\react\features\recording\components\native\styles.ts

import { createStyleSheet } from '../../../base/styles/functions.native';
import BaseTheme from '../../../base/ui/components/BaseTheme';

/**
 * The styles of the React {@code Components} of the feature recording.
 */
export default createStyleSheet({

    /**
     * Style for the recording indicator.
     */
    indicatorStyle: {
        marginRight: 4,
        marginLeft: 0,
        marginBottom: 0,
        backgroundColor: BaseTheme.palette.iconError
    }
});


################################################################################

## File: .\jitsi-meet\react\features\recording\components\Recording\AbstractHighlightButton.ts

import { Component } from 'react';
import { WithTranslation } from 'react-i18next';

import { IReduxState, IStore } from '../../../app/types';
import { openDialog } from '../../../base/dialog/actions';
import { MEET_FEATURES } from '../../../base/jwt/constants';
import { maybeShowPremiumFeatureDialog } from '../../../jaas/actions';
import { hideNotification, showNotification } from '../../../notifications/actions';
import { NOTIFICATION_TIMEOUT_TYPE, NOTIFICATION_TYPE } from '../../../notifications/constants';
import { iAmVisitor } from '../../../visitors/functions';
import { highlightMeetingMoment } from '../../actions.any';
import { PROMPT_RECORDING_NOTIFICATION_ID } from '../../constants';
import {
    getRecordButtonProps,
    isCloudRecordingRunning,
    isHighlightMeetingMomentDisabled
} from '../../functions';

import { StartRecordingDialog } from './index';

export interface IProps extends WithTranslation {

    /**
     * Indicates whether or not the button is disabled.
     */
    _disabled: boolean;

    /**
     * Indicates whether or not a highlight request is in progress.
     */
    _isHighlightInProgress: boolean;

    /**
     * Indicates whether or not the button should be visible.
     */
    _visible: boolean;

    /**
     * Redux dispatch function.
     */
    dispatch: IStore['dispatch'];
}

/**
 * Abstract class for the {@code AbstractHighlightButton} component.
 */
export default class AbstractHighlightButton<P extends IProps, S={}> extends Component<P, S> {
    /**
     * Initializes a new AbstractHighlightButton instance.
     *
     * @param {Object} props - The read-only properties with which the new
     * instance is to be initialized.
     */
    constructor(props: P) {
        super(props);

        this._onClick = this._onClick.bind(this);
    }

    /**
   * Handles clicking / pressing the button.
   *
   * @override
   * @protected
   * @returns {void}
   */
    _onClick() {
        const { _disabled, _isHighlightInProgress, dispatch } = this.props;

        if (_isHighlightInProgress) {
            return;
        }

        if (_disabled) {
            dispatch(showNotification({
                descriptionKey: 'recording.highlightMomentDisabled',
                titleKey: 'recording.highlightMoment',
                uid: PROMPT_RECORDING_NOTIFICATION_ID,
                customActionNameKey: [ 'localRecording.start' ],
                customActionHandler: [ () => {
                    dispatch(hideNotification(PROMPT_RECORDING_NOTIFICATION_ID));
                    const dialogShown = dispatch(maybeShowPremiumFeatureDialog(MEET_FEATURES.RECORDING));

                    if (!dialogShown) {
                        dispatch(openDialog(StartRecordingDialog));
                    }
                } ],
                appearance: NOTIFICATION_TYPE.NORMAL
            }, NOTIFICATION_TIMEOUT_TYPE.MEDIUM));
        } else {
            dispatch(highlightMeetingMoment());
        }
    }
}

/**
 * Maps (parts of) the Redux state to the associated
 * {@code AbstractHighlightButton}'s props.
 *
 * @param {Object} state - The Redux state.
 * @private
 * @returns {{
 *     _disabled: boolean,
 *     _isHighlightInProgress: boolean,
 *     _visible: boolean
 * }}
 */
export function _abstractMapStateToProps(state: IReduxState) {
    const isRecordingRunning = isCloudRecordingRunning(state);
    const isButtonDisabled = isHighlightMeetingMomentDisabled(state);
    const { webhookProxyUrl } = state['features/base/config'];
    const _iAmVisitor = iAmVisitor(state);
    const {
        disabled: isRecordButtonDisabled,
        visible: isRecordButtonVisible
    } = getRecordButtonProps(state);

    const canStartRecording = isRecordButtonVisible && !isRecordButtonDisabled;
    const _visible = Boolean((canStartRecording || isRecordingRunning) && Boolean(webhookProxyUrl) && !_iAmVisitor);

    return {
        _disabled: !isRecordingRunning,
        _isHighlightInProgress: isButtonDisabled,
        _visible
    };
}


################################################################################

## File: .\jitsi-meet\react\features\recording\components\Recording\AbstractRecordButton.ts

import { createToolbarEvent } from '../../../analytics/AnalyticsEvents';
import { sendAnalytics } from '../../../analytics/functions';
import { IReduxState } from '../../../app/types';
import { IconRecord, IconStop } from '../../../base/icons/svg';
import { MEET_FEATURES } from '../../../base/jwt/constants';
import { JitsiRecordingConstants } from '../../../base/lib-jitsi-meet';
import AbstractButton, { IProps as AbstractButtonProps } from '../../../base/toolbox/components/AbstractButton';
import { maybeShowPremiumFeatureDialog } from '../../../jaas/actions';
import { canStopRecording, getRecordButtonProps } from '../../functions';

/**
 * The type of the React {@code Component} props of
 * {@link AbstractRecordButton}.
 */
export interface IProps extends AbstractButtonProps {

    /**
     * True if the button needs to be disabled.
     */
    _disabled: boolean;

    /**
     * True if there is a running active recording, false otherwise.
     */
    _isRecordingRunning: boolean;

    /**
     * The tooltip to display when hovering over the button.
     */
    _tooltip?: string;
}

/**
 * An abstract implementation of a button for starting and stopping recording.
 */
export default class AbstractRecordButton<P extends IProps> extends AbstractButton<P> {
    accessibilityLabel = 'dialog.startRecording';
    toggledAccessibilityLabel = 'dialog.stopRecording';
    icon = IconRecord;
    label = 'dialog.startRecording';
    toggledLabel = 'dialog.stopRecording';
    toggledIcon = IconStop;

    /**
     * Returns the tooltip that should be displayed when the button is disabled.
     *
     * @private
     * @returns {string}
     */
    _getTooltip() {
        return this.props._tooltip ?? '';
    }

    /**
     * Helper function to be implemented by subclasses, which should be used
     * to handle the start recoding button being clicked / pressed.
     *
     * @protected
     * @returns {void}
     */
    _onHandleClick() {
        // To be implemented by subclass.
    }

    /**
     * Handles clicking / pressing the button.
     *
     * @override
     * @protected
     * @returns {void}
     */
    _handleClick() {
        const { _isRecordingRunning, dispatch } = this.props;

        sendAnalytics(createToolbarEvent(
            'recording.button',
            {
                'is_recording': _isRecordingRunning,
                type: JitsiRecordingConstants.mode.FILE
            }));
        const dialogShown = dispatch(maybeShowPremiumFeatureDialog(MEET_FEATURES.RECORDING));

        if (!dialogShown) {
            this._onHandleClick();
        }
    }

    /**
     * Helper function to be implemented by subclasses, which must return a
     * boolean value indicating if this button is disabled or not.
     *
     * @override
     * @protected
     * @returns {boolean}
     */
    _isDisabled() {
        return this.props._disabled;
    }

    /**
     * Indicates whether this button is in toggled state or not.
     *
     * @override
     * @protected
     * @returns {boolean}
     */
    _isToggled() {
        return this.props._isRecordingRunning;
    }
}

/**
 * Maps (parts of) the redux state to the associated props for the
 * {@code RecordButton} component.
 *
 * @param {Object} state - The Redux state.
 * @private
 * @returns {{
 *     _disabled: boolean,
 *     _isRecordingRunning: boolean,
 *     _tooltip: string,
 *     visible: boolean
 * }}
 */
export function _mapStateToProps(state: IReduxState) {
    const {
        disabled: _disabled,
        tooltip: _tooltip,
        visible
    } = getRecordButtonProps(state);

    return {
        _disabled,
        _isRecordingRunning: canStopRecording(state),
        _tooltip,
        visible
    };
}


################################################################################

## File: .\jitsi-meet\react\features\recording\components\Recording\AbstractStartRecordingDialog.ts

import { Component } from 'react';
import { WithTranslation } from 'react-i18next';

import { createRecordingDialogEvent } from '../../../analytics/AnalyticsEvents';
import { sendAnalytics } from '../../../analytics/functions';
import { IReduxState, IStore } from '../../../app/types';
import { IJitsiConference } from '../../../base/conference/reducer';
import { JitsiRecordingConstants } from '../../../base/lib-jitsi-meet';
import { updateDropboxToken } from '../../../dropbox/actions';
import { getDropboxData, getNewAccessToken, isEnabled as isDropboxEnabled } from '../../../dropbox/functions.any';
import { showErrorNotification } from '../../../notifications/actions';
import { NOTIFICATION_TIMEOUT_TYPE } from '../../../notifications/constants';
import { setRequestingSubtitles } from '../../../subtitles/actions.any';
import { setSelectedRecordingService, startLocalVideoRecording } from '../../actions';
import { RECORDING_METADATA_ID, RECORDING_TYPES } from '../../constants';
import { isRecordingSharingEnabled, shouldAutoTranscribeOnRecord, supportsLocalRecording } from '../../functions';

export interface IProps extends WithTranslation {

    /**
     * The app key for the dropbox authentication.
     */
    _appKey: string;

    /**
     * Requests transcribing when recording is turned on.
     */
    _autoTranscribeOnRecord: boolean;

    /**
     * The {@code JitsiConference} for the current conference.
     */
    _conference?: IJitsiConference;

    /**
     * Whether subtitles should be displayed or not.
     */
    _displaySubtitles?: boolean;

    /**
     * Whether to show file recordings service, even if integrations
     * are enabled.
     */
    _fileRecordingsServiceEnabled: boolean;

    /**
     * Whether to show the possibility to share file recording with other people (e.g. Meeting participants), based on
     * the actual implementation on the backend.
     */
    _fileRecordingsServiceSharingEnabled: boolean;

    /**
     * If true the dropbox integration is enabled, otherwise - disabled.
     */
    _isDropboxEnabled: boolean;

    /**
     * Whether or not local recording is enabled.
     */
    _localRecordingEnabled: boolean;

    /**
     * The dropbox refresh token.
     */
    _rToken: string;

    /**
     * Whether the record audio / video option is enabled by default.
     */
    _recordAudioAndVideo: boolean;

    /**
     * Whether or not the local participant is screensharing.
     */
    _screensharing: boolean;

    /**
     * Whether or not the screenshot capture feature is enabled.
     */
    _screenshotCaptureEnabled: boolean;

    /**
     * The selected language for subtitles.
     */
    _subtitlesLanguage: string | null;

    /**
     * The dropbox access token.
     */
    _token: string;

    /**
     * Access token's expiration date as UNIX timestamp.
     */
    _tokenExpireDate?: number;

    /**
     * The redux dispatch function.
     */
    dispatch: IStore['dispatch'];

    navigation: any;
}

interface IState {

    /**
     * <tt>true</tt> if we have valid oauth token.
     */
    isTokenValid: boolean;

    /**
     * <tt>true</tt> if we are in process of validating the oauth token.
     */
    isValidating: boolean;

    /**
     * Whether the local recording should record just the local user streams.
     */
    localRecordingOnlySelf: boolean;

    /**
     * The currently selected recording service of type: RECORDING_TYPES.
     */
    selectedRecordingService: string;

    /**
     * True if the user requested the service to share the recording with others.
     */
    sharingEnabled: boolean;

    /**
     * True if the user requested the service to record audio and video.
     */
    shouldRecordAudioAndVideo: boolean;

    /**
     * True if the user requested the service to record transcription.
     */
    shouldRecordTranscription: boolean;

    /**
     * Number of MiB of available space in user's Dropbox account.
     */
    spaceLeft?: number;

    /**
     * The display name of the user's Dropbox account.
     */
    userName?: string;
}

/**
 * Component for the recording start dialog.
 */
class AbstractStartRecordingDialog extends Component<IProps, IState> {
    /**
     * Initializes a new {@code StartRecordingDialog} instance.
     *
     * @inheritdoc
     */
    constructor(props: IProps) {
        super(props);

        // Bind event handler so it is only bound once for every instance.
        this._onSubmit = this._onSubmit.bind(this);
        this._onSelectedRecordingServiceChanged
            = this._onSelectedRecordingServiceChanged.bind(this);
        this._onSharingSettingChanged = this._onSharingSettingChanged.bind(this);
        this._toggleScreenshotCapture = this._toggleScreenshotCapture.bind(this);
        this._onLocalRecordingSelfChange = this._onLocalRecordingSelfChange.bind(this);
        this._onTranscriptionChange = this._onTranscriptionChange.bind(this);
        this._onRecordAudioAndVideoChange = this._onRecordAudioAndVideoChange.bind(this);

        let selectedRecordingService = '';

        // TODO: Potentially check if we need to handle changes of
        // _fileRecordingsServiceEnabled and _areIntegrationsEnabled()
        if (this.props._fileRecordingsServiceEnabled
                || !this._areIntegrationsEnabled()) {
            selectedRecordingService = RECORDING_TYPES.JITSI_REC_SERVICE;
        } else if (this._areIntegrationsEnabled()) {
            if (props._localRecordingEnabled && supportsLocalRecording()) {
                selectedRecordingService = RECORDING_TYPES.LOCAL;
            } else {
                selectedRecordingService = RECORDING_TYPES.DROPBOX;
            }
        }

        this.state = {
            isTokenValid: false,
            isValidating: false,
            userName: undefined,
            sharingEnabled: true,
            shouldRecordAudioAndVideo: this.props._recordAudioAndVideo,
            shouldRecordTranscription: this.props._autoTranscribeOnRecord,
            spaceLeft: undefined,
            selectedRecordingService,
            localRecordingOnlySelf: false
        };
    }

    /**
     * Validates the oauth access token.
     *
     * @inheritdoc
     * @returns {void}
     */
    componentDidMount() {
        if (typeof this.props._token !== 'undefined') {
            this._onTokenUpdated();
        }
    }

    /**
     * Validates the oauth access token.
     *
     * @inheritdoc
     * @returns {void}
     */
    componentDidUpdate(prevProps: IProps) {
        if (this.props._token !== prevProps._token) {
            this._onTokenUpdated();
        }
    }

    /**
     * Returns true if the integrations with third party services are enabled
     * and false otherwise.
     *
     * @returns {boolean} - True if the integrations with third party services
     * are enabled and false otherwise.
     */
    _areIntegrationsEnabled() {
        return this.props._isDropboxEnabled;
    }

    /**
     * Callback to handle sharing setting change from the dialog.
     *
     * @returns {void}
     */
    _onSharingSettingChanged() {
        this.setState({
            sharingEnabled: !this.state.sharingEnabled
        });
    }

    /**
     * Callback to handle local recording only self setting change.
     *
     * @returns {void}
     */
    _onLocalRecordingSelfChange() {
        this.setState({
            localRecordingOnlySelf: !this.state.localRecordingOnlySelf
        });
    }

    /**
     * Handles selected recording service changes.
     *
     * @param {string} selectedRecordingService - The new selected recording
     * service.
     * @returns {void}
     */
    _onSelectedRecordingServiceChanged(selectedRecordingService: string) {
        this.setState({ selectedRecordingService }, () => {
            this.props.dispatch(setSelectedRecordingService(selectedRecordingService));
        });
    }

    /**
     * Handles transcription switch change.
     *
     * @param {boolean} value - The new value.
     * @returns {void}
     */
    _onTranscriptionChange(value: boolean) {
        this.setState({
            shouldRecordTranscription: value
        });
    }

    /**
     * Handles audio and video switch change.
     *
     * @param {boolean} value - The new value.
     * @returns {void}
     */
    _onRecordAudioAndVideoChange(value: boolean) {
        this.setState({
            shouldRecordAudioAndVideo: value
        });
    }

    /**
     * Validates the dropbox access token and fetches account information.
     *
     * @returns {void}
     */
    _onTokenUpdated() {
        const { _appKey, _isDropboxEnabled, _token, _rToken, _tokenExpireDate, dispatch } = this.props;

        if (!_isDropboxEnabled) {
            return;
        }

        if (typeof _token === 'undefined') {
            this.setState({
                isTokenValid: false,
                isValidating: false
            });
        } else { // @ts-ignore
            if (_tokenExpireDate && Date.now() > new Date(_tokenExpireDate)) {
                getNewAccessToken(_appKey, _rToken)
                    .then((resp: { expireDate: number; rToken: string; token: string; }) =>
                        dispatch(updateDropboxToken(resp.token, resp.rToken, resp.expireDate)));

                return;
            }

            this.setState({
                isTokenValid: false,
                isValidating: true
            });
            getDropboxData(_token, _appKey).then(data => {
                if (typeof data === 'undefined') {
                    this.setState({
                        isTokenValid: false,
                        isValidating: false
                    });
                } else {
                    this.setState({
                        isTokenValid: true,
                        isValidating: false,
                        ...data
                    });
                }
            });
        }
    }

    /**
     * Starts a file recording session.
     *
     * @private
     * @returns {boolean} - True (to note that the modal should be closed).
     */
    _onSubmit() {
        const {
            _appKey,
            _conference,
            _displaySubtitles,
            _isDropboxEnabled,
            _rToken,
            _subtitlesLanguage,
            _token,
            dispatch
        } = this.props;
        let appData;
        const attributes: {
            type?: string;
        } = {};

        if (this.state.shouldRecordAudioAndVideo) {
            switch (this.state.selectedRecordingService) {
            case RECORDING_TYPES.DROPBOX: {
                if (_isDropboxEnabled && _token) {
                    appData = JSON.stringify({
                        'file_recording_metadata': {
                            'upload_credentials': {
                                'service_name': RECORDING_TYPES.DROPBOX,
                                'token': _token,
                                'r_token': _rToken,
                                'app_key': _appKey
                            }
                        }
                    });
                    attributes.type = RECORDING_TYPES.DROPBOX;
                } else {
                    dispatch(showErrorNotification({
                        titleKey: 'dialog.noDropboxToken'
                    }, NOTIFICATION_TIMEOUT_TYPE.LONG));

                    return;
                }
                break;
            }
            case RECORDING_TYPES.JITSI_REC_SERVICE: {
                appData = JSON.stringify({
                    'file_recording_metadata': {
                        'share': this.state.sharingEnabled
                    }
                });
                attributes.type = RECORDING_TYPES.JITSI_REC_SERVICE;
                break;
            }
            case RECORDING_TYPES.LOCAL: {
                dispatch(startLocalVideoRecording(this.state.localRecordingOnlySelf));

                return true;
            }
            }

            sendAnalytics(
                createRecordingDialogEvent('start', 'confirm.button', attributes)
            );

            this._toggleScreenshotCapture();
            _conference?.startRecording({
                mode: JitsiRecordingConstants.mode.FILE,
                appData
            });
        }

        if (this.state.selectedRecordingService === RECORDING_TYPES.JITSI_REC_SERVICE
                && this.state.shouldRecordTranscription) {
            dispatch(setRequestingSubtitles(true, _displaySubtitles, _subtitlesLanguage));
        }

        _conference?.getMetadataHandler().setMetadata(RECORDING_METADATA_ID, {
            isTranscribingEnabled: this.state.shouldRecordTranscription
        });

        return true;
    }

    /**
     * Toggles screenshot capture feature.
     *
     * @returns {void}
     */
    _toggleScreenshotCapture() {
        // To be implemented by subclass.
    }

    /**
     * Renders the platform specific dialog content.
     *
     * @protected
     * @returns {React$Component}
     */
    _renderDialogContent: () => React.Component;
}

/**
 * Maps (parts of) the Redux state to the associated props for the
 * {@code StartRecordingDialog} component.
 *
 * @param {Object} state - The Redux state.
 * @param {any} _ownProps - Component's own props.
 * @private
 * @returns {IProps}
 */
export function mapStateToProps(state: IReduxState, _ownProps: any) {
    const {
        recordingService,
        dropbox = { appKey: undefined },
        localRecording,
        recordings = { recordAudioAndVideo: true }
    } = state['features/base/config'];
    const {
        _displaySubtitles,
        _language: _subtitlesLanguage
    } = state['features/subtitles'];

    return {
        _appKey: dropbox.appKey ?? '',
        _autoTranscribeOnRecord: shouldAutoTranscribeOnRecord(state),
        _conference: state['features/base/conference'].conference,
        _displaySubtitles,
        _fileRecordingsServiceEnabled: recordingService?.enabled ?? false,
        _fileRecordingsServiceSharingEnabled: isRecordingSharingEnabled(state),
        _isDropboxEnabled: isDropboxEnabled(state),
        _localRecordingEnabled: !localRecording?.disable,
        _rToken: state['features/dropbox'].rToken ?? '',
        _recordAudioAndVideo: recordings?.recordAudioAndVideo ?? true,
        _subtitlesLanguage,
        _tokenExpireDate: state['features/dropbox'].expireDate,
        _token: state['features/dropbox'].token ?? ''
    };
}

export default AbstractStartRecordingDialog;


################################################################################

## File: .\jitsi-meet\react\features\recording\components\Recording\AbstractStopRecordingDialog.ts

import { Component } from 'react';
import { WithTranslation } from 'react-i18next';

import { createRecordingDialogEvent } from '../../../analytics/AnalyticsEvents';
import { sendAnalytics } from '../../../analytics/functions';
import { IReduxState, IStore } from '../../../app/types';
import { IJitsiConference } from '../../../base/conference/reducer';
import { JitsiRecordingConstants } from '../../../base/lib-jitsi-meet';
import { setVideoMuted } from '../../../base/media/actions';
import { setRequestingSubtitles } from '../../../subtitles/actions.any';
import { stopLocalVideoRecording } from '../../actions';
import { RECORDING_METADATA_ID } from '../../constants';
import { getActiveSession } from '../../functions';
import { ISessionData } from '../../reducer';

import LocalRecordingManager from './LocalRecordingManager';

/**
 * The type of the React {@code Component} props of
 * {@link AbstractStopRecordingDialog}.
 */
export interface IProps extends WithTranslation {

    /**
     * The {@code JitsiConference} for the current conference.
     */
    _conference?: IJitsiConference;

    /**
     * Whether subtitles should be displayed or not.
     */
    _displaySubtitles?: boolean;

    /**
     * The redux representation of the recording session to be stopped.
     */
    _fileRecordingSession?: ISessionData;

    /**
     * Whether the recording is a local recording or not.
     */
    _localRecording: boolean;

    /**
     * The selected language for subtitles.
     */
    _subtitlesLanguage: string | null;

    /**
     * The redux dispatch function.
     */
    dispatch: IStore['dispatch'];

    /**
     * The user trying to stop the video while local recording is running.
     */
    localRecordingVideoStop?: boolean;
}

/**
 * Abstract React Component for getting confirmation to stop a file recording
 * session in progress.
 *
 * @augments Component
 */
export default class AbstractStopRecordingDialog<P extends IProps>
    extends Component<P> {
    /**
     * Initializes a new {@code AbstrStopRecordingDialog} instance.
     *
     * @inheritdoc
     */
    constructor(props: P) {
        super(props);

        // Bind event handler so it is only bound once for every instance.
        this._onSubmit = this._onSubmit.bind(this);
        this._toggleScreenshotCapture = this._toggleScreenshotCapture.bind(this);
    }

    /**
     * Stops the recording session.
     *
     * @private
     * @returns {boolean} - True (to note that the modal should be closed).
     */
    _onSubmit() {
        sendAnalytics(createRecordingDialogEvent('stop', 'confirm.button'));

        const {
            _conference,
            _displaySubtitles,
            _fileRecordingSession,
            _localRecording,
            _subtitlesLanguage,
            dispatch,
            localRecordingVideoStop
        } = this.props;

        if (_localRecording) {
            dispatch(stopLocalVideoRecording());
            if (localRecordingVideoStop) {
                dispatch(setVideoMuted(true));
            }
        } else if (_fileRecordingSession) {
            _conference?.stopRecording(_fileRecordingSession.id);
            this._toggleScreenshotCapture();
        }

        // TODO: this should be an action in transcribing. -saghul
        this.props.dispatch(setRequestingSubtitles(Boolean(_displaySubtitles), _displaySubtitles, _subtitlesLanguage));

        this.props._conference?.getMetadataHandler().setMetadata(RECORDING_METADATA_ID, {
            isTranscribingEnabled: false
        });

        return true;
    }

    /**
     * Toggles screenshot capture feature.
     *
     * @returns {void}
     */
    _toggleScreenshotCapture() {
        // To be implemented by subclass.
    }
}

/**
 * Maps (parts of) the Redux state to the associated props for the
 * {@code StopRecordingDialog} component.
 *
 * @param {Object} state - The Redux state.
 * @private
 * @returns {IProps}
 */
export function _mapStateToProps(state: IReduxState) {
    const {
        _displaySubtitles,
        _language: _subtitlesLanguage
    } = state['features/subtitles'];

    return {
        _conference: state['features/base/conference'].conference,
        _displaySubtitles,
        _fileRecordingSession:
            getActiveSession(state, JitsiRecordingConstants.mode.FILE),
        _localRecording: LocalRecordingManager.isRecordingLocally(),
        _subtitlesLanguage
    };
}


################################################################################

## File: .\jitsi-meet\react\features\recording\components\Recording\index.native.ts

export { default as StartRecordingDialog } from './native/StartRecordingDialog';


################################################################################

## File: .\jitsi-meet\react\features\recording\components\Recording\index.web.ts

export { default as StartRecordingDialog } from './web/StartRecordingDialog';


################################################################################

## File: .\jitsi-meet\react\features\recording\components\Recording\LocalRecordingManager.native.ts

import { IStore } from '../../../app/types';

interface ILocalRecordingManager {
    addAudioTrackToLocalRecording: (track: any) => void;
    isRecordingLocally: () => boolean;
    selfRecording: {
        on: boolean;
        withVideo: boolean;
    };
    startLocalRecording: (store: IStore, onlySelf: boolean) => Promise<void>;
    stopLocalRecording: () => void;
}

const LocalRecordingManager: ILocalRecordingManager = {
    selfRecording: {
        on: false,
        withVideo: false
    },

    /**
     * Adds audio track to the recording stream.
     *
     * @param {any} track - Track to be added,.
     * @returns {void}
     */
    addAudioTrackToLocalRecording() { }, // eslint-disable-line @typescript-eslint/no-empty-function

    /**
     * Stops local recording.
     *
     * @returns {void}
     * */
    stopLocalRecording() { }, // eslint-disable-line @typescript-eslint/no-empty-function

    /**
     * Starts a local recording.
     *
     * @param {IStore} store - The Redux store.
     * @returns {void}
     */
    async startLocalRecording() { }, // eslint-disable-line @typescript-eslint/no-empty-function

    /**
     * Whether or not we're currently recording locally.
     *
     * @returns {boolean}
     */
    isRecordingLocally() {
        return false;
    }

};

export default LocalRecordingManager;


################################################################################

## File: .\jitsi-meet\react\features\recording\components\Recording\LocalRecordingManager.web.ts

import i18next from 'i18next';
import { v4 as uuidV4 } from 'uuid';
import fixWebmDuration from 'webm-duration-fix';

import { IStore } from '../../../app/types';
import { getRoomName } from '../../../base/conference/functions';
import { MEDIA_TYPE } from '../../../base/media/constants';
import { getLocalTrack, getTrackState } from '../../../base/tracks/functions';
import { inIframe } from '../../../base/util/iframeUtils';
import { stopLocalVideoRecording } from '../../actions.any';

interface ISelfRecording {
    on: boolean;
    withVideo: boolean;
}

interface ILocalRecordingManager {
    addAudioTrackToLocalRecording: (track: MediaStreamTrack) => void;
    audioContext: AudioContext | undefined;
    audioDestination: MediaStreamAudioDestinationNode | undefined;
    getFilename: () => string;
    initializeAudioMixer: () => void;
    isRecordingLocally: () => boolean;
    mediaType: string;
    mixAudioStream: (stream: MediaStream) => void;
    recorder: MediaRecorder | undefined;
    recordingData: Blob[];
    roomName: string;
    saveRecording: (recordingData: Blob[], filename: string) => void;
    selfRecording: ISelfRecording;
    startLocalRecording: (store: IStore, onlySelf: boolean) => Promise<void>;
    stopLocalRecording: () => void;
    stream: MediaStream | undefined;
    totalSize: number;
}

const getMimeType = (): string => {
    const possibleTypes = [
        'video/webm;codecs=vp8'
    ];

    for (const type of possibleTypes) {
        if (MediaRecorder.isTypeSupported(type)) {
            return type;
        }
    }
    throw new Error('No MIME Type supported by MediaRecorder');
};

const VIDEO_BIT_RATE = 2500000; // 2.5Mbps in bits
const MAX_SIZE = 1073741824; // 1GB in bytes

// Lazily initialize.
let preferredMediaType: string;

const LocalRecordingManager: ILocalRecordingManager = {
    recordingData: [],
    recorder: undefined,
    stream: undefined,
    audioContext: undefined,
    audioDestination: undefined,
    roomName: '',
    totalSize: MAX_SIZE,
    selfRecording: {
        on: false,
        withVideo: false
    },

    get mediaType() {
        if (this.selfRecording.on && !this.selfRecording.withVideo) {
            return 'audio/webm;';
        }
        if (!preferredMediaType) {
            preferredMediaType = getMimeType();
        }

        return preferredMediaType;
    },

    /**
     * Initializes audio context used for mixing audio tracks.
     *
     * @returns {void}
     */
    initializeAudioMixer() {
        this.audioContext = new AudioContext();
        this.audioDestination = this.audioContext.createMediaStreamDestination();
    },

    /**
     * Mixes multiple audio tracks to the destination media stream.
     *
     * @param {MediaStream} stream - The stream to mix.
     * @returns {void}
     * */
    mixAudioStream(stream) {
        if (stream.getAudioTracks().length > 0 && this.audioDestination) {
            this.audioContext?.createMediaStreamSource(stream).connect(this.audioDestination);
        }
    },

    /**
     * Adds audio track to the recording stream.
     *
     * @param {MediaStreamTrack} track - The track to be added.
     * @returns {void}
     */
    addAudioTrackToLocalRecording(track) {
        if (this.selfRecording.on) {
            return;
        }
        if (track) {
            const stream = new MediaStream([ track ]);

            this.mixAudioStream(stream);
        }
    },

    /**
     * Returns a filename based ono the Jitsi room name in the URL and timestamp.
     *
     * @returns {string}
     * */
    getFilename() {
        const now = new Date();
        const timestamp = now.toISOString();

        return `${this.roomName}_${timestamp}`;
    },

    /**
     * Saves local recording to file.
     *
     * @param {Array} recordingData - The recording data.
     * @param {string} filename - The name of the file.
     * @returns {void}
     * */
    async saveRecording(recordingData, filename) {
        // @ts-ignore
        const blob = await fixWebmDuration(new Blob(recordingData, { type: this.mediaType }));
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');

        const extension = this.mediaType.slice(this.mediaType.indexOf('/') + 1, this.mediaType.indexOf(';'));

        a.style.display = 'none';
        a.href = url;
        a.download = `${filename}.${extension}`;
        a.click();
    },

    /**
     * Stops local recording.
     *
     * @returns {void}
     * */
    stopLocalRecording() {
        if (this.recorder) {
            this.recorder.stop();
            this.recorder = undefined;
            this.audioContext = undefined;
            this.audioDestination = undefined;
            this.totalSize = MAX_SIZE;
            setTimeout(() => {
                if (this.recordingData.length > 0) {
                    this.saveRecording(this.recordingData, this.getFilename());
                }
            }, 1000);
        }
    },

    /**
     * Starts a local recording.
     *
     * @param {IStore} store - The redux store.
     * @param {boolean} onlySelf - Whether to record only self streams.
     * @returns {void}
     */
    async startLocalRecording(store, onlySelf) {
        const { dispatch, getState } = store;

        // @ts-ignore
        const supportsCaptureHandle = Boolean(navigator.mediaDevices.setCaptureHandleConfig) && !inIframe();
        const tabId = uuidV4();

        this.selfRecording.on = onlySelf;
        this.recordingData = [];
        this.roomName = getRoomName(getState()) ?? '';
        let gdmStream: MediaStream = new MediaStream();
        const tracks = getTrackState(getState());

        if (onlySelf) {
            let audioTrack: MediaStreamTrack | undefined = getLocalTrack(tracks, MEDIA_TYPE.AUDIO)?.jitsiTrack?.track;
            let videoTrack: MediaStreamTrack | undefined = getLocalTrack(tracks, MEDIA_TYPE.VIDEO)?.jitsiTrack?.track;

            if (!audioTrack) {
                APP.conference.muteAudio(false);
                setTimeout(() => APP.conference.muteAudio(true), 100);
                await new Promise(resolve => {
                    setTimeout(resolve, 100);
                });
            }
            if (videoTrack && videoTrack.readyState !== 'live') {
                videoTrack = undefined;
            }
            audioTrack = getLocalTrack(getTrackState(getState()), MEDIA_TYPE.AUDIO)?.jitsiTrack?.track;
            if (!audioTrack && !videoTrack) {
                throw new Error('NoLocalStreams');
            }
            this.selfRecording.withVideo = Boolean(videoTrack);
            const localTracks = [];

            audioTrack && localTracks.push(audioTrack);
            videoTrack && localTracks.push(videoTrack);
            this.stream = new MediaStream(localTracks);
        } else {
            if (supportsCaptureHandle) {
                // @ts-ignore
                navigator.mediaDevices.setCaptureHandleConfig({
                    handle: `JitsiMeet-${tabId}`,
                    permittedOrigins: [ '*' ]
                });
            }
            const localAudioTrack = getLocalTrack(tracks, MEDIA_TYPE.AUDIO)?.jitsiTrack?.track;

            // Starting chrome 107, the recorder does not record any data if the audio stream has no tracks
            // To fix this we create a track for the local user(muted track)
            if (!localAudioTrack) {
                APP.conference.muteAudio(false);
                setTimeout(() => APP.conference.muteAudio(true), 100);
                await new Promise(resolve => {
                    setTimeout(resolve, 100);
                });
            }

            // handle no mic permission
            if (!getLocalTrack(getTrackState(getState()), MEDIA_TYPE.AUDIO)?.jitsiTrack?.track) {
                throw new Error('NoMicTrack');
            }

            const currentTitle = document.title;

            document.title = i18next.t('localRecording.selectTabTitle');

            // @ts-ignore
            gdmStream = await navigator.mediaDevices.getDisplayMedia({
                video: { displaySurface: 'browser',
                    frameRate: 30 },
                audio: false, // @ts-ignore
                preferCurrentTab: true
            });
            document.title = currentTitle;

            const isBrowser = gdmStream.getVideoTracks()[0].getSettings().displaySurface === 'browser';

            if (!isBrowser || (supportsCaptureHandle // @ts-ignore
                && gdmStream.getVideoTracks()[0].getCaptureHandle()?.handle !== `JitsiMeet-${tabId}`)) {
                gdmStream.getTracks().forEach((track: MediaStreamTrack) => track.stop());
                throw new Error('WrongSurfaceSelected');
            }

            this.initializeAudioMixer();

            const allTracks = getTrackState(getState());

            allTracks.forEach((track: any) => {
                if (track.mediaType === MEDIA_TYPE.AUDIO) {
                    const audioTrack = track?.jitsiTrack?.track;

                    this.addAudioTrackToLocalRecording(audioTrack);
                }
            });
            this.stream = new MediaStream([
                ...this.audioDestination?.stream.getAudioTracks() || [],
                gdmStream.getVideoTracks()[0]
            ]);
        }

        this.recorder = new MediaRecorder(this.stream, {
            mimeType: this.mediaType,
            videoBitsPerSecond: VIDEO_BIT_RATE
        });
        this.recorder.addEventListener('dataavailable', e => {
            if (e.data && e.data.size > 0) {
                this.recordingData.push(e.data);
                this.totalSize -= e.data.size;
                if (this.totalSize <= 0) {
                    dispatch(stopLocalVideoRecording());
                }
            }
        });

        if (!onlySelf) {
            this.recorder.addEventListener('stop', () => {
                this.stream?.getTracks().forEach((track: MediaStreamTrack) => track.stop());
                gdmStream?.getTracks().forEach((track: MediaStreamTrack) => track.stop());
            });

            gdmStream?.addEventListener('inactive', () => {
                dispatch(stopLocalVideoRecording());
            });

            this.stream.addEventListener('inactive', () => {
                dispatch(stopLocalVideoRecording());
            });
        }

        this.recorder.start(5000);
    },

    /**
     * Whether or not we're currently recording locally.
     *
     * @returns {boolean}
     */
    isRecordingLocally() {
        return Boolean(this.recorder);
    }

};

export default LocalRecordingManager;


################################################################################

## File: .\jitsi-meet\react\features\recording\components\Recording\styles.native.ts

import ColorSchemeRegistry from '../../../base/color-scheme/ColorSchemeRegistry';
import { schemeColor } from '../../../base/color-scheme/functions';
import { BoxModel } from '../../../base/styles/components/styles/BoxModel';
import BaseTheme from '../../../base/ui/components/BaseTheme.native';

/* eslint-disable @typescript-eslint/no-var-requires */
export const DROPBOX_LOGO = require('../../../../../images/dropboxLogo_square.png');
export const ICON_CLOUD = require('../../../../../images/icon-cloud.png');
export const ICON_INFO = require('../../../../../images/icon-info.png');
export const ICON_USERS = require('../../../../../images/icon-users.png');
export const LOCAL_RECORDING = require('../../../../../images/downloadLocalRecording.png');
export const TRACK_COLOR = BaseTheme.palette.ui07;
/* eslint-enable @typescript-eslint/no-var-requires */

// XXX The "standard" {@code BoxModel.padding} has been deemed insufficient in
// the special case(s) of the recording feature below.
const _PADDING = BoxModel.padding * 1.5;

const header = {
    alignItems: 'center',
    flex: 0,
    flexDirection: 'row',
    justifyContent: 'space-between',
    paddingBottom: _PADDING,
    paddingTop: _PADDING
};

const recordingIcon = {
    width: BaseTheme.spacing[4],
    height: BaseTheme.spacing[4]
};

const title = {
    flex: 1,
    fontSize: 16,
    fontWeight: 'bold',
    textAlign: 'left',
    paddingLeft: BoxModel.padding
};

export default {
    /**
     * Container for the StartRecordingDialog screen.
     */
    startRecodingContainer: {
        backgroundColor: BaseTheme.palette.ui01,
        display: 'flex',
        flex: 1,
        flexDirection: 'column',
        justifyContent: 'center',
        paddingTop: BaseTheme.spacing[3]
    },

    /**
     * Label for the start recording button.
     */
    startRecordingLabel: {
        color: BaseTheme.palette.text01,
        marginRight: 12
    },
    highlightButton: {
        backgroundColor: BaseTheme.palette.ui09,
        flexDirection: 'row',
        alignItems: 'center',
        marginLeft: BaseTheme.spacing[0],
        marginBottom: BaseTheme.spacing[0],
        marginRight: BaseTheme.spacing[1]
    },
    highlightButtonText: {
        color: BaseTheme.palette.field01,
        paddingLeft: BaseTheme.spacing[2],
        ...BaseTheme.typography.labelBold
    },
    highlightDialog: {
        paddingLeft: BaseTheme.spacing[3],
        paddingRight: BaseTheme.spacing[3],
        paddingTop: BaseTheme.spacing[4],
        paddingBottom: BaseTheme.spacing[7]
    },
    highlightDialogHeading: {
        ...BaseTheme.typography.heading5,
        color: BaseTheme.palette.text01,
        marginBottom: BaseTheme.spacing[3]
    },
    highlightDialogText: {
        ...BaseTheme.typography.bodyLongRegularLarge,
        color: BaseTheme.palette.text01,
        marginBottom: BaseTheme.spacing[5]
    },
    highlightDialogButtonsContainer: {
        display: 'flex',
        flexDirection: 'column-reverse'
    },
    highlightDialogButtonsSpace: {
        height: 16,
        width: '100%'
    }

};

/**
 * Color schemed styles for the @{code StartRecordingDialogContent} component.
 */
ColorSchemeRegistry.register('StartRecordingDialogContent', {

    container: {
        flex: 0,
        flexDirection: 'column'
    },

    controlDisabled: {
        opacity: 0.5
    },

    header: {
        ...header,
        marginHorizontal: BaseTheme.spacing[3]
    },

    headerIntegrations: {
        ...header,
        paddingHorizontal: BaseTheme.spacing[3]
    },

    headerInfo: {
        ...header,
        backgroundColor: BaseTheme.palette.warning02,
        marginBottom: BaseTheme.spacing[4],
        paddingHorizontal: BaseTheme.spacing[3]
    },

    loggedIn: {
        paddingHorizontal: _PADDING
    },

    recordingIcon: {
        ...recordingIcon
    },

    recordingInfoIcon: {
        ...recordingIcon
    },

    recordingText: {
        color: BaseTheme.palette.text01
    },

    switch: {
        color: BaseTheme.palette.ui10
    },

    title: {
        ...title
    },

    titleInfo: {
        ...title,
        color: BaseTheme.palette.ui01
    },

    text: {
        color: schemeColor('text')
    }
});


################################################################################

## File: .\jitsi-meet\react\features\recording\components\Recording\styles.web.ts

// XXX CSS is used on Web, JavaScript styles are use only for mobile. Export an
// (empty) object so that styles[*] statements on Web don't trigger errors.

export default {};

export const DROPBOX_LOGO = 'images/dropboxLogo_square.png';

export const LOCAL_RECORDING = 'images/downloadLocalRecording.png';

export const ICON_CLOUD = 'images/icon-cloud.png';

export const ICON_INFO = 'images/icon-info.png';

export const ICON_USERS = 'images/icon-users.png';

export const ICON_OPTIONS = 'images/icon-info.png';


################################################################################

## File: .\jitsi-meet\react\features\recording\components\Recording\native\RecordButton.ts

import { Platform } from 'react-native';
import { connect } from 'react-redux';

import { IReduxState } from '../../../../app/types';
import { openDialog } from '../../../../base/dialog/actions';
import { IOS_RECORDING_ENABLED, RECORDING_ENABLED } from '../../../../base/flags/constants';
import { getFeatureFlag } from '../../../../base/flags/functions';
import { translate } from '../../../../base/i18n/functions';
import { navigate }
    from '../../../../mobile/navigation/components/conference/ConferenceNavigationContainerRef';
import { screen } from '../../../../mobile/navigation/routes';
import { IProps, _mapStateToProps as abstractMapStateToProps } from '../../LiveStream/AbstractStartLiveStreamDialog';
import AbstractRecordButton, {
    IProps as AbstractProps,
    _mapStateToProps as _abstractMapStateToProps
} from '../AbstractRecordButton';

import StopRecordingDialog from './StopRecordingDialog';

type Props = IProps & AbstractProps;

/**
 * Button for opening a screen where a recording session can be started.
 */
class RecordButton extends AbstractRecordButton<Props> {

    /**
     * Handles clicking / pressing the button.
     *
     * @override
     * @protected
     * @returns {void}
     */
    _onHandleClick() {
        const { _isRecordingRunning, dispatch } = this.props;

        if (_isRecordingRunning) {
            dispatch(openDialog(StopRecordingDialog));
        } else {
            navigate(screen.conference.recording);
        }
    }
}

/**
 * Maps (parts of) the redux state to the associated props for this component.
 *
 * @param {Object} state - The redux state.
 * @param {Object} ownProps - The properties explicitly passed to the component
 * instance.
 * @private
 * @returns {Props}
 */
export function mapStateToProps(state: IReduxState) {
    const enabled = getFeatureFlag(state, RECORDING_ENABLED, true);
    const iosEnabled = Platform.OS !== 'ios' || getFeatureFlag(state, IOS_RECORDING_ENABLED, false);
    const abstractProps = _abstractMapStateToProps(state);

    return {
        ...abstractProps,
        ...abstractMapStateToProps(state),
        visible: enabled && iosEnabled && abstractProps.visible
    };
}

export default translate(connect(mapStateToProps)(RecordButton));


################################################################################

## File: .\jitsi-meet\react\features\recording\components\Recording\web\RecordButton.ts

import { connect } from 'react-redux';

import { IReduxState } from '../../../../app/types';
import { openDialog } from '../../../../base/dialog/actions';
import { translate } from '../../../../base/i18n/functions';
import AbstractRecordButton, {
    IProps,
    _mapStateToProps as _abstractMapStateToProps
} from '../AbstractRecordButton';

import StartRecordingDialog from './StartRecordingDialog';
import StopRecordingDialog from './StopRecordingDialog';


/**
 * Button for opening a dialog where a recording session can be started.
 */
class RecordingButton extends AbstractRecordButton<IProps> {

    /**
     * Handles clicking / pressing the button.
     *
     * @override
     * @protected
     * @returns {void}
     */
    _onHandleClick() {
        const { _isRecordingRunning, dispatch } = this.props;

        dispatch(openDialog(
            _isRecordingRunning ? StopRecordingDialog : StartRecordingDialog
        ));
    }
}

/**
 * Maps (parts of) the redux state to the associated props for the
 * {@code RecordButton} component.
 *
 * @param {Object} state - The Redux state.
 * @private
 * @returns {{
 *     _fileRecordingsDisabledTooltipKey: ?string,
 *     _isRecordingRunning: boolean,
 *     _disabled: boolean,
 *     visible: boolean
 * }}
 */
export function _mapStateToProps(state: IReduxState) {
    const abstractProps = _abstractMapStateToProps(state);
    const { toolbarButtons } = state['features/toolbox'];
    const visible = Boolean(toolbarButtons?.includes('recording') && abstractProps.visible);

    return {
        ...abstractProps,
        visible
    };
}

export default translate(connect(_mapStateToProps)(RecordingButton));


################################################################################

## File: .\jitsi-meet\react\features\rejoin\middleware.ts

import { createRejoinedEvent } from '../analytics/AnalyticsEvents';
import { sendAnalytics } from '../analytics/functions';
import StateListenerRegistry from '../base/redux/StateListenerRegistry';

StateListenerRegistry.register(
    /* selector */ state => {
        const recentList = state['features/recent-list'];

        // Return the most recent conference entry
        return recentList?.length && recentList[recentList.length - 1];
    },
    // eslint-disable-next-line no-empty-pattern
    /* listener */ (newMostRecent, { }, prevMostRecent) => {
        if (prevMostRecent && newMostRecent) {

            // Send the rejoined event just before the duration is reset on the most recent entry
            if (prevMostRecent.conference === newMostRecent.conference && newMostRecent.duration === 0) {
                sendAnalytics(
                    createRejoinedEvent({
                        lastConferenceDuration: prevMostRecent.duration / 1000,
                        timeSinceLeft: (Date.now() - (prevMostRecent.date + prevMostRecent.duration)) / 1000,
                        url: prevMostRecent.conference
                    })
                );
            }
        }
    });


################################################################################

## File: .\jitsi-meet\react\features\remote-control\actions.ts

// @ts-expect-error
import $ from 'jquery';
import React from 'react';

import { IStore } from '../app/types';
import { openDialog } from '../base/dialog/actions';
import { JitsiConferenceEvents } from '../base/lib-jitsi-meet';
import { pinParticipant } from '../base/participants/actions';
import {
    getParticipantDisplayName,
    getPinnedParticipant,
    getVirtualScreenshareParticipantByOwnerId
} from '../base/participants/functions';
import { toggleScreensharing } from '../base/tracks/actions';
import { getLocalDesktopTrack } from '../base/tracks/functions';
import { showNotification } from '../notifications/actions';
import { NOTIFICATION_TIMEOUT_TYPE } from '../notifications/constants';
import { isScreenVideoShared } from '../screen-share/functions';

import {
    CAPTURE_EVENTS,
    REMOTE_CONTROL_ACTIVE,
    SET_CONTROLLED_PARTICIPANT,
    SET_CONTROLLER,
    SET_RECEIVER_ENABLED,
    SET_RECEIVER_TRANSPORT,
    SET_REQUESTED_PARTICIPANT
} from './actionTypes';
import RemoteControlAuthorizationDialog from './components/RemoteControlAuthorizationDialog';
import {
    DISCO_REMOTE_CONTROL_FEATURE,
    EVENTS,
    PERMISSIONS_ACTIONS,
    REMOTE_CONTROL_MESSAGE_NAME,
    REQUESTS
} from './constants';
import {
    getKey,
    getModifiers,
    getRemoteConrolEventCaptureArea,
    isRemoteControlEnabled,
    sendRemoteControlEndpointMessage
} from './functions';
import logger from './logger';

/**
 * Listeners.
 */
let permissionsReplyListener: Function | undefined,
    receiverEndpointMessageListener: Function, stopListener: Function | undefined;

/**
 * Signals that the remote control authorization dialog should be displayed.
 *
 * @param {string} participantId - The id of the participant who is requesting
 * the authorization.
 * @returns {{
 *     type: OPEN_DIALOG,
 *     component: {RemoteControlAuthorizationDialog},
 *     componentProps: {
 *         participantId: {string}
 *      }
 * }}
 * @public
 */
export function openRemoteControlAuthorizationDialog(participantId: string) {
    return openDialog(RemoteControlAuthorizationDialog, { participantId });
}

/**
 * Sets the remote control active property.
 *
 * @param {boolean} active - The new value for the active property.
 * @returns {Function}
 */
export function setRemoteControlActive(active: boolean) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const { active: oldActive } = state['features/remote-control'];
        const { conference } = state['features/base/conference'];

        if (active !== oldActive) {
            dispatch({
                type: REMOTE_CONTROL_ACTIVE,
                active
            });
            conference?.setLocalParticipantProperty('remoteControlSessionStatus', active);
        }
    };
}

/**
 * Requests permissions from the remote control receiver side.
 *
 * @param {string} userId - The user id of the participant that will be
 * requested.
 * @returns {Function}
 */
export function requestRemoteControl(userId: string) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const enabled = isRemoteControlEnabled(state);

        if (!enabled) {
            return Promise.reject(new Error('Remote control is disabled!'));
        }

        dispatch(setRemoteControlActive(true));

        logger.log(`Requsting remote control permissions from: ${userId}`);

        const { conference } = state['features/base/conference'];


        permissionsReplyListener = (participant: any, event: any) => {
            dispatch(processPermissionRequestReply(participant.getId(), event));
        };

        conference?.on(JitsiConferenceEvents.ENDPOINT_MESSAGE_RECEIVED, permissionsReplyListener);

        dispatch({
            type: SET_REQUESTED_PARTICIPANT,
            requestedParticipant: userId
        });

        if (!sendRemoteControlEndpointMessage(
            conference,
            userId,
            {
                type: EVENTS.permissions,
                action: PERMISSIONS_ACTIONS.request
            })) {
            dispatch(clearRequest());
        }
    };
}

/**
 * Handles permission request replies on the controller side.
 *
 * @param {string} participantId - The participant that sent the request.
 * @param {EndpointMessage} event - The permission request event.
 * @returns {Function}
 */
export function processPermissionRequestReply(participantId: string, event: any) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const { action, name, type } = event;
        const { requestedParticipant } = state['features/remote-control'].controller;

        if (isRemoteControlEnabled(state) && name === REMOTE_CONTROL_MESSAGE_NAME && type === EVENTS.permissions
                && participantId === requestedParticipant) {
            let descriptionKey, permissionGranted = false;

            switch (action) {
            case PERMISSIONS_ACTIONS.grant: {
                dispatch({
                    type: SET_CONTROLLED_PARTICIPANT,
                    controlled: participantId
                });

                logger.log('Remote control permissions granted!', participantId);
                logger.log('Starting remote control controller.');

                const { conference } = state['features/base/conference'];

                stopListener = (participant: any, stopEvent: { name: string; type: string; }) => {
                    dispatch(handleRemoteControlStoppedEvent(participant.getId(), stopEvent));
                };

                conference?.on(JitsiConferenceEvents.ENDPOINT_MESSAGE_RECEIVED, stopListener);

                dispatch(resume());

                permissionGranted = true;
                descriptionKey = 'dialog.remoteControlAllowedMessage';
                break;
            }
            case PERMISSIONS_ACTIONS.deny:
                logger.log('Remote control permissions denied!', participantId);
                descriptionKey = 'dialog.remoteControlDeniedMessage';
                break;
            case PERMISSIONS_ACTIONS.error:
                logger.error('Error occurred on receiver side');
                descriptionKey = 'dialog.remoteControlErrorMessage';
                break;
            default:
                logger.error('Unknown reply received!');
                descriptionKey = 'dialog.remoteControlErrorMessage';
            }

            dispatch(clearRequest());

            if (!permissionGranted) {
                dispatch(setRemoteControlActive(false));
            }

            dispatch(showNotification({
                descriptionArguments: { user: getParticipantDisplayName(state, participantId) },
                descriptionKey,
                titleKey: 'dialog.remoteControlTitle'
            }, NOTIFICATION_TIMEOUT_TYPE.MEDIUM));

            if (permissionGranted) {
                // the remote control permissions has been granted
                // pin the controlled participant
                const pinnedParticipant = getPinnedParticipant(state);
                const virtualScreenshareParticipant = getVirtualScreenshareParticipantByOwnerId(state, participantId);
                const pinnedId = pinnedParticipant?.id;

                if (virtualScreenshareParticipant?.id && pinnedId !== virtualScreenshareParticipant?.id) {
                    dispatch(pinParticipant(virtualScreenshareParticipant?.id));
                } else if (!virtualScreenshareParticipant?.id && pinnedId !== participantId) {
                    dispatch(pinParticipant(participantId));
                }
            }
        } else {
            // different message type or another user -> ignoring the message
        }
    };
}

/**
 * Handles remote control stopped.
 *
 * @param {string} participantId - The ID of the participant that has sent the event.
 * @param {EndpointMessage} event - EndpointMessage event from the data channels.
 * @property {string} type - The function process only events with name REMOTE_CONTROL_MESSAGE_NAME.
 * @returns {void}
 */
export function handleRemoteControlStoppedEvent(participantId: Object, event: { name: string; type: string; }) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const { name, type } = event;
        const { controlled } = state['features/remote-control'].controller;

        if (isRemoteControlEnabled(state) && name === REMOTE_CONTROL_MESSAGE_NAME && type === EVENTS.stop
                && participantId === controlled) {
            dispatch(stopController());
        }
    };
}

/**
 * Stops processing the mouse and keyboard events. Removes added listeners.
 * Enables the keyboard shortcuts. Displays dialog to notify the user that remote control session has ended.
 *
 * @param {boolean} notifyRemoteParty - If true a endpoint message to the controlled participant will be sent.
 * @returns {void}
 */
export function stopController(notifyRemoteParty = false) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const { controlled } = state['features/remote-control'].controller;

        if (!controlled) {
            return;
        }

        const { conference } = state['features/base/conference'];

        if (notifyRemoteParty) {
            sendRemoteControlEndpointMessage(conference, controlled, {
                type: EVENTS.stop
            });
        }

        logger.log('Stopping remote control controller.');

        conference?.off(JitsiConferenceEvents.ENDPOINT_MESSAGE_RECEIVED, stopListener);
        stopListener = undefined;

        dispatch(pause());

        dispatch({
            type: SET_CONTROLLED_PARTICIPANT,
            controlled: undefined
        });

        dispatch(setRemoteControlActive(false));
        dispatch(showNotification({
            descriptionKey: 'dialog.remoteControlStopMessage',
            titleKey: 'dialog.remoteControlTitle'
        }, NOTIFICATION_TIMEOUT_TYPE.LONG));
    };
}

/**
 * Clears a pending permission request.
 *
 * @returns {Function}
 */
export function clearRequest() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const { conference } = getState()['features/base/conference'];

        dispatch({
            type: SET_REQUESTED_PARTICIPANT,
            requestedParticipant: undefined
        });

        conference?.off(JitsiConferenceEvents.ENDPOINT_MESSAGE_RECEIVED, permissionsReplyListener);
        permissionsReplyListener = undefined;
    };
}


/**
 * Sets that transport object that is used by the receiver to communicate with the native part of the remote control
 * implementation.
 *
 * @param {Transport} transport - The transport to be set.
 * @returns {{
 *      type: SET_RECEIVER_TRANSPORT,
 *      transport: Transport
 * }}
 */
export function setReceiverTransport(transport?: Object) {
    return {
        type: SET_RECEIVER_TRANSPORT,
        transport
    };
}

/**
 * Enables the receiver functionality.
 *
 * @returns {Function}
 */
export function enableReceiver() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const { enabled } = state['features/remote-control'].receiver;

        if (enabled) {
            return;
        }

        const { connection } = state['features/base/connection'];
        const { conference } = state['features/base/conference'];

        if (!connection || !conference) {
            logger.error('Couldn\'t enable the remote receiver! The connection or conference instance is undefined!');

            return;
        }

        dispatch({
            type: SET_RECEIVER_ENABLED,
            enabled: true
        });

        connection.addFeature(DISCO_REMOTE_CONTROL_FEATURE, true);
        receiverEndpointMessageListener = (participant: any, message: {
            action: string; name: string; type: string; }) => {
            dispatch(endpointMessageReceived(participant.getId(), message));
        };
        conference.on(JitsiConferenceEvents.ENDPOINT_MESSAGE_RECEIVED, receiverEndpointMessageListener);
    };
}

/**
 * Disables the receiver functionality.
 *
 * @returns {Function}
 */
export function disableReceiver() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const { enabled } = state['features/remote-control'].receiver;

        if (!enabled) {
            return;
        }

        const { connection } = state['features/base/connection'];
        const { conference } = state['features/base/conference'];

        if (!connection || !conference) {
            logger.error('Couldn\'t enable the remote receiver! The connection or conference instance is undefined!');

            return;
        }

        logger.log('Remote control receiver disabled.');

        dispatch({
            type: SET_RECEIVER_ENABLED,
            enabled: false
        });

        dispatch(stopReceiver(true));

        connection.removeFeature(DISCO_REMOTE_CONTROL_FEATURE);
        conference.off(JitsiConferenceEvents.ENDPOINT_MESSAGE_RECEIVED, receiverEndpointMessageListener);
    };
}

/**
 * Stops a remote control session on the receiver side.
 *
 * @param {boolean} [dontNotifyLocalParty] - If true - a notification about stopping
 * the remote control won't be displayed.
 * @param {boolean} [dontNotifyRemoteParty] - If true a endpoint message to the controller participant will be sent.
 * @returns {Function}
 */
export function stopReceiver(dontNotifyLocalParty = false, dontNotifyRemoteParty = false) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const { receiver } = state['features/remote-control'];
        const { controller, transport } = receiver;

        if (!controller) {
            return;
        }

        const { conference } = state['features/base/conference'];

        if (!dontNotifyRemoteParty) {
            sendRemoteControlEndpointMessage(conference, controller, {
                type: EVENTS.stop
            });
        }

        dispatch({
            type: SET_CONTROLLER,
            controller: undefined
        });

        transport?.sendEvent({
            name: REMOTE_CONTROL_MESSAGE_NAME,
            type: EVENTS.stop
        });

        dispatch(setRemoteControlActive(false));

        if (!dontNotifyLocalParty) {
            dispatch(showNotification({
                descriptionKey: 'dialog.remoteControlStopMessage',
                titleKey: 'dialog.remoteControlTitle'
            }, NOTIFICATION_TIMEOUT_TYPE.LONG));
        }
    };
}


/**
 * Handles only remote control endpoint messages.
 *
 * @param {string} participantId - The controller participant ID.
 * @param {Object} message - EndpointMessage from the data channels.
 * @param {string} message.name - The function processes only messages with
 * name REMOTE_CONTROL_MESSAGE_NAME.
 * @returns {Function}
 */
export function endpointMessageReceived(participantId: string, message: {
    action: string; name: string; type: string; }) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const { action, name, type } = message;

        if (name !== REMOTE_CONTROL_MESSAGE_NAME) {
            return;
        }

        const state = getState();
        const { receiver } = state['features/remote-control'];
        const { enabled, transport } = receiver;

        if (enabled) {
            const { controller } = receiver;

            if (!controller && type === EVENTS.permissions && action === PERMISSIONS_ACTIONS.request) {
                dispatch(setRemoteControlActive(true));
                dispatch(openRemoteControlAuthorizationDialog(participantId));
            } else if (controller === participantId) {
                if (type === EVENTS.stop) {
                    dispatch(stopReceiver(false, true));
                } else { // forward the message
                    try {
                        transport?.sendEvent(message);
                    } catch (error) {
                        logger.error('Error while trying to execute remote control message', error);
                    }
                }
            } // else ignore
        } else {
            logger.log('Remote control message is ignored because remote control is disabled', message);
        }
    };
}

/**
 * Denies remote control access for user associated with the passed user id.
 *
 * @param {string} participantId - The id associated with the user who sent the
 * request for remote control authorization.
 * @returns {Function}
 */
export function deny(participantId: string) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const { conference } = state['features/base/conference'];

        dispatch(setRemoteControlActive(false));
        sendRemoteControlEndpointMessage(conference, participantId, {
            type: EVENTS.permissions,
            action: PERMISSIONS_ACTIONS.deny
        });
    };
}

/**
 * Sends start remote control request to the native implementation.
 *
 * @returns {Function}
 */
export function sendStartRequest() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const tracks = state['features/base/tracks'];
        const track = getLocalDesktopTrack(tracks);
        const { sourceId } = track?.jitsiTrack || {};
        const { transport } = state['features/remote-control'].receiver;

        if (typeof sourceId === 'undefined') {
            return Promise.reject(new Error('Cannot identify screen for the remote control session'));
        }

        return transport?.sendRequest({
            name: REMOTE_CONTROL_MESSAGE_NAME,
            type: REQUESTS.start,
            sourceId
        });
    };
}

/**
 * Grants remote control access to user associated with the passed user id.
 *
 * @param {string} participantId - The id associated with the user who sent the
 * request for remote control authorization.
 * @returns {Function}
 */
export function grant(participantId: string) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        dispatch({
            type: SET_CONTROLLER,
            controller: participantId
        });
        logger.log(`Remote control permissions granted to: ${participantId}`);

        let promise;
        const state = getState();
        const tracks = state['features/base/tracks'];
        const track = getLocalDesktopTrack(tracks);
        const isScreenSharing = isScreenVideoShared(state);
        const { sourceType } = track?.jitsiTrack || {};

        if (isScreenSharing && sourceType === 'screen') {
            promise = dispatch(sendStartRequest());
        } else {
            promise = dispatch(toggleScreensharing(
                true,
                false,
                { desktopSharingSources: [ 'screen' ] }
            ))
            .then(() => dispatch(sendStartRequest()));
        }

        const { conference } = state['features/base/conference'];

        promise
            .then(() => sendRemoteControlEndpointMessage(conference, participantId, {
                type: EVENTS.permissions,
                action: PERMISSIONS_ACTIONS.grant
            }))
            .catch((error: any) => {
                logger.error(error);

                sendRemoteControlEndpointMessage(conference, participantId, {
                    type: EVENTS.permissions,
                    action: PERMISSIONS_ACTIONS.error
                });

                dispatch(showNotification({
                    descriptionKey: 'dialog.startRemoteControlErrorMessage',
                    titleKey: 'dialog.remoteControlTitle'
                }, NOTIFICATION_TIMEOUT_TYPE.LONG));

                dispatch(stopReceiver(true));
            });
    };
}

/**
 * Handler for mouse click events on the controller side.
 *
 * @param {string} type - The type of event ("mousedown"/"mouseup").
 * @param {Event} event - The mouse event.
 * @returns {Function}
 */
export function mouseClicked(type: string, event: React.MouseEvent) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const { conference } = state['features/base/conference'];
        const { controller } = state['features/remote-control'];

        sendRemoteControlEndpointMessage(conference, controller.controlled, {
            type,

            // @ts-ignore
            button: event.which
        });
    };
}

/**
 * Handles mouse moved events on the controller side.
 *
 * @param {Event} event - The mouse event.
 * @returns {Function}
 */
export function mouseMoved(event: React.MouseEvent) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const area = getRemoteConrolEventCaptureArea();

        if (!area) {
            return;
        }

        const position = area.position();
        const state = getState();
        const { conference } = state['features/base/conference'];
        const { controller } = state['features/remote-control'];

        sendRemoteControlEndpointMessage(conference, controller.controlled, {
            type: EVENTS.mousemove,
            x: (event.pageX - position.left) / area.width(),
            y: (event.pageY - position.top) / area.height()
        });
    };
}

/**
 * Handles mouse scroll events on the controller side.
 *
 * @param {Event} event - The mouse event.
 * @returns {Function}
 */
export function mouseScrolled(event: { deltaX: number; deltaY: number; }) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const { conference } = state['features/base/conference'];
        const { controller } = state['features/remote-control'];

        sendRemoteControlEndpointMessage(conference, controller.controlled, {
            type: EVENTS.mousescroll,
            x: event.deltaX,
            y: event.deltaY
        });
    };
}

/**
 * Handles key press events on the controller side..
 *
 * @param {string} type - The type of event ("keydown"/"keyup").
 * @param {Event} event - The key event.
 * @returns {Function}
 */
export function keyPressed(type: string, event: React.KeyboardEvent) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const { conference } = state['features/base/conference'];
        const { controller } = state['features/remote-control'];

        sendRemoteControlEndpointMessage(conference, controller.controlled, {
            type,
            key: getKey(event),
            modifiers: getModifiers(event)
        });
    };
}

/**
* Disables the keyboatd shortcuts. Starts collecting remote control
* events. It can be used to resume an active remote control session which
* was paused with the pause action.
*
* @returns {Function}
*/
export function resume() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const area = getRemoteConrolEventCaptureArea();
        const state = getState();
        const { controller } = state['features/remote-control'];
        const { controlled, isCapturingEvents } = controller;

        if (!isRemoteControlEnabled(state) || !area || !controlled || isCapturingEvents) {
            return;
        }

        logger.log('Resuming remote control controller.');

        area.mousemove((event: React.MouseEvent) => {
            dispatch(mouseMoved(event));
        });
        area.mousedown((event: React.MouseEvent) => dispatch(mouseClicked(EVENTS.mousedown, event)));
        area.mouseup((event: React.MouseEvent) => dispatch(mouseClicked(EVENTS.mouseup, event)));
        area.dblclick((event: React.MouseEvent) => dispatch(mouseClicked(EVENTS.mousedblclick, event)));
        area.contextmenu(() => false);
        area[0].onwheel = (event: any) => {
            event.preventDefault();
            event.stopPropagation();
            dispatch(mouseScrolled(event));

            return false;
        };
        $(window).keydown((event: React.KeyboardEvent) => dispatch(keyPressed(EVENTS.keydown, event)));
        $(window).keyup((event: React.KeyboardEvent) => dispatch(keyPressed(EVENTS.keyup, event)));

        dispatch({
            type: CAPTURE_EVENTS,
            isCapturingEvents: true
        });
    };
}


/**
 * Pauses the collecting of events and enables the keyboard shortcus. But
 * it doesn't removes any other listeners. Basically the remote control
 * session will be still active after the pause action, but no events from the
 * controller side will be captured and sent. You can resume the collecting
 * of the events with the resume action.
 *
 * @returns {Function}
 */
export function pause() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const { controller } = state['features/remote-control'];
        const { controlled, isCapturingEvents } = controller;

        if (!isRemoteControlEnabled(state) || !controlled || !isCapturingEvents) {
            return;
        }

        logger.log('Pausing remote control controller.');

        const area = getRemoteConrolEventCaptureArea();

        if (area) {
            area.off('contextmenu');
            area.off('dblclick');
            area.off('mousedown');
            area.off('mousemove');
            area.off('mouseup');
            area[0].onwheel = undefined;
        }

        $(window).off('keydown');
        $(window).off('keyup');

        dispatch({
            type: CAPTURE_EVENTS,
            isCapturingEvents: false
        });
    };
}


################################################################################

## File: .\jitsi-meet\react\features\remote-control\actionTypes.ts

/**
 * The type of (redux) action which signals that the controller is capturing mouse and keyboard events.
 *
 * {
 *     type: CAPTURE_EVENTS,
 *     isCapturingEvents: boolean
 * }
 */
export const CAPTURE_EVENTS = 'CAPTURE_EVENTS';

/**
 * The type of (redux) action which signals that a remote control active state has changed.
 *
 * {
 *     type: REMOTE_CONTROL_ACTIVE,
 *     active: boolean
 * }
 */
export const REMOTE_CONTROL_ACTIVE = 'REMOTE_CONTROL_ACTIVE';

/**
 * The type of (redux) action which sets the receiver transport object.
 *
 * {
 *     type: SET_RECEIVER_TRANSPORT,
 *     transport: Transport
 * }
 */
export const SET_RECEIVER_TRANSPORT = 'SET_RECEIVER_TRANSPORT';

/**
 * The type of (redux) action which enables the receiver.
 *
 * {
 *     type: SET_RECEIVER_ENABLED,
 *     enabled: boolean
 * }
 */
export const SET_RECEIVER_ENABLED = 'SET_RECEIVER_ENABLED';

/**
 * The type of (redux) action which sets the controller participant on the receiver side.
 * {
 *     type: SET_CONTROLLER,
 *     controller: string
 * }
 */
export const SET_CONTROLLER = 'SET_CONTROLLER';

/**
 * The type of (redux) action which sets the controlled participant on the controller side.
 * {
 *     type: SET_CONTROLLED_PARTICIPANT,
 *     controlled: string
 * }
 */
export const SET_CONTROLLED_PARTICIPANT = 'SET_CONTROLLED_PARTICIPANT';


/**
 * The type of (redux) action which sets the requested participant on the controller side.
 * {
 *     type: SET_REQUESTED_PARTICIPANT,
 *     requestedParticipant: string
 * }
 */
export const SET_REQUESTED_PARTICIPANT = 'SET_REQUESTED_PARTICIPANT';



################################################################################

## File: .\jitsi-meet\react\features\remote-control\constants.ts

/**
 * The type of remote control messages.
 */
export const REMOTE_CONTROL_MESSAGE_NAME = 'remote-control';

/**
 * The value for the "var" attribute of feature tag in disco-info packets.
 */
export const DISCO_REMOTE_CONTROL_FEATURE = 'http://jitsi.org/meet/remotecontrol';

/**
 * The remote control event.
 *
 * @typedef {object} RemoteControlEvent
 * @property {EVENTS | REQUESTS} type - The type of the message.
 * @property {number} x - Avaibale for type === mousemove only. The new x
 * coordinate of the mouse.
 * @property {number} y - For mousemove type - the new y
 * coordinate of the mouse and for mousescroll - represents the vertical
 * scrolling diff value.
 * @property {number} button - 1(left), 2(middle) or 3 (right). Supported by
 * mousedown, mouseup and mousedblclick types.
 * @property {KEYS} key - Represents the key related to the event. Supported by
 * keydown and keyup types.
 * @property {KEYS[]} modifiers - Represents the modifier related to the event.
 * Supported by keydown and keyup types.
 * @property {PERMISSIONS_ACTIONS} action - Supported by type === permissions.
 * Represents the action related to the permissions event.
 */

/**
 * Optional properties. Supported for permissions event for action === request.
 *
 * @property {string} userId - The user id of the participant that has sent the
 * request.
 * @property {string} userJID - The full JID in the MUC of the user that has
 * sent the request.
 * @property {string} displayName - The displayName of the participant that has
 * sent the request.
 * @property {boolean} screenSharing - True if the SS is started for the local
 * participant and false if not.
 */

/**
 * Types of remote-control events.
 *
  * @readonly
  * @enum {string}
 */
export const EVENTS = {
    mousemove: 'mousemove',
    mousedown: 'mousedown',
    mouseup: 'mouseup',
    mousedblclick: 'mousedblclick',
    mousescroll: 'mousescroll',
    keydown: 'keydown',
    keyup: 'keyup',
    permissions: 'permissions',
    start: 'start',
    stop: 'stop',
    supported: 'supported'
};

/**
 * Types of remote-control requests.
 *
  * @readonly
  * @enum {string}
 */
export const REQUESTS = {
    start: 'start'
};

/**
 * Actions for the remote control permission events.
 *
 * @readonly
 * @enum {string}
 */
export const PERMISSIONS_ACTIONS = {
    request: 'request',
    grant: 'grant',
    deny: 'deny',
    error: 'error'
};



################################################################################

## File: .\jitsi-meet\react\features\remote-control\functions.ts

import React from 'react';

// @ts-expect-error
import VideoLayout from '../../../modules/UI/videolayout/VideoLayout';
import { IReduxState, IStore } from '../app/types';
import { IJitsiConference } from '../base/conference/reducer';
import JitsiMeetJS from '../base/lib-jitsi-meet';

import { enableReceiver, stopReceiver } from './actions';
import { EVENTS, REMOTE_CONTROL_MESSAGE_NAME } from './constants';
import { keyboardEventToKey } from './keycodes';
import logger from './logger';

/**
 * Checks if the remote control is enabled.
 *
 * @param {*} state - The redux state.
 * @returns {boolean} - True if the remote control is enabled and false otherwise.
 */
export function isRemoteControlEnabled(state: IReduxState) {
    return !state['features/base/config'].disableRemoteControl && JitsiMeetJS.isDesktopSharingEnabled();
}

/**
 * Sends remote control message to other participant through data channel.
 *
 * @param {JitsiConference} conference - The JitsiConference object.
 * @param {string} to - The participant who will receive the event.
 * @param {RemoteControlEvent} event - The remote control event.
 * @returns {boolean} - True if the message was sent successfully and false otherwise.
 */
export function sendRemoteControlEndpointMessage(
        conference: IJitsiConference | undefined,
        to: string | undefined,
        event: Object) {
    if (!to) {
        logger.warn('Remote control: Skip sending remote control event. Params:', to);

        return false;
    }

    try {
        conference?.sendEndpointMessage(to, {
            name: REMOTE_CONTROL_MESSAGE_NAME,
            ...event
        });

        return true;
    } catch (error) {
        logger.error('Failed to send EndpointMessage via the datachannels', error);

        return false;
    }
}

/**
* Handles remote control events from the external app. Currently only
* events with type EVENTS.supported and EVENTS.stop are
* supported.
*
* @param {RemoteControlEvent} event - The remote control event.
* @param {Store} store - The redux store.
* @returns {void}
*/
export function onRemoteControlAPIEvent(event: { type: string; }, { getState, dispatch }: IStore) {
    switch (event.type) {
    case EVENTS.supported:
        logger.log('Remote Control supported.');
        if (isRemoteControlEnabled(getState())) {
            dispatch(enableReceiver());
        } else {
            logger.log('Remote Control disabled.');
        }
        break;
    case EVENTS.stop: {
        dispatch(stopReceiver());

        break;
    }
    }
}

/**
 * Returns the area used for capturing mouse and key events.
 *
 * @returns {JQuery} - A JQuery selector.
 */
export function getRemoteConrolEventCaptureArea() {
    return VideoLayout.getLargeVideoWrapper();
}


/**
 * Extract the keyboard key from the keyboard event.
 *
 * @param {KeyboardEvent} event - The event.
 * @returns {KEYS} The key that is pressed or undefined.
 */
export function getKey(event: React.KeyboardEvent) {
    return keyboardEventToKey(event);
}

/**
 * Extract the modifiers from the keyboard event.
 *
 * @param {KeyboardEvent} event - The event.
 * @returns {Array} With possible values: "shift", "control", "alt", "command".
 */
export function getModifiers(event: React.KeyboardEvent) {
    const modifiers = [];

    if (event.shiftKey) {
        modifiers.push('shift');
    }

    if (event.ctrlKey) {
        modifiers.push('control');
    }


    if (event.altKey) {
        modifiers.push('alt');
    }

    if (event.metaKey) {
        modifiers.push('command');
    }

    return modifiers;
}



################################################################################

## File: .\jitsi-meet\react\features\remote-control\keycodes.ts

import React from 'react';

/**
 * Enumerates the supported keys.
 * NOTE: The maps represents physical keys on the keyboard, not chars.
 *
 * @readonly
 * @enum {string}
 */
export const KEYS = {
    BACKSPACE: 'backspace',
    DELETE: 'delete',
    RETURN: 'enter',
    TAB: 'tab',
    ESCAPE: 'escape',
    UP: 'up',
    DOWN: 'down',
    RIGHT: 'right',
    LEFT: 'left',
    HOME: 'home',
    END: 'end',
    PAGEUP: 'pageup',
    PAGEDOWN: 'pagedown',

    F1: 'f1',
    F2: 'f2',
    F3: 'f3',
    F4: 'f4',
    F5: 'f5',
    F6: 'f6',
    F7: 'f7',
    F8: 'f8',
    F9: 'f9',
    F10: 'f10',
    F11: 'f11',
    F12: 'f12',
    META: 'command',
    CMD_L: 'command',
    CMD_R: 'command',
    ALT: 'alt',
    CONTROL: 'control',
    SHIFT: 'shift',
    CAPS_LOCK: 'capslock',
    SPACE: 'space',
    PRINTSCREEN: 'printscreen',
    INSERT: 'insert',

    NUMPAD_0: 'numpad_0',
    NUMPAD_1: 'numpad_1',
    NUMPAD_2: 'numpad_2',
    NUMPAD_3: 'numpad_3',
    NUMPAD_4: 'numpad_4',
    NUMPAD_5: 'numpad_5',
    NUMPAD_6: 'numpad_6',
    NUMPAD_7: 'numpad_7',
    NUMPAD_8: 'numpad_8',
    NUMPAD_9: 'numpad_9',

    COMMA: ',',

    PERIOD: '.',
    SEMICOLON: ';',
    QUOTE: '\'',
    BRACKET_LEFT: '[',
    BRACKET_RIGHT: ']',
    BACKQUOTE: '`',
    BACKSLASH: '\\',
    MINUS: '-',
    EQUAL: '=',
    SLASH: '/',
    ASTERISK: '*',
    PLUS: '+'
};

/**
 * Mapping between the key codes and keys defined in KEYS.
 * The mappings are based on
 * https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode#Specifications.
 */
/* eslint-enable max-len */
const keyCodeToKey = {
    8: KEYS.BACKSPACE,
    9: KEYS.TAB,
    13: KEYS.RETURN,
    16: KEYS.SHIFT,
    17: KEYS.CONTROL,
    18: KEYS.ALT,
    20: KEYS.CAPS_LOCK,
    27: KEYS.ESCAPE,
    32: KEYS.SPACE,
    33: KEYS.PAGEUP,
    34: KEYS.PAGEDOWN,
    35: KEYS.END,
    36: KEYS.HOME,
    37: KEYS.LEFT,
    38: KEYS.UP,
    39: KEYS.RIGHT,
    40: KEYS.DOWN,
    42: KEYS.PRINTSCREEN,
    44: KEYS.PRINTSCREEN,
    45: KEYS.INSERT,
    46: KEYS.DELETE,
    59: KEYS.SEMICOLON,
    61: KEYS.EQUAL,
    91: KEYS.CMD_L,
    92: KEYS.CMD_R,
    93: KEYS.CMD_R,
    96: KEYS.NUMPAD_0,
    97: KEYS.NUMPAD_1,
    98: KEYS.NUMPAD_2,
    99: KEYS.NUMPAD_3,
    100: KEYS.NUMPAD_4,
    101: KEYS.NUMPAD_5,
    102: KEYS.NUMPAD_6,
    103: KEYS.NUMPAD_7,
    104: KEYS.NUMPAD_8,
    105: KEYS.NUMPAD_9,
    106: KEYS.ASTERISK,
    107: KEYS.PLUS,
    109: KEYS.MINUS,
    110: KEYS.PERIOD,
    111: KEYS.SLASH,
    112: KEYS.F1,
    113: KEYS.F2,
    114: KEYS.F3,
    115: KEYS.F4,
    116: KEYS.F5,
    117: KEYS.F6,
    118: KEYS.F7,
    119: KEYS.F8,
    120: KEYS.F9,
    121: KEYS.F10,
    122: KEYS.F11,
    123: KEYS.F12,
    124: KEYS.PRINTSCREEN,
    173: KEYS.MINUS,
    186: KEYS.SEMICOLON,
    187: KEYS.EQUAL,
    188: KEYS.COMMA,
    189: KEYS.MINUS,
    190: KEYS.PERIOD,
    191: KEYS.SLASH,
    192: KEYS.BACKQUOTE,
    219: KEYS.BRACKET_LEFT,
    220: KEYS.BACKSLASH,
    221: KEYS.BRACKET_RIGHT,
    222: KEYS.QUOTE,
    224: KEYS.META,
    229: KEYS.SEMICOLON
};

/**
 * Generate codes for digit keys (0-9).
 */
for (let i = 0; i < 10; i++) {
    keyCodeToKey[(i + 48) as keyof typeof keyCodeToKey] = `${i}`;
}

/**
 * Generate codes for letter keys (a-z).
 */
for (let i = 0; i < 26; i++) {
    const keyCode = i + 65;

    keyCodeToKey[keyCode as keyof typeof keyCodeToKey] = String.fromCharCode(keyCode).toLowerCase();
}

/**
 * Returns key associated with the keyCode from the passed event.
 *
 * @param {KeyboardEvent} event - The event.
 * @returns {KEYS} - The key on the keyboard.
 */
export function keyboardEventToKey(event: React.KeyboardEvent) {
    return keyCodeToKey[event.which as keyof typeof keyCodeToKey];
}


################################################################################

## File: .\jitsi-meet\react\features\remote-control\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/remote-control');


################################################################################

## File: .\jitsi-meet\react\features\remote-control\middleware.ts

// @ts-expect-error
import { PostMessageTransportBackend, Transport } from '@jitsi/js-utils/transport';

import { APP_WILL_MOUNT, APP_WILL_UNMOUNT } from '../base/app/actionTypes';
import { CONFERENCE_JOINED } from '../base/conference/actionTypes';
import { PARTICIPANT_LEFT } from '../base/participants/actionTypes';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';

import {
    clearRequest, setReceiverTransport, setRemoteControlActive, stopController, stopReceiver
} from './actions';
import { REMOTE_CONTROL_MESSAGE_NAME } from './constants';
import { onRemoteControlAPIEvent } from './functions';
import './subscriber';

/**
 * The redux middleware for the remote control feature.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {
    switch (action.type) {
    case APP_WILL_MOUNT: {
        const { dispatch } = store;

        dispatch(setReceiverTransport(new Transport({
            backend: new PostMessageTransportBackend({
                postisOptions: { scope: 'jitsi-remote-control' }
            })
        })));

        break;
    }
    case APP_WILL_UNMOUNT: {
        const { getState, dispatch } = store;
        const { transport } = getState()['features/remote-control'].receiver;

        if (transport) {
            transport.dispose();
            dispatch(setReceiverTransport());
        }

        break;
    }
    case CONFERENCE_JOINED: {
        const result = next(action);
        const { getState } = store;
        const { transport } = getState()['features/remote-control'].receiver;

        if (transport) {
            // We expect here that even if we receive the supported event earlier
            // it will be cached and we'll receive it.
            transport.on('event', (event: { name: string; type: string; }) => {
                if (event.name === REMOTE_CONTROL_MESSAGE_NAME) {
                    onRemoteControlAPIEvent(event, store);

                    return true;
                }

                return false;
            });
        }

        return result;
    }
    case PARTICIPANT_LEFT: {
        const { getState, dispatch } = store;
        const state = getState();
        const { id } = action.participant;
        const { receiver, controller } = state['features/remote-control'];
        const { requestedParticipant, controlled } = controller;

        if (id === controlled) {
            dispatch(stopController());
        }

        if (id === requestedParticipant) {
            dispatch(clearRequest());
            dispatch(setRemoteControlActive(false));
        }

        if (receiver?.controller === id) {
            dispatch(stopReceiver(false, true));
        }

        break;
    }
    }

    return next(action);
});


################################################################################

## File: .\jitsi-meet\react\features\remote-control\reducer.ts

import ReducerRegistry from '../base/redux/ReducerRegistry';
import { set } from '../base/redux/functions';

import {
    CAPTURE_EVENTS,
    REMOTE_CONTROL_ACTIVE,
    SET_CONTROLLED_PARTICIPANT,
    SET_CONTROLLER,
    SET_RECEIVER_ENABLED,
    SET_RECEIVER_TRANSPORT,
    SET_REQUESTED_PARTICIPANT
} from './actionTypes';

/**
 * The default state.
 */
const DEFAULT_STATE = {
    active: false,
    controller: {
        isCapturingEvents: false
    },
    receiver: {
        enabled: false
    }
};

export interface IRemoteControlState {
    active: boolean;
    controller: {
        controlled?: string;
        isCapturingEvents: boolean;
        requestedParticipant?: string;
    };
    receiver: {
        controller?: string;
        enabled: boolean;
        transport?: {
            dispose: Function;
            on: Function;
            sendEvent: Function;
            sendRequest: Function;
        };
    };
}

/**
 * Listen for actions that mutate the remote control state.
 */
ReducerRegistry.register<IRemoteControlState>(
    'features/remote-control', (state = DEFAULT_STATE, action): IRemoteControlState => {
        switch (action.type) {
        case CAPTURE_EVENTS:
            return {
                ...state,
                controller: set(state.controller, 'isCapturingEvents', action.isCapturingEvents)
            };
        case REMOTE_CONTROL_ACTIVE:
            return set(state, 'active', action.active);
        case SET_RECEIVER_TRANSPORT:
            return {
                ...state,
                receiver: set(state.receiver, 'transport', action.transport)
            };
        case SET_RECEIVER_ENABLED:
            return {
                ...state,
                receiver: set(state.receiver, 'enabled', action.enabled)
            };
        case SET_REQUESTED_PARTICIPANT:
            return {
                ...state,
                controller: set(state.controller, 'requestedParticipant', action.requestedParticipant)
            };
        case SET_CONTROLLED_PARTICIPANT:
            return {
                ...state,
                controller: set(state.controller, 'controlled', action.controlled)
            };
        case SET_CONTROLLER:
            return {
                ...state,
                receiver: set(state.receiver, 'controller', action.controller)
            };
        }

        return state;
    }
);


################################################################################

## File: .\jitsi-meet\react\features\remote-control\subscriber.ts

import {
    getParticipantById,
    getVirtualScreenshareParticipantByOwnerId,
    getVirtualScreenshareParticipantOwnerId,
    isScreenShareParticipant
} from '../base/participants/functions';
import StateListenerRegistry from '../base/redux/StateListenerRegistry';

import { pause, resume } from './actions';

/**
 * Listens for large video participant ID changes.
 */
StateListenerRegistry.register(
    /* selector */ state => {
        const { participantId = '' } = state['features/large-video'];
        const { controller } = state['features/remote-control'];
        const { controlled } = controller;

        if (!controlled) {
            return undefined;
        }

        const participant = getParticipantById(state, participantId);

        if (isScreenShareParticipant(participant)) {
            // multistream support is enabled and the user has selected the desktop sharing thumbnail.
            const id = getVirtualScreenshareParticipantOwnerId(participantId);

            return id === controlled;
        }

        const virtualParticipant = getVirtualScreenshareParticipantByOwnerId(state, participantId);

        if (virtualParticipant) { // multistream is enabled and the user has selected the camera thumbnail.
            return false;

        }

        return controlled === participantId;
    },
    /* listener */ (isControlledParticipantOnStage, { dispatch }) => {
        if (isControlledParticipantOnStage === true) {
            dispatch(resume());
        } else if (isControlledParticipantOnStage === false) {
            dispatch(pause());
        }

        // else {
        // isControlledParticipantOnStage === undefined. Ignore!
        // }
    }
);


################################################################################

## File: .\jitsi-meet\react\features\room-lock\actions.ts

import {
    appNavigate,
    maybeRedirectToWelcomePage
} from '../app/actions';
import { IStore } from '../app/types';
import { conferenceLeft, setPassword } from '../base/conference/actions';
import { JITSI_CONFERENCE_URL_KEY } from '../base/conference/constants';
import { IJitsiConference } from '../base/conference/reducer';
import { hideDialog, openDialog } from '../base/dialog/actions';
import { SecurityDialog } from '../security/components/security-dialog';

import PasswordRequiredPrompt from './components/PasswordRequiredPrompt';

/**
 * Cancels a prompt for a password to join a specific conference/room.
 *
 * @param {JitsiConference} conference - The {@code JitsiConference} requesting
 * the password to join.
 * @protected
 * @returns {Function}
 */
export function _cancelPasswordRequiredPrompt(conference: any) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {

        if (typeof APP !== 'undefined') {
            // when we are redirecting the library should handle any
            // unload and clean of the connection.
            APP.API.notifyReadyToClose();

            dispatch(maybeRedirectToWelcomePage());

            return;
        }

        // Canceling PasswordRequiredPrompt is to navigate the app/user to
        // WelcomePage. In other words, the canceling invalidates the
        // locationURL. Make sure that the canceling indeed has the intent to
        // invalidate the locationURL.
        const state = getState();

        if (conference === state['features/base/conference'].passwordRequired
                && conference[JITSI_CONFERENCE_URL_KEY]
                    === state['features/base/connection'].locationURL) {
            // XXX The error associated with CONFERENCE_FAILED was marked as
            // recoverable by the feature room-lock and, consequently,
            // recoverable-aware features such as mobile's external-api did not
            // deliver the CONFERENCE_FAILED to the SDK clients/consumers. Since
            // the app/user is going to nativate to WelcomePage, the SDK
            // clients/consumers need an event.
            dispatch(conferenceLeft(conference));

            dispatch(appNavigate(undefined));
        }
    };
}

/**
 * Ends a (user) request to lock a specific conference/room.
 *
 * @param {JitsiConference} conference - The JitsiConference to lock.
 * @param {string|undefined} password - The password with which the specified
 * conference is to be locked or undefined to cancel the (user) request to lock
 * the specified conference.
 * @returns {Function}
 */
export function endRoomLockRequest(
        conference: IJitsiConference,
        password?: string) {
    return (dispatch: IStore['dispatch']) => {
        const setPassword_
            = password
                ? dispatch(setPassword(conference, conference.lock, password))
                : Promise.resolve();
        const endRoomLockRequest_ = () => dispatch(hideDialog(SecurityDialog));

        setPassword_.then(endRoomLockRequest_, endRoomLockRequest_);
    };
}

/**
 * Begins a prompt for a password to join a specific conference/room.
 *
 * @param {JitsiConference} conference - The {@code JitsiConference}
 * requesting the password to join.
 * @protected
 * @returns {{
 *     type: OPEN_DIALOG,
 *     component: Component,
 *     props: PropTypes
 * }}
 */
export function _openPasswordRequiredPrompt(conference: IJitsiConference) {
    return openDialog(PasswordRequiredPrompt, { conference });
}

/**
 * Unlocks the current jitsi conference.
 *
 * @returns {Function}
 */
export function unlockRoom() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const { conference } = getState()['features/base/conference'];

        return dispatch(setPassword(
            conference,
            conference?.lock,
            ''
        ));
    };
}




################################################################################

## File: .\jitsi-meet\react\features\room-lock\constants.ts

/**
 * The conference/room lock state which identifies that the password was set by
 * the current/local participant/user.
 *
 * @type {string}
 */
export const LOCKED_LOCALLY = 'LOCKED_LOCALLY';

/**
 * The conference/room lock state which identifies that the password was set by
 * a remote participant/user.
 *
 * @type {string}
 */
export const LOCKED_REMOTELY = 'LOCKED_REMOTELY';


################################################################################

## File: .\jitsi-meet\react\features\room-lock\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/room-lock');


################################################################################

## File: .\jitsi-meet\react\features\room-lock\middleware.ts

import { AnyAction } from 'redux';

import { IStore } from '../app/types';
import {
    CONFERENCE_FAILED,
    CONFERENCE_JOINED,
    LOCK_STATE_CHANGED,
    SET_PASSWORD_FAILED
} from '../base/conference/actionTypes';
import { hideDialog } from '../base/dialog/actions';
import { JitsiConferenceErrors } from '../base/lib-jitsi-meet';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import { showErrorNotification, showNotification } from '../notifications/actions';
import { NOTIFICATION_TIMEOUT_TYPE } from '../notifications/constants';

import { _openPasswordRequiredPrompt } from './actions';
import PasswordRequiredPrompt from './components/PasswordRequiredPrompt';
import { LOCKED_REMOTELY } from './constants';
import logger from './logger';

/**
 * Middleware that captures conference failed and checks for password required
 * error and requests a dialog for user to enter password.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {
    switch (action.type) {
    case CONFERENCE_FAILED:
        return _conferenceFailed(store, next, action);

    case CONFERENCE_JOINED:
        return _conferenceJoined(store, next, action);

    case LOCK_STATE_CHANGED: {
        const previousLockedState = store.getState()['features/base/conference'].locked;

        const result = next(action);

        const currentLockedState = store.getState()['features/base/conference'].locked;

        if (currentLockedState === LOCKED_REMOTELY) {
            store.dispatch(
                showNotification({
                    titleKey: 'notify.passwordSetRemotely'
                }, NOTIFICATION_TIMEOUT_TYPE.SHORT));
        } else if (previousLockedState === LOCKED_REMOTELY && !currentLockedState) {
            store.dispatch(
                showNotification({
                    titleKey: 'notify.passwordRemovedRemotely'
                }, NOTIFICATION_TIMEOUT_TYPE.SHORT));
        }

        return result;
    }
    case SET_PASSWORD_FAILED:
        return _setPasswordFailed(store, next, action);
    }

    return next(action);
});

/**
 * Handles cleanup of lock prompt state when a conference is joined.
 *
 * @param {Store} store - The redux store in which the specified action is being
 * dispatched.
 * @param {Dispatch} next - The redux {@code dispatch} function to dispatch the
 * specified action to the specified store.
 * @param {Action} action - The redux action {@code CONFERENCE_JOINED} which
 * specifies the details associated with joining the conference.
 * @private
 * @returns {*}
 */
function _conferenceJoined({ dispatch }: IStore, next: Function, action: AnyAction) {
    dispatch(hideDialog(PasswordRequiredPrompt));

    return next(action);
}

/**
 * Handles errors that occur when a conference fails.
 *
 * @param {Store} store - The redux store in which the specified action is being
 * dispatched.
 * @param {Dispatch} next - The redux {@code dispatch} function to dispatch the
 * specified action to the specified store.
 * @param {Action} action - The redux action {@code CONFERENCE_FAILED} which
 * specifies the details associated with the error and the failed conference.
 * @private
 * @returns {*}
 */
function _conferenceFailed({ dispatch }: IStore, next: Function, action: AnyAction) {
    const { conference, error } = action;

    if (conference && error.name === JitsiConferenceErrors.PASSWORD_REQUIRED) {
        // XXX The feature room-lock affords recovery after CONFERENCE_FAILED
        // caused by JitsiConferenceErrors.PASSWORD_REQUIRED.
        if (typeof error.recoverable === 'undefined') {
            error.recoverable = true;
        }
        if (error.recoverable) {
            dispatch(_openPasswordRequiredPrompt(conference));
        }
    } else {
        dispatch(hideDialog(PasswordRequiredPrompt));
    }

    return next(action);
}

/**
 * Handles errors that occur when a password fails to be set.
 *
 * @param {Store} store - The redux store in which the specified action is being
 * dispatched.
 * @param {Dispatch} next - The redux {@code dispatch} function to dispatch the
 * specified action to the specified store.
 * @param {Action} action - The redux action {@code SET_PASSWORD_ERROR} which
 * has the error type that should be handled.
 * @private
 * @returns {*}
 */
function _setPasswordFailed(store: IStore, next: Function, action: AnyAction) {
    if (typeof APP !== 'undefined') {
        // TODO Remove this logic when displaying of error messages on web is
        // handled through react/redux.
        const { error } = action;
        let descriptionKey;
        let titleKey;

        if (error === JitsiConferenceErrors.PASSWORD_NOT_SUPPORTED) {
            logger.warn('room passwords not supported');
            descriptionKey = 'dialog.passwordNotSupported';
            titleKey = 'dialog.passwordNotSupportedTitle';
        } else {
            logger.warn('setting password failed', error);
            descriptionKey = 'dialog.lockMessage';
            titleKey = 'dialog.lockTitle';
        }
        APP.store.dispatch(showErrorNotification({
            descriptionKey,
            titleKey
        }, NOTIFICATION_TIMEOUT_TYPE.LONG));
    }

    return next(action);
}


################################################################################

## File: .\jitsi-meet\react\features\rtcstats\functions.ts


import { IStateful } from '../base/app/types';
import { toState } from '../base/redux/functions';

/**
 * Checks whether rtcstats is enabled or not.
 *
 * @param {IStateful} stateful - The redux store or {@code getState} function.
 * @returns {boolean}
 */
export function isRTCStatsEnabled(stateful: IStateful) {
    const state = toState(stateful);
    const { analytics } = state['features/base/config'];

    return analytics?.rtcstatsEnabled ?? false;
}

/**
 * Checks if the faceLandmarks data can be sent to the rtcstats server.
 *
 * @param {IStateful} stateful - The redux store or {@code getState} function.
 * @returns {boolean}
 */
export function canSendFaceLandmarksRTCStatsData(stateful: IStateful): boolean {
    const state = toState(stateful);
    const { faceLandmarks } = state['features/base/config'];

    return Boolean(faceLandmarks?.enableRTCStats && isRTCStatsEnabled(state));
}


################################################################################

## File: .\jitsi-meet\react\features\rtcstats\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/rtcstats');


################################################################################

## File: .\jitsi-meet\react\features\rtcstats\middleware.ts

import { AnyAction } from 'redux';

import { IStore } from '../app/types';
import {
    CONFERENCE_JOINED,
    E2E_RTT_CHANGED
} from '../base/conference/actionTypes';
import { DOMINANT_SPEAKER_CHANGED } from '../base/participants/actionTypes';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import { TRACK_ADDED, TRACK_UPDATED } from '../base/tracks/actionTypes';
import { ADD_FACE_LANDMARKS } from '../face-landmarks/actionTypes';
import { FaceLandmarks } from '../face-landmarks/types';
import { sendGetCustomerIdRequest } from '../jaas/functions';

import RTCStats from './RTCStats';
import {
    canSendFaceLandmarksRTCStatsData,
    isRTCStatsEnabled
} from './functions';
import logger from './logger';

/**
 * Middleware which intercepts lib-jitsi-meet initialization and conference join in order init the
 * rtcstats-client.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register((store: IStore) => (next: Function) => (action: AnyAction) => {
    const { getState } = store;
    const state = getState();

    switch (action.type) {
    case CONFERENCE_JOINED: {
        if (isRTCStatsEnabled(state)) {
            RTCStats.init();

            sendGetCustomerIdRequest(action?.conference, state)
                .then(customerData => {
                    const { customerId } = customerData ?? {};

                    customerId && RTCStats.sendIdentityData({ customerId });
                })
                .catch(error => {
                    logger.error('Error while getting customer id:', error);
                });
        }
        break;
    }
    case TRACK_ADDED: {
        if (isRTCStatsEnabled(state)) {
            const jitsiTrack = action?.track?.jitsiTrack;
            const { ssrc, videoType } = jitsiTrack || { };

            // Remote tracks store their ssrc in the jitsiTrack object. Local tracks don't. See getSsrcByTrack.
            if (videoType && ssrc && !jitsiTrack.isLocal() && !jitsiTrack.isAudioTrack()) {
                RTCStats.sendVideoTypeData({
                    ssrc,
                    videoType
                });
            }
        }
        break;
    }
    case TRACK_UPDATED: {
        if (isRTCStatsEnabled(state)) {
            const { videoType, jitsiTrack, muted } = action?.track || { };
            const { ssrc, isLocal, videoType: trackVideoType, conference } = jitsiTrack || { };

            if (trackVideoType === 'camera' && conference && isLocal()) {
                RTCStats.sendFaceLandmarksData({
                    duration: 0,
                    faceLandmarks: muted ? 'camera-off' : 'camera-on',
                    timestamp: Date.now()
                });
            }

            // if the videoType of the remote track has changed we expect to find it in track.videoType. grep for
            // trackVideoTypeChanged.
            if (videoType && ssrc && !jitsiTrack.isLocal() && !jitsiTrack.isAudioTrack()) {

                RTCStats.sendVideoTypeData({
                    ssrc,
                    videoType
                });
            }
        }
        break;
    }
    case DOMINANT_SPEAKER_CHANGED: {
        if (isRTCStatsEnabled(state)) {
            const { id, previousSpeakers, silence } = action.participant;

            RTCStats.sendDominantSpeakerData({
                dominantSpeakerEndpoint: silence ? null : id,
                previousSpeakers
            });
        }
        break;
    }
    case E2E_RTT_CHANGED: {
        if (isRTCStatsEnabled(state)) {
            const { participant, rtt } = action.e2eRtt;

            RTCStats.sendE2ERTTData({
                remoteEndpointId: participant.getId(),
                rtt,
                remoteRegion: participant.getProperty('region')
            });
        }
        break;
    }
    case ADD_FACE_LANDMARKS: {
        if (canSendFaceLandmarksRTCStatsData(state)) {
            const { duration, faceExpression, timestamp } = action.faceLandmarks as FaceLandmarks;
            const durationSeconds = Math.round(duration / 1000);

            RTCStats.sendFaceLandmarksData({
                duration: durationSeconds,
                faceLandmarks: faceExpression,
                timestamp
            });
        }
        break;
    }
    }

    return next(action);
});


################################################################################

## File: .\jitsi-meet\react\features\rtcstats\RTCStats.ts

/* eslint-disable lines-around-comment */
import {
    PC_CON_STATE_CHANGE,
    PC_STATE_CONNECTED,
    PC_STATE_FAILED
    // @ts-expect-error
} from '@jitsi/rtcstats/events';

import JitsiMeetJS, { RTCStatsEvents } from '../base/lib-jitsi-meet';

import logger from './logger';
import {
    DominantSpeakerData,
    E2ERTTData,
    FaceLandmarksData,
    VideoTypeData
} from './types';

/**
 * Handle lib-jitsi-meet rtcstats events and send jitsi-meet specific statistics.
 */
class RTCStats {
    private _connStateEvents: Array<any> = [];
    private _initialized = false;

    /**
     * Handles rtcstats events.
     *
     * @returns {void}
     */
    init() {
        this._connStateEvents = [];

        if (!this._initialized) {
            JitsiMeetJS.rtcstats.on(
                RTCStatsEvents.RTC_STATS_PC_EVENT,
                (pcEvent: any) => this.handleRTCStatsEvent(pcEvent));
            this._initialized = true;
        }
    }

    /**
     * Send console logs to rtcstats server.
     *
     * @param {Array<string|any>} logEntries - The log entries to send to the rtcstats server.
     * @returns {void}
     */
    sendLogs(logEntries: Array<string | any>) {
        JitsiMeetJS.rtcstats.sendStatsEntry('logs', logEntries);
    }

    /**
     * Send dominant speaker data, the data will be processed by rtcstats-server and saved in the dump file.
     *
     * @param {Object} dominantSpeakerData - Dominant speaker data to be saved in the rtcstats dump.
     * @returns {void}
     */
    sendDominantSpeakerData(dominantSpeakerData: DominantSpeakerData) {
        JitsiMeetJS.rtcstats.sendStatsEntry('dominantSpeaker', dominantSpeakerData);
    }

    /**
     * Send e2e rtt data, the data will be processed by rtcstats-server and saved in the dump file.
     *
     * @param {Object} e2eRttData - The object that holds the e2e data.
     * @returns {void}
     */
    sendE2ERTTData(e2eRttData: E2ERTTData) {
        JitsiMeetJS.rtcstats.sendStatsEntry('e2eRtt', e2eRttData);
    }

    /**
     * Send identity data, the data will be processed by rtcstats-server and saved in the dump file.
     *
     * @param {Object} identityData - The object that holds the identity data.
     * @returns {void}
     */
    sendIdentityData(identityData: Object) {
        JitsiMeetJS.rtcstats.sendIdentityEntry(identityData);
    }

    /**
     * Send the timestamp of the start of the conference, the data will be processed by the rtcstats-server
     * and saved in the dump file.
     *
     * @param {Object} timestamp - The object which contains the timestamp.
     * @returns {void}
     */
    sendConferenceTimestamp(timestamp: number) {
        JitsiMeetJS.rtcstats.sendStatsEntry('conferenceStartTimestamp', timestamp);
    }

    /**
     * Send videoType data, the data will be processed by rtcstats-server and saved in the dump file.
     *
     * @param {Object} videoTypeData - The object that holds the videoType data.
     * @returns {void}
     */
    sendVideoTypeData(videoTypeData: VideoTypeData) {
        JitsiMeetJS.rtcstats.sendStatsEntry('setVideoType', videoTypeData);
    }

    /**
     * Send face landmarks data, the data will be processed by rtcstats-server and saved in the dump file.
     *
     * @param {Object} faceLandmarksData - Face landmarks data to be saved in the rtcstats dump.
     * @returns {void}
     */
    sendFaceLandmarksData(faceLandmarksData: FaceLandmarksData) {
        JitsiMeetJS.rtcstats.sendStatsEntry('faceLandmarks', faceLandmarksData);
    }

    /**
     * RTCStats client can notify the APP of any PeerConnection related event that occurs.
     *
     * @param {Object} event - The PeerConnection event.
     * @param {string} event.type - The event type.
     * @param {Object} event.body - Event body.
     * @param {string} event.body.isP2P - PeerConnection type.
     * @param {string} event.body.state - PeerConnection state change which triggered the event.
     * @returns {void}
     */
    handleRTCStatsEvent(event: any) {
        switch (event.type) {
        case PC_CON_STATE_CHANGE: {
            const { body: { isP2P = null, state = null } } = event;

            this._connStateEvents.push(event.body);

            // We only report PC related connection issues. If the rtcstats websocket is not connected at this point
            // it usually means that none of our services can be reached i.e. there's problem with the internet
            // connection and not necessarily with reaching the JVB (due to a firewall or other reasons).
            if (state === PC_STATE_FAILED) {
                const connectionType = isP2P ? 'P2P' : 'JVB';
                const wasConnected = this._connStateEvents.some((connectionEvent: { isP2P: any; state: string; }) =>
                    (connectionEvent.isP2P === isP2P) && (connectionEvent.state === PC_STATE_CONNECTED));

                logger.info(`${connectionType} PeerConnection failed, previously connected: ${wasConnected}`);

                if (typeof APP !== 'undefined') {
                    APP.API.notifyPeerConnectionFailure(isP2P, wasConnected);
                }
            }

            break;
        }
        }
    }
}

export default new RTCStats();


################################################################################

## File: .\jitsi-meet\react\features\rtcstats\types.ts

export type VideoTypeData = {
    ssrc: number;
    videoType: string;
};

export type DominantSpeakerData = {
    dominantSpeakerEndpoint: string;
    previousSpeakers: string[];
};

export type E2ERTTData = {
    remoteEndpointId: string;
    remoteRegion: string;
    rtt: number;
};

export type FaceLandmarksData = {
    duration: number;
    faceLandmarks: string;
    timestamp: number;
};


################################################################################

## File: .\jitsi-meet\react\features\salesforce\actions.ts

import { IStore } from '../app/types';
import { openDialog } from '../base/dialog/actions';
import { hideNotification, showNotification } from '../notifications/actions';
import {
    NOTIFICATION_TIMEOUT_TYPE,
    NOTIFICATION_TYPE,
    SALESFORCE_LINK_NOTIFICATION_ID
} from '../notifications/constants';

import { SalesforceLinkDialog } from './components';
import { isSalesforceEnabled } from './functions';

/**
 * Displays the notification for linking the meeting to Salesforce.
 *
 * @returns {void}
 */
export function showSalesforceNotification() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        if (!isSalesforceEnabled(getState())) {
            return;
        }

        dispatch(showNotification({
            descriptionKey: 'notify.linkToSalesforceDescription',
            titleKey: 'notify.linkToSalesforce',
            uid: SALESFORCE_LINK_NOTIFICATION_ID,
            customActionNameKey: [ 'notify.linkToSalesforceKey' ],
            customActionHandler: [ () => {
                dispatch(hideNotification(SALESFORCE_LINK_NOTIFICATION_ID));
                dispatch(openDialog(SalesforceLinkDialog));
            } ],
            appearance: NOTIFICATION_TYPE.NORMAL
        }, NOTIFICATION_TIMEOUT_TYPE.LONG));
    };
}


################################################################################

## File: .\jitsi-meet\react\features\salesforce\constants.ts

import {
    IconRecordAccount,
    IconRecordContact,
    IconRecordLead,
    IconRecordOpportunity
} from '../base/icons/svg';

export const NOTES_MAX_LENGTH = 255;

export const NOTES_LINES = 4;

export const CONTENT_HEIGHT_OFFSET = 200;

export const LIST_HEIGHT_OFFSET = 250;

export const RECORD_TYPE: {
    [key: string]: {
        icon?: Function;
        label: string;
    };
} = {
    ACCOUNT: {
        label: 'record.type.account',
        icon: IconRecordAccount
    },
    CONTACT: {
        label: 'record.type.contact',
        icon: IconRecordContact
    },
    LEAD: {
        label: 'record.type.lead',
        icon: IconRecordLead
    },
    OPPORTUNITY: {
        label: 'record.type.opportunity',
        icon: IconRecordOpportunity
    },
    OWNER: {
        label: 'record.type.owner'
    }
};


################################################################################

## File: .\jitsi-meet\react\features\salesforce\functions.ts

import { IReduxState } from '../app/types';
import { doGetJSON } from '../base/util/httpUtils';
import { isInBreakoutRoom } from '../breakout-rooms/functions';

/**
 * Determines whether Salesforce is enabled for the current conference.
 *
 * @param {IReduxState} state - The redux store, the redux
 * {@code getState} function, or the redux state itself.
 * @returns {boolean}
 */
export const isSalesforceEnabled = (state: IReduxState) => {
    const { salesforceUrl } = state['features/base/config'];
    const isBreakoutRoom = isInBreakoutRoom(state);

    return Boolean(salesforceUrl) && !isBreakoutRoom;
};

/**
 * Fetches the Salesforce records that were most recently interacted with.
 *
 * @param {string} url - The endpoint for the session records.
 * @param {string} jwt - The JWT needed for authentication.
 * @returns {Promise<any>}
 */
export async function getRecentSessionRecords(
        url: string,
        jwt: string
) {
    return doGetJSON(`${url}/records/recents`, true, {
        headers: {
            'Authorization': `Bearer ${jwt}`
        }
    });
}

/**
 * Fetches the Salesforce records that match the search criteria.
 *
 * @param {string} url - The endpoint for the session records.
 * @param {string} jwt - The JWT needed for authentication.
 * @param {string} text - The search term for the session record to find.
 * @returns {Promise<any>}
 */
export async function searchSessionRecords(
        url: string,
        jwt: string,
        text: string
) {
    return doGetJSON(`${url}/records?text=${text}`, true, {
        headers: {
            'Authorization': `Bearer ${jwt}`
        }
    });
}

/**
* Fetches the Salesforce record details from the server.
*
* @param {string} url - The endpoint for the record details.
* @param {string} jwt - The JWT needed for authentication.
* @param {Object} item - The item for which details are being retrieved.
* @returns {Promise<any>}
*/
export async function getSessionRecordDetails(
        url: string,
        jwt: string,
        item: {
            id: string;
            type: string;
        } | null
) {
    const fullUrl = `${url}/records/${item?.id}?type=${item?.type}`;

    return doGetJSON(fullUrl, true, {
        headers: {
            'Authorization': `Bearer ${jwt}`
        }
    });
}

/**
* Executes the meeting linking.
*
* @param {string} url - The endpoint for meeting linking.
* @param {string} jwt - The JWT needed for authentication.
* @param {string} sessionId - The ID of the meeting session.
* @param {Object} body - The body of the request.
* @returns {Object}
*/
export async function executeLinkMeetingRequest(
        url: string,
        jwt: string,
        sessionId: String,
        body: {
            id?: string;
            notes: string;
            type?: string;
        }
) {
    const fullUrl = `${url}/sessions/${sessionId}/records/${body.id}`;
    const res = await fetch(fullUrl, {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${jwt}`
        },
        body: JSON.stringify(body)
    });

    const json = await res.json();

    return res.ok ? json : Promise.reject(json);
}


################################################################################

## File: .\jitsi-meet\react\features\salesforce\useSalesforceLinkDialog.ts

import { useCallback, useEffect, useState } from 'react';
import { useTranslation } from 'react-i18next';
import { GestureResponderEvent } from 'react-native';
import { useDispatch, useSelector } from 'react-redux';

import { IReduxState } from '../app/types';
import { getCurrentConference } from '../base/conference/functions';
import { hideNotification, showNotification } from '../notifications/actions';
import {
    NOTIFICATION_TIMEOUT_TYPE,
    NOTIFICATION_TYPE,
    SALESFORCE_LINK_NOTIFICATION_ID
} from '../notifications/constants';

import {
    executeLinkMeetingRequest,
    getRecentSessionRecords,
    getSessionRecordDetails,
    searchSessionRecords
} from './functions';

interface ISelectedRecord {
    id: string;
    name: string;
    onClick: (e?: React.MouseEvent | GestureResponderEvent) => void;
    type: string;
}

export const useSalesforceLinkDialog = () => {
    const { t } = useTranslation();
    const dispatch = useDispatch();
    const [ selectedRecord, setSelectedRecord ] = useState<ISelectedRecord | null>(null);
    const [ selectedRecordOwner, setSelectedRecordOwner ] = useState<{
        id: string; name: string; type: string; } | null>(null);
    const [ records, setRecords ] = useState([]);
    const [ isLoading, setLoading ] = useState(false);
    const [ searchTerm, setSearchTerm ] = useState<string | null>(null);
    const [ notes, setNotes ] = useState('');
    const [ hasRecordsErrors, setRecordsErrors ] = useState(false);
    const [ hasDetailsErrors, setDetailsErrors ] = useState(false);
    const conference = useSelector(getCurrentConference);
    const sessionId = conference?.getMeetingUniqueId();
    const { salesforceUrl = '' } = useSelector((state: IReduxState) => state['features/base/config']);
    const { jwt = '' } = useSelector((state: IReduxState) => state['features/base/jwt']);
    const showSearchResults = searchTerm && searchTerm.length > 1;
    const showNoResults = showSearchResults && records.length === 0;

    useEffect(() => {
        const fetchRecords = async () => {
            setRecordsErrors(false);
            setLoading(true);

            try {
                const text = showSearchResults ? searchTerm : null;
                const result = text
                    ? await searchSessionRecords(salesforceUrl, jwt, text)
                    : await getRecentSessionRecords(salesforceUrl, jwt);

                setRecords(result);
            } catch (error) {
                setRecordsErrors(true);
            }

            setLoading(false);
        };

        fetchRecords();
    }, [
        getRecentSessionRecords,
        jwt,
        salesforceUrl,
        searchSessionRecords,
        searchTerm
    ]);

    useEffect(() => {
        const fetchRecordDetails = async () => {
            setDetailsErrors(false);
            setSelectedRecordOwner(null);
            try {
                const result = await getSessionRecordDetails(salesforceUrl, jwt, selectedRecord);

                setSelectedRecordOwner({
                    id: result.id,
                    name: result.ownerName,
                    type: 'OWNER'
                });
            } catch (error) {
                setDetailsErrors(true);
            }
        };

        selectedRecord && fetchRecordDetails();
    }, [
        jwt,
        getSessionRecordDetails,
        salesforceUrl,
        selectedRecord
    ]);

    const linkMeeting = useCallback(async () => {
        dispatch(showNotification({
            titleKey: 'notify.linkToSalesforceProgress',
            uid: SALESFORCE_LINK_NOTIFICATION_ID,
            appearance: NOTIFICATION_TYPE.NORMAL
        }, NOTIFICATION_TIMEOUT_TYPE.STICKY));

        try {
            await executeLinkMeetingRequest(salesforceUrl, jwt, sessionId, {
                id: selectedRecord?.id,
                type: selectedRecord?.type,
                notes
            });
            dispatch(hideNotification(SALESFORCE_LINK_NOTIFICATION_ID));
            dispatch(showNotification({
                titleKey: 'notify.linkToSalesforceSuccess',
                uid: SALESFORCE_LINK_NOTIFICATION_ID,
                appearance: NOTIFICATION_TYPE.SUCCESS
            }, NOTIFICATION_TIMEOUT_TYPE.LONG));
        } catch (error: any) {
            dispatch(hideNotification(SALESFORCE_LINK_NOTIFICATION_ID));
            dispatch(showNotification({
                titleKey: 'notify.linkToSalesforceError',
                descriptionKey: error?.messageKey && t(error.messageKey),
                uid: SALESFORCE_LINK_NOTIFICATION_ID,
                appearance: NOTIFICATION_TYPE.ERROR
            }, NOTIFICATION_TIMEOUT_TYPE.LONG));
        }

    }, [
        executeLinkMeetingRequest,
        hideNotification,
        jwt,
        notes,
        salesforceUrl,
        selectedRecord,
        showNotification
    ]);

    return {
        hasDetailsErrors,
        hasRecordsErrors,
        isLoading,
        linkMeeting,
        notes,
        records,
        searchTerm,
        selectedRecord,
        selectedRecordOwner,
        setNotes,
        setSearchTerm,
        setSelectedRecord,
        showNoResults,
        showSearchResults
    };
};


################################################################################

## File: .\jitsi-meet\react\features\salesforce\components\index.native.ts

// @ts-ignore
export { default as SalesforceLinkDialog } from './native/SalesforceLinkDialog';


################################################################################

## File: .\jitsi-meet\react\features\salesforce\components\index.web.ts

export { default as SalesforceLinkDialog } from './web/SalesforceLinkDialog';


################################################################################

## File: .\jitsi-meet\react\features\salesforce\components\native\styles.ts

import BaseTheme from '../../../base/ui/components/BaseTheme.native';

export default {
    salesforceDialogContainer: {
        position: 'relative',
        flexDirection: 'column',
        flex: 1,
        display: 'flex',
        backgroundColor: BaseTheme.palette.ui01
    },
    recordsSearchContainer: {
        alignSelf: 'stretch',
        backgroundColor: BaseTheme.palette.ui01,
        paddingHorizontal: BaseTheme.spacing[3],
        paddingTop: BaseTheme.spacing[2],
        position: 'relative'
    },
    searchIcon: {
        color: BaseTheme.palette.text03,
        fontSize: 30,
        left: 22,
        position: 'absolute',
        top: 22,
        zIndex: 2
    },
    resultLabel: {
        backgroundColor: BaseTheme.palette.ui01,
        color: BaseTheme.palette.text03,
        fontSize: 15,
        margin: 0,
        paddingBottom: 8,
        paddingTop: 16
    },
    recordsSpinner: {
        alignItems: 'center',
        display: 'flex',
        justifyContent: 'center',
        width: '100%'
    },
    noRecords: {
        alignItems: 'center',
        backgroundColor: BaseTheme.palette.ui01,
        display: 'flex',
        flexDirection: 'column',
        justifyContent: 'center',
        padding: BaseTheme.spacing[3]
    },
    noRecordsText: {
        color: BaseTheme.palette.text03
    },
    recordsError: {
        alignItems: 'center',
        display: 'flex',
        flexDirection: 'column',
        justifyContent: 'center',
        paddingBottom: 30
    },
    recordsErrorText: {
        color: BaseTheme.palette.text03
    },
    recordList: {
        alignSelf: 'stretch',
        display: 'flex',
        listStyle: 'none',
        paddingVertical: BaseTheme.spacing[3],
        position: 'relative'
    },
    selectedRecord: {
        alignSelf: 'stretch',
        display: 'flex',
        paddingTop: BaseTheme.spacing[3],
        position: 'relative'
    },
    recordInfo: {
        backgroundColor: BaseTheme.palette.ui03,
        borderRadius: BaseTheme.shape.borderRadius,
        display: 'flex',
        margin: BaseTheme.spacing[3],
        position: 'relative'
    },
    detailsError: {
        color: BaseTheme.palette.text03,
        padding: BaseTheme.spacing[3]
    },
    addNote: {
        color: BaseTheme.palette.text01,
        margin: BaseTheme.spacing[3]
    },
    notes: {
        alignItems: 'flex-start',
        backgroundColor: BaseTheme.palette.field01,
        borderColor: BaseTheme.palette.ui05,
        borderRadius: BaseTheme.shape.borderRadius,
        borderWidth: 1,
        color: BaseTheme.palette.text01,
        lineHeight: 18,
        marginHorizontal: BaseTheme.spacing[3],
        marginVertical: BaseTheme.spacing[2],
        overflow: 'hidden',
        padding: BaseTheme.spacing[2],
        textAlignVertical: 'top'
    },
    cancelButton: {
        margin: BaseTheme.spacing[2]
    },
    linkButton: {
        marginBottom: BaseTheme.spacing[2],
        marginHorizontal: BaseTheme.spacing[2]
    },
    recordItem: {
        alignItems: 'center',
        display: 'flex',
        flex: 1,
        flexDirection: 'row',
        paddingHorizontal: BaseTheme.spacing[3]
    },
    recordTypeIcon: {
        alignItems: 'center',
        borderRadius: BaseTheme.shape.borderRadius,
        display: 'flex',
        height: 40,
        justifyContent: 'center',
        marginRight: BaseTheme.spacing[3],
        width: 40
    },
    recordIcon: {
        alignItems: 'center',
        display: 'flex',
        justifyContent: 'center'
    },
    recordDetails: {
        display: 'flex',
        flex: 1,
        flexDirection: 'column',
        justifyContent: 'space-around',
        overflow: 'hidden',
        paddingVertical: BaseTheme.spacing[3]
    },
    recordName: {
        color: BaseTheme.palette.text01,
        fontSize: 15,
        overflow: 'hidden'
    },
    recordType: {
        color: BaseTheme.palette.text01,
        fontSize: 13
    }
};


################################################################################

## File: .\jitsi-meet\react\features\screen-share\actions.any.ts

import {
    SET_SCREENSHARE_CAPTURE_FRAME_RATE
} from './actionTypes';

/**
 * Updates the capture frame rate for screenshare in redux.
 *
 * @param {number} captureFrameRate - The frame rate to be used for screenshare.
 * @returns {{
 *      type: SET_SCREENSHARE_CAPTURE_FRAME_RATE,
 *      captureFrameRate: number
 * }}
 */
export function setScreenshareFramerate(captureFrameRate: number) {
    return {
        type: SET_SCREENSHARE_CAPTURE_FRAME_RATE,
        captureFrameRate
    };
}


################################################################################

## File: .\jitsi-meet\react\features\screen-share\actions.web.ts

import { IStore } from '../app/types';
import { openDialog } from '../base/dialog/actions';
import { browser } from '../base/lib-jitsi-meet';
import { shouldHideShareAudioHelper } from '../base/settings/functions.web';
import { toggleScreensharing } from '../base/tracks/actions.web';

import {
    SET_SCREENSHARE_TRACKS,
    SET_SCREEN_AUDIO_SHARE_STATE
} from './actionTypes';
import ShareAudioDialog from './components/web/ShareAudioDialog';
import ShareMediaWarningDialog from './components/web/ShareScreenWarningDialog';
import { isAudioOnlySharing, isScreenVideoShared } from './functions';

export * from './actions.any';

/**
 * Updates the current known status of the shared video.
 *
 * @param {boolean} isSharingAudio - Is audio currently being shared or not.
 * @returns {{
 *     type: SET_SCREEN_AUDIO_SHARE_STATE,
 *     isSharingAudio: boolean
 * }}
 */
export function setScreenAudioShareState(isSharingAudio: boolean) {
    return {
        type: SET_SCREEN_AUDIO_SHARE_STATE,
        isSharingAudio
    };
}

/**
 * Updates the audio track associated with the screenshare.
 *
 * @param {JitsiLocalTrack} desktopAudioTrack - The audio track captured from the screenshare.
 * @returns {{
 *      type: SET_SCREENSHARE_TRACKS,
 *      desktopAudioTrack: JitsiTrack
 * }}
 */
export function setScreenshareAudioTrack(desktopAudioTrack: any) {
    return {
        type: SET_SCREENSHARE_TRACKS,
        desktopAudioTrack
    };
}

/**
 * Start the audio only screen sharing flow. Function will switch between off and on states depending on the context.
 *
 * @param {Object} state - The state of the application.
 * @returns {void}
 */
export function startAudioScreenShareFlow() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const audioOnlySharing = isAudioOnlySharing(state);

        // If we're already in a normal screen sharing session, warn the user.
        if (isScreenVideoShared(state)) {
            dispatch(openDialog(ShareMediaWarningDialog, { _isAudioScreenShareWarning: true }));

            return;
        }

        // If users opted out of the helper dialog toggle directly.
        // If we're in an electron environment the helper dialog is not needed as there's only one option
        // available for audio screen sharing, namely full window audio.
        // If we're already sharing audio, toggle off.
        if (shouldHideShareAudioHelper(state) || browser.isElectron() || audioOnlySharing) {
            // We don't want to explicitly set the screens share state, by passing undefined we let the
            // underlying logic decide if it's on or off.
            dispatch(toggleScreensharing(undefined, true));

            return;
        }

        dispatch(openDialog(ShareAudioDialog));
    };
}

/**
 * Start normal screen sharing flow.Function will switch between off and on states depending on the context, and if
 * not explicitly told otherwise.
 *
 * @param {boolean} enabled - Explicitly set the screen sharing state.
 * @returns {void}
 */
export function startScreenShareFlow(enabled: boolean) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const audioOnlySharing = isAudioOnlySharing(state);

        // If we're in an audio screen sharing session, warn the user.
        if (audioOnlySharing) {
            dispatch(openDialog(ShareMediaWarningDialog, { _isAudioScreenShareWarning: false }));

            return;
        }

        dispatch(toggleScreensharing(enabled));
    };
}


################################################################################

## File: .\jitsi-meet\react\features\screen-share\actionTypes.ts

/**
 * Type of action which sets the current state of screen audio sharing.
 *
 * {
 *     type: SET_SCREEN_AUDIO_SHARE_STATE,
 *     isSharingAudio: boolean
 * }
 */
export const SET_SCREEN_AUDIO_SHARE_STATE = 'SET_SCREEN_AUDIO_SHARE_STATE';

/**
 * Type of action which sets the capture frame rate for screenshare.
 * {
 *      type: SET_SCREENSHARE_CAPTURE_FRAME_RATE,
 *      captureFrameRate: number
 * }
 */
export const SET_SCREENSHARE_CAPTURE_FRAME_RATE = 'SET_SCREENSHARE_CAPTURE_FRAME_RATE';

/**
 * Type of action which sets the current audio track captured from the screenshare.
 * {
 *      type: SET_SCREENSHARE_TRACKS,
 *      desktopAudioTrack: JitsiTrack
 * }
 */
export const SET_SCREENSHARE_TRACKS = 'SET_SCREENSHARE_TRACKS';


################################################################################

## File: .\jitsi-meet\react\features\screen-share\functions.ts

import { IReduxState } from '../app/types';
import { isWindows } from '../base/environment/environment';
import { isMobileBrowser } from '../base/environment/utils';
import { browser } from '../base/lib-jitsi-meet';
import { getLocalDesktopTrack } from '../base/tracks/functions';

/**
 * Is the current screen sharing session audio only.
 *
 * @param {IReduxState} state - The state of the application.
 * @returns {boolean}
 */
export function isAudioOnlySharing(state: IReduxState) {
    return isScreenAudioShared(state) && !isScreenVideoShared(state);
}

/**
 * State of audio sharing.
 *
 * @param {IReduxState} state - The state of the application.
 * @returns {boolean}
 */
export function isScreenAudioShared(state: IReduxState) {
    return state['features/screen-share'].isSharingAudio;
}

/**
 * Returns the visibility of the audio only screen share button. Currently only chrome browser and electron on
 * windows supports this functionality.
 *
 * @returns {boolean}
 */
export function isScreenAudioSupported() {
    return (!isMobileBrowser() && browser.isChromiumBased()) || (browser.isElectron() && isWindows());
}

/**
 * Is any screen media currently being shared, audio or video.
 *
 * @param {IReduxState} state - The state of the application.
 * @returns {boolean}
 */
export function isScreenMediaShared(state: IReduxState) {
    return isScreenAudioShared(state) || isScreenVideoShared(state);
}

/**
 * Is screen sharing currently active.
 *
 * @param {IReduxState} state - The state of the application.
 * @returns {boolean}
 */
export function isScreenVideoShared(state: IReduxState) {
    const tracks = state['features/base/tracks'];
    const localScreenshare = getLocalDesktopTrack(tracks);

    return localScreenshare?.jitsiTrack && !localScreenshare.jitsiTrack.isMuted();
}


################################################################################

## File: .\jitsi-meet\react\features\screen-share\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/screen-share');


################################################################################

## File: .\jitsi-meet\react\features\screen-share\middleware.ts

import { IStore } from '../app/types';
import { CONFERENCE_JOINED } from '../base/conference/actionTypes';
import { MEDIA_TYPE } from '../base/media/constants';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';

import { SET_SCREENSHARE_CAPTURE_FRAME_RATE, SET_SCREEN_AUDIO_SHARE_STATE } from './actionTypes';
import logger from './logger';

/**
 * Implements the middleware of the feature screen-share.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {
    const result = next(action);
    const { getState } = store;
    const state = getState();

    switch (action.type) {
    case CONFERENCE_JOINED: {
        _setScreenshareCaptureFps(store);
        break;
    }
    case SET_SCREENSHARE_CAPTURE_FRAME_RATE: {
        const { captureFrameRate } = action;

        _setScreenshareCaptureFps(store, captureFrameRate);
        break;
    }

    case SET_SCREEN_AUDIO_SHARE_STATE: {
        const { isSharingAudio } = action;
        const { participantId } = state['features/large-video'];

        if (isSharingAudio) {
            logger.debug(`User with id: ${participantId} playing audio sharing.`);
            APP.API.notifyAudioOrVideoSharingToggled(MEDIA_TYPE.AUDIO, 'playing', participantId);
        } else {
            logger.debug(`User with id: ${participantId} stop audio sharing.`);
            APP.API.notifyAudioOrVideoSharingToggled(MEDIA_TYPE.AUDIO, 'stop', participantId);
        }
    }
    }

    return result;
});

/**
 * Sets the capture frame rate for screenshare.
 *
 * @param {Store} store - The redux store.
 * @param {number} frameRate - Frame rate to be configured.
 * @private
 * @returns {void}
 */
function _setScreenshareCaptureFps(store: IStore, frameRate?: number) {
    const state = store.getState();
    const { conference } = state['features/base/conference'];
    const { captureFrameRate } = state['features/screen-share'];
    const screenShareFps = frameRate ?? captureFrameRate;

    if (!conference) {
        return;
    }

    if (screenShareFps) {
        logger.debug(`Setting screenshare capture frame rate as ${screenShareFps}`);
        conference.setDesktopSharingFrameRate(screenShareFps);
    }

}


################################################################################

## File: .\jitsi-meet\react\features\screen-share\reducer.ts


import ReducerRegistry from '../base/redux/ReducerRegistry';

import {
    SET_SCREENSHARE_CAPTURE_FRAME_RATE,
    SET_SCREENSHARE_TRACKS,
    SET_SCREEN_AUDIO_SHARE_STATE
} from './actionTypes';

export interface IScreenShareState {
    captureFrameRate?: number;
    desktopAudioTrack?: any;
    isSharingAudio?: boolean;
}

/**
 * Reduces the Redux actions of the feature features/screen-share.
 */
ReducerRegistry.register<IScreenShareState>('features/screen-share', (state = {}, action): IScreenShareState => {
    const { captureFrameRate, isSharingAudio, desktopAudioTrack } = action;

    switch (action.type) {
    case SET_SCREEN_AUDIO_SHARE_STATE:
        return {
            ...state,
            isSharingAudio
        };

    case SET_SCREENSHARE_CAPTURE_FRAME_RATE:
        return {
            ...state,
            captureFrameRate
        };

    case SET_SCREENSHARE_TRACKS:
        return {
            ...state,
            desktopAudioTrack
        };

    default:
        return state;
    }
});


################################################################################

## File: .\jitsi-meet\react\features\screen-share\components\web\ShareAudioButton.ts

import { connect } from 'react-redux';

import { IReduxState } from '../../../app/types';
import { translate } from '../../../base/i18n/functions';
import { IconVolumeOff, IconVolumeUp } from '../../../base/icons/svg';
import JitsiMeetJS from '../../../base/lib-jitsi-meet';
import AbstractButton, { IProps as AbstractButtonProps } from '../../../base/toolbox/components/AbstractButton';
import { setOverflowMenuVisible } from '../../../toolbox/actions.web';
import { startAudioScreenShareFlow } from '../../actions.web';
import { isAudioOnlySharing, isScreenAudioSupported } from '../../functions';

interface IProps extends AbstractButtonProps {

    /**
     * Whether or not the local participant is audio only screen sharing.
     */
    _isAudioOnlySharing: boolean;
}

/**
 * Component that renders a toolbar button for toggling audio only screen share.
 */
class ShareAudioButton extends AbstractButton<IProps> {
    accessibilityLabel = 'toolbar.accessibilityLabel.shareaudio';
    icon = IconVolumeUp;
    label = 'toolbar.shareaudio';
    tooltip = 'toolbar.shareaudio';
    toggledIcon = IconVolumeOff;
    toggledLabel = 'toolbar.stopAudioSharing';

    /**
     * Handles clicking / pressing the button, and opens a new dialog.
     *
     * @private
     * @returns {void}
     */
    _handleClick() {
        const { dispatch } = this.props;

        dispatch(startAudioScreenShareFlow());
        dispatch(setOverflowMenuVisible(false));
    }

    /**
     * Indicates whether this button is in toggled state or not.
     *
     * @override
     * @protected
     * @returns {boolean}
     */
    _isToggled() {
        return this.props._isAudioOnlySharing;
    }
}

/**
 * Maps part of the Redux state to the props of this component.
 *
 * @param {Object} state - The Redux state.
 * @private
 * @returns {IProps}
 */
function _mapStateToProps(state: IReduxState) {

    return {
        _isAudioOnlySharing: Boolean(isAudioOnlySharing(state)),
        visible: JitsiMeetJS.isDesktopSharingEnabled() && isScreenAudioSupported()
    };
}

export default translate(connect(_mapStateToProps)(ShareAudioButton));


################################################################################

## File: .\jitsi-meet\react\features\screenshot-capture\actions.ts

import { IStore } from '../app/types';
import { getLocalJitsiDesktopTrack } from '../base/tracks/functions';

import { SET_SCREENSHOT_CAPTURE } from './actionTypes';
import { createScreenshotCaptureSummary } from './functions';
import logger from './logger';

let screenshotSummary: any;

/**
 * Marks the on-off state of screenshot captures.
 *
 * @param {boolean} enabled - Whether to turn screen captures on or off.
 * @returns {{
    *      type: START_SCREENSHOT_CAPTURE,
    *      payload: enabled
    * }}
*/
function setScreenshotCapture(enabled: boolean) {
    return {
        type: SET_SCREENSHOT_CAPTURE,
        payload: enabled
    };
}

/**
* Action that toggles the screenshot captures.
*
* @param {boolean} enabled - Bool that represents the intention to start/stop screenshot captures.
* @returns {Promise}
*/
export function toggleScreenshotCaptureSummary(enabled: boolean) {
    return async function(dispatch: IStore['dispatch'], getState: IStore['getState']) {
        const state = getState();

        if (state['features/screenshot-capture'].capturesEnabled !== enabled) {
            if (!screenshotSummary) {
                try {
                    screenshotSummary = await createScreenshotCaptureSummary(state);
                } catch (err) {
                    logger.error('Cannot create screenshotCaptureSummary', err);
                }
            }

            if (enabled) {
                try {
                    const jitsiTrack = getLocalJitsiDesktopTrack(state);

                    await screenshotSummary.start(jitsiTrack);
                    dispatch(setScreenshotCapture(enabled));
                } catch {
                    // Handle promise rejection from {@code start} due to stream type not being desktop.
                    logger.error('Unsupported stream type.');
                }
            } else {
                screenshotSummary.stop();
                dispatch(setScreenshotCapture(enabled));
            }
        }

        return Promise.resolve();
    };
}


################################################################################

## File: .\jitsi-meet\react\features\screenshot-capture\actionTypes.ts

/**
 * Redux action type dispatched in order to toggle screenshot captures.
 *
 * {
 *      type: SET_SCREENSHOT_CAPTURE
 * }
 */

export const SET_SCREENSHOT_CAPTURE = 'SET_SCREENSHOT_CAPTURE';


################################################################################

## File: .\jitsi-meet\react\features\screenshot-capture\constants.ts

/**
 * Percent of pixels that signal if two images should be considered different.
 */
export const PERCENTAGE_LOWER_BOUND = 4;

/**
 * Number of milliseconds that represent how often screenshots should be taken.
 */
export const POLL_INTERVAL = 2000;

/**
 * SET_TIMEOUT constant is used to set interval and it is set in
 * the id property of the request.data property. TimeMs property must
 * also be set.
 *
 * ```
 * Request.data example:
 * {
 *      id: SET_TIMEOUT,
 *      timeMs: 33
 * }
 * ```
 */
export const SET_TIMEOUT = 1;

/**
 * CLEAR_TIMEOUT constant is used to clear the interval and it is set in
 * the id property of the request.data property.
 *
 * ```
 * {
 *      id: CLEAR_TIMEOUT
 * }
 * ```
 */
export const CLEAR_TIMEOUT = 2;

/**
 * TIMEOUT_TICK constant is used as response and it is set in the id property.
 *
 * ```
 * {
 *      id: TIMEOUT_TICK
 * }
 * ```
 */
export const TIMEOUT_TICK = 3;

export const SCREENSHOT_QUEUE_LIMIT = 3;

export const MAX_FILE_SIZE = 1000000;


################################################################################

## File: .\jitsi-meet\react\features\screenshot-capture\createImageBitmap.js

/*
* Safari polyfill for createImageBitmap
* https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/createImageBitmap
*
* Support source image types: Canvas.
*/
if (!('createImageBitmap' in window)) {
    window.createImageBitmap = async function(data) {
        return new Promise((resolve, reject) => {
            let dataURL;

            if (data instanceof HTMLCanvasElement) {
                dataURL = data.toDataURL();
            } else {
                reject(new Error('createImageBitmap does not handle the provided image source type'));
            }
            const img = document.createElement('img');

            img.addEventListener('load', () => {
                resolve(img);
            });
            img.src = dataURL;
        });
    };
}


################################################################################

## File: .\jitsi-meet\react\features\screenshot-capture\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/screenshot-capture');


################################################################################

## File: .\jitsi-meet\react\features\screenshot-capture\processScreenshot.js

/**
 * Helper method used to process screenshots captured by the {@code ScreenshotCaptureEffect}.
 *
 * @param {Blob} imageBlob - The blob of the screenshot that has to be processed.
 * @param {Object} options - Custom options required for processing.
 * @returns {Promise<void>}
 */
export async function processScreenshot(imageBlob, options) { // eslint-disable-line no-unused-vars
    return;
}


################################################################################

## File: .\jitsi-meet\react\features\screenshot-capture\reducer.ts

import PersistenceRegistry from '../base/redux/PersistenceRegistry';
import ReducerRegistry from '../base/redux/ReducerRegistry';

import { SET_SCREENSHOT_CAPTURE } from './actionTypes';

PersistenceRegistry.register('features/screnshot-capture', true, {
    capturesEnabled: false
});

const DEFAULT_STATE = {
    capturesEnabled: false
};

export interface IScreenshotCaptureState {
    capturesEnabled: boolean;
}

ReducerRegistry.register<IScreenshotCaptureState>('features/screenshot-capture',
(state = DEFAULT_STATE, action): IScreenshotCaptureState => {
    switch (action.type) {
    case SET_SCREENSHOT_CAPTURE: {
        return {
            ...state,
            capturesEnabled: action.payload
        };
    }
    }

    return state;
});


################################################################################

## File: .\jitsi-meet\react\features\screenshot-capture\worker.ts

import pixelmatch from 'pixelmatch';

import {
    CLEAR_TIMEOUT,
    MAX_FILE_SIZE,
    PERCENTAGE_LOWER_BOUND,
    SET_TIMEOUT,
    TIMEOUT_TICK
} from './constants';


let timer: ReturnType<typeof setTimeout>;
const canvas = new OffscreenCanvas(0, 0);
const ctx = canvas.getContext('2d');
let storedImageData: ImageData | undefined;

/**
 * Sends Blob with the screenshot to main thread.
 *
  * @param {ImageData} imageData - The image of the screenshot.
 * @returns {void}
 */
async function sendBlob(imageData: ImageData) {
    let imageBlob = await canvas.convertToBlob({ type: 'image/jpeg' });

    if (imageBlob.size > MAX_FILE_SIZE) {
        const quality = Number((MAX_FILE_SIZE / imageBlob.size).toFixed(2)) * 0.92;

        imageBlob = await canvas.convertToBlob({ type: 'image/jpeg',
            quality });
    }

    storedImageData = imageData;

    postMessage({
        id: TIMEOUT_TICK,
        imageBlob
    });
}

/**
 * Sends empty message to main thread.
 *
 * @returns {void}
 */
function sendEmpty() {
    postMessage({
        id: TIMEOUT_TICK
    });
}

/**
 * Draws the image bitmap on the canvas and checks the difference percent with the previous image
 * if there is no previous image the percentage is not calculated.
 *
 * @param {ImageBitmap} imageBitmap - The image bitmap that is drawn on canvas.
 * @returns {void}
 */
function checkScreenshot(imageBitmap: ImageBitmap) {
    const { height, width } = imageBitmap;

    if (canvas.width !== width) {
        canvas.width = width;
    }

    if (canvas.height !== height) {
        canvas.height = height;
    }

    ctx?.drawImage(imageBitmap, 0, 0, width, height);
    const imageData = ctx?.getImageData(0, 0, width, height);

    imageBitmap.close();

    if (!imageData) {
        sendEmpty();

        return;
    }

    if (!storedImageData || imageData.data.length !== storedImageData.data.length) {
        sendBlob(imageData);

        return;
    }

    let numOfPixels = 0;

    try {
        numOfPixels = pixelmatch(
            imageData.data,
            storedImageData.data,
            null,
            width,
            height);
    } catch {
        sendEmpty();

        return;
    }

    const percent = numOfPixels / imageData.data.length * 100;

    if (percent >= PERCENTAGE_LOWER_BOUND) {
        sendBlob(imageData);
    } else {
        sendEmpty();
    }
}

onmessage = function(request) {
    switch (request.data.id) {
    case SET_TIMEOUT: {
        timer = setTimeout(async () => {
            const imageBitmap = request.data.imageBitmap;

            if (imageBitmap) {
                checkScreenshot(imageBitmap);
            } else {
                sendEmpty();
            }
        }, request.data.timeMs);
        break;
    }
    case CLEAR_TIMEOUT: {
        if (timer) {
            clearTimeout(timer);
        }
        break;
    }
    }
};


################################################################################

## File: .\jitsi-meet\react\features\security\actions.ts

import { IStore } from '../app/types';
import { toggleDialog } from '../base/dialog/actions';

import { SecurityDialog } from './components/security-dialog';

/**
 * Action that triggers toggle of the security options dialog.
 *
 * @returns {Function}
 */
export function toggleSecurityDialog() {
    return function(dispatch: IStore['dispatch']) {
        dispatch(toggleDialog(SecurityDialog));
    };
}


################################################################################

## File: .\jitsi-meet\react\features\security\functions.ts

/**
 * Returns true if the security dialog button should be visible and false otherwise.
 *
 * @param {Object} options - The parameters needed to determine the security dialog button visibility.
 * @returns {boolean}
 */
export function isSecurityDialogButtonVisible({
    conference,
    securityUIConfig,
    isModerator,
    enabledLobbyModeFlag,
    enabledSecurityOptionsFlag,
    enabledMeetingPassFlag
}: {
    conference: any;
    enabledLobbyModeFlag: boolean;
    enabledMeetingPassFlag: boolean;
    enabledSecurityOptionsFlag: boolean;
    isModerator: boolean;
    securityUIConfig: { hideLobbyButton?: boolean; };
}) {
    const { hideLobbyButton } = securityUIConfig;
    const lobbySupported = conference?.isLobbySupported();
    const lobby = lobbySupported && isModerator && !hideLobbyButton;


    return enabledSecurityOptionsFlag && ((enabledLobbyModeFlag && lobby) || enabledMeetingPassFlag);
}


################################################################################

## File: .\jitsi-meet\react\features\security\hooks.web.ts

import { useSelector } from 'react-redux';

import { IReduxState } from '../app/types';
import { getSecurityUiConfig } from '../base/config/functions.any';
import { LOBBY_MODE_ENABLED, MEETING_PASSWORD_ENABLED, SECURITY_OPTIONS_ENABLED } from '../base/flags/constants';
import { getFeatureFlag } from '../base/flags/functions';
import { isLocalParticipantModerator } from '../base/participants/functions';

import SecurityDialogButton from './components/security-dialog/web/SecurityDialogButton';
import { isSecurityDialogButtonVisible } from './functions';

const security = {
    key: 'security',
    alias: 'info',
    Content: SecurityDialogButton,
    group: 2
};

/**
 * A hook that returns the security dialog button if it is enabled and undefined otherwise.
 *
 *  @returns {Object | undefined}
 */
export function useSecurityDialogButton() {
    const conference = useSelector((state: IReduxState) => state['features/base/conference'].conference);
    const securityUIConfig = useSelector(getSecurityUiConfig);
    const isModerator = useSelector(isLocalParticipantModerator);
    const enabledLobbyModeFlag
        = useSelector((state: IReduxState) => getFeatureFlag(state, LOBBY_MODE_ENABLED, true));
    const enabledSecurityOptionsFlag
        = useSelector((state: IReduxState) => getFeatureFlag(state, SECURITY_OPTIONS_ENABLED, true));
    const enabledMeetingPassFlag
        = useSelector((state: IReduxState) => getFeatureFlag(state, MEETING_PASSWORD_ENABLED, true));

    if (isSecurityDialogButtonVisible({
        conference,
        securityUIConfig,
        isModerator,
        enabledLobbyModeFlag,
        enabledSecurityOptionsFlag,
        enabledMeetingPassFlag
    })) {
        return security;
    }
}


################################################################################

## File: .\jitsi-meet\react\features\security\components\security-dialog\AbstractSecurityDialogButton.ts

import { createToolbarEvent } from '../../../analytics/AnalyticsEvents';
import { sendAnalytics } from '../../../analytics/functions';
import { IReduxState } from '../../../app/types';
import { getSecurityUiConfig } from '../../../base/config/functions.any';
import { LOBBY_MODE_ENABLED, MEETING_PASSWORD_ENABLED, SECURITY_OPTIONS_ENABLED } from '../../../base/flags/constants';
import { getFeatureFlag } from '../../../base/flags/functions';
import { IconSecurityOff, IconSecurityOn } from '../../../base/icons/svg';
import { isLocalParticipantModerator } from '../../../base/participants/functions';
import AbstractButton, { IProps as AbstractButtonProps } from '../../../base/toolbox/components/AbstractButton';
import { isSecurityDialogButtonVisible } from '../../functions';

export interface IProps extends AbstractButtonProps {

    /**
     * Whether the shared document is being edited or not.
     */
    _locked: boolean;
}


/**
 * Implements an {@link AbstractButton} to open the security dialog/screen.
 */
export default class AbstractSecurityDialogButton<P extends IProps, S>
    extends AbstractButton<P, S> {
    accessibilityLabel = 'toolbar.accessibilityLabel.security';
    icon = IconSecurityOff;
    label = 'toolbar.security';
    toggledIcon = IconSecurityOn;
    tooltip = 'toolbar.security';

    /**
     * Helper function to be implemented by subclasses, which should be used
     * to handle the security button being clicked / pressed.
     *
     * @protected
     * @returns {void}
     */
    _handleClickSecurityButton() {
        // To be implemented by subclass.
    }

    /**
     * Handles clicking / pressing the button.
     *
     * @private
     * @returns {void}
     */
    _handleClick() {
        const { _locked } = this.props;

        sendAnalytics(createToolbarEvent('toggle.security', { enable: !_locked }));
        this._handleClickSecurityButton();
    }

    /**
     * Indicates whether this button is in toggled state or not.
     *
     * @override
     * @returns {boolean}
     */
    _isToggled() {
        return this.props._locked;
    }
}

/**
 * Maps part of the redux state to the component's props.
 *
 * @param {Object} state - The redux store/state.
 * @returns {IProps}
 */
export function _mapStateToProps(state: IReduxState) {
    const { conference } = state['features/base/conference'];
    const { locked } = state['features/base/conference'];
    const { lobbyEnabled } = state['features/lobby'];
    const enabledSecurityOptionsFlag = getFeatureFlag(state, SECURITY_OPTIONS_ENABLED, true);
    const enabledLobbyModeFlag = getFeatureFlag(state, LOBBY_MODE_ENABLED, true);
    const enabledMeetingPassFlag = getFeatureFlag(state, MEETING_PASSWORD_ENABLED, true);

    return {
        _locked: Boolean(locked || lobbyEnabled),
        visible: isSecurityDialogButtonVisible({
            conference,
            securityUIConfig: getSecurityUiConfig(state),
            isModerator: isLocalParticipantModerator(state),
            enabledLobbyModeFlag,
            enabledMeetingPassFlag,
            enabledSecurityOptionsFlag
        })
    };
}


################################################################################

## File: .\jitsi-meet\react\features\security\components\security-dialog\index.native.ts

// @ts-ignore
export { default as SecurityDialog } from './native/SecurityDialog';


################################################################################

## File: .\jitsi-meet\react\features\security\components\security-dialog\index.web.ts

export { default as SecurityDialog } from './web/SecurityDialog';


################################################################################

## File: .\jitsi-meet\react\features\security\components\security-dialog\native\SecurityDialogButton.ts

import { connect } from 'react-redux';

import { translate } from '../../../../base/i18n/functions';
import { navigate } from '../../../../mobile/navigation/components/conference/ConferenceNavigationContainerRef';
import { screen } from '../../../../mobile/navigation/routes';
import AbstractSecurityDialogButton, {
    IProps as AbstractSecurityDialogButtonProps,
    _mapStateToProps as _abstractMapStateToProps
} from '../AbstractSecurityDialogButton';

/**
 * Implements an {@link AbstractSecurityDialogButton} to open the security screen.
 */
class SecurityDialogButton<P extends AbstractSecurityDialogButtonProps, S> extends AbstractSecurityDialogButton<P, S> {

    /**
     * Opens / closes the security screen.
     *
     * @private
     * @returns {void}
     */
    _handleClickSecurityButton() {
        navigate(screen.conference.security);
    }
}

export default translate(connect(_abstractMapStateToProps)(SecurityDialogButton));


################################################################################

## File: .\jitsi-meet\react\features\security\components\security-dialog\native\styles.ts

import BaseTheme from '../../../../base/ui/components/BaseTheme.native';

/**
 * The styles of the feature security.
 */
export default {

    securityDialogContainer: {
        backgroundColor: BaseTheme.palette.ui01,
        flex: 1
    },

    headerCloseButton: {
        marginLeft: 12
    },

    lobbyModeContainer: {
        borderBottomColor: BaseTheme.palette.ui07,
        borderBottomWidth: 1,
        marginTop: BaseTheme.spacing[4]
    },

    lobbyModeContent: {
        marginHorizontal: BaseTheme.spacing[3],
        marginBottom: BaseTheme.spacing[4]
    },

    lobbyModeText: {
        color: BaseTheme.palette.text01
    },

    lobbyModeLabel: {
        color: BaseTheme.palette.text01,
        fontWeight: 'bold',
        marginTop: BaseTheme.spacing[2]
    },

    lobbyModeSection: {
        alignItems: 'center',
        flexDirection: 'row',
        justifyContent: 'space-between',
        marginTop: BaseTheme.spacing[1]
    },

    passwordContainer: {
        marginHorizontal: BaseTheme.spacing[3],
        marginTop: BaseTheme.spacing[4]
    },

    passwordContainerText: {
        color: BaseTheme.palette.text01
    },

    passwordContainerControls: {
        alignItems: 'center',
        flexDirection: 'row',
        justifyContent: 'space-between'
    },

    savedPasswordContainer: {
        flexDirection: 'row',
        width: 208
    },

    savedPasswordLabel: {
        color: BaseTheme.palette.text01,
        fontWeight: 'bold'
    },

    savedPassword: {
        color: BaseTheme.palette.text01
    },

    customContainer: {
        width: 208
    },

    passwordSetupButtonLabel: {
        color: BaseTheme.palette.link01
    },

    passwordSetRemotelyContainer: {
        alignItems: 'center',
        flexDirection: 'row',
        justifyContent: 'space-between'
    },

    passwordSetRemotelyText: {
        color: BaseTheme.palette.text01
    },

    passwordSetRemotelyTextDisabled: {
        color: BaseTheme.palette.text02
    }
};


################################################################################

## File: .\jitsi-meet\react\features\security\components\security-dialog\web\SecurityDialogButton.ts

import { connect } from 'react-redux';

import { translate } from '../../../../base/i18n/functions';
import { toggleSecurityDialog } from '../../../actions';
import AbstractSecurityDialogButton, {
    IProps as AbstractSecurityDialogButtonProps,
    _mapStateToProps as _abstractMapStateToProps
} from '../AbstractSecurityDialogButton';

/**
 * Implements an {@link AbstractSecurityDialogButton} to open the security dialog.
 */
class SecurityDialogButton<P extends AbstractSecurityDialogButtonProps, S> extends AbstractSecurityDialogButton<P, S> {

    /**
     * Opens / closes the security dialog.
     *
     * @private
     * @returns {void}
     */
    _handleClickSecurityButton() {
        const { dispatch } = this.props;

        dispatch(toggleSecurityDialog());
    }
}

export default translate(connect(_abstractMapStateToProps)(SecurityDialogButton));


################################################################################

## File: .\jitsi-meet\react\features\settings\actions.native.ts

import { Linking } from 'react-native';

import { IStore } from '../app/types';
import { isTokenAuthEnabled } from '../authentication/functions';
import { hangup } from '../base/connection/actions.native';
import { openDialog } from '../base/dialog/actions';

import LogoutDialog from './components/native/LogoutDialog';


/**
 * Opens {@code LogoutDialog}.
 *
 * @returns {Function}
 */
export function openLogoutDialog() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const { conference } = state['features/base/conference'];

        const config = state['features/base/config'];
        const logoutUrl = config.tokenLogoutUrl;

        dispatch(openDialog(LogoutDialog, {
            onLogout() {
                if (isTokenAuthEnabled(config)) {
                    if (logoutUrl) {
                        Linking.openURL(logoutUrl);
                    }

                    dispatch(hangup(true));
                } else {
                    conference?.room.xmpp.moderator.logout(() => dispatch(hangup(true)));
                }
            }
        }));
    };
}


################################################################################

## File: .\jitsi-meet\react\features\settings\actions.web.ts

import { batch } from 'react-redux';

import { IStore } from '../app/types';
import { setTokenAuthUrlSuccess } from '../authentication/actions.web';
import { isTokenAuthEnabled } from '../authentication/functions';
import {
    setFollowMe,
    setFollowMeRecorder,
    setStartMutedPolicy,
    setStartReactionsMuted
} from '../base/conference/actions';
import { hangup } from '../base/connection/actions.web';
import { openDialog } from '../base/dialog/actions';
import i18next from '../base/i18n/i18next';
import { browser } from '../base/lib-jitsi-meet';
import { getNormalizedDisplayName } from '../base/participants/functions';
import { updateSettings } from '../base/settings/actions';
import { getLocalVideoTrack } from '../base/tracks/functions.web';
import { appendURLHashParam } from '../base/util/uri';
import { disableKeyboardShortcuts, enableKeyboardShortcuts } from '../keyboard-shortcuts/actions';
import { toggleBackgroundEffect } from '../virtual-background/actions';
import virtualBackgroundLogger from '../virtual-background/logger';

import {
    SET_AUDIO_SETTINGS_VISIBILITY,
    SET_VIDEO_SETTINGS_VISIBILITY
} from './actionTypes';
import LogoutDialog from './components/web/LogoutDialog';
import SettingsDialog from './components/web/SettingsDialog';
import {
    getModeratorTabProps,
    getMoreTabProps,
    getNotificationsTabProps,
    getProfileTabProps,
    getShortcutsTabProps
} from './functions.web';


/**
 * Opens {@code LogoutDialog}.
 *
 * @returns {Function}
 */
export function openLogoutDialog() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();

        const config = state['features/base/config'];
        const logoutUrl = config.tokenLogoutUrl;

        const { conference } = state['features/base/conference'];
        const { jwt } = state['features/base/jwt'];

        dispatch(openDialog(LogoutDialog, {
            onLogout() {
                if (isTokenAuthEnabled(config) && config.tokenAuthUrlAutoRedirect && jwt) {

                    // user is logging out remove auto redirect indication
                    dispatch(setTokenAuthUrlSuccess(false));
                }

                if (logoutUrl && browser.isElectron()) {
                    const url = appendURLHashParam(logoutUrl, 'electron', 'true');

                    window.open(url, '_blank');
                    dispatch(hangup(true));
                } else {
                    if (logoutUrl) {
                        window.location.href = logoutUrl;

                        return;
                    }

                    conference?.room.xmpp.moderator.logout(() => dispatch(hangup(true)));
                }
            }
        }));
    };
}

/**
 * Opens {@code SettingsDialog}.
 *
 * @param {string} defaultTab - The tab in {@code SettingsDialog} that should be
 * displayed initially.
 * @param {boolean} isDisplayedOnWelcomePage - Indicates whether the device selection dialog is displayed on the
 * welcome page or not.
 * @returns {Function}
 */
export function openSettingsDialog(defaultTab?: string, isDisplayedOnWelcomePage?: boolean) {
    return openDialog(SettingsDialog, {
        defaultTab,
        isDisplayedOnWelcomePage
    });
}

/**
 * Sets the visibility of the audio settings.
 *
 * @param {boolean} value - The new value.
 * @returns {Function}
 */
function setAudioSettingsVisibility(value: boolean) {
    return {
        type: SET_AUDIO_SETTINGS_VISIBILITY,
        value
    };
}

/**
 * Sets the visibility of the video settings.
 *
 * @param {boolean} value - The new value.
 * @returns {Function}
 */
function setVideoSettingsVisibility(value: boolean) {
    return {
        type: SET_VIDEO_SETTINGS_VISIBILITY,
        value
    };
}

/**
 * Submits the settings from the "More" tab of the settings dialog.
 *
 * @param {Object} newState - The new settings.
 * @returns {Function}
 */
export function submitMoreTab(newState: any) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const currentState = getMoreTabProps(getState());

        const showPrejoinPage = newState.showPrejoinPage;

        if (showPrejoinPage !== currentState.showPrejoinPage) {
            dispatch(updateSettings({
                userSelectedSkipPrejoin: !showPrejoinPage
            }));
        }

        if (newState.maxStageParticipants !== currentState.maxStageParticipants) {
            dispatch(updateSettings({ maxStageParticipants: Number(newState.maxStageParticipants) }));
        }

        if (newState.hideSelfView !== currentState.hideSelfView) {
            dispatch(updateSettings({ disableSelfView: newState.hideSelfView }));
        }

        if (newState.currentLanguage !== currentState.currentLanguage) {
            i18next.changeLanguage(newState.currentLanguage);
        }
    };
}

/**
 * Submits the settings from the "Moderator" tab of the settings dialog.
 *
 * @param {Object} newState - The new settings.
 * @returns {Function}
 */
export function submitModeratorTab(newState: any) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const currentState = getModeratorTabProps(getState());

        if (newState.followMeEnabled !== currentState.followMeEnabled) {
            dispatch(setFollowMe(newState.followMeEnabled));
        }

        if (newState.followMeRecorderEnabled !== currentState.followMeRecorderEnabled) {
            dispatch(setFollowMeRecorder(newState.followMeRecorderEnabled));
        }

        if (newState.startReactionsMuted !== currentState.startReactionsMuted) {
            batch(() => {
                // updating settings we want to update and backend (notify the rest of the participants)
                dispatch(setStartReactionsMuted(newState.startReactionsMuted, true));
                dispatch(updateSettings({ soundsReactions: !newState.startReactionsMuted }));
            });
        }

        if (newState.startAudioMuted !== currentState.startAudioMuted
            || newState.startVideoMuted !== currentState.startVideoMuted) {
            dispatch(setStartMutedPolicy(
                newState.startAudioMuted, newState.startVideoMuted));
        }
    };
}

/**
 * Submits the settings from the "Profile" tab of the settings dialog.
 *
 * @param {Object} newState - The new settings.
 * @returns {Function}
 */
export function submitProfileTab(newState: any) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const currentState = getProfileTabProps(getState());

        if (newState.displayName !== currentState.displayName) {
            dispatch(updateSettings({ displayName: getNormalizedDisplayName(newState.displayName) }));
        }

        if (newState.email !== currentState.email) {
            APP.conference.changeLocalEmail(newState.email);
        }
    };
}

/**
 * Submits the settings from the "Sounds" tab of the settings dialog.
 *
 * @param {Object} newState - The new settings.
 * @returns {Function}
 */
export function submitNotificationsTab(newState: any) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const currentState = getNotificationsTabProps(getState());
        const shouldNotUpdateReactionSounds = getModeratorTabProps(getState()).startReactionsMuted;
        const shouldUpdate = (newState.soundsIncomingMessage !== currentState.soundsIncomingMessage)
            || (newState.soundsParticipantJoined !== currentState.soundsParticipantJoined)
            || (newState.soundsParticipantKnocking !== currentState.soundsParticipantKnocking)
            || (newState.soundsParticipantLeft !== currentState.soundsParticipantLeft)
            || (newState.soundsTalkWhileMuted !== currentState.soundsTalkWhileMuted)
            || (newState.soundsReactions !== currentState.soundsReactions);

        if (shouldUpdate) {
            const settingsToUpdate = {
                soundsIncomingMessage: newState.soundsIncomingMessage,
                soundsParticipantJoined: newState.soundsParticipantJoined,
                soundsParticipantKnocking: newState.soundsParticipantKnocking,
                soundsParticipantLeft: newState.soundsParticipantLeft,
                soundsTalkWhileMuted: newState.soundsTalkWhileMuted,
                soundsReactions: newState.soundsReactions
            };

            if (shouldNotUpdateReactionSounds) {
                delete settingsToUpdate.soundsReactions;
            }
            dispatch(updateSettings(settingsToUpdate));
        }

        const enabledNotifications = newState.enabledNotifications;

        if (enabledNotifications !== currentState.enabledNotifications) {
            dispatch(updateSettings({
                userSelectedNotifications: {
                    ...getState()['features/base/settings'].userSelectedNotifications,
                    ...enabledNotifications
                }
            }));
        }
    };
}

/**
 * Toggles the visibility of the audio settings.
 *
 * @returns {void}
 */
export function toggleAudioSettings() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const value = getState()['features/settings'].audioSettingsVisible;

        dispatch(setAudioSettingsVisibility(!value));
    };
}

/**
 * Toggles the visibility of the video settings.
 *
 * @returns {void}
 */
export function toggleVideoSettings() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const value = getState()['features/settings'].videoSettingsVisible;

        dispatch(setVideoSettingsVisibility(!value));
    };
}

/**
 * Submits the settings from the "Shortcuts" tab of the settings dialog.
 *
 * @param {Object} newState - The new settings.
 * @returns {Function}
 */
export function submitShortcutsTab(newState: any) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const currentState = getShortcutsTabProps(getState());

        if (newState.keyboardShortcutsEnabled !== currentState.keyboardShortcutsEnabled) {
            if (newState.keyboardShortcutsEnabled) {
                dispatch(enableKeyboardShortcuts());
            } else {
                dispatch(disableKeyboardShortcuts());
            }
        }
    };
}

/**
 * Submits the settings from the "Virtual Background" tab of the settings dialog.
 *
 * @param {Object} newState - The new settings.
 * @param {boolean} isCancel - Whether the change represents a cancel.
 * @returns {Function}
 */
export function submitVirtualBackgroundTab(newState: any, isCancel = false) {
    return async (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const track = getLocalVideoTrack(state['features/base/tracks'])?.jitsiTrack;
        const { localFlipX } = state['features/base/settings'];

        if (newState.options?.selectedThumbnail) {
            await dispatch(toggleBackgroundEffect(newState.options, track));

            if (!isCancel) {
                // Set x scale to default value.
                dispatch(updateSettings({
                    localFlipX
                }));

                virtualBackgroundLogger.info(`Virtual background type: '${
                    typeof newState.options.backgroundType === 'undefined'
                        ? 'none' : newState.options.backgroundType}' applied!`);
            }
        }
    };
}


################################################################################

## File: .\jitsi-meet\react\features\settings\actionTypes.ts

/**
 * The type of (redux) action which sets the visibility of the audio settings popup.
 */
export const SET_AUDIO_SETTINGS_VISIBILITY = 'SET_AUDIO_SETTINGS_VISIBILITY';

/**
 * The type of (redux) action which sets the visibility of the video settings popup.
 */
export const SET_VIDEO_SETTINGS_VISIBILITY = 'SET_VIDEO_SETTINGS_VISIBILITY';


################################################################################

## File: .\jitsi-meet\react\features\settings\constants.ts

export const SETTINGS_TABS = {
    AUDIO: 'audio_tab',
    CALENDAR: 'calendar_tab',
    MORE: 'more_tab',
    MODERATOR: 'moderator-tab',
    NOTIFICATIONS: 'notifications_tab',
    PROFILE: 'profile_tab',
    SHORTCUTS: 'shortcuts_tab',
    VIDEO: 'video_tab',
    VIRTUAL_BACKGROUND: 'virtual-background_tab'
};

/**
 * Default frame rate to be used for capturing screenshare.
 */
export const SS_DEFAULT_FRAME_RATE = 5;

/**
 * Supported framerates to be used for capturing screenshare.
 */
export const SS_SUPPORTED_FRAMERATES = [ 5, 15, 30 ];


################################################################################

## File: .\jitsi-meet\react\features\settings\functions.any.ts

import { IReduxState } from '../app/types';
import { IStateful } from '../base/app/types';
import { isNameReadOnly } from '../base/config/functions.any';
import { SERVER_URL_CHANGE_ENABLED } from '../base/flags/constants';
import { getFeatureFlag } from '../base/flags/functions';
import i18next, { DEFAULT_LANGUAGE, LANGUAGES } from '../base/i18n/i18next';
import { getLocalParticipant } from '../base/participants/functions';
import { toState } from '../base/redux/functions';
import { getHideSelfView } from '../base/settings/functions.any';
import { parseStandardURIString } from '../base/util/uri';
import { isStageFilmstripEnabled } from '../filmstrip/functions';
import { isFollowMeActive, isFollowMeRecorderActive } from '../follow-me/functions';
import { isPrejoinEnabledInConfig } from '../prejoin/functions';
import { isReactionsEnabled } from '../reactions/functions.any';
import { iAmVisitor } from '../visitors/functions';

import { shouldShowModeratorSettings } from './functions';

/**
 * Returns true if user is allowed to change Server URL.
 *
 * @param {(Function|Object)} stateful - The (whole) redux state, or redux's
 * {@code getState} function to be used to retrieve the state.
 * @returns {boolean} True to indicate that user can change Server URL, false otherwise.
 */
export function isServerURLChangeEnabled(stateful: IStateful) {
    const state = toState(stateful);

    return getFeatureFlag(state, SERVER_URL_CHANGE_ENABLED, true);
}

/**
 * Normalizes a URL entered by the user.
 * FIXME: Consider adding this to base/util/uri.
 *
 * @param {string} url - The URL to validate.
 * @returns {string|null} - The normalized URL, or null if the URL is invalid.
 */
export function normalizeUserInputURL(url: string) {
    /* eslint-disable no-param-reassign */

    if (url) {
        url = url.replace(/\s/g, '').toLowerCase();

        const urlRegExp = new RegExp('^(\\w+://)?(.+)$');
        const urlComponents = urlRegExp.exec(url);

        if (urlComponents && !urlComponents[1]?.startsWith('http')) {
            url = `https://${urlComponents[2]}`;
        }

        const parsedURI = parseStandardURIString(url);

        if (!parsedURI.host) {
            return null;
        }

        return parsedURI.toString();
    }

    return url;

    /* eslint-enable no-param-reassign */
}

/**
 * Returns the notification types and their user selected configuration.
 *
 * @param {(Function|Object)} stateful -The (whole) redux state, or redux's
 * {@code getState} function to be used to retrieve the state.
 * @returns {Object} - The section of notifications to be configured.
 */
export function getNotificationsMap(stateful: IStateful): { [key: string]: boolean; } {
    const state = toState(stateful);
    const { notifications } = state['features/base/config'];
    const { userSelectedNotifications } = state['features/base/settings'];

    if (!userSelectedNotifications) {
        return {};
    }

    return Object.keys(userSelectedNotifications)
        .filter(key => !notifications || notifications.includes(key))
        .reduce((notificationsMap, key) => {
            return {
                ...notificationsMap,
                [key]: userSelectedNotifications[key]
            };
        }, {});
}

/**
 * Returns the properties for the "More" tab from settings dialog from Redux
 * state.
 *
 * @param {(Function|Object)} stateful -The (whole) redux state, or redux's
 * {@code getState} function to be used to retrieve the state.
 * @returns {Object} - The properties for the "More" tab from settings dialog.
 */
export function getMoreTabProps(stateful: IStateful) {
    const state = toState(stateful);
    const stageFilmstripEnabled = isStageFilmstripEnabled(state);
    const language = i18next.language || DEFAULT_LANGUAGE;
    const configuredTabs: string[] = interfaceConfig.SETTINGS_SECTIONS || [];

    // when self view is controlled by the config we hide the settings
    const { disableSelfView, disableSelfViewSettings } = state['features/base/config'];

    return {
        currentLanguage: language,
        disableHideSelfView: disableSelfViewSettings || disableSelfView,
        hideSelfView: getHideSelfView(state),
        iAmVisitor: iAmVisitor(state),
        languages: LANGUAGES,
        maxStageParticipants: state['features/base/settings'].maxStageParticipants,
        showLanguageSettings: configuredTabs.includes('language'),
        showPrejoinPage: !state['features/base/settings'].userSelectedSkipPrejoin,
        showPrejoinSettings: isPrejoinEnabledInConfig(state),
        stageFilmstripEnabled
    };
}

/**
 * Returns the properties for the "More" tab from settings dialog from Redux
 * state.
 *
 * @param {(Function|Object)} stateful -The (whole) redux state, or redux's
 * {@code getState} function to be used to retrieve the state.
 * @returns {Object} - The properties for the "More" tab from settings dialog.
 */
export function getModeratorTabProps(stateful: IStateful) {
    const state = toState(stateful);
    const {
        conference,
        followMeEnabled,
        followMeRecorderEnabled,
        startAudioMutedPolicy,
        startVideoMutedPolicy,
        startReactionsMuted
    } = state['features/base/conference'];
    const { disableReactionsModeration } = state['features/base/config'];
    const followMeActive = isFollowMeActive(state);
    const followMeRecorderActive = isFollowMeRecorderActive(state);
    const showModeratorSettings = shouldShowModeratorSettings(state);

    // The settings sections to display.
    return {
        showModeratorSettings: Boolean(conference && showModeratorSettings),
        disableReactionsModeration: Boolean(disableReactionsModeration),
        followMeActive: Boolean(conference && followMeActive),
        followMeEnabled: Boolean(conference && followMeEnabled),
        followMeRecorderActive: Boolean(conference && followMeRecorderActive),
        followMeRecorderEnabled: Boolean(conference && followMeRecorderEnabled),
        startReactionsMuted: Boolean(conference && startReactionsMuted),
        startAudioMuted: Boolean(conference && startAudioMutedPolicy),
        startVideoMuted: Boolean(conference && startVideoMutedPolicy)
    };
}

/**
 * Returns the properties for the "Profile" tab from settings dialog from Redux
 * state.
 *
 * @param {(Function|Object)} stateful -The (whole) redux state, or redux's
 * {@code getState} function to be used to retrieve the state.
 * @returns {Object} - The properties for the "Profile" tab from settings
 * dialog.
 */
export function getProfileTabProps(stateful: IStateful) {
    const state = toState(stateful);
    const {
        authEnabled,
        authLogin,
        conference
    } = state['features/base/conference'];
    const config = state['features/base/config'];
    let { hideEmailInSettings } = config;
    const localParticipant = getLocalParticipant(state);

    if (config.gravatar?.disabled
        || (localParticipant?.avatarURL && localParticipant?.avatarURL.length > 0)) {
        hideEmailInSettings = true;
    }

    return {
        authEnabled: Boolean(conference && authEnabled),
        authLogin,
        displayName: localParticipant?.name,
        email: localParticipant?.email,
        hideEmailInSettings,
        id: localParticipant?.id,
        readOnlyName: isNameReadOnly(state)
    };
}

/**
 * Returns the properties for the "Sounds" tab from settings dialog from Redux
 * state.
 *
 * @param {(Function|Object)} stateful -The (whole) redux state, or redux's
 * {@code getState} function to be used to retrieve the state.
 * @param {boolean} showSoundsSettings - Whether to show the sound settings or not.
 * @returns {Object} - The properties for the "Sounds" tab from settings
 * dialog.
 */
export function getNotificationsTabProps(stateful: IStateful, showSoundsSettings?: boolean) {
    const state = toState(stateful);
    const {
        soundsIncomingMessage,
        soundsParticipantJoined,
        soundsParticipantKnocking,
        soundsParticipantLeft,
        soundsTalkWhileMuted,
        soundsReactions
    } = state['features/base/settings'];

    const enableReactions = isReactionsEnabled(state);
    const moderatorMutedSoundsReactions = state['features/base/conference'].startReactionsMuted ?? false;
    const enabledNotifications = getNotificationsMap(stateful);

    return {
        disabledSounds: state['features/base/config'].disabledSounds || [],
        enabledNotifications,
        showNotificationsSettings: Object.keys(enabledNotifications).length > 0,
        soundsIncomingMessage,
        soundsParticipantJoined,
        soundsParticipantKnocking,
        soundsParticipantLeft,
        soundsTalkWhileMuted,
        soundsReactions,
        enableReactions,
        moderatorMutedSoundsReactions,
        showSoundsSettings
    };
}

/**
 * Returns the visibility state of the audio settings.
 *
 * @param {Object} state - The state of the application.
 * @returns {boolean}
 */
export function getAudioSettingsVisibility(state: IReduxState) {
    return state['features/settings'].audioSettingsVisible;
}

/**
 * Returns the visibility state of the video settings.
 *
 * @param {Object} state - The state of the application.
 * @returns {boolean}
 */
export function getVideoSettingsVisibility(state: IReduxState) {
    return state['features/settings'].videoSettingsVisible;
}


################################################################################

## File: .\jitsi-meet\react\features\settings\functions.native.ts

import { IStateful } from '../base/app/types';
import { isLocalParticipantModerator } from '../base/participants/functions';
import { toState } from '../base/redux/functions';
import { getParticipantsPaneConfig } from '../participants-pane/functions';

export * from './functions.any';

/**
 * Used on web.
 *
 * @param {(Function|Object)} _stateful -The (whole) redux state, or redux's
 * {@code getState} function to be used to retrieve the state.
 * @param {boolean} _isDisplayedOnWelcomePage - Indicates whether the shortcuts dialog is displayed on the
 * welcome page or not.
 * @returns {Object} - The properties for the "Shortcuts" tab from settings
 * dialog.
 */
export function getShortcutsTabProps(_stateful: any, _isDisplayedOnWelcomePage?: boolean) {
    // needed to fix lint error.
    return {
        keyboardShortcutsEnabled: false
    };
}

/**
 * Returns true if moderator tab in settings should be visible/accessible.
 *
 * @param {(Function|Object)} stateful - The (whole) redux state, or redux's
 * {@code getState} function to be used to retrieve the state.
 * @returns {boolean} True to indicate that moderator tab should be visible, false otherwise.
 */
export function shouldShowModeratorSettings(stateful: IStateful) {
    const state = toState(stateful);
    const { hideModeratorSettingsTab } = getParticipantsPaneConfig(state);
    const hasModeratorRights = isLocalParticipantModerator(state);

    return hasModeratorRights && !hideModeratorSettingsTab;
}


################################################################################

## File: .\jitsi-meet\react\features\settings\functions.web.ts

import { IStateful } from '../base/app/types';
import { createLocalTrack } from '../base/lib-jitsi-meet/functions';
import { isLocalParticipantModerator } from '../base/participants/functions';
import { toState } from '../base/redux/functions';
import { getUserSelectedCameraDeviceId } from '../base/settings/functions.web';
import { areKeyboardShortcutsEnabled, getKeyboardShortcutsHelpDescriptions } from '../keyboard-shortcuts/functions';
import { getParticipantsPaneConfig } from '../participants-pane/functions';
import { isPrejoinPageVisible } from '../prejoin/functions';

export * from './functions.any';

/**
 * Returns a promise which resolves with a list of objects containing
 * all the video jitsiTracks and appropriate errors for the given device ids.
 *
 * @param {string[]} ids - The list of the camera ids for which to create tracks.
 * @param {number} [timeout] - A timeout for the createLocalTrack function call.
 *
 * @returns {Promise<Object[]>}
 */
export function createLocalVideoTracks(ids: string[], timeout?: number) {
    return Promise.all(ids.map(deviceId => createLocalTrack('video', deviceId, timeout)
                    .then((jitsiTrack: any) => {
                        return {
                            jitsiTrack,
                            deviceId
                        };
                    })
                    .catch(() => {
                        return {
                            jitsiTrack: null,
                            deviceId,
                            error: 'deviceSelection.previewUnavailable'
                        };
                    })));
}


/**
 * Returns a promise which resolves with a list of objects containing
 * the audio track and the corresponding audio device information.
 *
 * @param {Object[]} devices - A list of microphone devices.
 * @param {number} [timeout] - A timeout for the createLocalTrack function call.
 * @returns {Promise<{
 *   deviceId: string,
 *   hasError: boolean,
 *   jitsiTrack: Object,
 *   label: string
 * }[]>}
 */
export function createLocalAudioTracks(devices: Array<{ deviceId: string; label: string; }>, timeout?: number) {
    return Promise.all(
        devices.map(async ({ deviceId, label }) => {
            let jitsiTrack = null;
            let hasError = false;

            try {
                jitsiTrack = await createLocalTrack('audio', deviceId, timeout);
            } catch (err) {
                hasError = true;
            }

            return {
                deviceId,
                hasError,
                jitsiTrack,
                label
            };
        }));
}

/**
 * Returns the properties for the "Shortcuts" tab from settings dialog from Redux
 * state.
 *
 * @param {(Function|Object)} stateful -The (whole) redux state, or redux's
 * {@code getState} function to be used to retrieve the state.
 * @param {boolean} isDisplayedOnWelcomePage - Indicates whether the shortcuts dialog is displayed on the
 * welcome page or not.
 * @returns {Object} - The properties for the "Shortcuts" tab from settings
 * dialog.
 */
export function getShortcutsTabProps(stateful: IStateful, isDisplayedOnWelcomePage?: boolean) {
    const state = toState(stateful);

    return {
        displayShortcuts: !isDisplayedOnWelcomePage && !isPrejoinPageVisible(state),
        keyboardShortcutsEnabled: areKeyboardShortcutsEnabled(state),
        keyboardShortcutsHelpDescriptions: getKeyboardShortcutsHelpDescriptions(state)
    };
}

/**
 * Returns the properties for the "Virtual Background" tab from settings dialog from Redux
 * state.
 *
 * @param {(Function|Object)} stateful -The (whole) redux state, or redux's
 * {@code getState} function to be used to retrieve the state.
 * @param {boolean} isDisplayedOnWelcomePage - Indicates whether the device selection dialog is displayed on the
 * welcome page or not.
 * @returns {Object} - The properties for the "Shortcuts" tab from settings
 * dialog.
 */
export function getVirtualBackgroundTabProps(stateful: IStateful, isDisplayedOnWelcomePage?: boolean) {
    const state = toState(stateful);
    const settings = state['features/base/settings'];
    const userSelectedCamera = getUserSelectedCameraDeviceId(state);
    let selectedVideoInputId = settings.cameraDeviceId;

    if (isDisplayedOnWelcomePage) {
        selectedVideoInputId = userSelectedCamera;
    }

    return {
        options: state['features/virtual-background'],
        selectedVideoInputId
    };
}

/**
 * Used for web. Indicates if the setting section is enabled.
 *
 * @param {string} settingName - The name of the setting section as defined in
 * interface_config.js and SettingsMenu.js.
 * @returns {boolean} True to indicate that the given setting section
 * is enabled, false otherwise.
 */
export function isSettingEnabled(settingName: string) {
    return interfaceConfig.SETTINGS_SECTIONS.includes(settingName);
}


/**
 * Returns true if moderator tab in settings should be visible/accessible.
 *
 * @param {(Function|Object)} stateful - The (whole) redux state, or redux's
 * {@code getState} function to be used to retrieve the state.
 * @returns {boolean} True to indicate that moderator tab should be visible, false otherwise.
 */
export function shouldShowModeratorSettings(stateful: IStateful) {
    const state = toState(stateful);
    const { hideModeratorSettingsTab } = getParticipantsPaneConfig(state);
    const hasModeratorRights = Boolean(isSettingEnabled('moderator') && isLocalParticipantModerator(state));

    return hasModeratorRights && !hideModeratorSettingsTab;
}


################################################################################

## File: .\jitsi-meet\react\features\settings\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/settings');


################################################################################

## File: .\jitsi-meet\react\features\settings\middleware.web.ts

import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import { SETTINGS_UPDATED } from '../base/settings/actionTypes';
import { getHideSelfView } from '../base/settings/functions.web';
import { showNotification } from '../notifications/actions';
import { DISABLE_SELF_VIEW_NOTIFICATION_ID, NOTIFICATION_TIMEOUT_TYPE } from '../notifications/constants';

import { openSettingsDialog } from './actions';
import { SETTINGS_TABS } from './constants';

MiddlewareRegistry.register(({ dispatch, getState }) => next => action => {
    const oldValue = getHideSelfView(getState());

    const result = next(action);

    switch (action.type) {
    case SETTINGS_UPDATED: {
        const newValue = action.settings.disableSelfView;

        if (newValue !== oldValue && newValue) {
            dispatch(showNotification({
                uid: DISABLE_SELF_VIEW_NOTIFICATION_ID,
                titleKey: 'notify.selfViewTitle',
                customActionNameKey: [ 'settings.title' ],
                customActionHandler: [ () =>
                    dispatch(openSettingsDialog(SETTINGS_TABS.MORE))
                ]
            }, NOTIFICATION_TIMEOUT_TYPE.STICKY));
        }
    }
    }

    return result;
});


################################################################################

## File: .\jitsi-meet\react\features\settings\reducer.ts

import ReducerRegistry from '../base/redux/ReducerRegistry';

import {
    SET_AUDIO_SETTINGS_VISIBILITY,
    SET_VIDEO_SETTINGS_VISIBILITY
} from './actionTypes';

export interface ISettingsState {
    audioSettingsVisible?: boolean;
    videoSettingsVisible?: boolean;
}

ReducerRegistry.register('features/settings', (state: ISettingsState = {}, action) => {
    switch (action.type) {
    case SET_AUDIO_SETTINGS_VISIBILITY:
        return {
            ...state,
            audioSettingsVisible: action.value
        };
    case SET_VIDEO_SETTINGS_VISIBILITY:
        return {
            ...state,
            videoSettingsVisible: action.value
        };
    }

    return state;
});


################################################################################

## File: .\jitsi-meet\react\features\settings\components\native\constants.ts

export const AVATAR_SIZE = 64;


################################################################################

## File: .\jitsi-meet\react\features\settings\components\native\styles.ts

import BaseTheme from '../../../base/ui/components/BaseTheme.native';

export const ANDROID_UNDERLINE_COLOR = 'transparent';
export const PLACEHOLDER_COLOR = BaseTheme.palette.focus01;

/**
 * The styles of the native components of the feature {@code settings}.
 */
export default {

    profileContainerWrapper: {
        margin: BaseTheme.spacing[4]
    },

    profileContainer: {
        backgroundColor: BaseTheme.palette.ui02,
        borderRadius: BaseTheme.shape.borderRadius,
        alignItems: 'center',
        flexDirection: 'row',
        justifyContent: 'flex-start',
        padding: BaseTheme.spacing[3]
    },

    profileView: {
        flexGrow: 1,
        flexDirection: 'column',
        justifyContent: 'space-between'
    },

    applyProfileSettingsButton: {
        marginHorizontal: BaseTheme.spacing[4],
        marginVertical: BaseTheme.spacing[3]
    },

    avatarContainer: {
        alignItems: 'center',
        flexDirection: 'row',
        justifyContent: 'center',
        padding: BaseTheme.spacing[3],
        margin: BaseTheme.spacing[4]
    },

    gavatarMessageContainer: {
        marginHorizontal: BaseTheme.spacing[4],
        color: BaseTheme.palette.text02,
        marginTop: -BaseTheme.spacing[2],
        ...BaseTheme.typography.bodyShortRegular
    },

    displayName: {
        ...BaseTheme.typography.bodyLongRegularLarge,
        color: BaseTheme.palette.text01,
        marginLeft: BaseTheme.spacing[3],
        position: 'relative'
    },

    profileViewArrow: {
        position: 'absolute',
        right: BaseTheme.spacing[3]
    },

    /**
     * Style for screen container.
     */
    settingsViewContainer: {
        backgroundColor: BaseTheme.palette.ui01,
        flex: 1
    },

    /**
     * Standardized style for a field container {@code View}.
     */
    fieldContainer: {
        alignItems: 'center',
        flexDirection: 'row',
        minHeight: BaseTheme.spacing[8],
        paddingHorizontal: BaseTheme.spacing[2],
        justifyContent: 'space-between'
    },

    /**
     * * Appended style for column layout fields.
     */
    fieldContainerColumn: {
        alignItems: 'flex-start',
        flexDirection: 'column'
    },

    /**
     * Standard container for a {@code View} containing a field label.
     */
    fieldLabelContainer: {
        alignItems: 'center',
        flexShrink: 1,
        flexDirection: 'row',
        paddingLeft: BaseTheme.spacing[3],
        paddingRight: BaseTheme.spacing[1]
    },

    /**
     * Text of the field labels on the form.
     */
    fieldLabelText: {
        ...BaseTheme.typography.bodyShortRegularLarge
    },

    /**
     * Field container style for all but last row {@code View}.
     */
    fieldSeparator: {
        marginHorizontal: BaseTheme.spacing[4],
        borderBottomWidth: 1,
        borderColor: BaseTheme.palette.ui05,
        marginVertical: BaseTheme.spacing[3]
    },

    /**
     * Style for the {@code View} containing each
     * field values (the actual field).
     */
    fieldValueContainer: {
        alignItems: 'center',
        flexDirection: 'row',
        flexShrink: 1,
        justifyContent: 'flex-end',
        paddingRight: BaseTheme.spacing[3]
    },

    /**
     * Style for the form section separator titles.
     */

    formSectionTitleContent: {
        backgroundColor: BaseTheme.palette.ui02,
        paddingVertical: BaseTheme.spacing[1]
    },

    formSectionTitleText: {
        ...BaseTheme.typography.bodyShortBold,
        color: BaseTheme.palette.text02,
        marginHorizontal: BaseTheme.spacing[4],
        marginVertical: BaseTheme.spacing[3]
    },

    /**
     * Global {@code Text} color for the components.
     */
    text: {
        color: BaseTheme.palette.text01
    },

    /**
     * Text input container style.
     */
    customContainer: {
        marginBottom: BaseTheme.spacing[3],
        marginHorizontal: BaseTheme.spacing[4],
        marginTop: BaseTheme.spacing[2]
    },

    languageButtonContainer: {
        borderRadius: BaseTheme.shape.borderRadius,
        overflow: 'hidden'
    },

    languageButton: {
        alignItems: 'center',
        display: 'flex',
        flexDirection: 'row',
        height: BaseTheme.spacing[7],
        justifyContent: 'center'
    },

    languageOption: {
        display: 'flex',
        flexDirection: 'row',
        alignItems: 'center',
        height: BaseTheme.spacing[6],
        marginHorizontal: BaseTheme.spacing[4],
        borderBottomWidth: 1,
        borderColor: BaseTheme.palette.ui05
    },

    selectedLanguage: {
        color: BaseTheme.palette.text03
    },

    languageText: {
        ...BaseTheme.typography.bodyShortRegularLarge,
        color: BaseTheme.palette.text01,
        marginHorizontal: BaseTheme.spacing[2]
    },

    /**
     * Standard text input field style.
     */
    textInputField: {
        color: BaseTheme.palette.field01,
        flex: 1,
        ...BaseTheme.typography.bodyShortRegularLarge,
        textAlign: 'right'
    },

    /**
     * Appended style for column layout fields.
     */
    textInputFieldColumn: {
        backgroundColor: 'rgb(245, 245, 245)',
        borderRadius: 8,
        marginVertical: 5,
        paddingVertical: 3,
        textAlign: 'left'
    },

    /**
     * Style for screen container.
     */
    screenContainer: {
        flex: 1
    },

    linksSection: {
        display: 'flex',
        flexDirection: 'row',
        flex: 1,
        marginHorizontal: BaseTheme.spacing[3]
    },

    linksButton: {
        width: '33%',
        justifyContent: 'center',
        flexDirection: 'row',
        alignItems: 'center',
        ...BaseTheme.typography.bodyShortBoldLarge
    },

    logBtn: {
        marginRight: BaseTheme.spacing[3]
    },

    backBtn: {
        marginLeft: BaseTheme.spacing[3]
    }
};


################################################################################

## File: .\jitsi-meet\react\features\settings\components\web\SettingsButton.ts

import { connect } from 'react-redux';

import { createToolbarEvent } from '../../../analytics/AnalyticsEvents';
import { sendAnalytics } from '../../../analytics/functions';
import { translate } from '../../../base/i18n/functions';
import { IconGear } from '../../../base/icons/svg';
import AbstractButton, { IProps as AbstractButtonProps } from '../../../base/toolbox/components/AbstractButton';
import { openSettingsDialog } from '../../actions';

/**
 * The type of the React {@code Component} props of {@link SettingsButton}.
 */
interface IProps extends AbstractButtonProps {

    /**
     * The default tab at which the settings dialog will be opened.
     */
    defaultTab: string;

    /**
     * Indicates whether the device selection dialog is displayed on the
     * welcome page or not.
     */
    isDisplayedOnWelcomePage: boolean;
}

/**
 * An abstract implementation of a button for accessing settings.
 */
class SettingsButton extends AbstractButton<IProps> {
    accessibilityLabel = 'toolbar.accessibilityLabel.Settings';
    icon = IconGear;
    label = 'toolbar.Settings';
    tooltip = 'toolbar.Settings';

    /**
     * Handles clicking / pressing the button, and opens the appropriate dialog.
     *
     * @protected
     * @returns {void}
     */
    _handleClick() {
        const { dispatch, isDisplayedOnWelcomePage = false } = this.props;

        sendAnalytics(createToolbarEvent('settings'));
        dispatch(openSettingsDialog(undefined, isDisplayedOnWelcomePage));
    }
}

export default translate(connect()(SettingsButton));


################################################################################

## File: .\jitsi-meet\react\features\share-room\actions.ts

import { IStore } from '../app/types';
import { getInviteURL } from '../base/connection/functions';

import {
    BEGIN_SHARE_ROOM,
    END_SHARE_ROOM,
    TOGGLE_SHARE_DIALOG
} from './actionTypes';

/**
 * Begins the UI procedure to share the URL for the current conference/room.
 *
 * @param {string} roomURL - The URL of the room to share.
 * @public
 * @returns {Function}
 */
export function beginShareRoom(roomURL?: string) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        if (!roomURL) {
            // eslint-disable-next-line no-param-reassign
            roomURL = getInviteURL(getState);
        }

        dispatch({
            type: BEGIN_SHARE_ROOM,
            roomURL
        });
    };
}

/**
 * Ends the UI procedure to share a specific conference/room URL.
 *
 * @param {string} roomURL - The URL of the conference/room which was shared.
 * @param {boolean} shared - True if the URL was shared successfully; false,
 * otherwise.
 * @public
 * @returns {{
 *     type: END_SHARE_ROOM,
 *     roomURL: string,
 *     shared: boolean
 * }}
 */
export function endShareRoom(roomURL: string, shared: boolean) {
    return {
        type: END_SHARE_ROOM,
        roomURL,
        shared
    };
}


/**
 * UI procedure for sharing conference room URL inside a dialog.
 *
 * @param {boolean} visible - True if share dialog is visible; false,
 * otherwise.
 * @public
 * @returns {{
 *     type: TOGGLE_SHARE_DIALOG,
 *     visible: boolean
 * }}
 */
export function toggleShareDialog(visible: boolean) {
    return {
        type: TOGGLE_SHARE_DIALOG,
        visible
    };
}


################################################################################

## File: .\jitsi-meet\react\features\share-room\actionTypes.ts

/**
 * The type of (redux) action which begins the UI procedure to share the current
 * conference/room URL.
 *
 * {
 *     type: BEGIN_SHARE_ROOM,
 *     roomURL: string,
 *     includeDialInfo: boolean
 * }
 */
export const BEGIN_SHARE_ROOM = 'BEGIN_SHARE_ROOM';

/**
 * The type of (redux) action which ends the UI procedure to share a specific
 * conference/room URL.
 *
 * {
 *     type: END_SHARE_ROOM,
 *     roomURL: string,
 *     shared: boolean
 * }
 */
export const END_SHARE_ROOM = 'END_SHARE_ROOM';

/**
 * The type of (redux) action which toggles the share meeting url dialog visibility.
 *
 * {
 *     type: TOGGLE_SHARE_DIALOG,
 *     visible: boolean
 * }
 */
export const TOGGLE_SHARE_DIALOG = 'TOGGLE_SHARE_DIALOG';


################################################################################

## File: .\jitsi-meet\react\features\share-room\functions.ts

import { IReduxState } from '../app/types';
import BaseTheme from '../base/ui/components/BaseTheme.native';

/**
 * Control for invite others button enabling.
 *
 * @param {IReduxState} state - State object.
 * @returns {Object}
 */
export function getInviteOthersControl(state: IReduxState) {
    const { shareDialogVisible } = state['features/share-room'];
    const { icon01, icon03 } = BaseTheme.palette;

    return {
        color: shareDialogVisible ? icon03 : icon01,
        shareDialogVisible
    };
}


################################################################################

## File: .\jitsi-meet\react\features\share-room\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/share-room');


################################################################################

## File: .\jitsi-meet\react\features\share-room\middleware.ts

import { Share } from 'react-native';

import { getName } from '../app/functions.native';
import { IStore } from '../app/types';
import { INVITE_DIAL_IN_ENABLED } from '../base/flags/constants';
import { getFeatureFlag } from '../base/flags/functions';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import { getShareInfoText } from '../invite/functions';

import { BEGIN_SHARE_ROOM } from './actionTypes';
import { endShareRoom, toggleShareDialog } from './actions';
import logger from './logger';

/**
 * Middleware that captures room URL sharing actions and starts the sharing
 * process.
 *
 * @param {Store} store - Redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {
    switch (action.type) {
    case BEGIN_SHARE_ROOM:
        _shareRoom(action.roomURL, store);
        break;
    }

    return next(action);
});

/**
 * Open the native sheet for sharing a specific conference/room URL.
 *
 * @param {string} roomURL - The URL of the conference/room to be shared.
 * @param {Store} store - Redux store.
 * @private
 * @returns {void}
 */
function _shareRoom(roomURL: string, { dispatch, getState }: IStore) {
    const dialInEnabled = getFeatureFlag(getState(), INVITE_DIAL_IN_ENABLED, true);

    getShareInfoText(getState(), roomURL, false /* useHtml */, !dialInEnabled /* skipDialIn */)
        .then(message => {
            const title = `${getName()} Conference`;
            const onFulfilled
                = (shared: boolean) => dispatch(endShareRoom(roomURL, shared));

            Share.share(
                /* content */ {
                    message,
                    title
                },
                /* options */ {
                    dialogTitle: title, // Android
                    subject: title // iOS
                })
                .then(
                    /* onFulfilled */ value => {
                        onFulfilled(value.action === Share.sharedAction);
                    },
                    /* onRejected */ reason => {
                        logger.error(
                            `Failed to share conference/room URL ${roomURL}:`,
                            reason);
                        onFulfilled(false);
                    })
                .finally(() => {
                    dispatch(toggleShareDialog(false));
                });
        });
}


################################################################################

## File: .\jitsi-meet\react\features\share-room\reducer.ts

import ReducerRegistry from '../base/redux/ReducerRegistry';

import { TOGGLE_SHARE_DIALOG } from './actionTypes';

const DEFAULT_STATE = {
    shareDialogVisible: false
};

export interface IShareRoomState {
    shareDialogVisible: boolean;
}

ReducerRegistry.register<IShareRoomState>('features/share-room', (state = DEFAULT_STATE, action): IShareRoomState => {
    switch (action.type) {
    case TOGGLE_SHARE_DIALOG:
        return {
            ...state,
            shareDialogVisible: action.visible
        };
    }

    return state;
});


################################################################################

## File: .\jitsi-meet\react\features\shared-video\actions.any.ts

import { IStore } from '../app/types';
import { getCurrentConference } from '../base/conference/functions';
import { hideDialog, openDialog } from '../base/dialog/actions';
import { getLocalParticipant } from '../base/participants/functions';

import {
    RESET_SHARED_VIDEO_STATUS,
    SET_ALLOWED_URL_DOMAINS,
    SET_CONFIRM_SHOW_VIDEO,
    SET_SHARED_VIDEO_STATUS
} from './actionTypes';
import { ShareVideoConfirmDialog, SharedVideoDialog } from './components';
import { PLAYBACK_START, PLAYBACK_STATUSES } from './constants';
import { isSharedVideoEnabled, sendShareVideoCommand } from './functions';


/**
 * Marks that user confirmed or not to play video.
 *
 * @param {boolean} value - The value to set.
 * @returns {{
 *     type: SET_CONFIRM_SHOW_VIDEO,
 * }}
 */
export function setConfirmShowVideo(value: boolean) {
    return {
        type: SET_CONFIRM_SHOW_VIDEO,
        value
    };
}

/**
 * Resets the status of the shared video.
 *
 * @returns {{
 *     type: SET_SHARED_VIDEO_STATUS,
 * }}
 */
export function resetSharedVideoStatus() {
    return {
        type: RESET_SHARED_VIDEO_STATUS
    };
}

/**
 * Updates the current known status of the shared video.
 *
 * @param {Object} options - The options.
 * @param {boolean} options.muted - Is video muted.
 * @param {boolean} options.ownerId - Participant ID of the owner.
 * @param {boolean} options.status - Sharing status.
 * @param {boolean} options.time - Playback timestamp.
 * @param {boolean} options.videoUrl - URL of the shared video.
 *
 * @returns {{
 *     type: SET_SHARED_VIDEO_STATUS,
 *     muted: boolean,
 *     ownerId: string,
 *     status: string,
 *     time: number,
 *     videoUrl: string,
 * }}
 */
export function setSharedVideoStatus({ videoUrl, status, time, ownerId, muted }: {
    muted?: boolean; ownerId?: string; status: string; time: number; videoUrl: string;
}) {
    return {
        type: SET_SHARED_VIDEO_STATUS,
        ownerId,
        status,
        time,
        videoUrl,
        muted
    };
}

/**
 * Displays the dialog for entering the video link.
 *
 * @param {Function} onPostSubmit - The function to be invoked when a valid link is entered.
 * @returns {Function}
 */
export function showSharedVideoDialog(onPostSubmit: Function) {
    return openDialog(SharedVideoDialog, { onPostSubmit });
}

/**
 *
 * Stops playing a shared video.
 *
 * @returns {Function}
 */
export function stopSharedVideo() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const { ownerId } = state['features/shared-video'];
        const localParticipant = getLocalParticipant(state);

        if (ownerId === localParticipant?.id) {
            dispatch(resetSharedVideoStatus());
        }
    };
}

/**
 *
 * Plays a shared video.
 *
 * @param {string} videoUrl - The video url to be played.
 *
 * @returns {Function}
 */
export function playSharedVideo(videoUrl: string) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        if (!isSharedVideoEnabled(getState())) {
            return;
        }
        const conference = getCurrentConference(getState());

        if (conference) {
            const localParticipant = getLocalParticipant(getState());

            // we will send the command and will create local video fake participant
            // and start playing once we receive ourselves the command
            sendShareVideoCommand({
                conference,
                id: videoUrl,
                localParticipantId: localParticipant?.id,
                status: PLAYBACK_START,
                time: 0
            });
        }
    };
}

/**
 *
 * Stops playing a shared video.
 *
 * @returns {Function}
 */
export function toggleSharedVideo() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const { status = '' } = state['features/shared-video'];

        if ([ PLAYBACK_STATUSES.PLAYING, PLAYBACK_START, PLAYBACK_STATUSES.PAUSED ].includes(status)) {
            dispatch(stopSharedVideo());
        } else {
            dispatch(showSharedVideoDialog((id: string) => dispatch(playSharedVideo(id))));
        }
    };
}

/**
 * Sets the allowed URL domains of the shared video.
 *
 * @param {Array<string>} allowedUrlDomains - The new whitelist to be set.
 * @returns {{
 *     type: SET_ALLOWED_URL_DOMAINS,
 *     allowedUrlDomains: Array<string>
 * }}
 */
export function setAllowedUrlDomians(allowedUrlDomains: Array<string>) {
    return {
        type: SET_ALLOWED_URL_DOMAINS,
        allowedUrlDomains
    };
}

/**
 * Shows a confirmation dialog whether to play the external video link.
 *
 * @param {string} actor - The actor's name.
 * @param {Function} onSubmit - The function to execute when confirmed.
 *
 * @returns {Function}
 */
export function showConfirmPlayingDialog(actor: String, onSubmit: Function) {
    return (dispatch: IStore['dispatch']) => {
        // shows only one dialog at a time
        dispatch(setConfirmShowVideo(false));

        dispatch(openDialog(ShareVideoConfirmDialog, {
            actorName: actor,
            onSubmit: () => {
                dispatch(setConfirmShowVideo(true));
                onSubmit();
            }
        }));
    };
}

/**
 * Hides the video play confirmation dialog.
 *
 * @returns {Function}
 */
export function hideConfirmPlayingDialog() {
    return (dispatch: IStore['dispatch']) => {
        dispatch(hideDialog(ShareVideoConfirmDialog));
    };
}


################################################################################

## File: .\jitsi-meet\react\features\shared-video\actions.native.ts

export * from './actions.any';


################################################################################

## File: .\jitsi-meet\react\features\shared-video\actions.web.ts

import { SET_DISABLE_BUTTON } from './actionTypes';

export * from './actions.any';

/**
 * Disabled share video button.
 *
 * @param {boolean} disabled - The current state of the share video button.
 * @returns {{
 *     type: SET_DISABLE_BUTTON,
 *     disabled: boolean
 * }}
 */
export function setDisableButton(disabled: boolean) {
    return {
        type: SET_DISABLE_BUTTON,
        disabled
    };
}


################################################################################

## File: .\jitsi-meet\react\features\shared-video\actionTypes.ts

/**
 * The type of the action which signals to update the current known state of the
 * shared video.
 *
 * {
 *     type: SET_SHARED_VIDEO_STATUS,
 *     status: string
 * }
 */
export const SET_SHARED_VIDEO_STATUS = 'SET_SHARED_VIDEO_STATUS';

/**
 * The type of the action which signals to reset the current known state of the
 * shared video.
 *
 * {
 *     type: RESET_SHARED_VIDEO_STATUS,
 * }
 */
export const RESET_SHARED_VIDEO_STATUS = 'RESET_SHARED_VIDEO_STATUS';

/**
 * The type of the action which marks that the user had confirmed to play video.
 *
 * {
 *     type: SET_CONFIRM_SHOW_VIDEO
 * }
 */
export const SET_CONFIRM_SHOW_VIDEO = 'SET_CONFIRM_SHOW_VIDEO';


/**
 * The type of the action which signals to disable or enable the shared video
 * button.
 *
 * {
 *     type: SET_DISABLE_BUTTON
 * }
 */
export const SET_DISABLE_BUTTON = 'SET_DISABLE_BUTTON';

/**
 * The type of the action which sets an array of whitelisted urls.
 *
 * {
 *     type: SET_ALLOWED_URL_DOMAINS
 * }
 */
export const SET_ALLOWED_URL_DOMAINS = 'SET_ALLOWED_URL_DOMAINS';


################################################################################

## File: .\jitsi-meet\react\features\shared-video\constants.ts

/**
 * Fixed name of the video player fake participant.
 *
 * @type {string}
 */
export const VIDEO_PLAYER_PARTICIPANT_NAME = 'Video';

/**
 * Fixed name of the youtube player fake participant.
 *
 * @type {string}
 */
export const YOUTUBE_PLAYER_PARTICIPANT_NAME = 'YouTube';


/**
 * Shared video command.
 *
 * @type {string}
 */
export const SHARED_VIDEO = 'shared-video';

/**
 * Available playback statuses.
 */
export const PLAYBACK_STATUSES = {
    PLAYING: 'playing',
    PAUSED: 'pause',
    STOPPED: 'stop'
};

/**
 * Playback start state.
 */
export const PLAYBACK_START = 'start';

/**
 * The domain for youtube URLs.
 */
export const YOUTUBE_URL_DOMAIN = 'youtube.com';

/**
 * The constant to allow URL domains.
 */
export const ALLOW_ALL_URL_DOMAINS = '*';

/**
 * The default white listed domains for shared video.
 */
export const DEFAULT_ALLOWED_URL_DOMAINS = [ YOUTUBE_URL_DOMAIN ];


################################################################################

## File: .\jitsi-meet\react\features\shared-video\functions.ts

import { IStateful } from '../base/app/types';
import { IJitsiConference } from '../base/conference/reducer';
import { getFakeParticipants } from '../base/participants/functions';
import { toState } from '../base/redux/functions';

import {
    ALLOW_ALL_URL_DOMAINS,
    PLAYBACK_START,
    PLAYBACK_STATUSES,
    SHARED_VIDEO,
    VIDEO_PLAYER_PARTICIPANT_NAME,
    YOUTUBE_PLAYER_PARTICIPANT_NAME,
    YOUTUBE_URL_DOMAIN
} from './constants';

/**
 * Validates the entered video url.
 *
 * It returns a boolean to reflect whether the url matches the youtube regex.
 *
 * @param {string} url - The entered video link.
 * @returns {string} The youtube video id if matched.
 */
function getYoutubeId(url: string) {
    if (!url) {
        return null;
    }

    const p = /^(?:https?:\/\/)?(?:www\.)?(?:youtu\.be\/|(?:m\.)?youtube\.com\/(?:embed\/|v\/|watch\?v=|watch\?.+&v=))((\w|-){11})(?:\S+)?$/;// eslint-disable-line max-len
    const result = url.match(p);

    return result ? result[1] : null;
}

/**
 * Checks if the status is one that is actually sharing the video - playing, pause or start.
 *
 * @param {string} status - The shared video status.
 * @returns {boolean}
 */
export function isSharingStatus(status: string) {
    return [ PLAYBACK_STATUSES.PLAYING, PLAYBACK_STATUSES.PAUSED, PLAYBACK_START ].includes(status);
}


/**
 * Returns true if there is a video being shared in the meeting.
 *
 * @param {Object | Function} stateful - The Redux state or a function that gets resolved to the Redux state.
 * @returns {boolean}
 */
export function isVideoPlaying(stateful: IStateful): boolean {
    let videoPlaying = false;

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    for (const [ id, p ] of getFakeParticipants(stateful)) {
        if (p.name === VIDEO_PLAYER_PARTICIPANT_NAME || p.name === YOUTUBE_PLAYER_PARTICIPANT_NAME) {
            videoPlaying = true;
            break;
        }
    }

    return videoPlaying;
}

/**
 * Extracts a Youtube id or URL from the user input.
 *
 * @param {string} input - The user input.
 * @returns {string|undefined}
 */
export function extractYoutubeIdOrURL(input: string) {
    if (!input) {
        return;
    }

    const trimmedLink = input.trim();

    if (!trimmedLink) {
        return;
    }

    const youtubeId = getYoutubeId(trimmedLink);

    if (youtubeId) {
        return youtubeId;
    }

    // Check if the URL is valid, native may crash otherwise.
    try {
        // eslint-disable-next-line no-new
        new URL(trimmedLink);
    } catch (_) {
        return;
    }

    return trimmedLink;
}

/**
 * Returns true if shared video functionality is enabled and false otherwise.
 *
 * @param {IStateful} stateful - - The redux store or {@code getState} function.
 * @returns {boolean}
 */
export function isSharedVideoEnabled(stateful: IStateful) {
    const state = toState(stateful);

    const { disableThirdPartyRequests = false } = state['features/base/config'];

    return !disableThirdPartyRequests;
}

/**
 * Checks if you youtube URLs should be allowed for shared videos.
 *
 * @param {Array<string>} allowedUrlDomains - The allowed URL domains for shared video.
 * @returns {boolean}
 */
export function areYoutubeURLsAllowedForSharedVideo(allowedUrlDomains?: Array<string>) {
    return Boolean(allowedUrlDomains?.includes(YOUTUBE_URL_DOMAIN));
}

/**
 * Returns true if the passed url is allowed to be used for shared video or not.
 *
 * @param {string} url - The URL.
 * @param {Array<string>} allowedUrlDomains - The allowed url domains.
 * @param {boolean} considerNonURLsAllowedForYoututbe - If true, the invalid URLs will be considered youtube IDs
 * and if youtube is allowed the function will return true.
 * @returns {boolean}
 */
export function isURLAllowedForSharedVideo(url: string,
        allowedUrlDomains: Array<string> = [], considerNonURLsAllowedForYoututbe = false) {
    if (!url) {
        return false;
    }

    try {
        const urlObject = new URL(url);

        if ([ 'http:', 'https:' ].includes(urlObject?.protocol?.toLowerCase())) {
            return allowedUrlDomains.includes(ALLOW_ALL_URL_DOMAINS) || allowedUrlDomains.includes(urlObject?.hostname);
        }
    } catch (_e) { // it should be YouTube id.
        return considerNonURLsAllowedForYoututbe && allowedUrlDomains.includes(YOUTUBE_URL_DOMAIN);
    }

    return false;
}

/**
 * Sends SHARED_VIDEO command.
 *
 * @param {string} id - The id of the video.
 * @param {string} status - The status of the shared video.
 * @param {JitsiConference} conference - The current conference.
 * @param {string} localParticipantId - The id of the local participant.
 * @param {string} time - The seek position of the video.
 * @returns {void}
 */
export function sendShareVideoCommand({ id, status, conference, localParticipantId = '', time, muted, volume }: {
    conference?: IJitsiConference; id: string; localParticipantId?: string; muted?: boolean;
    status: string; time: number; volume?: number;
}) {
    conference?.sendCommandOnce(SHARED_VIDEO, {
        value: id,
        attributes: {
            from: localParticipantId,
            muted,
            state: status,
            time,
            volume
        }
    });
}


################################################################################

## File: .\jitsi-meet\react\features\shared-video\hooks.ts

import { useSelector } from 'react-redux';

import { SharedVideoButton } from './components';
import { isSharedVideoEnabled } from './functions';

const shareVideo = {
    key: 'sharedvideo',
    Content: SharedVideoButton,
    group: 3
};

/**
 * A hook that returns the shared video button if it is enabled and undefined otherwise.
 *
 *  @returns {Object | undefined}
 */
export function useSharedVideoButton() {
    const sharedVideoEnabled = useSelector(isSharedVideoEnabled);

    if (sharedVideoEnabled) {
        return shareVideo;
    }
}



################################################################################

## File: .\jitsi-meet\react\features\shared-video\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/share-video');


################################################################################

## File: .\jitsi-meet\react\features\shared-video\middleware.any.ts

import { batch } from 'react-redux';

import { IStore } from '../app/types';
import { CONFERENCE_JOIN_IN_PROGRESS, CONFERENCE_LEFT } from '../base/conference/actionTypes';
import { getCurrentConference } from '../base/conference/functions';
import { IJitsiConference } from '../base/conference/reducer';
import { SET_CONFIG } from '../base/config/actionTypes';
import { MEDIA_TYPE } from '../base/media/constants';
import { PARTICIPANT_LEFT } from '../base/participants/actionTypes';
import { participantJoined, participantLeft, pinParticipant } from '../base/participants/actions';
import { getLocalParticipant, getParticipantById, getParticipantDisplayName } from '../base/participants/functions';
import { FakeParticipant } from '../base/participants/types';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import { SET_DYNAMIC_BRANDING_DATA } from '../dynamic-branding/actionTypes';
import { showWarningNotification } from '../notifications/actions';
import { NOTIFICATION_TIMEOUT_TYPE } from '../notifications/constants';

import { RESET_SHARED_VIDEO_STATUS, SET_SHARED_VIDEO_STATUS } from './actionTypes';
import {
    hideConfirmPlayingDialog,
    resetSharedVideoStatus,
    setAllowedUrlDomians,
    setSharedVideoStatus,
    showConfirmPlayingDialog
} from './actions.any';
import {
    DEFAULT_ALLOWED_URL_DOMAINS,
    PLAYBACK_START,
    PLAYBACK_STATUSES,
    SHARED_VIDEO,
    VIDEO_PLAYER_PARTICIPANT_NAME
} from './constants';
import { isSharedVideoEnabled, isSharingStatus, isURLAllowedForSharedVideo, sendShareVideoCommand } from './functions';
import logger from './logger';


/**
 * Middleware that captures actions related to video sharing and updates
 * components not hooked into redux.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {
    const { dispatch, getState } = store;

    if (!isSharedVideoEnabled(getState())) {
        return next(action);
    }

    switch (action.type) {
    case CONFERENCE_JOIN_IN_PROGRESS: {
        const { conference } = action;
        const localParticipantId = getLocalParticipant(getState())?.id;

        conference.addCommandListener(SHARED_VIDEO,
            ({ value, attributes }: { attributes: {
                from: string; muted: string; state: string; time: string; }; value: string; }) => {
                const state = getState();

                const { from } = attributes;
                const sharedVideoStatus = attributes.state;

                if (isSharingStatus(sharedVideoStatus)) {
                    // confirmShowVideo is undefined the first time we receive
                    // when confirmShowVideo is false we ignore everything except stop that resets it
                    if (getState()['features/shared-video'].confirmShowVideo === false) {
                        return;
                    }

                    if (isURLAllowedForSharedVideo(value, getState()['features/shared-video'].allowedUrlDomains, true)
                        || localParticipantId === from
                        || getState()['features/shared-video'].confirmShowVideo) { // if confirmed skip asking again
                        handleSharingVideoStatus(store, value, attributes, conference);
                    } else {
                        dispatch(showConfirmPlayingDialog(getParticipantDisplayName(getState(), from), () => {

                            handleSharingVideoStatus(store, value, attributes, conference);

                            return true; // on mobile this is used to close the dialog
                        }));
                    }

                    return;
                }

                if (sharedVideoStatus === 'stop') {
                    const videoParticipant = getParticipantById(state, value);

                    if (getState()['features/shared-video'].confirmShowVideo === false) {
                        dispatch(showWarningNotification({
                            titleKey: 'dialog.shareVideoLinkStopped',
                            titleArguments: {
                                name: getParticipantDisplayName(getState(), from)
                            }
                        }, NOTIFICATION_TIMEOUT_TYPE.LONG));
                    }

                    dispatch(hideConfirmPlayingDialog());

                    dispatch(participantLeft(value, conference, {
                        fakeParticipant: videoParticipant?.fakeParticipant
                    }));

                    if (localParticipantId !== from) {
                        dispatch(resetSharedVideoStatus());
                    }
                }
            }
        );
        break;
    }
    case CONFERENCE_LEFT:
        dispatch(setAllowedUrlDomians(DEFAULT_ALLOWED_URL_DOMAINS));
        dispatch(resetSharedVideoStatus());
        break;
    case PARTICIPANT_LEFT: {
        const state = getState();
        const conference = getCurrentConference(state);
        const { ownerId: stateOwnerId, videoUrl: statevideoUrl } = state['features/shared-video'];

        if (action.participant.id === stateOwnerId) {
            batch(() => {
                dispatch(resetSharedVideoStatus());
                dispatch(participantLeft(statevideoUrl ?? '', conference));
            });
        }
        break;
    }
    case SET_CONFIG:
    case SET_DYNAMIC_BRANDING_DATA: {
        const result = next(action);
        const state = getState();
        const { sharedVideoAllowedURLDomains: allowedURLDomainsFromConfig = [] } = state['features/base/config'];
        const { sharedVideoAllowedURLDomains: allowedURLDomainsFromBranding = [] } = state['features/dynamic-branding'];

        dispatch(setAllowedUrlDomians([
            ...DEFAULT_ALLOWED_URL_DOMAINS,
            ...allowedURLDomainsFromBranding,
            ...allowedURLDomainsFromConfig
        ]));

        return result;
    }
    case SET_SHARED_VIDEO_STATUS: {
        const state = getState();
        const conference = getCurrentConference(state);
        const localParticipantId = getLocalParticipant(state)?.id;
        const { videoUrl, status, ownerId, time, muted, volume } = action;
        const operator = status === PLAYBACK_STATUSES.PLAYING ? 'is' : '';

        logger.debug(`User with id: ${ownerId} ${operator} ${status} video sharing.`);

        if (typeof APP !== 'undefined') {
            APP.API.notifyAudioOrVideoSharingToggled(MEDIA_TYPE.VIDEO, status, ownerId);
        }

        // when setting status we need to send the command for that, but not do it for the start command
        // as we are sending the command in playSharedVideo and setting the start status once
        // we receive the response, this way we will start the video at the same time when remote participants
        // start it, on receiving the command
        if (status === 'start') {
            break;
        }

        if (localParticipantId === ownerId) {
            sendShareVideoCommand({
                conference,
                localParticipantId,
                muted,
                status,
                time,
                id: videoUrl,
                volume
            });
        }
        break;
    }
    case RESET_SHARED_VIDEO_STATUS: {
        const state = getState();
        const localParticipantId = getLocalParticipant(state)?.id;
        const { ownerId: stateOwnerId, videoUrl: statevideoUrl } = state['features/shared-video'];

        if (!stateOwnerId) {
            break;
        }

        logger.debug(`User with id: ${stateOwnerId} stop video sharing.`);

        if (typeof APP !== 'undefined') {
            APP.API.notifyAudioOrVideoSharingToggled(MEDIA_TYPE.VIDEO, 'stop', stateOwnerId);
        }

        if (localParticipantId === stateOwnerId) {
            const conference = getCurrentConference(state);

            sendShareVideoCommand({
                conference,
                id: statevideoUrl ?? '',
                localParticipantId,
                muted: true,
                status: 'stop',
                time: 0,
                volume: 0
            });
        }
        break;
    }
    }

    return next(action);
});

/**
 * Handles the playing, pause and start statuses for the shared video.
 * Dispatches participantJoined event and, if necessary, pins it.
 * Sets the SharedVideoStatus if the event was triggered by the local user.
 *
 * @param {Store} store - The redux store.
 * @param {string} videoUrl - The id of the video to the shared.
 * @param {Object} attributes - The attributes received from the share video command.
 * @param {JitsiConference} conference - The current conference.
 * @returns {void}
 */
function handleSharingVideoStatus(store: IStore, videoUrl: string,
        { state, time, from, muted }: { from: string; muted: string; state: string; time: string; },
        conference: IJitsiConference) {
    const { dispatch, getState } = store;
    const localParticipantId = getLocalParticipant(getState())?.id;
    const oldStatus = getState()['features/shared-video']?.status ?? '';
    const oldVideoUrl = getState()['features/shared-video'].videoUrl;

    if (oldVideoUrl && oldVideoUrl !== videoUrl) {
        logger.warn(
            `User with id: ${from} sent videoUrl: ${videoUrl} while we are playing: ${oldVideoUrl}`);

        return;
    }

    // If the video was not started (no participant) we want to create the participant
    // this can be triggered by start, but also by paused or playing
    // commands (joining late) and getting the current state
    if (state === PLAYBACK_START || !isSharingStatus(oldStatus)) {
        const youtubeId = videoUrl.match(/http/) ? false : videoUrl;
        const avatarURL = youtubeId ? `https://img.youtube.com/vi/${youtubeId}/0.jpg` : '';

        dispatch(participantJoined({
            conference,
            fakeParticipant: FakeParticipant.SharedVideo,
            id: videoUrl,
            avatarURL,
            name: VIDEO_PLAYER_PARTICIPANT_NAME
        }));

        dispatch(pinParticipant(videoUrl));

        if (localParticipantId === from) {
            dispatch(setSharedVideoStatus({
                videoUrl,
                status: state,
                time: Number(time),
                ownerId: localParticipantId
            }));
        }
    }

    if (localParticipantId !== from) {
        dispatch(setSharedVideoStatus({
            muted: muted === 'true',
            ownerId: from,
            status: state,
            time: Number(time),
            videoUrl
        }));
    }
}


################################################################################

## File: .\jitsi-meet\react\features\shared-video\middleware.native.ts

import './middleware.any';


################################################################################

## File: .\jitsi-meet\react\features\shared-video\middleware.web.ts

import { CONFERENCE_JOIN_IN_PROGRESS } from '../base/conference/actionTypes';
import { getLocalParticipant } from '../base/participants/functions';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';

import { setDisableButton } from './actions.web';
import { PLAYBACK_STATUSES, SHARED_VIDEO } from './constants';
import { isSharedVideoEnabled } from './functions';

import './middleware.any';

MiddlewareRegistry.register(({ dispatch, getState }) => next => action => {
    const state = getState();
    const localParticipantId = getLocalParticipant(state)?.id;

    switch (action.type) {
    case CONFERENCE_JOIN_IN_PROGRESS: {
        if (!isSharedVideoEnabled(state)) {
            break;
        }

        const { conference } = action;

        conference.addCommandListener(SHARED_VIDEO, ({ attributes }: { attributes:
            { from: string; state: string; }; }) => {
            const { from } = attributes;
            const status = attributes.state;

            if (status === PLAYBACK_STATUSES.PLAYING) {
                if (localParticipantId !== from) {
                    dispatch(setDisableButton(true));
                }
            } else if (status === 'stop') {
                dispatch(setDisableButton(false));
            }
        });
        break;
    }
    }

    return next(action);
});


################################################################################

## File: .\jitsi-meet\react\features\shared-video\reducer.ts

import ReducerRegistry from '../base/redux/ReducerRegistry';

import {
    RESET_SHARED_VIDEO_STATUS,
    SET_ALLOWED_URL_DOMAINS,
    SET_CONFIRM_SHOW_VIDEO,
    SET_DISABLE_BUTTON,
    SET_SHARED_VIDEO_STATUS
} from './actionTypes';
import { DEFAULT_ALLOWED_URL_DOMAINS } from './constants';

const initialState = {
    allowedUrlDomains: DEFAULT_ALLOWED_URL_DOMAINS
};

export interface ISharedVideoState {
    allowedUrlDomains: Array<string>;
    confirmShowVideo?: boolean;
    disabled?: boolean;
    muted?: boolean;
    ownerId?: string;
    status?: string;
    time?: number;
    videoUrl?: string;
    volume?: number;
}

/**
 * Reduces the Redux actions of the feature features/shared-video.
 */
ReducerRegistry.register<ISharedVideoState>('features/shared-video',
(state = initialState, action): ISharedVideoState => {
    const { videoUrl, status, time, ownerId, disabled, muted, volume } = action;

    switch (action.type) {
    case RESET_SHARED_VIDEO_STATUS:
        return {
            ...initialState,
            allowedUrlDomains: state.allowedUrlDomains
        };
    case SET_CONFIRM_SHOW_VIDEO: {
        return {
            ...state,
            confirmShowVideo: action.value
        };
    }
    case SET_SHARED_VIDEO_STATUS:
        return {
            ...state,
            muted,
            ownerId,
            status,
            time,
            videoUrl,
            volume
        };

    case SET_DISABLE_BUTTON:
        return {
            ...state,
            disabled
        };

    case SET_ALLOWED_URL_DOMAINS: {
        return {
            ...state,
            allowedUrlDomains: action.allowedUrlDomains
        };
    }

    default:
        return state;
    }
});


################################################################################

## File: .\jitsi-meet\react\features\shared-video\components\index.native.ts

// @ts-ignore
export { default as SharedVideoDialog } from './native/SharedVideoDialog';
export { default as SharedVideoButton } from './native/SharedVideoButton';
export { default as ShareVideoConfirmDialog } from './native/ShareVideoConfirmDialog';


################################################################################

## File: .\jitsi-meet\react\features\shared-video\components\index.web.ts

export { default as SharedVideoDialog } from './web/SharedVideoDialog';
export { default as SharedVideoButton } from './web/SharedVideoButton';
export { default as ShareVideoConfirmDialog } from './web/ShareVideoConfirmDialog';


################################################################################

## File: .\jitsi-meet\react\features\shared-video\components\native\AbstractVideoManager.ts

import { throttle } from 'lodash-es';
import { PureComponent } from 'react';

import { IReduxState, IStore } from '../../../app/types';
import { getCurrentConference } from '../../../base/conference/functions';
import { IJitsiConference } from '../../../base/conference/reducer';
import { getLocalParticipant } from '../../../base/participants/functions';
import { setSharedVideoStatus } from '../../actions.any';
import { PLAYBACK_STATUSES } from '../../constants';

/**
 * Return true if the difference between the two times is larger than 5.
 *
 * @param {number} newTime - The current time.
 * @param {number} previousTime - The previous time.
 * @private
 * @returns {boolean}
*/
function shouldSeekToPosition(newTime: number, previousTime: number) {
    return Math.abs(newTime - previousTime) > 5;
}

/**
 * The type of the React {@link Component} props of {@link AbstractVideoManager}.
 */
export interface IProps {

    /**
     * The current conference.
     */
    _conference?: IJitsiConference;

    /**
     * Is the video shared by the local user.
     *
     * @private
     */
    _isOwner: boolean;

    /**
     * The shared video owner id.
     */
    _ownerId?: string;

    /**
     * The shared video status.
     */
    _status?: string;

    /**
     * Seek time in seconds.
     *
     */
    _time: number;

    /**
     * The video url.
     */
    _videoUrl?: string;

    /**
     * The Redux dispatch function.
     */
    dispatch: IStore['dispatch'];

    /**
      * The player's height.
    */
    height: number;

    /**
      * The video id.
    */
    videoId: string;

    /**
      * The player's width.
    */
    width: number;
}

/**
 * Manager of shared video.
 */
abstract class AbstractVideoManager<S=void> extends PureComponent<IProps, S> {
    throttledFireUpdateSharedVideoEvent: Function;

    /**
     * Initializes a new instance of AbstractVideoManager.
     *
     * @param {IProps} props - Component props.
     * @returns {void}
     */
    constructor(props: IProps) {
        super(props);

        this.throttledFireUpdateSharedVideoEvent = throttle(this.fireUpdateSharedVideoEvent.bind(this), 5000);
    }

    /**
     * Implements React Component's componentDidMount.
     *
     * @inheritdoc
     */
    componentDidMount() {
        this.processUpdatedProps();
    }

    /**
     * Implements React Component's componentDidUpdate.
     *
     * @inheritdoc
     */
    componentDidUpdate() {
        this.processUpdatedProps();
    }

    /**
     * Implements React Component's componentWillUnmount.
     *
     * @inheritdoc
     */
    componentWillUnmount() {
        if (this.dispose) {
            this.dispose();
        }
    }

    /**
     * Processes new properties.
     *
     * @returns {void}
     */
    async processUpdatedProps() {
        const { _status, _time, _isOwner } = this.props;

        if (_isOwner) {
            return;
        }

        const playerTime = await this.getTime();

        if (shouldSeekToPosition(_time, playerTime)) {
            this.seek(_time);
        }

        if (this.getPlaybackStatus() !== _status) {
            if (_status === PLAYBACK_STATUSES.PLAYING) {
                this.play();
            } else if (_status === PLAYBACK_STATUSES.PAUSED) {
                this.pause();
            }
        }
    }

    /**
     * Handle video playing.
     *
     * @returns {void}
     */
    onPlay() {
        this.fireUpdateSharedVideoEvent();
    }

    /**
     * Handle video paused.
     *
     * @returns {void}
     */
    onPause() {
        this.fireUpdateSharedVideoEvent();
    }

    /**
     * Dispatches an update action for the shared video.
     *
     * @returns {void}
     */
    async fireUpdateSharedVideoEvent() {
        const { _isOwner } = this.props;

        if (!_isOwner) {
            return;
        }

        const status = this.getPlaybackStatus();

        if (!Object.values(PLAYBACK_STATUSES).includes(status)) {
            return;
        }

        const time = await this.getTime();

        const {
            _ownerId,
            _videoUrl,
            dispatch
        } = this.props;

        dispatch(setSharedVideoStatus({
            videoUrl: _videoUrl ?? '',
            status,
            time,
            ownerId: _ownerId
        }));
    }

    /**
     * Seeks video to provided time.
     */
    abstract seek(time: number): void;

    /**
     * Indicates the playback state of the video.
     */
    abstract getPlaybackStatus(): string;

    /**
     * Plays video.
     */
    abstract play(): void;

    /**
     * Pauses video.
     *
     * @returns {void}
     */
    abstract pause(): void;

    /**
     * Retrieves current time.
     */
    abstract getTime(): number;

    /**
     * Disposes current video player.
     *
     * @returns {void}
     */
    dispose() {
        // optional abstract method to be implemented by sub-class
    }
}


export default AbstractVideoManager;

/**
 * Maps part of the Redux store to the props of this component.
 *
 * @param {Object} state - The Redux state.
 * @returns {IProps}
 */
export function _mapStateToProps(state: IReduxState) {
    const { ownerId, status, time, videoUrl } = state['features/shared-video'];
    const localParticipant = getLocalParticipant(state);

    return {
        _conference: getCurrentConference(state),
        _isOwner: ownerId === localParticipant?.id,
        _ownerId: ownerId,
        _status: status,
        _time: Number(time),
        _videoUrl: videoUrl
    };
}


################################################################################

## File: .\jitsi-meet\react\features\shared-video\components\native\SharedVideoButton.ts

import { connect } from 'react-redux';

import { IReduxState } from '../../../app/types';
import { VIDEO_SHARE_BUTTON_ENABLED } from '../../../base/flags/constants';
import { getFeatureFlag } from '../../../base/flags/functions';
import { translate } from '../../../base/i18n/functions';
import { IconPlay } from '../../../base/icons/svg';
import { getLocalParticipant } from '../../../base/participants/functions';
import AbstractButton, { IProps as AbstractButtonProps } from '../../../base/toolbox/components/AbstractButton';
import { toggleSharedVideo } from '../../actions.native';
import { isSharingStatus } from '../../functions';

/**
 * The type of the React {@code Component} props of {@link TileViewButton}.
 */
interface IProps extends AbstractButtonProps {

    /**
     * Whether or not the button is disabled.
     */
    _isDisabled: boolean;

    /**
     * Whether or not the local participant is sharing a video.
     */
    _sharingVideo: boolean;
}

/**
 * Component that renders a toolbar button for toggling the tile layout view.
 *
 * @augments AbstractButton
 */
class VideoShareButton extends AbstractButton<IProps> {
    accessibilityLabel = 'toolbar.accessibilityLabel.sharedvideo';
    icon = IconPlay;
    label = 'toolbar.sharedvideo';
    toggledLabel = 'toolbar.stopSharedVideo';

    /**
     * Handles clicking / pressing the button.
     *
     * @override
     * @protected
     * @returns {void}
     */
    _handleClick() {
        this._doToggleSharedVideo();
    }

    /**
     * Indicates whether this button is in toggled state or not.
     *
     * @override
     * @protected
     * @returns {boolean}
     */
    _isToggled() {
        return this.props._sharingVideo;
    }

    /**
     * Indicates whether this button is disabled or not.
     *
     * @override
     * @protected
     * @returns {boolean}
     */
    _isDisabled() {
        return this.props._isDisabled;
    }

    /**
     * Dispatches an action to toggle video sharing.
     *
     * @private
     * @returns {void}
     */
    _doToggleSharedVideo() {
        this.props.dispatch(toggleSharedVideo());
    }
}

/**
 * Maps part of the Redux state to the props of this component.
 *
 * @param {Object} state - The Redux state.
 * @param {Object} ownProps - The properties explicitly passed to the component instance.
 * @private
 * @returns {IProps}
 */
function _mapStateToProps(state: IReduxState, ownProps: any) {
    const { ownerId, status: sharedVideoStatus } = state['features/shared-video'];
    const localParticipantId = getLocalParticipant(state)?.id;
    const enabled = getFeatureFlag(state, VIDEO_SHARE_BUTTON_ENABLED, true);
    const { visible = enabled } = ownProps;

    if (ownerId !== localParticipantId) {
        return {
            _isDisabled: isSharingStatus(sharedVideoStatus ?? ''),
            _sharingVideo: false,
            visible
        };
    }

    return {
        _isDisabled: false,
        _sharingVideo: isSharingStatus(sharedVideoStatus ?? ''),
        visible
    };
}

export default translate(connect(_mapStateToProps)(VideoShareButton));


################################################################################

## File: .\jitsi-meet\react\features\shared-video\components\native\styles.ts

/**
 * The style of toolbar buttons.
 */
export default {
    videoContainer: {
        alignItems: 'center',
        flex: 1,
        flexDirection: 'column',
        justifyContent: 'center'
    }
};


################################################################################

## File: .\jitsi-meet\react\features\shared-video\components\web\AbstractVideoManager.ts

// @ts-expect-error
import Logger from '@jitsi/logger';
import { throttle } from 'lodash-es';
import { PureComponent } from 'react';

import { createSharedVideoEvent as createEvent } from '../../../analytics/AnalyticsEvents';
import { sendAnalytics } from '../../../analytics/functions';
import { IReduxState, IStore } from '../../../app/types';
import { getCurrentConference } from '../../../base/conference/functions';
import { IJitsiConference } from '../../../base/conference/reducer';
import { MEDIA_TYPE } from '../../../base/media/constants';
import { getLocalParticipant } from '../../../base/participants/functions';
import { isLocalTrackMuted } from '../../../base/tracks/functions';
import { showWarningNotification } from '../../../notifications/actions';
import { NOTIFICATION_TIMEOUT_TYPE } from '../../../notifications/constants';
import { dockToolbox } from '../../../toolbox/actions';
import { muteLocal } from '../../../video-menu/actions.any';
import { setSharedVideoStatus, stopSharedVideo } from '../../actions.any';
import { PLAYBACK_STATUSES } from '../../constants';

const logger = Logger.getLogger(__filename);

/**
 * Return true if the difference between the two times is larger than 5.
 *
 * @param {number} newTime - The current time.
 * @param {number} previousTime - The previous time.
 * @private
 * @returns {boolean}
*/
function shouldSeekToPosition(newTime: number, previousTime: number) {
    return Math.abs(newTime - previousTime) > 5;
}

/**
 * The type of the React {@link PureComponent} props of {@link AbstractVideoManager}.
 */
export interface IProps {

    /**
     * The current conference.
     */
    _conference?: IJitsiConference;

    /**
     * Warning that indicates an incorrect video url.
     */
    _displayWarning: Function;

    /**
     * Docks the toolbox.
     */
    _dockToolbox: Function;

    /**
     * Indicates whether the local audio is muted.
    */
    _isLocalAudioMuted: boolean;

    /**
     * Is the video shared by the local user.
     *
     * @private
     */
    _isOwner: boolean;

    /**
     * Mutes local audio track.
     */
    _muteLocal: Function;

    /**
     * Store flag for muted state.
     */
    _muted?: boolean;

    /**
     * The shared video owner id.
     */
    _ownerId?: string;

    /**
     * Updates the shared video status.
     */
    _setSharedVideoStatus: Function;

    /**
     * The shared video status.
     */
    _status?: string;

    /**
     * Action to stop video sharing.
    */
    _stopSharedVideo: Function;

    /**
     * Seek time in seconds.
     *
     */
    _time?: number;

    /**
     * The video url.
     */
    _videoUrl?: string;

    /**
      * The video id.
      */
    videoId: string;
}

/**
 * Manager of shared video.
 */
class AbstractVideoManager extends PureComponent<IProps> {
    throttledFireUpdateSharedVideoEvent: Function;

    /**
     * Initializes a new instance of AbstractVideoManager.
     *
     * @param {IProps} props - Component props.
     * @returns {void}
     */
    constructor(props: IProps) {
        super(props);

        this.throttledFireUpdateSharedVideoEvent = throttle(this.fireUpdateSharedVideoEvent.bind(this), 5000);

        // selenium tests handler
        window._sharedVideoPlayer = this;
    }

    /**
     * Implements React Component's componentDidMount.
     *
     * @inheritdoc
     */
    componentDidMount() {
        this.props._dockToolbox(true);
        this.processUpdatedProps();
    }

    /**
     * Implements React Component's componentDidUpdate.
     *
     * @inheritdoc
     */
    componentDidUpdate(prevProps: IProps) {
        const { _videoUrl } = this.props;

        if (prevProps._videoUrl !== _videoUrl) {
            sendAnalytics(createEvent('started'));
        }

        this.processUpdatedProps();
    }

    /**
     * Implements React Component's componentWillUnmount.
     *
     * @inheritdoc
     */
    componentWillUnmount() {
        sendAnalytics(createEvent('stopped'));

        if (this.dispose) {
            this.dispose();
        }

        this.props._dockToolbox(false);
    }

    /**
     * Processes new properties.
     *
     * @returns {void}
     */
    processUpdatedProps() {
        const { _status, _time, _isOwner, _muted } = this.props;

        if (_isOwner) {
            return;
        }

        const playerTime = this.getTime();

        if (shouldSeekToPosition(Number(_time), Number(playerTime))) {
            this.seek(Number(_time));
        }

        if (this.getPlaybackStatus() !== _status) {
            if (_status === PLAYBACK_STATUSES.PLAYING) {
                this.play();
            }

            if (_status === PLAYBACK_STATUSES.PAUSED) {
                this.pause();
            }
        }

        if (this.isMuted() !== _muted) {
            if (_muted) {
                this.mute();
            } else {
                this.unMute();
            }
        }
    }

    /**
     * Handle video error.
     *
     * @param {Object|undefined} e - The error returned by the API or none.
     * @returns {void}
     */
    onError(e?: any) {
        logger.error('Error in the video player', e?.data,
            e?.data ? 'Check error code at https://developers.google.com/youtube/iframe_api_reference#onError' : '');
        this.props._stopSharedVideo();
        this.props._displayWarning();
    }

    /**
     * Handle video playing.
     *
     * @returns {void}
     */
    onPlay() {
        this.smartAudioMute();
        sendAnalytics(createEvent('play'));
        this.fireUpdateSharedVideoEvent();
    }

    /**
     * Handle video paused.
     *
     * @returns {void}
     */
    onPause() {
        sendAnalytics(createEvent('paused'));
        this.fireUpdateSharedVideoEvent();
    }

    /**
     * Handle volume changed.
     *
     * @returns {void}
     */
    onVolumeChange() {
        const volume = this.getVolume();
        const muted = this.isMuted();

        if (Number(volume) > 0 && !muted) {
            this.smartAudioMute();
        }

        sendAnalytics(createEvent(
            'volume.changed',
            {
                volume,
                muted
            }));

        this.fireUpdatePlayingVideoEvent();
    }

    /**
     * Handle changes to the shared playing video.
     *
     * @returns {void}
     */
    fireUpdatePlayingVideoEvent() {
        if (this.getPlaybackStatus() === PLAYBACK_STATUSES.PLAYING) {
            this.fireUpdateSharedVideoEvent();
        }
    }

    /**
     * Dispatches an update action for the shared video.
     *
     * @returns {void}
     */
    fireUpdateSharedVideoEvent() {
        const { _isOwner } = this.props;

        if (!_isOwner) {
            return;
        }

        const status = this.getPlaybackStatus();

        if (!Object.values(PLAYBACK_STATUSES).includes(status ?? '')) {
            return;
        }

        const {
            _ownerId,
            _setSharedVideoStatus,
            _videoUrl
        } = this.props;

        _setSharedVideoStatus({
            videoUrl: _videoUrl,
            status,
            time: this.getTime(),
            ownerId: _ownerId,
            muted: this.isMuted()
        });
    }

    /**
     * Indicates if the player volume is currently on. This will return true if
     * we have an available player, which is currently in a PLAYING state,
     * which isn't muted and has it's volume greater than 0.
     *
     * @returns {boolean} Indicating if the volume of the shared video is
     * currently on.
     */
    isSharedVideoVolumeOn() {
        return this.getPlaybackStatus() === PLAYBACK_STATUSES.PLAYING
                && !this.isMuted()
                && Number(this.getVolume()) > 0;
    }

    /**
     * Smart mike mute. If the mike isn't currently muted and the shared video
     * volume is on we mute the mike.
     *
     * @returns {void}
     */
    smartAudioMute() {
        const { _isLocalAudioMuted, _muteLocal } = this.props;

        if (!_isLocalAudioMuted
            && this.isSharedVideoVolumeOn()) {
            sendAnalytics(createEvent('audio.muted'));
            _muteLocal(true);
        }
    }

    /**
     * Seeks video to provided time.
     *
     * @param {number} _time - Time to seek to.
     * @returns {void}
     */
    seek(_time: number) {
        // to be implemented by subclass
    }

    /**
     * Indicates the playback state of the video.
     *
     * @returns {string}
     */
    getPlaybackStatus(): string | undefined {
        return;
    }

    /**
     * Indicates whether the video is muted.
     *
     * @returns {boolean}
     */
    isMuted(): boolean | undefined {
        return;
    }

    /**
     * Retrieves current volume.
     *
     * @returns {number}
     */
    getVolume() {
        return 1;
    }

    /**
     * Plays video.
     *
     * @returns {void}
     */
    play() {
        // to be implemented by subclass
    }

    /**
     * Pauses video.
     *
     * @returns {void}
     */
    pause() {
        // to be implemented by subclass
    }

    /**
     * Mutes video.
     *
     * @returns {void}
     */
    mute() {
        // to be implemented by subclass
    }

    /**
     * Unmutes video.
     *
     * @returns {void}
     */
    unMute() {
        // to be implemented by subclass
    }

    /**
     * Retrieves current time.
     *
     * @returns {number}
     */
    getTime() {
        return 0;
    }

    /**
     * Disposes current video player.
     *
     * @returns {void}
     */
    dispose() {
        // to be implemented by subclass
    }
}


export default AbstractVideoManager;

/**
 * Maps part of the Redux store to the props of this component.
 *
 * @param {Object} state - The Redux state.
 * @returns {IProps}
 */
export function _mapStateToProps(state: IReduxState) {
    const { ownerId, status, time, videoUrl, muted } = state['features/shared-video'];
    const localParticipant = getLocalParticipant(state);
    const _isLocalAudioMuted = isLocalTrackMuted(state['features/base/tracks'], MEDIA_TYPE.AUDIO);

    return {
        _conference: getCurrentConference(state),
        _isLocalAudioMuted,
        _isOwner: ownerId === localParticipant?.id,
        _muted: muted,
        _ownerId: ownerId,
        _status: status,
        _time: time,
        _videoUrl: videoUrl
    };
}

/**
 * Maps part of the props of this component to Redux actions.
 *
 * @param {Function} dispatch - The Redux dispatch function.
 * @returns {IProps}
 */
export function _mapDispatchToProps(dispatch: IStore['dispatch']) {
    return {
        _displayWarning: () => {
            dispatch(showWarningNotification({
                titleKey: 'dialog.shareVideoLinkError'
            }, NOTIFICATION_TIMEOUT_TYPE.LONG));
        },
        _dockToolbox: (value: boolean) => {
            dispatch(dockToolbox(value));
        },
        _stopSharedVideo: () => {
            dispatch(stopSharedVideo());
        },
        _muteLocal: (value: boolean) => {
            dispatch(muteLocal(value, MEDIA_TYPE.AUDIO));
        },
        _setSharedVideoStatus: ({ videoUrl, status, time, ownerId, muted }: any) => {
            dispatch(setSharedVideoStatus({
                videoUrl,
                status,
                time,
                ownerId,
                muted
            }));
        }
    };
}


################################################################################

## File: .\jitsi-meet\react\features\shared-video\components\web\SharedVideoButton.ts

import { connect } from 'react-redux';

import { IReduxState } from '../../../app/types';
import { translate } from '../../../base/i18n/functions';
import { IconPlay } from '../../../base/icons/svg';
import AbstractButton, { IProps as AbstractButtonProps } from '../../../base/toolbox/components/AbstractButton';
import { toggleSharedVideo } from '../../actions.any';
import { isSharingStatus } from '../../functions';

interface IProps extends AbstractButtonProps {

    /**
     * Whether or not the button is disabled.
     */
    _isDisabled: boolean;

    /**
     * Whether or not the local participant is sharing a video.
     */
    _sharingVideo: boolean;
}

/**
 * Implements an {@link AbstractButton} to open the user documentation in a new window.
 */
class SharedVideoButton extends AbstractButton<IProps> {
    accessibilityLabel = 'toolbar.accessibilityLabel.sharedvideo';
    toggledAccessibilityLabel = 'toolbar.accessibilityLabel.stopSharedVideo';
    icon = IconPlay;
    label = 'toolbar.sharedvideo';
    toggledLabel = 'toolbar.stopSharedVideo';
    tooltip = 'toolbar.sharedvideo';
    toggledTooltip = 'toolbar.stopSharedVideo';

    /**
     * Handles clicking / pressing the button, and opens a new dialog.
     *
     * @private
     * @returns {void}
     */
    _handleClick() {
        this._doToggleSharedVideo();
    }

    /**
     * Indicates whether this button is in toggled state or not.
     *
     * @override
     * @protected
     * @returns {boolean}
     */
    _isToggled() {
        return this.props._sharingVideo;
    }

    /**
     * Indicates whether this button is disabled or not.
     *
     * @override
     * @protected
     * @returns {boolean}
     */
    _isDisabled() {
        return this.props._isDisabled;
    }

    /**
     * Dispatches an action to toggle video sharing.
     *
     * @private
     * @returns {void}
     */
    _doToggleSharedVideo() {
        this.props.dispatch(toggleSharedVideo());
    }
}

/**
 * Maps part of the Redux state to the props of this component.
 *
 * @param {Object} state - The Redux state.
 * @private
 * @returns {IProps}
 */
function _mapStateToProps(state: IReduxState) {
    const {
        disabled: sharedVideoBtnDisabled,
        status: sharedVideoStatus
    } = state['features/shared-video'];

    return {
        _isDisabled: Boolean(sharedVideoBtnDisabled),
        _sharingVideo: isSharingStatus(sharedVideoStatus ?? '')
    };
}


export default translate(connect(_mapStateToProps)(SharedVideoButton));


################################################################################

## File: .\jitsi-meet\react\features\speaker-stats\actions.any.ts

import { IStore } from '../app/types';

import {
    ADD_TO_OFFSET,
    ADD_TO_OFFSET_LEFT,
    ADD_TO_OFFSET_RIGHT,
    INIT_REORDER_STATS,
    INIT_SEARCH,
    INIT_UPDATE_STATS,
    RESET_SEARCH_CRITERIA,
    SET_PANNING,
    SET_TIMELINE_BOUNDARY,
    TOGGLE_FACE_EXPRESSIONS,
    UPDATE_SORTED_SPEAKER_STATS_IDS,
    UPDATE_STATS
} from './actionTypes';
import { MINIMUM_INTERVAL } from './constants';
import { getCurrentDuration, getTimelineBoundaries } from './functions';
import { ISpeakerStats } from './reducer';

/**
 * Starts a search by criteria.
 *
 * @param {string} criteria - The search criteria.
 * @returns {Object}
 */
export function initSearch(criteria: string) {
    return {
        type: INIT_SEARCH,
        criteria
    };
}

/**
 * Gets the new stats and triggers update.
 *
 * @param {Function} getSpeakerStats - Function to get the speaker stats.
 * @returns {Object}
 */
export function initUpdateStats(getSpeakerStats: () => ISpeakerStats) {
    return {
        type: INIT_UPDATE_STATS,
        getSpeakerStats
    };
}

/**
 * Updates the stats with new stats.
 *
 * @param {Object} stats - The new stats.
 * @returns {Object}
 */
export function updateStats(stats: Object) {
    return {
        type: UPDATE_STATS,
        stats
    };
}

/**
 * Updates the speaker stats order.
 *
 * @param {Array<string>} participantIds - Participant ids.
 * @returns {Object}
 */
export function updateSortedSpeakerStatsIds(participantIds: Array<string>) {
    return {
        type: UPDATE_SORTED_SPEAKER_STATS_IDS,
        participantIds
    };
}

/**
 * Initiates reordering of the stats.
 *
 * @returns {Object}
 */
export function initReorderStats() {
    return {
        type: INIT_REORDER_STATS
    };
}

/**
 * Resets the search criteria.
 *
 * @returns {Object}
 */
export function resetSearchCriteria() {
    return {
        type: RESET_SEARCH_CRITERIA
    };
}

/**
 * Toggles the face expressions grid.
 *
 * @returns {Object}
 */
export function toggleFaceExpressions() {
    return {
        type: TOGGLE_FACE_EXPRESSIONS
    };
}

/**
 * Adds a value to the boundary offset of the timeline.
 *
 * @param {number} value - The value to be added.
 * @param {number} left - The left boundary.
 * @param {number} right - The right boundary.
 * @param {number} currentDuration - The currentDuration of the conference.
 * @returns {Object}
 */
export function addToOffset(value: number) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const { left, right } = getTimelineBoundaries(state);
        const currentDuration = getCurrentDuration(state) ?? 0;
        const newLeft = left + value;
        const newRight = right + value;

        if (newLeft >= 0 && newRight <= currentDuration) {
            dispatch({
                type: ADD_TO_OFFSET,
                value
            });
        } else if (newLeft < 0) {
            dispatch({
                type: ADD_TO_OFFSET,
                value: -left
            });
        } else if (newRight > currentDuration) {
            dispatch({
                type: ADD_TO_OFFSET,
                value: currentDuration - right
            });
        }
    };
}

/**
 * Adds the value to the offset of the left boundary for the timeline.
 *
 * @param {number} value - The new value for the offset.
 * @returns {Object}
 */
export function addToOffsetLeft(value: number) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const { left, right } = getTimelineBoundaries(state);
        const newLeft = left + value;

        if (newLeft >= 0 && right - newLeft > MINIMUM_INTERVAL) {
            dispatch({
                type: ADD_TO_OFFSET_LEFT,
                value
            });
        } else if (newLeft < 0) {
            dispatch({
                type: ADD_TO_OFFSET_LEFT,
                value: -left
            });
        }
    };
}

/**
 * Adds the value to the offset of the right boundary for the timeline.
 *
 * @param {number} value - The new value for the offset.
 * @returns {Object}
 */
export function addToOffsetRight(value: number) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const { left, right } = getTimelineBoundaries(state);
        const currentDuration = getCurrentDuration(state) ?? 0;
        const newRight = right + value;

        if (newRight <= currentDuration && newRight - left > MINIMUM_INTERVAL) {
            dispatch({
                type: ADD_TO_OFFSET_RIGHT,
                value
            });
        } else if (newRight > currentDuration) {
            dispatch({
                type: ADD_TO_OFFSET_RIGHT,
                value: currentDuration - right
            });
        }
    };
}

/**
 * Sets the current time boundary of the timeline, when zoomed in.
 *
 * @param {number} boundary - The current time boundary.
 * @returns {Object}
 */
export function setTimelineBoundary(boundary: number) {
    return {
        type: SET_TIMELINE_BOUNDARY,
        boundary
    };
}

/**
 * Clears the current time boundary of the timeline, when zoomed out full.
 *
 * @returns {Object}
 */
export function clearTimelineBoundary() {
    return {
        type: SET_TIMELINE_BOUNDARY,
        boundary: null
    };
}

/**
 * Sets the state of the timeline panning.
 *
 * @param {Object} panning - The state of the timeline panning.
 * @returns {Object}
 */
export function setTimelinePanning(panning: { active: boolean; x: number; }) {
    return {
        type: SET_PANNING,
        panning
    };
}


################################################################################

## File: .\jitsi-meet\react\features\speaker-stats\actions.native.ts

export * from './actions.any';


################################################################################

## File: .\jitsi-meet\react\features\speaker-stats\actions.web.ts

export * from './actions.any';


################################################################################

## File: .\jitsi-meet\react\features\speaker-stats\actionTypes.ts

/**
 * Action type to start search.
 *
 * {
 *     type: INIT_SEARCH
 * }
 */
export const INIT_SEARCH = 'INIT_SEARCH';

/**
 * Action type to start stats retrieval.
 *
 * {
 *     type: INIT_UPDATE_STATS,
 *     getSpeakerStats: Function
 * }
 */
export const INIT_UPDATE_STATS = 'INIT_UPDATE_STATS';

/**
 * Action type to update stats.
 *
 * {
 *     type: UPDATE_STATS,
 *     stats: Object
 * }
 */
export const UPDATE_STATS = 'UPDATE_STATS';

/**
 * Action type to update the speaker stats order.
 * {
 *     type: UPDATE_SORTED_SPEAKER_STATS_IDS
 * }
 */
export const UPDATE_SORTED_SPEAKER_STATS_IDS = 'UPDATE_SORTED_SPEAKER_STATS_IDS'

/**
 * Action type to initiate reordering of the stats.
 *
 * {
 *     type: INIT_REORDER_STATS
 * }
 */
export const INIT_REORDER_STATS = 'INIT_REORDER_STATS';

/**
 * Action type to reset the search criteria.
 *
 * {
 *     type: RESET_SEARCH_CRITERIA
 * }
 */
export const RESET_SEARCH_CRITERIA = 'RESET_SEARCH_CRITERIA'

/**
 * Action type to toggle the face expressions grid.
 * {
 *     type: TOGGLE_FACE_EXPRESSIONS
 * }
 */
export const TOGGLE_FACE_EXPRESSIONS = 'SHOW_FACE_EXPRESSIONS';


export const INCREASE_ZOOM = 'INCREASE_ZOOM';

export const DECREASE_ZOOM = 'DECREASE_ZOOM';

export const ADD_TO_OFFSET = 'ADD_TO_OFFSET';

export const SET_OFFSET = 'RESET_OFFSET';

export const ADD_TO_OFFSET_LEFT = 'ADD_TO_OFFSET_LEFT';

export const ADD_TO_OFFSET_RIGHT = 'ADD_TO_OFFSET_RIGHT';

export const SET_TIMELINE_BOUNDARY = 'SET_TIMELINE_BOUNDARY';

export const SET_PANNING = 'SET_PANNING';



################################################################################

## File: .\jitsi-meet\react\features\speaker-stats\constants.ts

export const SPEAKER_STATS_RELOAD_INTERVAL = 1000;

export const DISPLAY_SWITCH_BREAKPOINT = 600;

export const MOBILE_BREAKPOINT = 480;

export const THRESHOLD_FIXED_AXIS = 10000;

export const MINIMUM_INTERVAL = 4000;

export const SCROLL_RATE = 500;

export const MIN_HANDLER_WIDTH = 30;

export const TIMELINE_COLORS: {
    [key: string]: string;
} = {
    happy: '#F3AD26',
    neutral: '#676767',
    sad: '#539EF9',
    surprised: '#BC72E1',
    angry: '#F35826',
    fearful: '#3AC8C8',
    disgusted: '#65B16B',
    'no-detection': '#FFFFFF00'
};

export const CLEAR_TIME_BOUNDARY_THRESHOLD = 1000;


################################################################################

## File: .\jitsi-meet\react\features\speaker-stats\functions.ts

import { cloneDeep } from 'lodash-es';

import { IReduxState } from '../app/types';
import { getConferenceTimestamp } from '../base/conference/functions';
import { PARTICIPANT_ROLE } from '../base/participants/constants';
import { getParticipantById } from '../base/participants/functions';
import { FaceLandmarks } from '../face-landmarks/types';

import { THRESHOLD_FIXED_AXIS } from './constants';
import { ISpeaker, ISpeakerStats } from './reducer';

/**
 * Checks if the speaker stats search is disabled.
 *
 * @param {IReduxState} state - The redux state.
 * @returns {boolean} - True if the speaker stats search is disabled and false otherwise.
 */
export function isSpeakerStatsSearchDisabled(state: IReduxState) {
    return state['features/base/config']?.speakerStats?.disableSearch;
}

/**
 * Checks if the speaker stats is disabled.
 *
 * @param {IReduxState} state - The redux state.
 * @returns {boolean} - True if the speaker stats search is disabled and false otherwise.
 */
export function isSpeakerStatsDisabled(state: IReduxState) {
    return state['features/base/config']?.speakerStats?.disabled;
}

/**
 * Gets whether participants in speaker stats should be ordered or not, and with what priority.
 *
 * @param {IReduxState} state - The redux state.
 * @returns {Array<string>} - The speaker stats order array or an empty array.
 */
export function getSpeakerStatsOrder(state: IReduxState) {
    return state['features/base/config']?.speakerStats?.order ?? [
        'role',
        'name',
        'hasLeft'
    ];
}

/**
 * Gets speaker stats.
 *
 * @param {IReduxState} state - The redux state.
 * @returns {Object} - The speaker stats.
 */
export function getSpeakerStats(state: IReduxState) {
    return state['features/speaker-stats']?.stats ?? {};
}

/**
 * Gets speaker stats search criteria.
 *
 * @param {IReduxState} state - The redux state.
 * @returns {string | null} - The search criteria.
 */
export function getSearchCriteria(state: IReduxState) {
    return state['features/speaker-stats']?.criteria;
}

/**
 * Gets if speaker stats reorder is pending.
 *
 * @param {IReduxState} state - The redux state.
 * @returns {boolean} - The pending reorder flag.
 */
export function getPendingReorder(state: IReduxState) {
    return state['features/speaker-stats']?.pendingReorder ?? false;
}

/**
 * Get sorted speaker stats ids based on a configuration setting.
 *
 * @param {IState} state - The redux state.
 * @param {IState} stats - The current speaker stats.
 * @returns {string[] | undefined} - Ordered speaker stats ids.
 * @public
 */
export function getSortedSpeakerStatsIds(state: IReduxState, stats: ISpeakerStats) {
    const orderConfig = getSpeakerStatsOrder(state);

    if (orderConfig) {
        const enhancedStats = getEnhancedStatsForOrdering(state, stats, orderConfig);

        return Object.entries(enhancedStats)
            .sort(([ , a ], [ , b ]) => compareFn(a, b))
            .map(el => el[0]);
    }

    /**
     *
     * Compares the order of two participants in the speaker stats list.
     *
     * @param {ISpeaker} currentParticipant - The first participant for comparison.
     * @param {ISpeaker} nextParticipant - The second participant for comparison.
     * @returns {number} - The sort order of the two participants.
     */
    function compareFn(currentParticipant: ISpeaker, nextParticipant: ISpeaker) {
        if (orderConfig.includes('hasLeft')) {
            if (nextParticipant.hasLeft() && !currentParticipant.hasLeft()) {
                return -1;
            } else if (currentParticipant.hasLeft() && !nextParticipant.hasLeft()) {
                return 1;
            }
        }

        let result = 0;

        for (const sortCriteria of orderConfig) {
            switch (sortCriteria) {
            case 'role':
                if (!nextParticipant.isModerator && currentParticipant.isModerator) {
                    result = -1;
                } else if (!currentParticipant.isModerator && nextParticipant.isModerator) {
                    result = 1;
                } else {
                    result = 0;
                }
                break;
            case 'name':
                result = (currentParticipant.displayName || '').localeCompare(
                    nextParticipant.displayName || ''
                );
                break;
            }

            if (result !== 0) {
                break;
            }
        }

        return result;
    }
}

/**
 * Enhance speaker stats to include data needed for ordering.
 *
 * @param {IState} state - The redux state.
 * @param {ISpeakerStats} stats - Speaker stats.
 * @param {Array<string>} orderConfig - Ordering configuration.
 * @returns {ISpeakerStats} - Enhanced speaker stats.
 * @public
 */
function getEnhancedStatsForOrdering(state: IReduxState, stats: ISpeakerStats, orderConfig: Array<string>) {
    if (!orderConfig) {
        return stats;
    }

    for (const id in stats) {
        if (stats[id].hasOwnProperty('_hasLeft') && !stats[id].hasLeft()) {
            if (orderConfig.includes('role')) {
                const participant = getParticipantById(state, stats[id].getUserId());

                stats[id].isModerator = participant && participant.role === PARTICIPANT_ROLE.MODERATOR;
            }
        }
    }

    return stats;
}

/**
 * Filter stats by search criteria.
 *
 * @param {IState} state - The redux state.
 * @param {ISpeakerStats | undefined} stats - The unfiltered stats.
 *
 * @returns {ISpeakerStats} - Filtered speaker stats.
 * @public
 */
export function filterBySearchCriteria(state: IReduxState, stats?: ISpeakerStats) {
    const filteredStats = cloneDeep(stats ?? getSpeakerStats(state));
    const criteria = getSearchCriteria(state);

    if (criteria !== null) {
        const searchRegex = new RegExp(criteria, 'gi');

        for (const id in filteredStats) {
            if (filteredStats[id].hasOwnProperty('_isLocalStats')) {
                const name = filteredStats[id].getDisplayName();

                filteredStats[id].hidden = !name?.match(searchRegex);
            }
        }
    }

    return filteredStats;
}

/**
 * Reset the hidden speaker stats.
 *
 * @param {IState} state - The redux state.
 * @param {ISpeakerStats | undefined} stats - The unfiltered stats.
 *
 * @returns {Object} - Speaker stats.
 * @public
 */
export function resetHiddenStats(state: IReduxState, stats?: ISpeakerStats) {
    const resetStats = cloneDeep(stats ?? getSpeakerStats(state));

    for (const id in resetStats) {
        if (resetStats[id].hidden) {
            resetStats[id].hidden = false;
        }
    }

    return resetStats;
}

/**
 * Gets the current duration of the conference.
 *
 * @param {IState} state - The redux state.
 * @returns {number | null} - The duration in milliseconds or null.
 */
export function getCurrentDuration(state: IReduxState) {
    const startTimestamp = getConferenceTimestamp(state);

    return startTimestamp ? Date.now() - startTimestamp : null;
}

/**
 * Gets the boundaries of the emotion timeline.
 *
 * @param {IState} state - The redux state.
 * @returns {Object} - The left and right boundaries.
 */
export function getTimelineBoundaries(state: IReduxState) {
    const { timelineBoundary, offsetLeft, offsetRight } = state['features/speaker-stats'];
    const currentDuration = getCurrentDuration(state) ?? 0;
    const rightBoundary = timelineBoundary ? timelineBoundary : currentDuration;
    let leftOffset = 0;

    if (rightBoundary > THRESHOLD_FIXED_AXIS) {
        leftOffset = rightBoundary - THRESHOLD_FIXED_AXIS;
    }

    const left = offsetLeft + leftOffset;
    const right = rightBoundary + offsetRight;

    return {
        left,
        right
    };
}

/**
 * Returns the conference start time of the face landmarks.
 *
 * @param {FaceLandmarks} faceLandmarks - The face landmarks.
 * @param {number} startTimestamp - The start timestamp of the conference.
 * @returns {number}
 */
export function getFaceLandmarksStart(faceLandmarks: FaceLandmarks, startTimestamp: number) {
    return faceLandmarks.timestamp - startTimestamp;
}

/**
 * Returns the conference end time of the face landmarks.
 *
 * @param {FaceLandmarks} faceLandmarks - The face landmarks.
 * @param {number} startTimestamp - The start timestamp of the conference.
 * @returns {number}
 */
export function getFaceLandmarksEnd(faceLandmarks: FaceLandmarks, startTimestamp: number) {
    return getFaceLandmarksStart(faceLandmarks, startTimestamp) + faceLandmarks.duration;
}


################################################################################

## File: .\jitsi-meet\react\features\speaker-stats\hooks.web.ts

import { useSelector } from 'react-redux';

import SpeakerStatsButton from './components/web/SpeakerStatsButton';
import { isSpeakerStatsDisabled } from './functions';

const speakerStats = {
    key: 'stats',
    Content: SpeakerStatsButton,
    group: 3
};

/**
 * A hook that returns the speaker stats button if it is enabled and undefined otherwise.
 *
 *  @returns {Object | undefined}
 */
export function useSpeakerStatsButton() {
    const disabled = useSelector(isSpeakerStatsDisabled);

    if (!disabled) {
        return speakerStats;
    }
}


################################################################################

## File: .\jitsi-meet\react\features\speaker-stats\middleware.ts

import { batch } from 'react-redux';
import { AnyAction } from 'redux';

import { IStore } from '../app/types';
import {
    PARTICIPANT_JOINED,
    PARTICIPANT_KICKED,
    PARTICIPANT_LEFT,
    PARTICIPANT_UPDATED
} from '../base/participants/actionTypes';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';

import {
    ADD_TO_OFFSET,
    INIT_SEARCH,
    INIT_UPDATE_STATS,
    RESET_SEARCH_CRITERIA
} from './actionTypes';
import {
    clearTimelineBoundary,
    initReorderStats,
    setTimelineBoundary,
    updateSortedSpeakerStatsIds,
    updateStats
} from './actions.any';
import { CLEAR_TIME_BOUNDARY_THRESHOLD } from './constants';
import {
    filterBySearchCriteria,
    getCurrentDuration,
    getPendingReorder,
    getSortedSpeakerStatsIds,
    getTimelineBoundaries,
    resetHiddenStats
} from './functions';

MiddlewareRegistry.register(({ dispatch, getState }: IStore) => (next: Function) => (action: AnyAction) => {
    switch (action.type) {
    case INIT_SEARCH: {
        const state = getState();
        const stats = filterBySearchCriteria(state);

        dispatch(updateStats(stats));
        break;
    }

    case INIT_UPDATE_STATS:
        if (action.getSpeakerStats) {
            const state = getState();
            const speakerStats = { ...action.getSpeakerStats() };
            const stats = filterBySearchCriteria(state, speakerStats);
            const pendingReorder = getPendingReorder(state);

            batch(() => {
                if (pendingReorder) {
                    dispatch(updateSortedSpeakerStatsIds(getSortedSpeakerStatsIds(state, stats) ?? []));
                }

                dispatch(updateStats(stats));
            });

        }

        break;

    case RESET_SEARCH_CRITERIA: {
        const state = getState();
        const stats = resetHiddenStats(state);

        dispatch(updateStats(stats));
        break;
    }
    case PARTICIPANT_JOINED:
    case PARTICIPANT_LEFT:
    case PARTICIPANT_KICKED:
    case PARTICIPANT_UPDATED: {
        const { pendingReorder } = getState()['features/speaker-stats'];

        if (!pendingReorder) {
            dispatch(initReorderStats());
        }
        break;
    }

    case ADD_TO_OFFSET: {
        const state = getState();
        const { timelineBoundary } = state['features/speaker-stats'];
        const { right } = getTimelineBoundaries(state);
        const currentDuration = getCurrentDuration(state) ?? 0;

        if (Math.abs((right + action.value) - currentDuration) < CLEAR_TIME_BOUNDARY_THRESHOLD) {
            dispatch(clearTimelineBoundary());
        } else if (!timelineBoundary) {
            dispatch(setTimelineBoundary(currentDuration ?? 0));
        }

        break;
    }
    }

    return next(action);
});


################################################################################

## File: .\jitsi-meet\react\features\speaker-stats\reducer.ts

import { assign } from 'lodash-es';

import ReducerRegistry from '../base/redux/ReducerRegistry';
import { FaceLandmarks } from '../face-landmarks/types';

import {
    ADD_TO_OFFSET,
    ADD_TO_OFFSET_LEFT,
    ADD_TO_OFFSET_RIGHT,
    INIT_REORDER_STATS,
    INIT_SEARCH,
    RESET_SEARCH_CRITERIA,
    SET_PANNING,
    SET_TIMELINE_BOUNDARY,
    TOGGLE_FACE_EXPRESSIONS,
    UPDATE_SORTED_SPEAKER_STATS_IDS,
    UPDATE_STATS
} from './actionTypes';

/**
 * The initial state of the feature speaker-stats.
 *
 * @type {Object}
 */
const INITIAL_STATE = {
    stats: {},
    isOpen: false,
    pendingReorder: true,
    criteria: null,
    showFaceExpressions: false,
    sortedSpeakerStatsIds: [],
    timelineBoundary: null,
    offsetLeft: 0,
    offsetRight: 0,
    timelinePanning: {
        active: false,
        x: 0
    }
};

export interface ISpeaker {
    addFaceLandmarks: (faceLandmarks: FaceLandmarks) => void;
    displayName?: string;
    getDisplayName: () => string;
    getFaceLandmarks: () => FaceLandmarks[];
    getTotalDominantSpeakerTime: () => number;
    getUserId: () => string;
    hasLeft: () => boolean;
    hidden?: boolean;
    isDominantSpeaker: () => boolean;
    isLocalStats: () => boolean;
    isModerator?: boolean;
    markAsHasLeft: () => boolean;
    setDisplayName: (newName: string) => void;
    setDominantSpeaker: (isNowDominantSpeaker: boolean, silence: boolean) => void;
    setFaceLandmarks: (faceLandmarks: FaceLandmarks[]) => void;
}

export interface ISpeakerStats {
    [key: string]: ISpeaker;
}

export interface ISpeakerStatsState {
    criteria: string | null;
    isOpen: boolean;
    offsetLeft: number;
    offsetRight: number;
    pendingReorder: boolean;
    showFaceExpressions: boolean;
    sortedSpeakerStatsIds: Array<string>;
    stats: ISpeakerStats;
    timelineBoundary: number | null;
    timelinePanning: {
        active: boolean;
        x: number;
    };
}

ReducerRegistry.register<ISpeakerStatsState>('features/speaker-stats',
(state = INITIAL_STATE, action): ISpeakerStatsState => {
    switch (action.type) {
    case INIT_SEARCH:
        return _updateCriteria(state, action);
    case UPDATE_STATS:
        return _updateStats(state, action);
    case INIT_REORDER_STATS:
        return _initReorderStats(state);
    case UPDATE_SORTED_SPEAKER_STATS_IDS:
        return _updateSortedSpeakerStats(state, action);
    case RESET_SEARCH_CRITERIA:
        return _updateCriteria(state, { criteria: null });
    case TOGGLE_FACE_EXPRESSIONS: {
        return {
            ...state,
            showFaceExpressions: !state.showFaceExpressions
        };
    }
    case ADD_TO_OFFSET: {
        return {
            ...state,
            offsetLeft: state.offsetLeft + action.value,
            offsetRight: state.offsetRight + action.value
        };
    }
    case ADD_TO_OFFSET_RIGHT: {
        return {
            ...state,
            offsetRight: state.offsetRight + action.value
        };
    }
    case ADD_TO_OFFSET_LEFT: {
        return {
            ...state,
            offsetLeft: state.offsetLeft + action.value
        };
    }
    case SET_TIMELINE_BOUNDARY: {
        return {
            ...state,
            timelineBoundary: action.boundary
        };
    }
    case SET_PANNING: {
        return {
            ...state,
            timelinePanning: action.panning
        };
    }
    }

    return state;
});

/**
 * Reduces a specific Redux action INIT_SEARCH of the feature
 * speaker-stats.
 *
 * @param {Object} state - The Redux state of the feature speaker-stats.
 * @param {Action} action - The Redux action INIT_SEARCH to reduce.
 * @private
 * @returns {Object} The new state after the reduction of the specified action.
 */
function _updateCriteria(state: ISpeakerStatsState, { criteria }: { criteria: string | null; }) {
    return assign({}, state, { criteria });
}

/**
 * Reduces a specific Redux action UPDATE_STATS of the feature speaker-stats.
 *
 * @param {Object} state - The Redux state of the feature speaker-stats.
 * @param {Action} action - The Redux action UPDATE_STATS to reduce.
 * @private
 * @returns {Object} - The new state after the reduction of the specified action.
 */
function _updateStats(state: ISpeakerStatsState, { stats }: { stats: any; }) {
    return {
        ...state,
        stats
    };
}

/**
 * Reduces a specific Redux action UPDATE_SORTED_SPEAKER_STATS_IDS of the feature speaker-stats.
 *
 * @param {Object} state - The Redux state of the feature speaker-stats.
 * @param {Action} action - The Redux action UPDATE_SORTED_SPEAKER_STATS_IDS to reduce.
 * @private
 * @returns {Object} The new state after the reduction of the specified action.
 */
function _updateSortedSpeakerStats(state: ISpeakerStatsState, { participantIds }: { participantIds: Array<string>; }) {
    return {
        ...state,
        sortedSpeakerStatsIds: participantIds,
        pendingReorder: false
    };
}

/**
 * Reduces a specific Redux action INIT_REORDER_STATS of the feature
 * speaker-stats.
 *
 * @param {Object} state - The Redux state of the feature speaker-stats.
 * @private
 * @returns {Object} The new state after the reduction of the specified action.
 */
function _initReorderStats(state: ISpeakerStatsState) {
    return assign({}, state, { pendingReorder: true });
}


################################################################################

## File: .\jitsi-meet\react\features\speaker-stats\components\AbstractSpeakerStatsList.ts

import { useCallback, useEffect, useRef } from 'react';
import { useTranslation } from 'react-i18next';
import { useDispatch, useSelector } from 'react-redux';

import { IReduxState } from '../../app/types';
import { getLocalParticipant } from '../../base/participants/functions';
import { initUpdateStats } from '../actions.any';
import {
    SPEAKER_STATS_RELOAD_INTERVAL
} from '../constants';

/**
 * Component that renders the list of speaker stats.
 *
 * @param {Function} speakerStatsItem - React element tu use when rendering.
 * @param {Object} itemStyles - Styles for the speaker stats item.
 * @returns {Function}
 */
const abstractSpeakerStatsList = (speakerStatsItem: Function): Function[] => {
    const dispatch = useDispatch();
    const { t } = useTranslation();
    const { conference } = useSelector((state: IReduxState) => state['features/base/conference']);
    const {
        stats: speakerStats,
        showFaceExpressions,
        sortedSpeakerStatsIds
    } = useSelector((state: IReduxState) => state['features/speaker-stats']);
    const localParticipant = useSelector(getLocalParticipant);
    const { defaultRemoteDisplayName } = useSelector(
        (state: IReduxState) => state['features/base/config']) || {};
    const { faceLandmarks: faceLandmarksConfig } = useSelector((state: IReduxState) =>
        state['features/base/config']) || {};
    const { faceLandmarks } = useSelector((state: IReduxState) => state['features/face-landmarks'])
        || { faceLandmarks: [] };
    const reloadInterval = useRef<number>();

    /**
     * Update the internal state with the latest speaker stats.
     *
     * @returns {Object}
     * @private
     */
    const getSpeakerStats = useCallback(() => {
        const stats = conference?.getSpeakerStats();

        for (const userId in stats) {
            if (stats[userId]) {
                if (stats[userId].isLocalStats()) {
                    const meString = t('me');

                    stats[userId].setDisplayName(
                        localParticipant?.name
                            ? `${localParticipant.name} (${meString})`
                            : meString
                    );

                    if (faceLandmarksConfig?.enableDisplayFaceExpressions) {
                        stats[userId].setFaceLandmarks(faceLandmarks);
                    }
                }

                if (!stats[userId].getDisplayName()) {
                    stats[userId].setDisplayName(
                        conference?.getParticipantById(userId)?.name
                    );
                }
            }
        }

        return stats ?? {};
    }, [ faceLandmarks ]);

    const updateStats = useCallback(
        () => dispatch(initUpdateStats(getSpeakerStats)),
    [ dispatch, initUpdateStats, getSpeakerStats ]);

    useEffect(() => {
        reloadInterval.current = window.setInterval(() => {
            updateStats();
        }, SPEAKER_STATS_RELOAD_INTERVAL);

        return () => {
            if (reloadInterval.current) {
                clearInterval(reloadInterval.current);
            }
        };
    }, [ faceLandmarks ]);

    const localSpeakerStats = Object.keys(speakerStats).length === 0 ? getSpeakerStats() : speakerStats;
    const localSortedSpeakerStatsIds
        = sortedSpeakerStatsIds.length === 0 ? Object.keys(localSpeakerStats) : sortedSpeakerStatsIds;

    const userIds = localSortedSpeakerStatsIds.filter(id => localSpeakerStats[id] && !localSpeakerStats[id].hidden);

    return userIds.map(userId => {
        const statsModel = localSpeakerStats[userId];
        const props = {
            isDominantSpeaker: statsModel.isDominantSpeaker(),
            dominantSpeakerTime: statsModel.getTotalDominantSpeakerTime(),
            participantId: userId,
            hasLeft: statsModel.hasLeft(),
            faceLandmarks: showFaceExpressions ? statsModel.getFaceLandmarks() : undefined,
            hidden: statsModel.hidden,
            showFaceExpressions,
            displayName: statsModel.getDisplayName() || defaultRemoteDisplayName,
            t
        };

        return speakerStatsItem(props);
    });
};


export default abstractSpeakerStatsList;


################################################################################

## File: .\jitsi-meet\react\features\speaker-stats\components\timeFunctions.ts

/**
 * Counts how many whole hours are included in the given time total.
 *
 * @param {number} milliseconds - The millisecond total to get hours from.
 * @private
 * @returns {number}
 */
function getHoursCount(milliseconds: number) {
    return Math.floor(milliseconds / (60 * 60 * 1000));
}

/**
 * Counts how many whole minutes are included in the given time total.
 *
 * @param {number} milliseconds - The millisecond total to get minutes from.
 * @private
 * @returns {number}
 */
function getMinutesCount(milliseconds: number) {
    return Math.floor(milliseconds / (60 * 1000) % 60);
}

/**
 * Counts how many whole seconds are included in the given time total.
 *
 * @param {number} milliseconds - The millisecond total to get seconds from.
 * @private
 * @returns {number}
 */
function getSecondsCount(milliseconds: number) {
    return Math.floor(milliseconds / 1000 % 60);
}

/**
 * Creates human readable localized time string.
 *
 * @param {number} time - Value in milliseconds.
 * @param {Function} t - Translate function.
 * @returns {string}
 */
export function createLocalizedTime(time: number, t: Function) {
    const hours = getHoursCount(time);
    const minutes = getMinutesCount(time);
    const seconds = getSecondsCount(time);
    const timeElapsed = [];

    if (hours) {
        const hourPassed
            = createTimeDisplay(hours, 'speakerStats.hours', t);

        timeElapsed.push(hourPassed);
    }

    if (hours || minutes) {
        const minutesPassed
            = createTimeDisplay(
            minutes,
            'speakerStats.minutes',
            t);

        timeElapsed.push(minutesPassed);
    }

    const secondsPassed
        = createTimeDisplay(
        seconds,
        'speakerStats.seconds',
        t);

    timeElapsed.push(secondsPassed);

    return timeElapsed;
}

/**
 * Returns a string to display the passed in count and a count noun.
 *
 * @private
 * @param {number} count - The number used for display and to check for
 * count noun plurality.
 * @param {string} countNounKey - Translation key for the time's count noun.
 * @param {Function} t - What is being counted. Used as the element's
 * key for react to iterate upon.
 * @returns {string}
 */
function createTimeDisplay(count: number, countNounKey: string, t: Function) {
    return t(countNounKey, { count });
}


################################################################################

## File: .\jitsi-meet\react\features\speaker-stats\components\native\SpeakerStatsButton.ts

import { connect } from 'react-redux';

import { createToolbarEvent } from '../../../analytics/AnalyticsEvents';
import { sendAnalytics } from '../../../analytics/functions';
import { IReduxState } from '../../../app/types';
import { SPEAKERSTATS_ENABLED } from '../../../base/flags/constants';
import { getFeatureFlag } from '../../../base/flags/functions';
import { translate } from '../../../base/i18n/functions';
import { navigate } from '../../../mobile/navigation/components/conference/ConferenceNavigationContainerRef';
import { screen } from '../../../mobile/navigation/routes';
import AbstractSpeakerStatsButton from '../AbstractSpeakerStatsButton';

/**
 * Implementation of a button for opening speaker stats dialog.
 */
class SpeakerStatsButton extends AbstractSpeakerStatsButton {

    /**
     * Handles clicking / pressing the button, and opens the appropriate dialog.
     *
     * @protected
     * @returns {void}
     */
    _handleClick() {
        sendAnalytics(createToolbarEvent('speaker.stats'));

        return navigate(screen.conference.speakerStats);
    }
}

/**
 * Maps (parts of) the redux state to the associated props for the
 * {@code SpeakerStatsButton} component.
 *
 * @param {Object} state - The Redux state.
 * @private
 * @returns {{
 *     visible: boolean
 * }}
 */
function _mapStateToProps(state: IReduxState) {
    const enabled = getFeatureFlag(state, SPEAKERSTATS_ENABLED, true);

    return {
        visible: enabled
    };
}


export default translate(connect(_mapStateToProps)(SpeakerStatsButton));


################################################################################

## File: .\jitsi-meet\react\features\speaker-stats\components\native\styles.ts

import BaseTheme from '../../../base/ui/components/BaseTheme.native';

export default {

    customContainer: {
        marginVertical: BaseTheme.spacing[2]
    },

    speakerStatsContainer: {
        flexDirection: 'column',
        flex: 1,
        height: 'auto',
        paddingHorizontal: BaseTheme.spacing[3],
        backgroundColor: BaseTheme.palette.ui01
    },

    speakerStatsItemContainer: {
        flexDirection: 'row',
        alignSelf: 'stretch',
        height: BaseTheme.spacing[9],
        alignItems: 'center'
    },

    speakerStatsAvatar: {
        width: BaseTheme.spacing[5],
        height: BaseTheme.spacing[5],
        marginRight: BaseTheme.spacing[3]
    },

    speakerStatsNameTime: {
        flexDirection: 'row',
        flex: 1,
        justifyContent: 'space-between',
        alignItems: 'center'
    },

    speakerStatsText: {
        ...BaseTheme.typography.bodyShortRegularLarge,
        color: BaseTheme.palette.text01
    },

    speakerStatsTime: {
        paddingHorizontal: 4,
        paddingVertical: 2,
        borderRadius: 4
    },

    speakerStatsDominant: {
        backgroundColor: BaseTheme.palette.success02
    },

    speakerStatsLeft: {
        color: BaseTheme.palette.text03
    }
};


################################################################################

## File: .\jitsi-meet\react\features\stream-effects\audio-mixer\AudioMixerEffect.ts

import JitsiMeetJS from '../../base/lib-jitsi-meet';
import { MEDIA_TYPE } from '../../base/media/constants';

/**
 * Class Implementing the effect interface expected by a JitsiLocalTrack.
 * The AudioMixerEffect, as the name implies, mixes two JitsiLocalTracks containing a audio track. First track is
 * provided at the moment of creation, second is provided through the effect interface.
 */
export class AudioMixerEffect {
    /**
     * JitsiLocalTrack that is going to be mixed into the track that uses this effect.
     */
    _mixAudio: any;

    /**
     * MediaStream resulted from mixing.
     */
    _mixedMediaStream: any;

    /**
     * MediaStreamTrack obtained from mixed stream.
     */
    _mixedMediaTrack: Object;

    /**
     * Original MediaStream from the JitsiLocalTrack that uses this effect.
     */
    _originalStream: Object;

    /**
     * MediaStreamTrack obtained from the original MediaStream.
     */
    _originalTrack: any;

    /**
     * Lib-jitsi-meet AudioMixer.
     */
    _audioMixer: any;

    /**
     * Creates AudioMixerEffect.
     *
     * @param {JitsiLocalTrack} mixAudio - JitsiLocalTrack which will be mixed with the original track.
     */
    constructor(mixAudio: any) {
        if (mixAudio.getType() !== MEDIA_TYPE.AUDIO) {
            throw new Error('AudioMixerEffect only supports audio JitsiLocalTracks; effect will not work!');
        }

        this._mixAudio = mixAudio;
    }

    /**
     * Checks if the JitsiLocalTrack supports this effect.
     *
     * @param {JitsiLocalTrack} sourceLocalTrack - Track to which the effect will be applied.
     * @returns {boolean} - Returns true if this effect can run on the specified track, false otherwise.
     */
    isEnabled(sourceLocalTrack: any) {
        // Both JitsiLocalTracks need to be audio i.e. contain an audio MediaStreamTrack
        return sourceLocalTrack.isAudioTrack() && this._mixAudio.isAudioTrack();
    }

    /**
     * Effect interface called by source JitsiLocalTrack, At this point a WebAudio ChannelMergerNode is created
     * and and the two associated MediaStreams are connected to it; the resulting mixed MediaStream is returned.
     *
     * @param {MediaStream} audioStream - Audio stream which will be mixed with _mixAudio.
     * @returns {MediaStream} - MediaStream containing both audio tracks mixed together.
     */
    startEffect(audioStream: MediaStream) {
        this._originalStream = audioStream;
        this._originalTrack = audioStream.getTracks()[0];

        this._audioMixer = JitsiMeetJS.createAudioMixer();
        this._audioMixer.addMediaStream(this._mixAudio.getOriginalStream());
        this._audioMixer.addMediaStream(this._originalStream);

        this._mixedMediaStream = this._audioMixer.start();
        this._mixedMediaTrack = this._mixedMediaStream.getTracks()[0];

        return this._mixedMediaStream;
    }

    /**
     * Reset the AudioMixer stopping it in the process.
     *
     * @returns {void}
     */
    stopEffect() {
        this._audioMixer.reset();
    }

    /**
     * Change the muted state of the effect.
     *
     * @param {boolean} muted - Should effect be muted or not.
     * @returns {void}
     */
    setMuted(muted: boolean) {
        this._originalTrack.enabled = !muted;
    }

    /**
     * Check whether or not this effect is muted.
     *
     * @returns {boolean}
     */
    isMuted() {
        return !this._originalTrack.enabled;
    }
}


################################################################################

## File: .\jitsi-meet\react\features\stream-effects\noise-suppression\logger.ts

import { getLogger } from '../../base/logging/functions';

export default getLogger('features/stream-effects/noise-suppression');


################################################################################

## File: .\jitsi-meet\react\features\stream-effects\noise-suppression\NoiseSuppressionEffect.ts

import { INoiseSuppressionConfig } from '../../base/config/configType';
import { getBaseUrl } from '../../base/util/helpers';

import logger from './logger';

interface IKrispState {
    filterNode?: AudioWorkletNode;
    filterNodeReady: boolean;
    sdk: any;
    sdkInitialized: boolean;
}

const krispState: IKrispState = {
    filterNode: undefined,
    filterNodeReady: false,
    sdk: undefined,
    sdkInitialized: false
};

let audioContext: AudioContext;

/**
 * Class Implementing the effect interface expected by a JitsiLocalTrack.
 * Effect applies rnnoise denoising on a audio JitsiLocalTrack.
 */
export class NoiseSuppressionEffect {

    /**
     * Source that will be attached to the track affected by the effect.
     */
    private _audioSource: MediaStreamAudioSourceNode;

    /**
     * Destination that will contain denoised audio from the audio worklet.
     */
    private _audioDestination: MediaStreamAudioDestinationNode;

    /**
     * `AudioWorkletProcessor` associated node.
     */
    private _noiseSuppressorNode?: AudioWorkletNode;

    /**
     * Audio track extracted from the original MediaStream to which the effect is applied.
     */
    private _originalMediaTrack: MediaStreamTrack;

    /**
     * Noise suppressed audio track extracted from the media destination node.
     */
    private _outputMediaTrack: MediaStreamTrack;

    /**
     * Configured options for noise suppression.
     */
    private _options?: INoiseSuppressionConfig;

    /**
     * Instantiates a noise suppressor audio effect which will use either rnnoise or krisp.
     *
     * @param {INoiseSuppressionConfig} options - Configured options.
     */
    constructor(options?: INoiseSuppressionConfig) {
        this._options = options;

        const useKrisp = options?.krisp?.enabled;

        logger.info(`NoiseSuppressionEffect created with ${useKrisp ? 'Krisp' : 'RNNoise'}`);
    }

    /**
     * Effect interface called by source JitsiLocalTrack.
     * Applies effect that uses a {@code NoiseSuppressor} service initialized with {@code RnnoiseProcessor}
     * for denoising.
     *
     * @param {MediaStream} audioStream - Audio stream which will be mixed with _mixAudio.
     * @returns {MediaStream} - MediaStream containing both audio tracks mixed together.
     */
    startEffect(audioStream: MediaStream): MediaStream {
        this._originalMediaTrack = audioStream.getAudioTracks()[0];

        if (!audioContext) {
            audioContext = new AudioContext();
        }

        this._audioSource = audioContext.createMediaStreamSource(audioStream);
        this._audioDestination = audioContext.createMediaStreamDestination();
        this._outputMediaTrack = this._audioDestination.stream.getAudioTracks()[0];

        let init;

        if (this._options?.krisp?.enabled) {
            init = _initializeKrisp(this._options).then(filterNode => {
                this._noiseSuppressorNode = filterNode;

                if (krispState.filterNodeReady) {
                    // @ts-ignore
                    krispState.filterNode?.enable();
                }
            });
        } else {
            init = _initializeKRnnoise().then(filterNode => {
                this._noiseSuppressorNode = filterNode;
            });
        }

        // Connect the audio processing graph MediaStream -> AudioWorkletNode -> MediaStreamAudioDestinationNode

        init.then(() => {
            if (this._noiseSuppressorNode) {
                this._audioSource.connect(this._noiseSuppressorNode);
                this._noiseSuppressorNode.connect(this._audioDestination);
            }
        });

        // Sync the effect track muted state with the original track state.
        this._outputMediaTrack.enabled = this._originalMediaTrack.enabled;

        // We enable the audio on the original track because mute/unmute action will only affect the audio destination
        // output track from this point on.
        this._originalMediaTrack.enabled = true;

        return this._audioDestination.stream;
    }

    /**
     * Checks if the JitsiLocalTrack supports this effect.
     *
     * @param {JitsiLocalTrack} sourceLocalTrack - Track to which the effect will be applied.
     * @returns {boolean} - Returns true if this effect can run on the specified track, false otherwise.
     */
    isEnabled(sourceLocalTrack: any): boolean {
        // JitsiLocalTracks needs to be an audio track.
        return sourceLocalTrack.isAudioTrack();
    }

    /**
     * Clean up resources acquired by noise suppressor and rnnoise processor.
     *
     * @returns {void}
     */
    stopEffect(): void {
        // Sync original track muted state with effect state before removing the effect.
        this._originalMediaTrack.enabled = this._outputMediaTrack.enabled;

        if (this._options?.krisp?.enabled) {
            // When using Krisp we'll just disable the filter which we'll keep reusing.

            // @ts-ignore
            this._noiseSuppressorNode?.disable();
        } else {
            // Technically after this process the Audio Worklet along with it's resources should be garbage collected,
            // however on chrome there seems to be a problem as described here:
            // https://bugs.chromium.org/p/chromium/issues/detail?id=1298955
            this._noiseSuppressorNode?.port?.close();
        }

        this._audioDestination?.disconnect();
        this._noiseSuppressorNode?.disconnect();
        this._audioSource?.disconnect();

        audioContext.suspend();
    }
}

/**
 * Initializes the Krisp SDK and creates the filter node.
 *
 * @param {INoiseSuppressionConfig} options - Krisp options.
 *
 * @returns {Promise<AudioWorkletNode | undefined>}
 */
async function _initializeKrisp(options: INoiseSuppressionConfig): Promise<AudioWorkletNode | undefined> {
    await audioContext.resume();

    if (!krispState.sdk) {
        const baseUrl = `${getBaseUrl()}libs/krisp`;
        const { default: KrispSDK } = await import(/* webpackIgnore: true */ `${baseUrl}/krispsdk.mjs`);

        krispState.sdk = new KrispSDK({
            params: {
                models: {
                    model8: `${baseUrl}/models/model_8.kw`,
                    model16: `${baseUrl}/models/model_16.kw`,
                    model32: `${baseUrl}/models/model_32.kw`
                },
                logProcessStats: options?.krisp?.logProcessStats,
                debugLogs: options?.krisp?.debugLogs
            },
            callbacks: {}
        });
    }

    if (!krispState.sdkInitialized) {
        // @ts-ignore
        await krispState.sdk?.init();

        krispState.sdkInitialized = true;
    }

    if (!krispState.filterNode) {
        try {
            // @ts-ignore
            krispState.filterNode = await krispState.sdk?.createNoiseFilter(audioContext, () => {
                logger.info('Krisp audio filter ready');

                // Enable audio filtering.
                // @ts-ignore
                krispState.filterNode?.enable();
                krispState.filterNodeReady = true;
            });
        } catch (e) {
            logger.error('Failed to create Krisp noise filter', e);

            krispState.filterNode = undefined;
            krispState.filterNodeReady = false;
        }
    }

    return krispState.filterNode;
}

/**
 * Initializes the RNNoise audio worklet and creates the filter node.
 *
 * @returns {Promise<AudioWorkletNode | undefined>}
 */
async function _initializeKRnnoise(): Promise<AudioWorkletNode | undefined> {
    await audioContext.resume();

    const baseUrl = `${getBaseUrl()}libs/`;
    const workletUrl = `${baseUrl}noise-suppressor-worklet.min.js`;

    try {
        await audioContext.audioWorklet.addModule(workletUrl);
    } catch (e) {
        logger.error('Error while adding audio worklet module: ', e);

        return;
    }

    // After the resolution of module loading, an AudioWorkletNode can be constructed.

    return new AudioWorkletNode(audioContext, 'NoiseSuppressorWorklet');
}


################################################################################

## File: .\jitsi-meet\react\features\stream-effects\noise-suppression\NoiseSuppressorWorklet.ts

// @ts-expect-error
import { createRNNWasmModuleSync } from '@jitsi/rnnoise-wasm';

import { leastCommonMultiple } from '../../base/util/math';
import RnnoiseProcessor from '../rnnoise/RnnoiseProcessor';


/**
 * Audio worklet which will denoise targeted audio stream using rnnoise.
 */
class NoiseSuppressorWorklet extends AudioWorkletProcessor {
    /**
     * RnnoiseProcessor instance.
     */
    private _denoiseProcessor: RnnoiseProcessor;

    /**
     * Audio worklets work with a predefined sample rate of 128.
     */
    private _procNodeSampleRate = 128;

    /**
     * PCM Sample size expected by the denoise processor.
     */
    private _denoiseSampleSize: number;

    /**
     * Circular buffer data used for efficient memory operations.
     */
    private _circularBufferLength: number;

    private _circularBuffer: Float32Array;

    /**
     * The circular buffer uses a couple of indexes to track data segments. Input data from the stream is
     * copied to the circular buffer as it comes in, one `procNodeSampleRate` sized sample at a time.
     * _inputBufferLength denotes the current length of all gathered raw audio segments.
     */
    private _inputBufferLength = 0;

    /**
     * Denoising is done directly on the circular buffer using subArray views, but because
     * `procNodeSampleRate` and `_denoiseSampleSize` have different sizes, denoised samples lag behind
     * the current gathered raw audio samples so we need a different index, `_denoisedBufferLength`.
     */
    private _denoisedBufferLength = 0;

    /**
     * Once enough data has been denoised (size of procNodeSampleRate) it's sent to the
     * output buffer, `_denoisedBufferIndx` indicates the start index on the circular buffer
     * of denoised data not yet sent.
     */
    private _denoisedBufferIndx = 0;

    /**
     * C'tor.
     */
    constructor() {
        super();

        /**
         * The wasm module needs to be compiled to load synchronously as the audio worklet `addModule()`
         * initialization process does not wait for the resolution of promises in the AudioWorkletGlobalScope.
         */
        this._denoiseProcessor = new RnnoiseProcessor(createRNNWasmModuleSync());

        /**
         * PCM Sample size expected by the denoise processor.
         */
        this._denoiseSampleSize = this._denoiseProcessor.getSampleLength();

        /**
         * In order to avoid unnecessary memory related operations a circular buffer was used.
         * Because the audio worklet input array does not match the sample size required by rnnoise two cases can occur
         * 1. There is not enough data in which case we buffer it.
         * 2. There is enough data but some residue remains after the call to `processAudioFrame`, so its buffered
         * for the next call.
         * A problem arises when the circular buffer reaches the end and a rollover is required, namely
         * the residue could potentially be split between the end of buffer and the beginning and would
         * require some complicated logic to handle. Using the lcm as the size of the buffer will
         * guarantee that by the time the buffer reaches the end the residue will be a multiple of the
         * `procNodeSampleRate` and the residue won't be split.
         */
        this._circularBufferLength = leastCommonMultiple(this._procNodeSampleRate, this._denoiseSampleSize);
        this._circularBuffer = new Float32Array(this._circularBufferLength);
    }

    /**
     * Worklet interface process method. The inputs parameter contains PCM audio that is then sent to rnnoise.
     * Rnnoise only accepts PCM samples of 480 bytes whereas `process` handles 128 sized samples, we take this into
     * account using a circular buffer.
     *
     * @param {Float32Array[]} inputs - Array of inputs connected to the node, each of them with their associated
     * array of channels. Each channel is an array of 128 pcm samples.
     * @param {Float32Array[]} outputs - Array of outputs similar to the inputs parameter structure, expected to be
     * filled during the execution of `process`. By default each channel is zero filled.
     * @returns {boolean} - Boolean value that returns whether or not the processor should remain active. Returning
     * false will terminate it.
     */
    process(inputs: Float32Array[][], outputs: Float32Array[][]) {

        // We expect the incoming track to be mono, if a stereo track is passed only on of its channels will get
        // denoised and sent pack.
        // TODO Technically we can denoise both channel however this might require a new rnnoise context, some more
        // investigation is required.
        const inData = inputs[0][0];
        const outData = outputs[0][0];

        // Exit out early if there is no input data (input node not connected/disconnected)
        // as rest of worklet will crash otherwise
        if (!inData) {
            return true;
        }

        // Append new raw PCM sample.
        this._circularBuffer.set(inData, this._inputBufferLength);
        this._inputBufferLength += inData.length;

        // New raw samples were just added, start denoising frames, _denoisedBufferLength gives us
        // the position at which the previous denoise iteration ended, basically it takes into account
        // residue data.
        for (; this._denoisedBufferLength + this._denoiseSampleSize <= this._inputBufferLength;
            this._denoisedBufferLength += this._denoiseSampleSize) {
            // Create view of circular buffer so it can be modified in place, removing the need for
            // extra copies.

            const denoiseFrame = this._circularBuffer.subarray(
                this._denoisedBufferLength,
                this._denoisedBufferLength + this._denoiseSampleSize
            );

            this._denoiseProcessor.processAudioFrame(denoiseFrame, true);
        }

        // Determine how much denoised audio is available, if the start index of denoised samples is smaller
        // then _denoisedBufferLength that means a rollover occurred.
        let unsentDenoisedDataLength;

        if (this._denoisedBufferIndx > this._denoisedBufferLength) {
            unsentDenoisedDataLength = this._circularBufferLength - this._denoisedBufferIndx;
        } else {
            unsentDenoisedDataLength = this._denoisedBufferLength - this._denoisedBufferIndx;
        }

        // Only copy denoised data to output when there's enough of it to fit the exact buffer length.
        // e.g. if the buffer size is 1024 samples but we only denoised 960 (this happens on the first iteration)
        // nothing happens, then on the next iteration 1920 samples will be denoised so we send 1024 which leaves
        // 896 for the next iteration and so on.
        if (unsentDenoisedDataLength >= outData.length) {
            const denoisedFrame = this._circularBuffer.subarray(
                this._denoisedBufferIndx,
                this._denoisedBufferIndx + outData.length
            );

            outData.set(denoisedFrame, 0);
            this._denoisedBufferIndx += outData.length;
        }

        // When the end of the circular buffer has been reached, start from the beginning. By the time the index
        // starts over, the data from the begging is stale (has already been processed) and can be safely
        // overwritten.
        if (this._denoisedBufferIndx === this._circularBufferLength) {
            this._denoisedBufferIndx = 0;
        }

        // Because the circular buffer's length is the lcm of both input size and the processor's sample size,
        // by the time we reach the end with the input index the denoise length index will be there as well.
        if (this._inputBufferLength === this._circularBufferLength) {
            this._inputBufferLength = 0;
            this._denoisedBufferLength = 0;
        }

        return true;
    }
}

registerProcessor('NoiseSuppressorWorklet', NoiseSuppressorWorklet);


################################################################################

## File: .\jitsi-meet\react\features\stream-effects\rnnoise\index.ts

// Script expects to find rnnoise webassembly binary in the same public path root, otherwise it won't load
// During the build phase this needs to be taken care of manually
// @ts-expect-error
import { createRNNWasmModule } from '@jitsi/rnnoise-wasm';

import RnnoiseProcessor from './RnnoiseProcessor';

export { RNNOISE_SAMPLE_LENGTH } from './RnnoiseProcessor';
export type { RnnoiseProcessor };

let rnnoiseModule: Promise<any> | undefined;

/**
 * Creates a new instance of RnnoiseProcessor.
 *
 * @returns {Promise<RnnoiseProcessor>}
 */
export function createRnnoiseProcessor() {
    if (!rnnoiseModule) {
        rnnoiseModule = createRNNWasmModule();
    }

    return rnnoiseModule?.then(mod => new RnnoiseProcessor(mod));
}


################################################################################

## File: .\jitsi-meet\react\features\stream-effects\rnnoise\RnnoiseProcessor.ts

/* eslint-disable no-bitwise */

interface IRnnoiseModule extends EmscriptenModule {
    _rnnoise_create: () => number;
    _rnnoise_destroy: (context: number) => void;
    _rnnoise_process_frame: (context: number, input: number, output: number) => number;
}

/**
 * Constant. Rnnoise default sample size, samples of different size won't work.
 */
export const RNNOISE_SAMPLE_LENGTH = 480;

/**
 *  Constant. Rnnoise only takes inputs of 480 PCM float32 samples thus 480*4.
 */
const RNNOISE_BUFFER_SIZE: number = RNNOISE_SAMPLE_LENGTH * 4;

/**
 *  Constant. Rnnoise only takes operates on 44.1Khz float 32 little endian PCM.
 */
const PCM_FREQUENCY = 44100;

/**
 * Used to shift a 32 bit number by 16 bits.
 */
const SHIFT_16_BIT_NR = 32768;

/**
 * Represents an adaptor for the rnnoise library compiled to webassembly. The class takes care of webassembly
 * memory management and exposes rnnoise functionality such as PCM audio denoising and VAD (voice activity
 * detection) scores.
 */
export default class RnnoiseProcessor {
    /**
     * Rnnoise context object needed to perform the audio processing.
     */
    private _context: number;

    /**
     * State flag, check if the instance was destroyed.
     */
    private _destroyed = false;

    /**
     * WASM interface through which calls to rnnoise are made.
     */
    private _wasmInterface: IRnnoiseModule;

    /**
     * WASM dynamic memory buffer used as input for rnnoise processing method.
     */
    private _wasmPcmInput: number;

    /**
     * The Float32Array index representing the start point in the wasm heap of the _wasmPcmInput buffer.
     */
    private _wasmPcmInputF32Index: number;

    /**
     * Constructor.
     *
     * @class
     * @param {Object} wasmInterface - WebAssembly module interface that exposes rnnoise functionality.
     */
    constructor(wasmInterface: IRnnoiseModule) {
        // Considering that we deal with dynamic allocated memory employ exception safety strong guarantee
        // i.e. in case of exception there are no side effects.
        try {
            this._wasmInterface = wasmInterface;

            // For VAD score purposes only allocate the buffers once and reuse them
            this._wasmPcmInput = this._wasmInterface._malloc(RNNOISE_BUFFER_SIZE);

            this._wasmPcmInputF32Index = this._wasmPcmInput >> 2;

            if (!this._wasmPcmInput) {
                throw Error('Failed to create wasm input memory buffer!');
            }

            this._context = this._wasmInterface._rnnoise_create();
        } catch (error) {
            // release can be called even if not all the components were initialized.
            this.destroy();
            throw error;
        }
    }

    /**
     * Release resources associated with the wasm context. If something goes downhill here
     * i.e. Exception is thrown, there is nothing much we can do.
     *
     * @returns {void}
     */
    _releaseWasmResources(): void {
        // For VAD score purposes only allocate the buffers once and reuse them
        if (this._wasmPcmInput) {
            this._wasmInterface._free(this._wasmPcmInput);
        }

        if (this._context) {
            this._wasmInterface._rnnoise_destroy(this._context);
        }
    }

    /**
     * Rnnoise can only operate on a certain PCM array size.
     *
     * @returns {number} - The PCM sample array size as required by rnnoise.
     */
    getSampleLength(): number {
        return RNNOISE_SAMPLE_LENGTH;
    }

    /**
     * Rnnoise can only operate on a certain format of PCM sample namely float 32 44.1Kz.
     *
     * @returns {number} - PCM sample frequency as required by rnnoise.
     */
    getRequiredPCMFrequency(): number {
        return PCM_FREQUENCY;
    }

    /**
     * Release any resources required by the rnnoise context this needs to be called
     * before destroying any context that uses the processor.
     *
     * @returns {void}
     */
    destroy(): void {
        // Attempting to release a non initialized processor, do nothing.
        if (this._destroyed) {
            return;
        }

        this._releaseWasmResources();

        this._destroyed = true;
    }

    /**
     * Calculate the Voice Activity Detection for a raw Float32 PCM sample Array.
     * The size of the array must be of exactly 480 samples, this constraint comes from the rnnoise library.
     *
     * @param {Float32Array} pcmFrame - Array containing 32 bit PCM samples.
     * @returns {Float} Contains VAD score in the interval 0 - 1 i.e. 0.90.
     */
    calculateAudioFrameVAD(pcmFrame: Float32Array): number {
        return this.processAudioFrame(pcmFrame);
    }

    /**
     * Process an audio frame, optionally denoising the input pcmFrame and returning the Voice Activity Detection score
     * for a raw Float32 PCM sample Array.
     * The size of the array must be of exactly 480 samples, this constraint comes from the rnnoise library.
     *
     * @param {Float32Array} pcmFrame - Array containing 32 bit PCM samples. Parameter is also used as output
     * when {@code shouldDenoise} is true.
     * @param {boolean} shouldDenoise - Should the denoised frame be returned in pcmFrame.
     * @returns {Float} Contains VAD score in the interval 0 - 1 i.e. 0.90 .
     */
    processAudioFrame(pcmFrame: Float32Array, shouldDenoise: Boolean = false): number {
        // Convert 32 bit Float PCM samples to 16 bit Float PCM samples as that's what rnnoise accepts as input
        for (let i = 0; i < RNNOISE_SAMPLE_LENGTH; i++) {
            this._wasmInterface.HEAPF32[this._wasmPcmInputF32Index + i] = pcmFrame[i] * SHIFT_16_BIT_NR;
        }

        // Use the same buffer for input/output, rnnoise supports this behavior
        const vadScore = this._wasmInterface._rnnoise_process_frame(
            this._context,
            this._wasmPcmInput,
            this._wasmPcmInput
        );

        // Rnnoise denoises the frame by default but we can avoid unnecessary operations if the calling
        // client doesn't use the denoised frame.
        if (shouldDenoise) {
            // Convert back to 32 bit PCM
            for (let i = 0; i < RNNOISE_SAMPLE_LENGTH; i++) {
                pcmFrame[i] = this._wasmInterface.HEAPF32[this._wasmPcmInputF32Index + i] / SHIFT_16_BIT_NR;
            }
        }

        return vadScore;
    }
}


################################################################################

## File: .\jitsi-meet\react\features\stream-effects\virtual-background\index.ts

/* eslint-disable lines-around-comment */
import { IStore } from '../../app/types';
import { showWarningNotification } from '../../notifications/actions';
import { NOTIFICATION_TIMEOUT_TYPE } from '../../notifications/constants';
import { timeout } from '../../virtual-background/functions';
import logger from '../../virtual-background/logger';

import JitsiStreamBackgroundEffect, { IBackgroundEffectOptions } from './JitsiStreamBackgroundEffect';
// @ts-expect-error
import createTFLiteModule from './vendor/tflite/tflite';
// @ts-expect-error
import createTFLiteSIMDModule from './vendor/tflite/tflite-simd';
const models = {
    modelLandscape: 'libs/selfie_segmentation_landscape.tflite'
};
/* eslint-enable lines-around-comment */

let modelBuffer: ArrayBuffer;
let tflite: any;
let wasmCheck;
let isWasmDisabled = false;

const segmentationDimensions = {
    modelLandscape: {
        height: 144,
        width: 256
    }
};

/**
 * Creates a new instance of JitsiStreamBackgroundEffect. This loads the Meet background model that is used to
 * extract person segmentation.
 *
 * @param {Object} virtualBackground - The virtual object that contains the background image source and
 * the isVirtualBackground flag that indicates if virtual image is activated.
 * @param {Function} dispatch - The Redux dispatch function.
 * @returns {Promise<JitsiStreamBackgroundEffect>}
 */
export async function createVirtualBackgroundEffect(virtualBackground: IBackgroundEffectOptions['virtualBackground'],
        dispatch?: IStore['dispatch']) {
    if (!MediaStreamTrack.prototype.getSettings && !MediaStreamTrack.prototype.getConstraints) {
        throw new Error('JitsiStreamBackgroundEffect not supported!');
    }

    if (isWasmDisabled) {
        dispatch?.(showWarningNotification({
            titleKey: 'virtualBackground.backgroundEffectError'
        }, NOTIFICATION_TIMEOUT_TYPE.LONG));

        return;
    }

    // Checks if WebAssembly feature is supported or enabled by/in the browser.
    // Conditional import of wasm-check package is done to prevent
    // the browser from crashing when the user opens the app.

    if (!tflite) {
        try {
            wasmCheck = require('wasm-check');
            const tfliteTimeout = 10000;

            if (wasmCheck?.feature?.simd) {
                tflite = await timeout(tfliteTimeout, createTFLiteSIMDModule());
            } else {
                tflite = await timeout(tfliteTimeout, createTFLiteModule());
            }
        } catch (err: any) {
            if (err?.message === '408') {
                logger.error('Failed to download tflite model!');
                dispatch?.(showWarningNotification({
                    titleKey: 'virtualBackground.backgroundEffectError'
                }, NOTIFICATION_TIMEOUT_TYPE.LONG));
            } else {
                isWasmDisabled = true;
                logger.error('Looks like WebAssembly is disabled or not supported on this browser', err);
                dispatch?.(showWarningNotification({
                    titleKey: 'virtualBackground.webAssemblyWarning',
                    descriptionKey: 'virtualBackground.webAssemblyWarningDescription'
                }, NOTIFICATION_TIMEOUT_TYPE.LONG));
            }

            return;
        }
    }

    if (!modelBuffer) {
        const modelResponse = await fetch(models.modelLandscape);

        if (!modelResponse.ok) {
            throw new Error('Failed to download tflite model!');
        }

        modelBuffer = await modelResponse.arrayBuffer();

        tflite.HEAPU8.set(new Uint8Array(modelBuffer), tflite._getModelBufferMemoryOffset());

        tflite._loadModel(modelBuffer.byteLength);
    }

    const options = {
        ...segmentationDimensions.modelLandscape,
        virtualBackground
    };

    return new JitsiStreamBackgroundEffect(tflite, options);
}


################################################################################

## File: .\jitsi-meet\react\features\stream-effects\virtual-background\JitsiStreamBackgroundEffect.ts

import { VIRTUAL_BACKGROUND_TYPE } from '../../virtual-background/constants';

import {
    CLEAR_TIMEOUT,
    SET_TIMEOUT,
    TIMEOUT_TICK,
    timerWorkerScript
} from './TimerWorker';

export interface IBackgroundEffectOptions {
    height: number;
    virtualBackground: {
        backgroundType?: string;
        blurValue?: number;
        virtualSource?: string;
    };
    width: number;
}

/**
 * Represents a modified MediaStream that adds effects to video background.
 * <tt>JitsiStreamBackgroundEffect</tt> does the processing of the original
 * video stream.
 */
export default class JitsiStreamBackgroundEffect {
    _model: any;
    _options: IBackgroundEffectOptions;
    _stream: any;
    _segmentationPixelCount: number;
    _inputVideoElement: HTMLVideoElement;
    _maskFrameTimerWorker: Worker;
    _outputCanvasElement: HTMLCanvasElement;
    _outputCanvasCtx: CanvasRenderingContext2D | null;
    _segmentationMaskCtx: CanvasRenderingContext2D | null;
    _segmentationMask: ImageData;
    _segmentationMaskCanvas: HTMLCanvasElement;
    _virtualImage: HTMLImageElement;
    _virtualVideo: HTMLVideoElement;

    /**
     * Represents a modified video MediaStream track.
     *
     * @class
     * @param {Object} model - Meet model.
     * @param {Object} options - Segmentation dimensions.
     */
    constructor(model: Object, options: IBackgroundEffectOptions) {
        this._options = options;

        if (this._options.virtualBackground.backgroundType === VIRTUAL_BACKGROUND_TYPE.IMAGE) {
            this._virtualImage = document.createElement('img');
            this._virtualImage.crossOrigin = 'anonymous';
            this._virtualImage.src = this._options.virtualBackground.virtualSource ?? '';
        }
        this._model = model;
        this._segmentationPixelCount = this._options.width * this._options.height;

        // Bind event handler so it is only bound once for every instance.
        this._onMaskFrameTimer = this._onMaskFrameTimer.bind(this);

        // Workaround for FF issue https://bugzilla.mozilla.org/show_bug.cgi?id=1388974
        this._outputCanvasElement = document.createElement('canvas');
        this._outputCanvasElement.getContext('2d');
        this._inputVideoElement = document.createElement('video');
    }

    /**
     * EventHandler onmessage for the maskFrameTimerWorker WebWorker.
     *
     * @private
     * @param {EventHandler} response - The onmessage EventHandler parameter.
     * @returns {void}
     */
    _onMaskFrameTimer(response: { data: { id: number; }; }) {
        if (response.data.id === TIMEOUT_TICK) {
            this._renderMask();
        }
    }

    /**
     * Represents the run post processing.
     *
     * @returns {void}
     */
    runPostProcessing() {

        const track = this._stream.getVideoTracks()[0];
        const { height, width } = track.getSettings() ?? track.getConstraints();
        const { backgroundType } = this._options.virtualBackground;

        if (!this._outputCanvasCtx) {
            return;
        }

        this._outputCanvasElement.height = height;
        this._outputCanvasElement.width = width;
        this._outputCanvasCtx.globalCompositeOperation = 'copy';

        // Draw segmentation mask.

        // Smooth out the edges.
        this._outputCanvasCtx.filter = backgroundType === VIRTUAL_BACKGROUND_TYPE.IMAGE ? 'blur(4px)' : 'blur(8px)';
        this._outputCanvasCtx?.drawImage( // @ts-ignore
            this._segmentationMaskCanvas,
            0,
            0,
            this._options.width,
            this._options.height,
            0,
            0,
            this._inputVideoElement.width,
            this._inputVideoElement.height
        );
        this._outputCanvasCtx.globalCompositeOperation = 'source-in';
        this._outputCanvasCtx.filter = 'none';

        // Draw the foreground video.
        // @ts-ignore
        this._outputCanvasCtx?.drawImage(this._inputVideoElement, 0, 0);

        // Draw the background.
        this._outputCanvasCtx.globalCompositeOperation = 'destination-over';
        if (backgroundType === VIRTUAL_BACKGROUND_TYPE.IMAGE) {
            this._outputCanvasCtx?.drawImage( // @ts-ignore
                backgroundType === VIRTUAL_BACKGROUND_TYPE.IMAGE
                    ? this._virtualImage : this._virtualVideo,
                0,
                0,
                this._outputCanvasElement.width,
                this._outputCanvasElement.height
            );
        } else {
            this._outputCanvasCtx.filter = `blur(${this._options.virtualBackground.blurValue}px)`;

            // @ts-ignore
            this._outputCanvasCtx?.drawImage(this._inputVideoElement, 0, 0);
        }
    }

    /**
     * Represents the run Tensorflow Interference.
     *
     * @returns {void}
     */
    runInference() {
        this._model._runInference();
        const outputMemoryOffset = this._model._getOutputMemoryOffset() / 4;

        for (let i = 0; i < this._segmentationPixelCount; i++) {
            const person = this._model.HEAPF32[outputMemoryOffset + i];

            // Sets only the alpha component of each pixel.
            this._segmentationMask.data[(i * 4) + 3] = 255 * person;

        }
        this._segmentationMaskCtx?.putImageData(this._segmentationMask, 0, 0);
    }

    /**
     * Loop function to render the background mask.
     *
     * @private
     * @returns {void}
     */
    _renderMask() {
        this.resizeSource();
        this.runInference();
        this.runPostProcessing();

        this._maskFrameTimerWorker.postMessage({
            id: SET_TIMEOUT,
            timeMs: 1000 / 30
        });
    }

    /**
     * Represents the resize source process.
     *
     * @returns {void}
     */
    resizeSource() {
        this._segmentationMaskCtx?.drawImage( // @ts-ignore
            this._inputVideoElement,
            0,
            0,
            this._inputVideoElement.width,
            this._inputVideoElement.height,
            0,
            0,
            this._options.width,
            this._options.height
        );

        const imageData = this._segmentationMaskCtx?.getImageData(
            0,
            0,
            this._options.width,
            this._options.height
        );
        const inputMemoryOffset = this._model._getInputMemoryOffset() / 4;

        for (let i = 0; i < this._segmentationPixelCount; i++) {
            this._model.HEAPF32[inputMemoryOffset + (i * 3)] = Number(imageData?.data[i * 4]) / 255;
            this._model.HEAPF32[inputMemoryOffset + (i * 3) + 1] = Number(imageData?.data[(i * 4) + 1]) / 255;
            this._model.HEAPF32[inputMemoryOffset + (i * 3) + 2] = Number(imageData?.data[(i * 4) + 2]) / 255;
        }
    }

    /**
     * Checks if the local track supports this effect.
     *
     * @param {JitsiLocalTrack} jitsiLocalTrack - Track to apply effect.
     * @returns {boolean} - Returns true if this effect can run on the specified track
     * false otherwise.
     */
    isEnabled(jitsiLocalTrack: any) {
        return jitsiLocalTrack.isVideoTrack() && jitsiLocalTrack.videoType === 'camera';
    }

    /**
     * Starts loop to capture video frame and render the segmentation mask.
     *
     * @param {MediaStream} stream - Stream to be used for processing.
     * @returns {MediaStream} - The stream with the applied effect.
     */
    startEffect(stream: MediaStream) {
        this._stream = stream;
        this._maskFrameTimerWorker = new Worker(timerWorkerScript, { name: 'Blur effect worker' });
        this._maskFrameTimerWorker.onmessage = this._onMaskFrameTimer;
        const firstVideoTrack = this._stream.getVideoTracks()[0];
        const { height, frameRate, width }
            = firstVideoTrack.getSettings ? firstVideoTrack.getSettings() : firstVideoTrack.getConstraints();

        this._segmentationMask = new ImageData(this._options.width, this._options.height);
        this._segmentationMaskCanvas = document.createElement('canvas');
        this._segmentationMaskCanvas.width = this._options.width;
        this._segmentationMaskCanvas.height = this._options.height;
        this._segmentationMaskCtx = this._segmentationMaskCanvas.getContext('2d');

        this._outputCanvasElement.width = parseInt(width, 10);
        this._outputCanvasElement.height = parseInt(height, 10);
        this._outputCanvasCtx = this._outputCanvasElement.getContext('2d');
        this._inputVideoElement.width = parseInt(width, 10);
        this._inputVideoElement.height = parseInt(height, 10);
        this._inputVideoElement.autoplay = true;
        this._inputVideoElement.srcObject = this._stream;
        this._inputVideoElement.onloadeddata = () => {
            this._maskFrameTimerWorker.postMessage({
                id: SET_TIMEOUT,
                timeMs: 1000 / 30
            });
        };

        return this._outputCanvasElement.captureStream(parseInt(frameRate, 10));
    }

    /**
     * Stops the capture and render loop.
     *
     * @returns {void}
     */
    stopEffect() {
        this._maskFrameTimerWorker.postMessage({
            id: CLEAR_TIMEOUT
        });

        this._maskFrameTimerWorker.terminate();
    }
}


################################################################################

## File: .\jitsi-meet\react\features\stream-effects\virtual-background\TimerWorker.ts


/**
 * SET_TIMEOUT constant is used to set interval and it is set in
 * the id property of the request.data property. TimeMs property must
 * also be set.
 *
 * ```
 * //Request.data example:
 * {
 *      id: SET_TIMEOUT,
 *      timeMs: 33
 * }
 * ```
 */
export const SET_TIMEOUT = 1;

/**
 * CLEAR_TIMEOUT constant is used to clear the interval and it is set in
 * the id property of the request.data property.
 *
 * ```
 * {
 *      id: CLEAR_TIMEOUT
 * }
 * ```
 */
export const CLEAR_TIMEOUT = 2;

/**
 * TIMEOUT_TICK constant is used as response and it is set in the id property.
 *
 * ```
 * {
 *      id: TIMEOUT_TICK
 * }
 * ```
 */
export const TIMEOUT_TICK = 3;

/**
 * The following code is needed as string to create a URL from a Blob.
 * The URL is then passed to a WebWorker. Reason for this is to enable
 * use of setInterval that is not throttled when tab is inactive.
 */
const code = `
    var timer;

    onmessage = function(request) {
        switch (request.data.id) {
        case ${SET_TIMEOUT}: {
            timer = setTimeout(() => {
                postMessage({ id: ${TIMEOUT_TICK} });
            }, request.data.timeMs);
            break;
        }
        case ${CLEAR_TIMEOUT}: {
            if (timer) {
                clearTimeout(timer);
            }
            break;
        }
        }
    };
`;

// @ts-ignore
export const timerWorkerScript = URL.createObjectURL(new Blob([ code ], { type: 'application/javascript' }));


################################################################################

## File: .\jitsi-meet\react\features\stream-effects\virtual-background\vendor\tflite\tflite-simd.js


var createTFLiteSIMDModule = (function() {
  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
  if (typeof __filename !== 'undefined') _scriptDir = _scriptDir || __filename;
  return (
function(createTFLiteSIMDModule) {
  createTFLiteSIMDModule = createTFLiteSIMDModule || {};

var Module=typeof createTFLiteSIMDModule!=="undefined"?createTFLiteSIMDModule:{};var readyPromiseResolve,readyPromiseReject;Module["ready"]=new Promise(function(resolve,reject){readyPromiseResolve=resolve;readyPromiseReject=reject});var moduleOverrides={};var key;for(key in Module){if(Module.hasOwnProperty(key)){moduleOverrides[key]=Module[key]}}var arguments_=[];var thisProgram="./this.program";var quit_=function(status,toThrow){throw toThrow};var ENVIRONMENT_IS_WEB=false;var ENVIRONMENT_IS_WORKER=false;var ENVIRONMENT_IS_NODE=false;var ENVIRONMENT_IS_SHELL=false;ENVIRONMENT_IS_WEB=typeof window==="object";ENVIRONMENT_IS_WORKER=typeof importScripts==="function";ENVIRONMENT_IS_NODE=typeof process==="object"&&typeof process.versions==="object"&&typeof process.versions.node==="string";ENVIRONMENT_IS_SHELL=!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_NODE&&!ENVIRONMENT_IS_WORKER;var scriptDirectory="";function locateFile(path){if(Module["locateFile"]){return Module["locateFile"](path,scriptDirectory)}return scriptDirectory+path}var read_,readAsync,readBinary,setWindowTitle;var nodeFS;var nodePath;if(ENVIRONMENT_IS_NODE){if(ENVIRONMENT_IS_WORKER){scriptDirectory=require("path").dirname(scriptDirectory)+"/"}else{scriptDirectory=__dirname+"/"}read_=function shell_read(filename,binary){if(!nodeFS)nodeFS=require("fs");if(!nodePath)nodePath=require("path");filename=nodePath["normalize"](filename);return nodeFS["readFileSync"](filename,binary?null:"utf8")};readBinary=function readBinary(filename){var ret=read_(filename,true);if(!ret.buffer){ret=new Uint8Array(ret)}assert(ret.buffer);return ret};if(process["argv"].length>1){thisProgram=process["argv"][1].replace(/\\/g,"/")}arguments_=process["argv"].slice(2);process["on"]("uncaughtException",function(ex){if(!(ex instanceof ExitStatus)){throw ex}});process["on"]("unhandledRejection",abort);quit_=function(status){process["exit"](status)};Module["inspect"]=function(){return"[Emscripten Module object]"}}else if(ENVIRONMENT_IS_SHELL){if(typeof read!="undefined"){read_=function shell_read(f){return read(f)}}readBinary=function readBinary(f){var data;if(typeof readbuffer==="function"){return new Uint8Array(readbuffer(f))}data=read(f,"binary");assert(typeof data==="object");return data};if(typeof scriptArgs!="undefined"){arguments_=scriptArgs}else if(typeof arguments!="undefined"){arguments_=arguments}if(typeof quit==="function"){quit_=function(status){quit(status)}}if(typeof print!=="undefined"){if(typeof console==="undefined")console={};console.log=print;console.warn=console.error=typeof printErr!=="undefined"?printErr:print}}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){if(ENVIRONMENT_IS_WORKER){scriptDirectory=self.location.href}else if(typeof document!=="undefined"&&document.currentScript){scriptDirectory=document.currentScript.src}if(_scriptDir){scriptDirectory=_scriptDir}if(scriptDirectory.indexOf("blob:")!==0){scriptDirectory=scriptDirectory.substr(0,scriptDirectory.lastIndexOf("/")+1)}else{scriptDirectory=""}{read_=function(url){var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.send(null);return xhr.responseText};if(ENVIRONMENT_IS_WORKER){readBinary=function(url){var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.responseType="arraybuffer";xhr.send(null);return new Uint8Array(xhr.response)}}readAsync=function(url,onload,onerror){var xhr=new XMLHttpRequest;xhr.open("GET",url,true);xhr.responseType="arraybuffer";xhr.onload=function(){if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response);return}onerror()};xhr.onerror=onerror;xhr.send(null)}}setWindowTitle=function(title){document.title=title}}else{}var out=Module["print"]||console.log.bind(console);var err=Module["printErr"]||console.warn.bind(console);for(key in moduleOverrides){if(moduleOverrides.hasOwnProperty(key)){Module[key]=moduleOverrides[key]}}moduleOverrides=null;if(Module["arguments"])arguments_=Module["arguments"];if(Module["thisProgram"])thisProgram=Module["thisProgram"];if(Module["quit"])quit_=Module["quit"];var wasmBinary;if(Module["wasmBinary"])wasmBinary=Module["wasmBinary"];var noExitRuntime;if(Module["noExitRuntime"])noExitRuntime=Module["noExitRuntime"];if(typeof WebAssembly!=="object"){abort("no native wasm support detected")}var wasmMemory;var ABORT=false;var EXITSTATUS;function assert(condition,text){if(!condition){abort("Assertion failed: "+text)}}var UTF8Decoder=typeof TextDecoder!=="undefined"?new TextDecoder("utf8"):undefined;function UTF8ArrayToString(heap,idx,maxBytesToRead){var endIdx=idx+maxBytesToRead;var endPtr=idx;while(heap[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&heap.subarray&&UTF8Decoder){return UTF8Decoder.decode(heap.subarray(idx,endPtr))}else{var str="";while(idx<endPtr){var u0=heap[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=heap[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=heap[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2}else{u0=(u0&7)<<18|u1<<12|u2<<6|heap[idx++]&63}if(u0<65536){str+=String.fromCharCode(u0)}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}}}return str}function UTF8ToString(ptr,maxBytesToRead){return ptr?UTF8ArrayToString(HEAPU8,ptr,maxBytesToRead):""}function writeAsciiToMemory(str,buffer,dontAddNull){for(var i=0;i<str.length;++i){HEAP8[buffer++>>0]=str.charCodeAt(i)}if(!dontAddNull)HEAP8[buffer>>0]=0}function alignUp(x,multiple){if(x%multiple>0){x+=multiple-x%multiple}return x}var buffer,HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateGlobalBufferAndViews(buf){buffer=buf;Module["HEAP8"]=HEAP8=new Int8Array(buf);Module["HEAP16"]=HEAP16=new Int16Array(buf);Module["HEAP32"]=HEAP32=new Int32Array(buf);Module["HEAPU8"]=HEAPU8=new Uint8Array(buf);Module["HEAPU16"]=HEAPU16=new Uint16Array(buf);Module["HEAPU32"]=HEAPU32=new Uint32Array(buf);Module["HEAPF32"]=HEAPF32=new Float32Array(buf);Module["HEAPF64"]=HEAPF64=new Float64Array(buf)}var INITIAL_MEMORY=Module["INITIAL_MEMORY"]||16777216;var wasmTable;var __ATPRERUN__=[];var __ATINIT__=[];var __ATMAIN__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;var runtimeExited=false;__ATINIT__.push({func:function(){___wasm_call_ctors()}});function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift())}}callRuntimeCallbacks(__ATPRERUN__)}function initRuntime(){runtimeInitialized=true;callRuntimeCallbacks(__ATINIT__)}function preMain(){callRuntimeCallbacks(__ATMAIN__)}function exitRuntime(){runtimeExited=true}function postRun(){if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift())}}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;function addRunDependency(id){runDependencies++;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}}function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}Module["preloadedImages"]={};Module["preloadedAudios"]={};function abort(what){if(Module["onAbort"]){Module["onAbort"](what)}what+="";err(what);ABORT=true;EXITSTATUS=1;what="abort("+what+"). Build with -s ASSERTIONS=1 for more info.";var e=new WebAssembly.RuntimeError(what);readyPromiseReject(e);throw e}function hasPrefix(str,prefix){return String.prototype.startsWith?str.startsWith(prefix):str.indexOf(prefix)===0}var dataURIPrefix="data:application/octet-stream;base64,";function isDataURI(filename){return hasPrefix(filename,dataURIPrefix)}var fileURIPrefix="file://";function isFileURI(filename){return hasPrefix(filename,fileURIPrefix)}var wasmBinaryFile="tflite-simd.wasm";if(!isDataURI(wasmBinaryFile)){wasmBinaryFile=locateFile(wasmBinaryFile)}function getBinary(file){try{if(file==wasmBinaryFile&&wasmBinary){return new Uint8Array(wasmBinary)}if(readBinary){return readBinary(file)}else{throw"both async and sync fetching of the wasm failed"}}catch(err){abort(err)}}function getBinaryPromise(){if(!wasmBinary&&(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER)){if(typeof fetch==="function"&&!isFileURI(wasmBinaryFile)){return fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){if(!response["ok"]){throw"failed to load wasm binary file at '"+wasmBinaryFile+"'"}return response["arrayBuffer"]()}).catch(function(){return getBinary(wasmBinaryFile)})}else{if(readAsync){return new Promise(function(resolve,reject){readAsync(wasmBinaryFile,function(response){resolve(new Uint8Array(response))},reject)})}}}return Promise.resolve().then(function(){return getBinary(wasmBinaryFile)})}function createWasm(){var info={"a":asmLibraryArg};function receiveInstance(instance,module){var exports=instance.exports;Module["asm"]=exports;wasmMemory=Module["asm"]["q"];updateGlobalBufferAndViews(wasmMemory.buffer);wasmTable=Module["asm"]["D"];removeRunDependency("wasm-instantiate")}addRunDependency("wasm-instantiate");function receiveInstantiatedSource(output){receiveInstance(output["instance"])}function instantiateArrayBuffer(receiver){return getBinaryPromise().then(function(binary){return WebAssembly.instantiate(binary,info)}).then(receiver,function(reason){err("failed to asynchronously prepare wasm: "+reason);abort(reason)})}function instantiateAsync(){if(!wasmBinary&&typeof WebAssembly.instantiateStreaming==="function"&&!isDataURI(wasmBinaryFile)&&!isFileURI(wasmBinaryFile)&&typeof fetch==="function"){return fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){var result=WebAssembly.instantiateStreaming(response,info);return result.then(receiveInstantiatedSource,function(reason){err("wasm streaming compile failed: "+reason);err("falling back to ArrayBuffer instantiation");return instantiateArrayBuffer(receiveInstantiatedSource)})})}else{return instantiateArrayBuffer(receiveInstantiatedSource)}}if(Module["instantiateWasm"]){try{var exports=Module["instantiateWasm"](info,receiveInstance);return exports}catch(e){err("Module.instantiateWasm callback failed with error: "+e);return false}}instantiateAsync().catch(readyPromiseReject);return{}}function callRuntimeCallbacks(callbacks){while(callbacks.length>0){var callback=callbacks.shift();if(typeof callback=="function"){callback(Module);continue}var func=callback.func;if(typeof func==="number"){if(callback.arg===undefined){wasmTable.get(func)()}else{wasmTable.get(func)(callback.arg)}}else{func(callback.arg===undefined?null:callback.arg)}}}function _abort(){abort()}var _emscripten_get_now;if(ENVIRONMENT_IS_NODE){_emscripten_get_now=function(){var t=process["hrtime"]();return t[0]*1e3+t[1]/1e6}}else if(typeof dateNow!=="undefined"){_emscripten_get_now=dateNow}else _emscripten_get_now=function(){return performance.now()};var _emscripten_get_now_is_monotonic=true;function setErrNo(value){HEAP32[___errno_location()>>2]=value;return value}function _clock_gettime(clk_id,tp){var now;if(clk_id===0){now=Date.now()}else if((clk_id===1||clk_id===4)&&_emscripten_get_now_is_monotonic){now=_emscripten_get_now()}else{setErrNo(28);return-1}HEAP32[tp>>2]=now/1e3|0;HEAP32[tp+4>>2]=now%1e3*1e3*1e3|0;return 0}function _dlopen(filename,flag){abort("To use dlopen, you need to use Emscripten's linking support, see https://github.com/emscripten-core/emscripten/wiki/Linking")}function _dlsym(handle,symbol){abort("To use dlopen, you need to use Emscripten's linking support, see https://github.com/emscripten-core/emscripten/wiki/Linking")}function _emscripten_memcpy_big(dest,src,num){HEAPU8.copyWithin(dest,src,src+num)}function _emscripten_get_heap_size(){return HEAPU8.length}function emscripten_realloc_buffer(size){try{wasmMemory.grow(size-buffer.byteLength+65535>>>16);updateGlobalBufferAndViews(wasmMemory.buffer);return 1}catch(e){}}function _emscripten_resize_heap(requestedSize){requestedSize=requestedSize>>>0;var oldSize=_emscripten_get_heap_size();var maxHeapSize=2147483648;if(requestedSize>maxHeapSize){return false}var minHeapSize=16777216;for(var cutDown=1;cutDown<=4;cutDown*=2){var overGrownHeapSize=oldSize*(1+.2/cutDown);overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296);var newSize=Math.min(maxHeapSize,alignUp(Math.max(minHeapSize,requestedSize,overGrownHeapSize),65536));var replacement=emscripten_realloc_buffer(newSize);if(replacement){return true}}return false}function _emscripten_thread_sleep(msecs){var start=_emscripten_get_now();while(_emscripten_get_now()-start<msecs){}}var ENV={};function getExecutableName(){return thisProgram||"./this.program"}function getEnvStrings(){if(!getEnvStrings.strings){var lang=(typeof navigator==="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8";var env={"USER":"web_user","LOGNAME":"web_user","PATH":"/","PWD":"/","HOME":"/home/web_user","LANG":lang,"_":getExecutableName()};for(var x in ENV){env[x]=ENV[x]}var strings=[];for(var x in env){strings.push(x+"="+env[x])}getEnvStrings.strings=strings}return getEnvStrings.strings}var SYSCALLS={mappings:{},buffers:[null,[],[]],printChar:function(stream,curr){var buffer=SYSCALLS.buffers[stream];if(curr===0||curr===10){(stream===1?out:err)(UTF8ArrayToString(buffer,0));buffer.length=0}else{buffer.push(curr)}},varargs:undefined,get:function(){SYSCALLS.varargs+=4;var ret=HEAP32[SYSCALLS.varargs-4>>2];return ret},getStr:function(ptr){var ret=UTF8ToString(ptr);return ret},get64:function(low,high){return low}};function _environ_get(__environ,environ_buf){var bufSize=0;getEnvStrings().forEach(function(string,i){var ptr=environ_buf+bufSize;HEAP32[__environ+i*4>>2]=ptr;writeAsciiToMemory(string,ptr);bufSize+=string.length+1});return 0}function _environ_sizes_get(penviron_count,penviron_buf_size){var strings=getEnvStrings();HEAP32[penviron_count>>2]=strings.length;var bufSize=0;strings.forEach(function(string){bufSize+=string.length+1});HEAP32[penviron_buf_size>>2]=bufSize;return 0}function _exit(status){exit(status)}function _fd_close(fd){return 0}function _fd_seek(fd,offset_low,offset_high,whence,newOffset){}function _fd_write(fd,iov,iovcnt,pnum){var num=0;for(var i=0;i<iovcnt;i++){var ptr=HEAP32[iov+i*8>>2];var len=HEAP32[iov+(i*8+4)>>2];for(var j=0;j<len;j++){SYSCALLS.printChar(fd,HEAPU8[ptr+j])}num+=len}HEAP32[pnum>>2]=num;return 0}function _pthread_create(){return 6}function _pthread_join(){return 28}function _sysconf(name){switch(name){case 30:return 16384;case 85:var maxHeapSize=2147483648;return maxHeapSize/16384;case 132:case 133:case 12:case 137:case 138:case 15:case 235:case 16:case 17:case 18:case 19:case 20:case 149:case 13:case 10:case 236:case 153:case 9:case 21:case 22:case 159:case 154:case 14:case 77:case 78:case 139:case 82:case 68:case 67:case 164:case 11:case 29:case 47:case 48:case 95:case 52:case 51:case 46:return 200809;case 27:case 246:case 127:case 128:case 23:case 24:case 160:case 161:case 181:case 182:case 242:case 183:case 184:case 243:case 244:case 245:case 165:case 178:case 179:case 49:case 50:case 168:case 169:case 175:case 170:case 171:case 172:case 97:case 76:case 32:case 173:case 35:case 80:case 81:case 79:return-1;case 176:case 177:case 7:case 155:case 8:case 157:case 125:case 126:case 92:case 93:case 129:case 130:case 131:case 94:case 91:return 1;case 74:case 60:case 69:case 70:case 4:return 1024;case 31:case 42:case 72:return 32;case 87:case 26:case 33:return 2147483647;case 34:case 1:return 47839;case 38:case 36:return 99;case 43:case 37:return 2048;case 0:return 2097152;case 3:return 65536;case 28:return 32768;case 44:return 32767;case 75:return 16384;case 39:return 1e3;case 89:return 700;case 71:return 256;case 40:return 255;case 2:return 100;case 180:return 64;case 25:return 20;case 5:return 16;case 6:return 6;case 73:return 4;case 84:{if(typeof navigator==="object")return navigator["hardwareConcurrency"]||1;return 1}}setErrNo(28);return-1}var asmLibraryArg={"a":_abort,"n":_clock_gettime,"i":_dlopen,"e":_dlsym,"l":_emscripten_memcpy_big,"m":_emscripten_resize_heap,"o":_emscripten_thread_sleep,"p":_environ_get,"g":_environ_sizes_get,"j":_exit,"h":_fd_close,"k":_fd_seek,"c":_fd_write,"d":_pthread_create,"f":_pthread_join,"b":_sysconf};var asm=createWasm();var ___wasm_call_ctors=Module["___wasm_call_ctors"]=function(){return(___wasm_call_ctors=Module["___wasm_call_ctors"]=Module["asm"]["r"]).apply(null,arguments)};var _getModelBufferMemoryOffset=Module["_getModelBufferMemoryOffset"]=function(){return(_getModelBufferMemoryOffset=Module["_getModelBufferMemoryOffset"]=Module["asm"]["s"]).apply(null,arguments)};var _getInputMemoryOffset=Module["_getInputMemoryOffset"]=function(){return(_getInputMemoryOffset=Module["_getInputMemoryOffset"]=Module["asm"]["t"]).apply(null,arguments)};var _getInputHeight=Module["_getInputHeight"]=function(){return(_getInputHeight=Module["_getInputHeight"]=Module["asm"]["u"]).apply(null,arguments)};var _getInputWidth=Module["_getInputWidth"]=function(){return(_getInputWidth=Module["_getInputWidth"]=Module["asm"]["v"]).apply(null,arguments)};var _getInputChannelCount=Module["_getInputChannelCount"]=function(){return(_getInputChannelCount=Module["_getInputChannelCount"]=Module["asm"]["w"]).apply(null,arguments)};var _getOutputMemoryOffset=Module["_getOutputMemoryOffset"]=function(){return(_getOutputMemoryOffset=Module["_getOutputMemoryOffset"]=Module["asm"]["x"]).apply(null,arguments)};var _getOutputHeight=Module["_getOutputHeight"]=function(){return(_getOutputHeight=Module["_getOutputHeight"]=Module["asm"]["y"]).apply(null,arguments)};var _getOutputWidth=Module["_getOutputWidth"]=function(){return(_getOutputWidth=Module["_getOutputWidth"]=Module["asm"]["z"]).apply(null,arguments)};var _getOutputChannelCount=Module["_getOutputChannelCount"]=function(){return(_getOutputChannelCount=Module["_getOutputChannelCount"]=Module["asm"]["A"]).apply(null,arguments)};var _loadModel=Module["_loadModel"]=function(){return(_loadModel=Module["_loadModel"]=Module["asm"]["B"]).apply(null,arguments)};var _runInference=Module["_runInference"]=function(){return(_runInference=Module["_runInference"]=Module["asm"]["C"]).apply(null,arguments)};var ___errno_location=Module["___errno_location"]=function(){return(___errno_location=Module["___errno_location"]=Module["asm"]["E"]).apply(null,arguments)};var calledRun;function ExitStatus(status){this.name="ExitStatus";this.message="Program terminated with exit("+status+")";this.status=status}dependenciesFulfilled=function runCaller(){if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller};function run(args){args=args||arguments_;if(runDependencies>0){return}preRun();if(runDependencies>0){return}function doRun(){if(calledRun)return;calledRun=true;Module["calledRun"]=true;if(ABORT)return;initRuntime();preMain();readyPromiseResolve(Module);if(Module["onRuntimeInitialized"])Module["onRuntimeInitialized"]();postRun()}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout(function(){setTimeout(function(){Module["setStatus"]("")},1);doRun()},1)}else{doRun()}}Module["run"]=run;function exit(status,implicit){if(implicit&&noExitRuntime&&status===0){return}if(noExitRuntime){}else{EXITSTATUS=status;exitRuntime();if(Module["onExit"])Module["onExit"](status);ABORT=true}quit_(status,new ExitStatus(status))}if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0){Module["preInit"].pop()()}}noExitRuntime=true;run();


  return createTFLiteSIMDModule.ready
}
);
})();
if (typeof exports === 'object' && typeof module === 'object')
  module.exports = createTFLiteSIMDModule;
else if (typeof define === 'function' && define['amd'])
  define([], function() { return createTFLiteSIMDModule; });
else if (typeof exports === 'object')
  exports["createTFLiteSIMDModule"] = createTFLiteSIMDModule;


################################################################################

## File: .\jitsi-meet\react\features\stream-effects\virtual-background\vendor\tflite\tflite.js


var createTFLiteModule = (function() {
  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
  if (typeof __filename !== 'undefined') _scriptDir = _scriptDir || __filename;
  return (
function(createTFLiteModule) {
  createTFLiteModule = createTFLiteModule || {};

var Module=typeof createTFLiteModule!=="undefined"?createTFLiteModule:{};var readyPromiseResolve,readyPromiseReject;Module["ready"]=new Promise(function(resolve,reject){readyPromiseResolve=resolve;readyPromiseReject=reject});var moduleOverrides={};var key;for(key in Module){if(Module.hasOwnProperty(key)){moduleOverrides[key]=Module[key]}}var arguments_=[];var thisProgram="./this.program";var quit_=function(status,toThrow){throw toThrow};var ENVIRONMENT_IS_WEB=false;var ENVIRONMENT_IS_WORKER=false;var ENVIRONMENT_IS_NODE=false;var ENVIRONMENT_IS_SHELL=false;ENVIRONMENT_IS_WEB=typeof window==="object";ENVIRONMENT_IS_WORKER=typeof importScripts==="function";ENVIRONMENT_IS_NODE=typeof process==="object"&&typeof process.versions==="object"&&typeof process.versions.node==="string";ENVIRONMENT_IS_SHELL=!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_NODE&&!ENVIRONMENT_IS_WORKER;var scriptDirectory="";function locateFile(path){if(Module["locateFile"]){return Module["locateFile"](path,scriptDirectory)}return scriptDirectory+path}var read_,readAsync,readBinary,setWindowTitle;var nodeFS;var nodePath;if(ENVIRONMENT_IS_NODE){if(ENVIRONMENT_IS_WORKER){scriptDirectory=require("path").dirname(scriptDirectory)+"/"}else{scriptDirectory=__dirname+"/"}read_=function shell_read(filename,binary){if(!nodeFS)nodeFS=require("fs");if(!nodePath)nodePath=require("path");filename=nodePath["normalize"](filename);return nodeFS["readFileSync"](filename,binary?null:"utf8")};readBinary=function readBinary(filename){var ret=read_(filename,true);if(!ret.buffer){ret=new Uint8Array(ret)}assert(ret.buffer);return ret};if(process["argv"].length>1){thisProgram=process["argv"][1].replace(/\\/g,"/")}arguments_=process["argv"].slice(2);process["on"]("uncaughtException",function(ex){if(!(ex instanceof ExitStatus)){throw ex}});process["on"]("unhandledRejection",abort);quit_=function(status){process["exit"](status)};Module["inspect"]=function(){return"[Emscripten Module object]"}}else if(ENVIRONMENT_IS_SHELL){if(typeof read!="undefined"){read_=function shell_read(f){return read(f)}}readBinary=function readBinary(f){var data;if(typeof readbuffer==="function"){return new Uint8Array(readbuffer(f))}data=read(f,"binary");assert(typeof data==="object");return data};if(typeof scriptArgs!="undefined"){arguments_=scriptArgs}else if(typeof arguments!="undefined"){arguments_=arguments}if(typeof quit==="function"){quit_=function(status){quit(status)}}if(typeof print!=="undefined"){if(typeof console==="undefined")console={};console.log=print;console.warn=console.error=typeof printErr!=="undefined"?printErr:print}}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){if(ENVIRONMENT_IS_WORKER){scriptDirectory=self.location.href}else if(typeof document!=="undefined"&&document.currentScript){scriptDirectory=document.currentScript.src}if(_scriptDir){scriptDirectory=_scriptDir}if(scriptDirectory.indexOf("blob:")!==0){scriptDirectory=scriptDirectory.substr(0,scriptDirectory.lastIndexOf("/")+1)}else{scriptDirectory=""}{read_=function(url){var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.send(null);return xhr.responseText};if(ENVIRONMENT_IS_WORKER){readBinary=function(url){var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.responseType="arraybuffer";xhr.send(null);return new Uint8Array(xhr.response)}}readAsync=function(url,onload,onerror){var xhr=new XMLHttpRequest;xhr.open("GET",url,true);xhr.responseType="arraybuffer";xhr.onload=function(){if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response);return}onerror()};xhr.onerror=onerror;xhr.send(null)}}setWindowTitle=function(title){document.title=title}}else{}var out=Module["print"]||console.log.bind(console);var err=Module["printErr"]||console.warn.bind(console);for(key in moduleOverrides){if(moduleOverrides.hasOwnProperty(key)){Module[key]=moduleOverrides[key]}}moduleOverrides=null;if(Module["arguments"])arguments_=Module["arguments"];if(Module["thisProgram"])thisProgram=Module["thisProgram"];if(Module["quit"])quit_=Module["quit"];var wasmBinary;if(Module["wasmBinary"])wasmBinary=Module["wasmBinary"];var noExitRuntime;if(Module["noExitRuntime"])noExitRuntime=Module["noExitRuntime"];if(typeof WebAssembly!=="object"){abort("no native wasm support detected")}var wasmMemory;var ABORT=false;var EXITSTATUS;function assert(condition,text){if(!condition){abort("Assertion failed: "+text)}}var UTF8Decoder=typeof TextDecoder!=="undefined"?new TextDecoder("utf8"):undefined;function UTF8ArrayToString(heap,idx,maxBytesToRead){var endIdx=idx+maxBytesToRead;var endPtr=idx;while(heap[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&heap.subarray&&UTF8Decoder){return UTF8Decoder.decode(heap.subarray(idx,endPtr))}else{var str="";while(idx<endPtr){var u0=heap[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=heap[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=heap[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2}else{u0=(u0&7)<<18|u1<<12|u2<<6|heap[idx++]&63}if(u0<65536){str+=String.fromCharCode(u0)}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}}}return str}function UTF8ToString(ptr,maxBytesToRead){return ptr?UTF8ArrayToString(HEAPU8,ptr,maxBytesToRead):""}function writeAsciiToMemory(str,buffer,dontAddNull){for(var i=0;i<str.length;++i){HEAP8[buffer++>>0]=str.charCodeAt(i)}if(!dontAddNull)HEAP8[buffer>>0]=0}function alignUp(x,multiple){if(x%multiple>0){x+=multiple-x%multiple}return x}var buffer,HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateGlobalBufferAndViews(buf){buffer=buf;Module["HEAP8"]=HEAP8=new Int8Array(buf);Module["HEAP16"]=HEAP16=new Int16Array(buf);Module["HEAP32"]=HEAP32=new Int32Array(buf);Module["HEAPU8"]=HEAPU8=new Uint8Array(buf);Module["HEAPU16"]=HEAPU16=new Uint16Array(buf);Module["HEAPU32"]=HEAPU32=new Uint32Array(buf);Module["HEAPF32"]=HEAPF32=new Float32Array(buf);Module["HEAPF64"]=HEAPF64=new Float64Array(buf)}var INITIAL_MEMORY=Module["INITIAL_MEMORY"]||16777216;var wasmTable;var __ATPRERUN__=[];var __ATINIT__=[];var __ATMAIN__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;var runtimeExited=false;__ATINIT__.push({func:function(){___wasm_call_ctors()}});function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift())}}callRuntimeCallbacks(__ATPRERUN__)}function initRuntime(){runtimeInitialized=true;callRuntimeCallbacks(__ATINIT__)}function preMain(){callRuntimeCallbacks(__ATMAIN__)}function exitRuntime(){runtimeExited=true}function postRun(){if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift())}}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;function addRunDependency(id){runDependencies++;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}}function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}Module["preloadedImages"]={};Module["preloadedAudios"]={};function abort(what){if(Module["onAbort"]){Module["onAbort"](what)}what+="";err(what);ABORT=true;EXITSTATUS=1;what="abort("+what+"). Build with -s ASSERTIONS=1 for more info.";var e=new WebAssembly.RuntimeError(what);readyPromiseReject(e);throw e}function hasPrefix(str,prefix){return String.prototype.startsWith?str.startsWith(prefix):str.indexOf(prefix)===0}var dataURIPrefix="data:application/octet-stream;base64,";function isDataURI(filename){return hasPrefix(filename,dataURIPrefix)}var fileURIPrefix="file://";function isFileURI(filename){return hasPrefix(filename,fileURIPrefix)}var wasmBinaryFile="tflite.wasm";if(!isDataURI(wasmBinaryFile)){wasmBinaryFile=locateFile(wasmBinaryFile)}function getBinary(file){try{if(file==wasmBinaryFile&&wasmBinary){return new Uint8Array(wasmBinary)}if(readBinary){return readBinary(file)}else{throw"both async and sync fetching of the wasm failed"}}catch(err){abort(err)}}function getBinaryPromise(){if(!wasmBinary&&(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER)){if(typeof fetch==="function"&&!isFileURI(wasmBinaryFile)){return fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){if(!response["ok"]){throw"failed to load wasm binary file at '"+wasmBinaryFile+"'"}return response["arrayBuffer"]()}).catch(function(){return getBinary(wasmBinaryFile)})}else{if(readAsync){return new Promise(function(resolve,reject){readAsync(wasmBinaryFile,function(response){resolve(new Uint8Array(response))},reject)})}}}return Promise.resolve().then(function(){return getBinary(wasmBinaryFile)})}function createWasm(){var info={"a":asmLibraryArg};function receiveInstance(instance,module){var exports=instance.exports;Module["asm"]=exports;wasmMemory=Module["asm"]["q"];updateGlobalBufferAndViews(wasmMemory.buffer);wasmTable=Module["asm"]["D"];removeRunDependency("wasm-instantiate")}addRunDependency("wasm-instantiate");function receiveInstantiatedSource(output){receiveInstance(output["instance"])}function instantiateArrayBuffer(receiver){return getBinaryPromise().then(function(binary){return WebAssembly.instantiate(binary,info)}).then(receiver,function(reason){err("failed to asynchronously prepare wasm: "+reason);abort(reason)})}function instantiateAsync(){if(!wasmBinary&&typeof WebAssembly.instantiateStreaming==="function"&&!isDataURI(wasmBinaryFile)&&!isFileURI(wasmBinaryFile)&&typeof fetch==="function"){return fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){var result=WebAssembly.instantiateStreaming(response,info);return result.then(receiveInstantiatedSource,function(reason){err("wasm streaming compile failed: "+reason);err("falling back to ArrayBuffer instantiation");return instantiateArrayBuffer(receiveInstantiatedSource)})})}else{return instantiateArrayBuffer(receiveInstantiatedSource)}}if(Module["instantiateWasm"]){try{var exports=Module["instantiateWasm"](info,receiveInstance);return exports}catch(e){err("Module.instantiateWasm callback failed with error: "+e);return false}}instantiateAsync().catch(readyPromiseReject);return{}}function callRuntimeCallbacks(callbacks){while(callbacks.length>0){var callback=callbacks.shift();if(typeof callback=="function"){callback(Module);continue}var func=callback.func;if(typeof func==="number"){if(callback.arg===undefined){wasmTable.get(func)()}else{wasmTable.get(func)(callback.arg)}}else{func(callback.arg===undefined?null:callback.arg)}}}function _abort(){abort()}var _emscripten_get_now;if(ENVIRONMENT_IS_NODE){_emscripten_get_now=function(){var t=process["hrtime"]();return t[0]*1e3+t[1]/1e6}}else if(typeof dateNow!=="undefined"){_emscripten_get_now=dateNow}else _emscripten_get_now=function(){return performance.now()};var _emscripten_get_now_is_monotonic=true;function setErrNo(value){HEAP32[___errno_location()>>2]=value;return value}function _clock_gettime(clk_id,tp){var now;if(clk_id===0){now=Date.now()}else if((clk_id===1||clk_id===4)&&_emscripten_get_now_is_monotonic){now=_emscripten_get_now()}else{setErrNo(28);return-1}HEAP32[tp>>2]=now/1e3|0;HEAP32[tp+4>>2]=now%1e3*1e3*1e3|0;return 0}function _dlopen(filename,flag){abort("To use dlopen, you need to use Emscripten's linking support, see https://github.com/emscripten-core/emscripten/wiki/Linking")}function _dlsym(handle,symbol){abort("To use dlopen, you need to use Emscripten's linking support, see https://github.com/emscripten-core/emscripten/wiki/Linking")}function _emscripten_memcpy_big(dest,src,num){HEAPU8.copyWithin(dest,src,src+num)}function _emscripten_get_heap_size(){return HEAPU8.length}function emscripten_realloc_buffer(size){try{wasmMemory.grow(size-buffer.byteLength+65535>>>16);updateGlobalBufferAndViews(wasmMemory.buffer);return 1}catch(e){}}function _emscripten_resize_heap(requestedSize){requestedSize=requestedSize>>>0;var oldSize=_emscripten_get_heap_size();var maxHeapSize=2147483648;if(requestedSize>maxHeapSize){return false}var minHeapSize=16777216;for(var cutDown=1;cutDown<=4;cutDown*=2){var overGrownHeapSize=oldSize*(1+.2/cutDown);overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296);var newSize=Math.min(maxHeapSize,alignUp(Math.max(minHeapSize,requestedSize,overGrownHeapSize),65536));var replacement=emscripten_realloc_buffer(newSize);if(replacement){return true}}return false}function _emscripten_thread_sleep(msecs){var start=_emscripten_get_now();while(_emscripten_get_now()-start<msecs){}}var ENV={};function getExecutableName(){return thisProgram||"./this.program"}function getEnvStrings(){if(!getEnvStrings.strings){var lang=(typeof navigator==="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8";var env={"USER":"web_user","LOGNAME":"web_user","PATH":"/","PWD":"/","HOME":"/home/web_user","LANG":lang,"_":getExecutableName()};for(var x in ENV){env[x]=ENV[x]}var strings=[];for(var x in env){strings.push(x+"="+env[x])}getEnvStrings.strings=strings}return getEnvStrings.strings}var SYSCALLS={mappings:{},buffers:[null,[],[]],printChar:function(stream,curr){var buffer=SYSCALLS.buffers[stream];if(curr===0||curr===10){(stream===1?out:err)(UTF8ArrayToString(buffer,0));buffer.length=0}else{buffer.push(curr)}},varargs:undefined,get:function(){SYSCALLS.varargs+=4;var ret=HEAP32[SYSCALLS.varargs-4>>2];return ret},getStr:function(ptr){var ret=UTF8ToString(ptr);return ret},get64:function(low,high){return low}};function _environ_get(__environ,environ_buf){var bufSize=0;getEnvStrings().forEach(function(string,i){var ptr=environ_buf+bufSize;HEAP32[__environ+i*4>>2]=ptr;writeAsciiToMemory(string,ptr);bufSize+=string.length+1});return 0}function _environ_sizes_get(penviron_count,penviron_buf_size){var strings=getEnvStrings();HEAP32[penviron_count>>2]=strings.length;var bufSize=0;strings.forEach(function(string){bufSize+=string.length+1});HEAP32[penviron_buf_size>>2]=bufSize;return 0}function _exit(status){exit(status)}function _fd_close(fd){return 0}function _fd_seek(fd,offset_low,offset_high,whence,newOffset){}function _fd_write(fd,iov,iovcnt,pnum){var num=0;for(var i=0;i<iovcnt;i++){var ptr=HEAP32[iov+i*8>>2];var len=HEAP32[iov+(i*8+4)>>2];for(var j=0;j<len;j++){SYSCALLS.printChar(fd,HEAPU8[ptr+j])}num+=len}HEAP32[pnum>>2]=num;return 0}function _pthread_create(){return 6}function _pthread_join(){return 28}function _sysconf(name){switch(name){case 30:return 16384;case 85:var maxHeapSize=2147483648;return maxHeapSize/16384;case 132:case 133:case 12:case 137:case 138:case 15:case 235:case 16:case 17:case 18:case 19:case 20:case 149:case 13:case 10:case 236:case 153:case 9:case 21:case 22:case 159:case 154:case 14:case 77:case 78:case 139:case 82:case 68:case 67:case 164:case 11:case 29:case 47:case 48:case 95:case 52:case 51:case 46:return 200809;case 27:case 246:case 127:case 128:case 23:case 24:case 160:case 161:case 181:case 182:case 242:case 183:case 184:case 243:case 244:case 245:case 165:case 178:case 179:case 49:case 50:case 168:case 169:case 175:case 170:case 171:case 172:case 97:case 76:case 32:case 173:case 35:case 80:case 81:case 79:return-1;case 176:case 177:case 7:case 155:case 8:case 157:case 125:case 126:case 92:case 93:case 129:case 130:case 131:case 94:case 91:return 1;case 74:case 60:case 69:case 70:case 4:return 1024;case 31:case 42:case 72:return 32;case 87:case 26:case 33:return 2147483647;case 34:case 1:return 47839;case 38:case 36:return 99;case 43:case 37:return 2048;case 0:return 2097152;case 3:return 65536;case 28:return 32768;case 44:return 32767;case 75:return 16384;case 39:return 1e3;case 89:return 700;case 71:return 256;case 40:return 255;case 2:return 100;case 180:return 64;case 25:return 20;case 5:return 16;case 6:return 6;case 73:return 4;case 84:{if(typeof navigator==="object")return navigator["hardwareConcurrency"]||1;return 1}}setErrNo(28);return-1}var asmLibraryArg={"a":_abort,"n":_clock_gettime,"i":_dlopen,"e":_dlsym,"l":_emscripten_memcpy_big,"m":_emscripten_resize_heap,"o":_emscripten_thread_sleep,"p":_environ_get,"g":_environ_sizes_get,"j":_exit,"h":_fd_close,"k":_fd_seek,"c":_fd_write,"d":_pthread_create,"f":_pthread_join,"b":_sysconf};var asm=createWasm();var ___wasm_call_ctors=Module["___wasm_call_ctors"]=function(){return(___wasm_call_ctors=Module["___wasm_call_ctors"]=Module["asm"]["r"]).apply(null,arguments)};var _getModelBufferMemoryOffset=Module["_getModelBufferMemoryOffset"]=function(){return(_getModelBufferMemoryOffset=Module["_getModelBufferMemoryOffset"]=Module["asm"]["s"]).apply(null,arguments)};var _getInputMemoryOffset=Module["_getInputMemoryOffset"]=function(){return(_getInputMemoryOffset=Module["_getInputMemoryOffset"]=Module["asm"]["t"]).apply(null,arguments)};var _getInputHeight=Module["_getInputHeight"]=function(){return(_getInputHeight=Module["_getInputHeight"]=Module["asm"]["u"]).apply(null,arguments)};var _getInputWidth=Module["_getInputWidth"]=function(){return(_getInputWidth=Module["_getInputWidth"]=Module["asm"]["v"]).apply(null,arguments)};var _getInputChannelCount=Module["_getInputChannelCount"]=function(){return(_getInputChannelCount=Module["_getInputChannelCount"]=Module["asm"]["w"]).apply(null,arguments)};var _getOutputMemoryOffset=Module["_getOutputMemoryOffset"]=function(){return(_getOutputMemoryOffset=Module["_getOutputMemoryOffset"]=Module["asm"]["x"]).apply(null,arguments)};var _getOutputHeight=Module["_getOutputHeight"]=function(){return(_getOutputHeight=Module["_getOutputHeight"]=Module["asm"]["y"]).apply(null,arguments)};var _getOutputWidth=Module["_getOutputWidth"]=function(){return(_getOutputWidth=Module["_getOutputWidth"]=Module["asm"]["z"]).apply(null,arguments)};var _getOutputChannelCount=Module["_getOutputChannelCount"]=function(){return(_getOutputChannelCount=Module["_getOutputChannelCount"]=Module["asm"]["A"]).apply(null,arguments)};var _loadModel=Module["_loadModel"]=function(){return(_loadModel=Module["_loadModel"]=Module["asm"]["B"]).apply(null,arguments)};var _runInference=Module["_runInference"]=function(){return(_runInference=Module["_runInference"]=Module["asm"]["C"]).apply(null,arguments)};var ___errno_location=Module["___errno_location"]=function(){return(___errno_location=Module["___errno_location"]=Module["asm"]["E"]).apply(null,arguments)};var calledRun;function ExitStatus(status){this.name="ExitStatus";this.message="Program terminated with exit("+status+")";this.status=status}dependenciesFulfilled=function runCaller(){if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller};function run(args){args=args||arguments_;if(runDependencies>0){return}preRun();if(runDependencies>0){return}function doRun(){if(calledRun)return;calledRun=true;Module["calledRun"]=true;if(ABORT)return;initRuntime();preMain();readyPromiseResolve(Module);if(Module["onRuntimeInitialized"])Module["onRuntimeInitialized"]();postRun()}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout(function(){setTimeout(function(){Module["setStatus"]("")},1);doRun()},1)}else{doRun()}}Module["run"]=run;function exit(status,implicit){if(implicit&&noExitRuntime&&status===0){return}if(noExitRuntime){}else{EXITSTATUS=status;exitRuntime();if(Module["onExit"])Module["onExit"](status);ABORT=true}quit_(status,new ExitStatus(status))}if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0){Module["preInit"].pop()()}}noExitRuntime=true;run();


  return createTFLiteModule.ready
}
);
})();
if (typeof exports === 'object' && typeof module === 'object')
  module.exports = createTFLiteModule;
else if (typeof define === 'function' && define['amd'])
  define([], function() { return createTFLiteModule; });
else if (typeof exports === 'object')
  exports["createTFLiteModule"] = createTFLiteModule;


################################################################################

## File: .\jitsi-meet\react\features\subtitles\actions.any.ts

import { DEFAULT_LANGUAGE } from '../base/i18n/i18next';

import {
    REMOVE_TRANSCRIPT_MESSAGE,
    SET_REQUESTING_SUBTITLES,
    TOGGLE_REQUESTING_SUBTITLES,
    UPDATE_TRANSCRIPT_MESSAGE
} from './actionTypes';

/**
 * Signals that a transcript has to be removed from the state.
 *
 * @param {string} transcriptMessageID - The message_id to be removed.
 * @returns {{
 *      type: REMOVE_TRANSCRIPT_MESSAGE,
 *      transcriptMessageID: string,
 * }}
 */
export function removeTranscriptMessage(transcriptMessageID: string) {
    return {
        type: REMOVE_TRANSCRIPT_MESSAGE,
        transcriptMessageID
    };
}

/**
 * Signals that a transcript with the given message_id to be added or updated
 * is received.
 *
 * @param {string} transcriptMessageID -The transcript message_id to be updated.
 * @param {Object} newTranscriptMessage - The updated transcript message.
 * @returns {{
 *      type: UPDATE_TRANSCRIPT_MESSAGE,
 *      transcriptMessageID: string,
 *      newTranscriptMessage: Object
 * }}
 */
export function updateTranscriptMessage(transcriptMessageID: string,
        newTranscriptMessage: Object) {
    return {
        type: UPDATE_TRANSCRIPT_MESSAGE,
        transcriptMessageID,
        newTranscriptMessage
    };
}

/**
 * Signals that the local user has toggled the ClosedCaption button.
 *
 * @returns {{
 *      type: TOGGLE_REQUESTING_SUBTITLES
 * }}
 */
export function toggleRequestingSubtitles() {
    return {
        type: TOGGLE_REQUESTING_SUBTITLES
    };
}

/**
 * Signals that the local user has enabled or disabled the subtitles.
 *
 * @param {boolean} enabled - The new state of the subtitles.
 * @param {boolean} displaySubtitles - Whether to display subtitles or not.
 * @param {string} language - The language of the subtitles.
 * @returns {{
 *    type: SET_REQUESTING_SUBTITLES,
 *    enabled: boolean,
 *    displaySubtitles: boolean,
 *    language: string
 * }}
 */
export function setRequestingSubtitles(
        enabled: boolean,
        displaySubtitles = true,
        language: string | null = `translation-languages:${DEFAULT_LANGUAGE}`) {
    return {
        type: SET_REQUESTING_SUBTITLES,
        displaySubtitles,
        enabled,
        language
    };
}


################################################################################

## File: .\jitsi-meet\react\features\subtitles\actions.native.ts

export * from './actions.any';


################################################################################

## File: .\jitsi-meet\react\features\subtitles\actions.web.ts

import { IStore } from '../app/types';
import { toggleDialog } from '../base/dialog/actions';

import LanguageSelectorDialog from './components/web/LanguageSelectorDialog';

export * from './actions.any';

/**
 * Signals that the local user has toggled the LanguageSelector button.
 *
 * @returns {Function}
 */
export function toggleLanguageSelectorDialog() {
    return function(dispatch: IStore['dispatch']) {
        dispatch(toggleDialog(LanguageSelectorDialog));
    };
}


################################################################################

## File: .\jitsi-meet\react\features\subtitles\actionTypes.ts

/**
 * The type of (redux) action which indicates that an existing transcript
 * has to be removed from the state.
 *
 * {
 *      type: REMOVE_TRANSCRIPT_MESSAGE,
 *      transciptMessageID: string,
 * }
 */
export const REMOVE_TRANSCRIPT_MESSAGE = 'REMOVE_TRANSCRIPT_MESSAGE';

/**
 * The type of (redux) action which indicates that a transcript with an
 * given message_id to be added or updated is received.
 *
 * {
 *      type: UPDATE_TRANSCRIPT_MESSAGE,
 *      transcriptMessageID: string,
 *      newTranscriptMessage: Object
 * }
 */
export const UPDATE_TRANSCRIPT_MESSAGE = 'UPDATE_TRANSCRIPT_MESSAGE';

/**
 * The type of (redux) action which indicates that the user pressed the
 * ClosedCaption button, to either enable or disable subtitles based on the
 * current state.
 *
 * {
 *      type: TOGGLE_REQUESTING_SUBTITLES
 * }
 */
export const TOGGLE_REQUESTING_SUBTITLES
    = 'TOGGLE_REQUESTING_SUBTITLES';

/**
 * The type of (redux) action which indicates if the user set the state of
 * the subtitles to enabled or disabled.
 *
 * {
 *      type: SET_REQUESTING_SUBTITLES
 *      enabled: boolean
 * }
 */
export const SET_REQUESTING_SUBTITLES
    = 'SET_REQUESTING_SUBTITLES';


################################################################################

## File: .\jitsi-meet\react\features\subtitles\constants.ts

/**
 * The minimum font size for subtitles.
 */
export const MIN_SUBTITLES_FONT_SIZE = 16;


################################################################################

## File: .\jitsi-meet\react\features\subtitles\functions.any.ts

import { IReduxState } from '../app/types';
import { canAddTranscriber, isTranscribing } from '../transcribing/functions';

/**
 * Checks whether the participant can start the subtitles.
 *
 * @param {IReduxState} state - The redux state.
 * @returns {boolean} - True if the participant can start the subtitles.
 */
export function canStartSubtitles(state: IReduxState) {
    return canAddTranscriber(state) || isTranscribing(state);
}


################################################################################

## File: .\jitsi-meet\react\features\subtitles\functions.native.ts

/* eslint-disable max-params, max-len */

import { sendEvent } from '../mobile/external-api/functions';


/**
 * Event which will be emitted on the native side to indicate that the transcription chunk was received.
 */
const TRANSCRIPTION_CHUNK_RECEIVED = 'TRANSCRIPTION_CHUNK_RECEIVED';

/**
 * Logs when about the received transcription chunk.
 *
 * @param {string} transcriptMessageID - Transcription message id.
 * @param {string} language - The language of the transcribed message.
 * @param {Object} participant - The participant who send the message.
 * @param {any} text - The message text.
 * @param {any} _store - The store.
 * @returns {Event}
 */
export const notifyTranscriptionChunkReceived = (transcriptMessageID: string, language: string, participant: Object, text: any, _store?: any) =>
    sendEvent(
        _store,
        TRANSCRIPTION_CHUNK_RECEIVED,
        {
            messageID: transcriptMessageID,
            language,
            participant,
            text
        });


################################################################################

## File: .\jitsi-meet\react\features\subtitles\functions.web.ts

/* eslint-disable max-params, max-len */

import { MIN_SUBTITLES_FONT_SIZE } from './constants';

/**
 * Logs when about the received transcription chunk.
 *
 * @param {string} transcriptMessageID - Transcription message id.
 * @param {string} language - The language of the transcribed message.
 * @param {Object} participant - The participant who send the message.
 * @param {any} text - The message text.
 * @param {any} _store - The store.
 * @returns {Event}
 */
export const notifyTranscriptionChunkReceived = (transcriptMessageID: string, language: string, participant: Object, text: any, _store?: any) =>
    APP.API.notifyTranscriptionChunkReceived({
        messageID: transcriptMessageID,
        language,
        participant,
        ...text
    });

/**
 * Calculates the font size for the subtitles.
 *
 * @param {number} clientHeight - The height of the visible area of the window.
 * @returns {number}
 */
export function calculateSubtitlesFontSize(clientHeight?: number) {
    if (typeof clientHeight === 'undefined') {
        return MIN_SUBTITLES_FONT_SIZE;
    }

    return Math.max(Math.floor(clientHeight * 0.04), MIN_SUBTITLES_FONT_SIZE);
}


################################################################################

## File: .\jitsi-meet\react\features\subtitles\hooks.web.ts

import { useSelector } from 'react-redux';

import ClosedCaptionButton from './components/web/ClosedCaptionButton';
import { canStartSubtitles } from './functions.any';

const cc = {
    key: 'closedcaptions',
    Content: ClosedCaptionButton,
    group: 2
};

/**
 * A hook that returns the CC button if it is enabled and undefined otherwise.
 *
 *  @returns {Object | undefined}
 */
export function useClosedCaptionButton() {
    const isStartSubtitlesButtonVisible = useSelector(canStartSubtitles);

    if (isStartSubtitlesButtonVisible) {
        return cc;
    }
}


################################################################################

## File: .\jitsi-meet\react\features\subtitles\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/subtitles');


################################################################################

## File: .\jitsi-meet\react\features\subtitles\middleware.ts

import { AnyAction } from 'redux';

import { IStore } from '../app/types';
import { ENDPOINT_MESSAGE_RECEIVED } from '../base/conference/actionTypes';
import { isJwtFeatureEnabled } from '../base/jwt/functions';
import JitsiMeetJS from '../base/lib-jitsi-meet';
import { isLocalParticipantModerator } from '../base/participants/functions';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';

import {
    SET_REQUESTING_SUBTITLES,
    TOGGLE_REQUESTING_SUBTITLES
} from './actionTypes';
import {
    removeTranscriptMessage,
    setRequestingSubtitles,
    updateTranscriptMessage
} from './actions.any';
import { notifyTranscriptionChunkReceived } from './functions';
import logger from './logger';
import { ITranscriptMessage } from './types';


/**
 * The type of json-message which indicates that json carries a
 * transcription result.
 */
const JSON_TYPE_TRANSCRIPTION_RESULT = 'transcription-result';

/**
 * The type of json-message which indicates that json carries a
 * translation result.
 */
const JSON_TYPE_TRANSLATION_RESULT = 'translation-result';

/**
 * The local participant property which is used to set whether the local
 * participant wants to have a transcriber in the room.
 */
const P_NAME_REQUESTING_TRANSCRIPTION = 'requestingTranscription';

/**
 * The local participant property which is used to store the language
 * preference for translation for a participant.
 */
const P_NAME_TRANSLATION_LANGUAGE = 'translation_language';

/**
 * The dial command to use for starting a transcriber.
 */
const TRANSCRIBER_DIAL_NUMBER = 'jitsi_meet_transcribe';

/**
* Time after which the rendered subtitles will be removed.
*/
const REMOVE_AFTER_MS = 3000;

/**
 * Stability factor for a transcription. We'll treat a transcript as stable
 * beyond this value.
 */
const STABLE_TRANSCRIPTION_FACTOR = 0.85;

/**
 * Middleware that catches actions related to transcript messages to be rendered
 * in {@link Captions}.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {
    switch (action.type) {
    case ENDPOINT_MESSAGE_RECEIVED:
        return _endpointMessageReceived(store, next, action);

    case TOGGLE_REQUESTING_SUBTITLES: {
        const state = store.getState()['features/subtitles'];
        const toggledValue = !state._requestingSubtitles;

        _requestingSubtitlesChange(store, toggledValue, state._language);
        break;
    }
    case SET_REQUESTING_SUBTITLES:
        _requestingSubtitlesChange(store, action.enabled, action.language);
        break;
    }

    return next(action);
});

/**
 * Notifies the feature transcription that the action
 * {@code ENDPOINT_MESSAGE_RECEIVED} is being dispatched within a specific redux
 * store.
 *
 * @param {Store} store - The redux store in which the specified {@code action}
 * is being dispatched.
 * @param {Dispatch} next - The redux {@code dispatch} function to
 * dispatch the specified {@code action} to the specified {@code store}.
 * @param {Action} action - The redux action {@code ENDPOINT_MESSAGE_RECEIVED}
 * which is being dispatched in the specified {@code store}.
 * @private
 * @returns {Object} The value returned by {@code next(action)}.
 */
function _endpointMessageReceived(store: IStore, next: Function, action: AnyAction) {
    const { data: json } = action;

    if (![ JSON_TYPE_TRANSCRIPTION_RESULT, JSON_TYPE_TRANSLATION_RESULT ].includes(json?.type)) {
        return next(action);
    }

    const { dispatch, getState } = store;
    const state = getState();
    const language
        = state['features/base/conference'].conference
            ?.getLocalParticipantProperty(P_NAME_TRANSLATION_LANGUAGE);
    const { dumpTranscript, skipInterimTranscriptions } = state['features/base/config'].testing ?? {};

    const transcriptMessageID = json.message_id;
    const { name, id, avatar_url: avatarUrl } = json.participant;
    const participant = {
        avatarUrl,
        id,
        name
    };

    if (json.type === JSON_TYPE_TRANSLATION_RESULT && json.language === language) {
        // Displays final results in the target language if translation is
        // enabled.

        const newTranscriptMessage = {
            clearTimeOut: undefined,
            final: json.text,
            participant
        };

        _setClearerOnTranscriptMessage(dispatch, transcriptMessageID, newTranscriptMessage);
        dispatch(updateTranscriptMessage(transcriptMessageID, newTranscriptMessage));
    } else if (json.type === JSON_TYPE_TRANSCRIPTION_RESULT) {
        // Displays interim and final results without any translation if
        // translations are disabled.

        const { text } = json.transcript[0];

        // First, notify the external API.
        if (!(json.is_interim && skipInterimTranscriptions)) {
            const txt: any = {};

            if (!json.is_interim) {
                txt.final = text;
            } else if (json.stability > STABLE_TRANSCRIPTION_FACTOR) {
                txt.stable = text;
            } else {
                txt.unstable = text;
            }

            notifyTranscriptionChunkReceived(
                transcriptMessageID,
                json.language,
                participant,
                txt,
                store
            );

            if (navigator.product !== 'ReactNative') {

                // Dump transcript in a <transcript> element for debugging purposes.
                if (!json.is_interim && dumpTranscript) {
                    try {
                        let elem = document.body.getElementsByTagName('transcript')[0];

                        // eslint-disable-next-line max-depth
                        if (!elem) {
                            elem = document.createElement('transcript');
                            document.body.appendChild(elem);
                        }

                        elem.append(`${new Date(json.timestamp).toISOString()} ${participant.name}: ${text}`);
                    } catch (_) {
                        // Ignored.
                    }
                }
            }
        }

        // If the user is not requesting transcriptions just bail.
        // Regex to filter out all possible country codes after language code:
        // this should catch all notations like 'en-GB' 'en_GB' and 'enGB'
        // and be independent of the country code length
        if (json.language.replace(/[-_A-Z].*/, '') !== language) {
            return next(action);
        }

        if (json.is_interim && skipInterimTranscriptions) {
            return next(action);
        }

        // We update the previous transcript message with the same
        // message ID or adds a new transcript message if it does not
        // exist in the map.
        const existingMessage = state['features/subtitles']._transcriptMessages.get(transcriptMessageID);
        const newTranscriptMessage: ITranscriptMessage = {
            clearTimeOut: existingMessage?.clearTimeOut,
            participant
        };

        _setClearerOnTranscriptMessage(dispatch, transcriptMessageID, newTranscriptMessage);

        // If this is final result, update the state as a final result
        // and start a count down to remove the subtitle from the state
        if (!json.is_interim) {
            newTranscriptMessage.final = text;
        } else if (json.stability > STABLE_TRANSCRIPTION_FACTOR) {
            // If the message has a high stability, we can update the
            // stable field of the state and remove the previously
            // unstable results
            newTranscriptMessage.stable = text;
        } else {
            // Otherwise, this result has an unstable result, which we
            // add to the state. The unstable result will be appended
            // after the stable part.
            newTranscriptMessage.unstable = text;
        }

        dispatch(updateTranscriptMessage(transcriptMessageID, newTranscriptMessage));
    }

    return next(action);
}

/**
 * Toggle the local property 'requestingTranscription'. This will cause Jicofo
 * and Jigasi to decide whether the transcriber needs to be in the room.
 *
 * @param {Store} store - The redux store.
 * @param {boolean} enabled - Whether subtitles should be enabled or not.
 * @param {string} language - The language to use for translation.
 * @private
 * @returns {void}
 */
function _requestingSubtitlesChange(
        { dispatch, getState }: IStore,
        enabled: boolean,
        language?: string | null) {
    const state = getState();
    const { conference } = state['features/base/conference'];

    conference?.setLocalParticipantProperty(
        P_NAME_REQUESTING_TRANSCRIPTION,
        enabled);

    if (enabled && conference?.getTranscriptionStatus() === JitsiMeetJS.constants.transcriptionStatus.OFF) {
        const isModerator = isLocalParticipantModerator(state);
        const featureAllowed = isJwtFeatureEnabled(getState(), 'transcription', isModerator, false);

        if (featureAllowed) {
            conference?.dial(TRANSCRIBER_DIAL_NUMBER)
                .catch((e: any) => {
                    logger.error('Error dialing', e);

                    // let's back to the correct state
                    dispatch(setRequestingSubtitles(false, false, null));
                });
        }
    }

    if (enabled && language) {
        conference?.setLocalParticipantProperty(
            P_NAME_TRANSLATION_LANGUAGE,
            language.replace('translation-languages:', ''));
    }
}

/**
 * Set a timeout on a TranscriptMessage object so it clears itself when it's not
 * updated.
 *
 * @param {Function} dispatch - Dispatch remove action to store.
 * @param {string} transcriptMessageID - The id of the message to remove.
 * @param {Object} transcriptMessage - The message to remove.
 * @returns {void}
 */
function _setClearerOnTranscriptMessage(
        dispatch: IStore['dispatch'],
        transcriptMessageID: string,
        transcriptMessage: { clearTimeOut?: number; }) {
    if (transcriptMessage.clearTimeOut) {
        clearTimeout(transcriptMessage.clearTimeOut);
    }

    transcriptMessage.clearTimeOut
        = window.setTimeout(
            () => dispatch(removeTranscriptMessage(transcriptMessageID)),
            REMOVE_AFTER_MS);
}


################################################################################

## File: .\jitsi-meet\react\features\subtitles\reducer.ts

import ReducerRegistry from '../base/redux/ReducerRegistry';
import { TRANSCRIBER_LEFT } from '../transcribing/actionTypes';

import {
    REMOVE_TRANSCRIPT_MESSAGE,
    SET_REQUESTING_SUBTITLES,
    TOGGLE_REQUESTING_SUBTITLES,
    UPDATE_TRANSCRIPT_MESSAGE
} from './actionTypes';
import { ITranscriptMessage } from './types';

/**
 * Default State for 'features/transcription' feature.
 */
const defaultState = {
    _displaySubtitles: false,
    _transcriptMessages: new Map(),
    _requestingSubtitles: false,
    _language: null
};

export interface ISubtitlesState {
    _displaySubtitles: boolean;
    _language: string | null;
    _requestingSubtitles: boolean;
    _transcriptMessages: Map<string, ITranscriptMessage>;
}

/**
 * Listen for actions for the transcription feature to be used by the actions
 * to update the rendered transcription subtitles.
 */
ReducerRegistry.register<ISubtitlesState>('features/subtitles', (
        state = defaultState, action): ISubtitlesState => {
    switch (action.type) {
    case REMOVE_TRANSCRIPT_MESSAGE:
        return _removeTranscriptMessage(state, action);
    case UPDATE_TRANSCRIPT_MESSAGE:
        return _updateTranscriptMessage(state, action);
    case SET_REQUESTING_SUBTITLES:
        return {
            ...state,
            _displaySubtitles: action.displaySubtitles,
            _language: action.language,
            _requestingSubtitles: action.enabled
        };
    case TOGGLE_REQUESTING_SUBTITLES:
        return {
            ...state,
            _requestingSubtitles: !state._requestingSubtitles
        };
    case TRANSCRIBER_LEFT:
        return {
            ...state,
            ...defaultState
        };
    }

    return state;
});

/**
 * Reduces a specific Redux action REMOVE_TRANSCRIPT_MESSAGE of the feature
 * transcription.
 *
 * @param {Object} state - The Redux state of the feature transcription.
 * @param {Action} action -The Redux action REMOVE_TRANSCRIPT_MESSAGE to reduce.
 * @returns {Object} The new state of the feature transcription after the
 * reduction of the specified action.
 */
function _removeTranscriptMessage(state: ISubtitlesState, { transcriptMessageID }: { transcriptMessageID: string; }) {
    const newTranscriptMessages = new Map(state._transcriptMessages);

    // Deletes the key from Map once a final message arrives.
    newTranscriptMessages.delete(transcriptMessageID);

    return {
        ...state,
        _transcriptMessages: newTranscriptMessages
    };
}

/**
 * Reduces a specific Redux action UPDATE_TRANSCRIPT_MESSAGE of the feature
 * transcription.
 *
 * @param {Object} state - The Redux state of the feature transcription.
 * @param {Action} action -The Redux action UPDATE_TRANSCRIPT_MESSAGE to reduce.
 * @returns {Object} The new state of the feature transcription after the
 * reduction of the specified action.
 */
function _updateTranscriptMessage(state: ISubtitlesState, { transcriptMessageID, newTranscriptMessage }:
    { newTranscriptMessage: ITranscriptMessage; transcriptMessageID: string; }) {
    const newTranscriptMessages = new Map(state._transcriptMessages);

    // Updates the new message for the given key in the Map.
    newTranscriptMessages.set(transcriptMessageID, newTranscriptMessage);

    return {
        ...state,
        _transcriptMessages: newTranscriptMessages
    };
}


################################################################################

## File: .\jitsi-meet\react\features\subtitles\types.ts

export interface ITranscriptMessage {
    clearTimeOut?: number;
    final?: string;
    participant: {
        avatarUrl?: string;
        id?: string;
        name?: string;
    };
    stable?: string;
    unstable?: string;
}


################################################################################

## File: .\jitsi-meet\react\features\subtitles\components\native\styles.ts

import { BoxModel } from '../../../base/styles/components/styles/BoxModel';
import {
    ColorPalette
} from '../../../base/styles/components/styles/ColorPalette';
import BaseTheme from '../../../base/ui/components/BaseTheme.native';

/**
 * The styles of the React {@code Component}s of the feature subtitles.
 */
export default {
    languageItemWrapper: {
        alignItems: 'center',
        display: 'flex',
        flexDirection: 'row'
    },

    iconWrapper: {
        width: 32
    },

    activeLanguageItemText: {
        ...BaseTheme.typography.bodyShortBoldLarge
    },

    languageItemText: {
        ...BaseTheme.typography.bodyShortRegularLarge,
        color: BaseTheme.palette.text01,
        marginLeft: BaseTheme.spacing[2],
        marginVertical: BaseTheme.spacing[2]
    },

    subtitlesContainer: {
        backgroundColor: BaseTheme.palette.ui01,
        flex: 1
    },

    /**
     * Style for subtitle paragraph.
     */
    captionsSubtitles: {
        backgroundColor: ColorPalette.black,
        borderRadius: BoxModel.margin / 4,
        color: ColorPalette.white,
        marginBottom: BoxModel.margin,
        padding: BoxModel.padding / 2
    },

    /**
     * Style for the subtitles container.
     */
    captionsSubtitlesContainer: {
        alignItems: 'center',
        flexDirection: 'column',
        flexGrow: 0,
        justifyContent: 'flex-end',
        margin: BoxModel.margin
    },

    itemsContainer: {
        marginHorizontal: BaseTheme.spacing[4],
        marginVertical: BaseTheme.spacing[4]
    }
};


################################################################################

## File: .\jitsi-meet\react\features\talk-while-muted\actions.ts

import { SET_CURRENT_NOTIFICATION_UID } from './actionTypes';

/**
 * Sets UID of the the pending notification to use it when hiding
 * the notification is necessary, or unsets it when undefined (or no param) is
 * passed.
 *
 * @param {?number} uid - The UID of the notification.
 * @returns {{
 *     type: SET_CURRENT_NOTIFICATION_UID,
 *     uid: number
 * }}
 */
export function setCurrentNotificationUid(uid?: string) {
    return {
        type: SET_CURRENT_NOTIFICATION_UID,
        uid
    };
}


################################################################################

## File: .\jitsi-meet\react\features\talk-while-muted\actionTypes.ts

/**
 * The type of Redux action which sets the pending notification UID
 * to use it for when hiding the notification is necessary, or unsets it when
 * undefined (or no param) is passed.
 *
 * {
 *     type: SET_CURRENT_NOTIFICATION_UID,
 *     uid: ?number
 * }
 * @public
 */
export const SET_CURRENT_NOTIFICATION_UID = 'SET_CURRENT_NOTIFICATION_UID';


################################################################################

## File: .\jitsi-meet\react\features\talk-while-muted\constants.ts

/**
 * The identifier of the sound to be played when we got event for talking while muted.
 *
 * @type {string}
 */
export const TALK_WHILE_MUTED_SOUND_ID = 'TALK_WHILE_MUTED_SOUND';


################################################################################

## File: .\jitsi-meet\react\features\talk-while-muted\middleware.ts

import { APP_WILL_MOUNT, APP_WILL_UNMOUNT } from '../base/app/actionTypes';
import { CONFERENCE_JOINED } from '../base/conference/actionTypes';
import { JitsiConferenceEvents } from '../base/lib-jitsi-meet';
import { setAudioMuted } from '../base/media/actions';
import { MEDIA_TYPE } from '../base/media/constants';
import { raiseHand } from '../base/participants/actions';
import { getLocalParticipant } from '../base/participants/functions';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import { playSound, registerSound, unregisterSound } from '../base/sounds/actions';
import { hideNotification, showNotification } from '../notifications/actions';
import { NOTIFICATION_TIMEOUT_TYPE } from '../notifications/constants';
import { isForceMuted } from '../participants-pane/functions';
import { isAudioMuteButtonDisabled } from '../toolbox/functions.any';

import { setCurrentNotificationUid } from './actions';
import { TALK_WHILE_MUTED_SOUND_ID } from './constants';
import { TALK_WHILE_MUTED_SOUND_FILE } from './sounds';

MiddlewareRegistry.register(store => next => action => {
    const result = next(action);
    const { dispatch, getState } = store;
    const { conference } = action;

    switch (action.type) {
    case APP_WILL_MOUNT:
        dispatch(registerSound(TALK_WHILE_MUTED_SOUND_ID, TALK_WHILE_MUTED_SOUND_FILE));
        break;
    case APP_WILL_UNMOUNT:
        dispatch(unregisterSound(TALK_WHILE_MUTED_SOUND_ID));
        break;

    case CONFERENCE_JOINED: {
        conference.on(
            JitsiConferenceEvents.TRACK_MUTE_CHANGED,
            (track: any) => {
                const { currentNotificationUid } = getState()['features/talk-while-muted'];

                if (currentNotificationUid && track.isAudioTrack() && track.isLocal() && !track.isMuted()) {
                    dispatch(hideNotification(currentNotificationUid));
                    dispatch(setCurrentNotificationUid());
                }
            });
        conference.on(
            JitsiConferenceEvents.TALK_WHILE_MUTED, () => {
                const state = getState();
                const local = getLocalParticipant(state);

                // Display the talk while muted notification only when the audio button is not disabled.
                if (!isAudioMuteButtonDisabled(state)) {
                    const forceMuted = isForceMuted(local, MEDIA_TYPE.AUDIO, state);
                    const notification = dispatch(showNotification({
                        titleKey: 'toolbar.talkWhileMutedPopup',
                        customActionNameKey: [ forceMuted ? 'notify.raiseHandAction' : 'notify.unmute' ],
                        customActionHandler: [ () => dispatch(forceMuted ? raiseHand(true) : setAudioMuted(false)) ]
                    }, NOTIFICATION_TIMEOUT_TYPE.LONG));

                    const { soundsTalkWhileMuted } = getState()['features/base/settings'];

                    if (soundsTalkWhileMuted) {
                        dispatch(playSound(TALK_WHILE_MUTED_SOUND_ID));
                    }

                    if (notification) {
                        // we store the last start muted notification id that we showed,
                        // so we can hide it when unmuted mic is detected
                        dispatch(setCurrentNotificationUid(notification.uid));
                    }
                }
            });
        break;
    }
    }

    return result;
});


################################################################################

## File: .\jitsi-meet\react\features\talk-while-muted\reducer.ts

import ReducerRegistry from '../base/redux/ReducerRegistry';
import { set } from '../base/redux/functions';

import { SET_CURRENT_NOTIFICATION_UID } from './actionTypes';

export interface ITalkWhileMutedState {
    currentNotificationUid?: string;
}

/**
 * Reduces the redux actions of the feature talk while muted.
 */
ReducerRegistry.register<ITalkWhileMutedState>('features/talk-while-muted',
(state = {}, action): ITalkWhileMutedState => {
    switch (action.type) {
    case SET_CURRENT_NOTIFICATION_UID:
        return set(state, 'currentNotificationUid', action.uid);
    }

    return state;
});


################################################################################

## File: .\jitsi-meet\react\features\talk-while-muted\sounds.ts

/**
 * The file used for the talk while muted sound notification.
 *
 * @type {string}
 */
export const TALK_WHILE_MUTED_SOUND_FILE = 'talkWhileMuted.mp3';


################################################################################

## File: .\jitsi-meet\react\features\toolbox\actions.any.ts

import { VIDEO_MUTE, createToolbarEvent } from '../analytics/AnalyticsEvents';
import { sendAnalytics } from '../analytics/functions';
import { IStore } from '../app/types';
import { setAudioOnly } from '../base/audio-only/actions';
import { setVideoMuted } from '../base/media/actions';
import { VIDEO_MUTISM_AUTHORITY } from '../base/media/constants';

import {
    SET_TOOLBOX_ENABLED,
    SET_TOOLBOX_SHIFT_UP,
    SET_TOOLBOX_VISIBLE,
    TOGGLE_TOOLBOX_VISIBLE
} from './actionTypes';

/**
 * Enables/disables the toolbox.
 *
 * @param {boolean} enabled - True to enable the toolbox or false to disable it.
 * @returns {{
 *     type: SET_TOOLBOX_ENABLED,
 *     enabled: boolean
 * }}
 */
export function setToolboxEnabled(enabled: boolean) {
    return {
        type: SET_TOOLBOX_ENABLED,
        enabled
    };
}

/**
 * Shows/hides the toolbox.
 *
 * @param {boolean} visible - True to show the toolbox or false to hide it.
 * @returns {Function}
 */
export function setToolboxVisible(visible: boolean) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const { toolbarConfig } = getState()['features/base/config'];
        const alwaysVisible = toolbarConfig?.alwaysVisible;

        if (!visible && alwaysVisible) {
            return;
        }

        dispatch({
            type: SET_TOOLBOX_VISIBLE,
            visible
        });
    };
}

/**
 * Action to toggle the toolbox visibility.
 *
 * @returns {Function}
 */
export function toggleToolboxVisible() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const { toolbarConfig } = getState()['features/base/config'];
        const alwaysVisible = toolbarConfig?.alwaysVisible;
        const { visible } = state['features/toolbox'];

        if (visible && alwaysVisible) {
            return;
        }

        dispatch({
            type: TOGGLE_TOOLBOX_VISIBLE
        });
    };
}


/**
 * Action to handle toggle video from toolbox's video buttons.
 *
 * @param {boolean} muted - Whether to mute or unmute.
 * @param {boolean} showUI - When set to false will not display any error.
 * @param {boolean} ensureTrack - True if we want to ensure that a new track is
 * created if missing.
 * @returns {Function}
 */
export function handleToggleVideoMuted(muted: boolean, showUI: boolean, ensureTrack: boolean) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const { enabled: audioOnly } = state['features/base/audio-only'];

        sendAnalytics(createToolbarEvent(VIDEO_MUTE, { enable: muted }));
        if (audioOnly) {
            dispatch(setAudioOnly(false));
        }

        dispatch(
            setVideoMuted(
                muted,
                VIDEO_MUTISM_AUTHORITY.USER,
                ensureTrack));

        // FIXME: The old conference logic still relies on this event being
        // emitted.
        typeof APP === 'undefined'
            || APP.conference.muteVideo(muted, showUI);

    };
}

/**
 * Sets whether the toolbox should be shifted up or not.
 *
 * @param {boolean} shiftUp - Whether the toolbox should shift up or not.
 * @returns {Object}
 */
export function setShiftUp(shiftUp: boolean) {
    return {
        type: SET_TOOLBOX_SHIFT_UP,
        shiftUp
    };
}


################################################################################

## File: .\jitsi-meet\react\features\toolbox\actions.native.ts

import { CUSTOM_OVERFLOW_MENU_BUTTON_PRESSED } from './actionTypes';

export * from './actions.any';

/**
 * Shows the toolbox for specified timeout.
 *
 * @param {number} _timeout - Timeout for showing the toolbox.
 * @returns {Function}
 */
export function showToolbox(_timeout?: number): any {
    return {};
}

/**
 * Shows/hides the overflow menu.
 *
 * @param {boolean} _visible - True to show it or false to hide it.
 * @returns {{
 *     type: SET_OVERFLOW_MENU_VISIBLE,
 *     visible: boolean
 * }}
 */
export function setOverflowMenuVisible(_visible: boolean): any {
    return {};
}

/**
 * Creates a (redux) action which that a custom overflow menu button was pressed.
 *
 * @param {string} id - The id for the custom button.
 * @param {string} text - The label for the custom button.
 * @returns {{
 *     type: CUSTOM_OVERFLOW_MENU_BUTTON_PRESSED,
 *     id: string,
 *     text: string
 * }}
 */
export function customOverflowMenuButtonPressed(id: string, text: string) {
    return {
        type: CUSTOM_OVERFLOW_MENU_BUTTON_PRESSED,
        id,
        text
    };
}


################################################################################

## File: .\jitsi-meet\react\features\toolbox\actions.web.ts

import { IStore } from '../app/types';
import { overwriteConfig } from '../base/config/actions';
import { isMobileBrowser } from '../base/environment/utils';
import { isLayoutTileView } from '../video-layout/functions.any';

import {
    CLEAR_TOOLBOX_TIMEOUT,
    FULL_SCREEN_CHANGED,
    SET_FULL_SCREEN,
    SET_HANGUP_MENU_VISIBLE,
    SET_MAIN_TOOLBAR_BUTTONS_THRESHOLDS,
    SET_OVERFLOW_DRAWER,
    SET_OVERFLOW_MENU_VISIBLE,
    SET_TOOLBAR_HOVERED,
    SET_TOOLBOX_TIMEOUT
} from './actionTypes';
import { setToolboxVisible } from './actions.web';
import { THRESHOLDS } from './constants';
import { getToolbarTimeout } from './functions.web';
import { IMainToolbarButtonThresholds } from './types';

export * from './actions.any';

/**
 * Docks/undocks the Toolbox.
 *
 * @param {boolean} dock - True if dock, false otherwise.
 * @returns {Function}
 */
export function dockToolbox(dock: boolean) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const { visible } = state['features/toolbox'];
        const toolbarTimeout = getToolbarTimeout(state);

        if (dock) {
            // First make sure the toolbox is shown.
            visible || dispatch(showToolbox());

            dispatch(clearToolboxTimeout());
        } else if (visible) {
            dispatch(
                setToolboxTimeout(
                    () => dispatch(hideToolbox()),
                    toolbarTimeout));
        } else {
            dispatch(showToolbox());
        }
    };
}

/**
 * Signals that full screen mode has been entered or exited.
 *
 * @param {boolean} fullScreen - Whether or not full screen mode is currently
 * enabled.
 * @returns {{
 *     type: FULL_SCREEN_CHANGED,
 *     fullScreen: boolean
 * }}
 */
export function fullScreenChanged(fullScreen: boolean) {
    return {
        type: FULL_SCREEN_CHANGED,
        fullScreen
    };
}

/**
 * Hides the toolbox.
 *
 * @param {boolean} force - True to force the hiding of the toolbox without
 * caring about the extended toolbar side panels.
 * @returns {Function}
 */
export function hideToolbox(force = false) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const { toolbarConfig } = state['features/base/config'];
        const alwaysVisible = toolbarConfig?.alwaysVisible;
        const autoHideWhileChatIsOpen = toolbarConfig?.autoHideWhileChatIsOpen;
        const { hovered } = state['features/toolbox'];
        const toolbarTimeout = getToolbarTimeout(state);

        if (alwaysVisible) {
            return;
        }

        dispatch(clearToolboxTimeout());

        const hoverSelector = isLayoutTileView(state)
            ? '.remotevideomenu:hover'
            : '.filmstrip:hover,.remotevideomenu:hover';
        const hoveredElem = document.querySelector(hoverSelector);

        if (!force
                && (hovered
                    || state['features/invite'].calleeInfoVisible
                    || (state['features/chat'].isOpen && !autoHideWhileChatIsOpen)
                    || hoveredElem)) {
            dispatch(
                setToolboxTimeout(
                    () => dispatch(hideToolbox()),
                    toolbarTimeout));
        } else {
            dispatch(setToolboxVisible(false));
        }
    };
}

/**
 * Signals a request to enter or exit full screen mode.
 *
 * @param {boolean} fullScreen - True to enter full screen mode, false to exit.
 * @returns {{
 *     type: SET_FULL_SCREEN,
 *     fullScreen: boolean
 * }}
 */
export function setFullScreen(fullScreen: boolean) {
    return {
        type: SET_FULL_SCREEN,
        fullScreen
    };
}

/**
 * Sets the mainToolbarButtonsThresholds.
 *
 * @returns {Function}
 */
export function setMainToolbarThresholds() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const { mainToolbarButtons } = getState()['features/base/config'];

        if (!mainToolbarButtons || !Array.isArray(mainToolbarButtons) || mainToolbarButtons.length === 0) {
            return;
        }

        const mainToolbarButtonsThresholds: IMainToolbarButtonThresholds = [];

        const mainToolbarButtonsLenghtMap = new Map();
        let orderIsChanged = false;

        mainToolbarButtons.forEach(buttons => {
            if (!Array.isArray(buttons) || buttons.length === 0) {
                return;
            }

            mainToolbarButtonsLenghtMap.set(buttons.length, buttons);
        });

        THRESHOLDS.forEach(({ width, order }) => {
            let finalOrder = mainToolbarButtonsLenghtMap.get(order.length);

            if (finalOrder) {
                orderIsChanged = true;
            } else {
                finalOrder = order;
            }

            mainToolbarButtonsThresholds.push({
                order: finalOrder,
                width
            });
        });

        if (orderIsChanged) {
            dispatch({
                type: SET_MAIN_TOOLBAR_BUTTONS_THRESHOLDS,
                mainToolbarButtonsThresholds
            });
        }
    };
}

/**
 * Shows the toolbox for specified timeout.
 *
 * @param {number} timeout - Timeout for showing the toolbox.
 * @returns {Function}
 */
export function showToolbox(timeout = 0) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const { toolbarConfig } = state['features/base/config'];
        const toolbarTimeout = getToolbarTimeout(state);
        const initialTimeout = toolbarConfig?.initialTimeout;
        const alwaysVisible = toolbarConfig?.alwaysVisible;

        const {
            enabled,
            visible
        } = state['features/toolbox'];

        if (enabled && !visible) {
            dispatch(setToolboxVisible(true));

            // If the Toolbox is always visible, there's no need for a timeout
            // to toggle its visibility.
            if (!alwaysVisible) {
                if (typeof initialTimeout === 'number') {
                    // reset `initialTimeout` once it is consumed once
                    dispatch(overwriteConfig({ toolbarConfig: {
                        ...toolbarConfig,
                        initialTimeout: null
                    } }));
                }
                dispatch(
                    setToolboxTimeout(
                        () => dispatch(hideToolbox()),
                        timeout || initialTimeout || toolbarTimeout));
            }
        }
    };
}

/**
 * Signals a request to display overflow as drawer.
 *
 * @param {boolean} displayAsDrawer - True to display overflow as drawer, false to preserve original behaviour.
 * @returns {{
 *     type: SET_OVERFLOW_DRAWER,
 *     displayAsDrawer: boolean
 * }}
 */
export function setOverflowDrawer(displayAsDrawer: boolean) {
    return {
        type: SET_OVERFLOW_DRAWER,
        displayAsDrawer
    };
}

/**
 * Signals that toolbox timeout should be cleared.
 *
 * @returns {{
 *     type: CLEAR_TOOLBOX_TIMEOUT
 * }}
 */
export function clearToolboxTimeout() {
    return {
        type: CLEAR_TOOLBOX_TIMEOUT
    };
}

/**
 * Shows/hides the hangup menu.
 *
 * @param {boolean} visible - True to show it or false to hide it.
 * @returns {{
 *     type: SET_HANGUP_MENU_VISIBLE,
 *     visible: boolean
 * }}
 */
export function setHangupMenuVisible(visible: boolean) {
    return {
        type: SET_HANGUP_MENU_VISIBLE,
        visible
    };
}

/**
 * Shows/hides the overflow menu.
 *
 * @param {boolean} visible - True to show it or false to hide it.
 * @returns {{
 *     type: SET_OVERFLOW_MENU_VISIBLE,
 *     visible: boolean
 * }}
 */
export function setOverflowMenuVisible(visible: boolean) {
    return {
        type: SET_OVERFLOW_MENU_VISIBLE,
        visible
    };
}

/**
 * Signals that toolbar is hovered value should be changed.
 *
 * @param {boolean} hovered - Flag showing whether toolbar is hovered.
 * @returns {{
 *     type: SET_TOOLBAR_HOVERED,
 *     hovered: boolean
 * }}
 */
export function setToolbarHovered(hovered: boolean) {
    return {
        type: SET_TOOLBAR_HOVERED,
        hovered
    };
}

/**
 * Dispatches an action which sets new timeout for the toolbox visibility and clears the previous one.
 * On mobile browsers the toolbox does not hide on timeout. It is toggled on simple tap.
 *
 * @param {Function} handler - Function to be invoked after the timeout.
 * @param {number} timeoutMS - Delay.
 * @returns {{
 *     type: SET_TOOLBOX_TIMEOUT,
 *     handler: Function,
 *     timeoutMS: number
 * }}
 */
export function setToolboxTimeout(handler: Function, timeoutMS: number) {
    return function(dispatch: IStore['dispatch']) {
        if (isMobileBrowser()) {
            return;
        }

        dispatch({
            type: SET_TOOLBOX_TIMEOUT,
            handler,
            timeoutMS
        });
    };
}

/**
     * Closes the overflow menu if opened.
     *
     * @private
     * @returns {void}
     */
export function closeOverflowMenuIfOpen() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const { overflowMenuVisible } = getState()['features/toolbox'];

        overflowMenuVisible && dispatch(setOverflowMenuVisible(false));
    };
}


################################################################################

## File: .\jitsi-meet\react\features\toolbox\actionTypes.ts

/**
 * The type of the action which clears the Toolbox visibility timeout.
 *
 * {
 *     type: CLEAR_TOOLBOX_TIMEOUT
 * }
 */
export const CLEAR_TOOLBOX_TIMEOUT = 'CLEAR_TOOLBOX_TIMEOUT';

/**
 * The type of (redux) action which signals that a custom button from the overflow menu was pressed.
 *
 * @returns {{
 *      type: CUSTOM_OVERFLOW_MENU_BUTTON_PRESSED,
 *      id: string,
 *      text: string
 * }}
 */
export const CUSTOM_OVERFLOW_MENU_BUTTON_PRESSED = 'CUSTOM_OVERFLOW_MENU_BUTTON_PRESSED';

/**
 * The type of (redux) action which updates whether the conference is or is not
 * currently in full screen view.
 *
 * {
 *     type: FULL_SCREEN_CHANGED,
 *     fullScreen: boolean
 * }
 */
export const FULL_SCREEN_CHANGED = 'FULL_SCREEN_CHANGED';

/**
 * The type of (redux) action which sets the buttonsWithNotifyClick redux property.
 *
 * {
 *     type: SET_BUTTONS_WITH_NOTIFY_CLICK,
 *     buttonsWithNotifyClick: Map<string, NOTIFY_CLICK_MODE>
 * }
 */
export const SET_BUTTONS_WITH_NOTIFY_CLICK = 'SET_BUTTONS_WITH_NOTIFY_CLICK';

/**
 * The type of (redux) action which sets the participantMenuButtonsWithNotifyClick redux property.
 *
 * {
 *     type: SET_BUTTONS_WITH_NOTIFY_CLICK,
 *     participantMenuButtonsWithNotifyClick: Map<string, NOTIFY_CLICK_MODE>
 * }
 */
export const SET_PARTICIPANT_MENU_BUTTONS_WITH_NOTIFY_CLICK = 'SET_PARTICIPANT_MENU_BUTTONS_WITH_NOTIFY_CLICK';

/**
 * The type of (redux) action which requests full screen mode be entered or
 * exited.
 *
 * {
 *     type: SET_FULL_SCREEN,
 *     fullScreen: boolean
 * }
 */
export const SET_FULL_SCREEN = 'SET_FULL_SCREEN';

/**
 * The type of the (redux) action which shows/hides the hangup menu.
 *
 * {
 *     type: SET_HANGUP_MENU_VISIBLE,
 *     visible: boolean
 * }
 */
export const SET_HANGUP_MENU_VISIBLE = 'SET_HANGUP_MENU_VISIBLE';

/**
 * The type of the (redux) action which sets the main toolbar thresholds.
 *
 * {
 *     type: SET_MAIN_TOOLBAR_BUTTONS_THRESHOLDS,
 *     mainToolbarButtonsThresholds: IMainToolbarButtonThresholds
 * }
 */
export const SET_MAIN_TOOLBAR_BUTTONS_THRESHOLDS = 'SET_MAIN_TOOLBAR_BUTTONS_THRESHOLDS';

/**
 * The type of the redux action that toggles whether the overflow menu(s) should be shown as drawers.
 */
export const SET_OVERFLOW_DRAWER = 'SET_OVERFLOW_DRAWER';

/**
 * The type of the (redux) action which shows/hides the OverflowMenu.
 *
 * {
 *     type: SET_OVERFLOW_MENU_VISIBLE,
 *     visible: boolean
 * }
 */
export const SET_OVERFLOW_MENU_VISIBLE = 'SET_OVERFLOW_MENU_VISIBLE';


/**
 * The type of the action which sets enabled toolbar buttons.
 *
 * {
 *     type: SET_TOOLBAR_BUTTONS,
 *     toolbarButtons: Array<string>
 * }
 */
export const SET_TOOLBAR_BUTTONS = 'SET_TOOLBAR_BUTTONS';

/**
 * The type of the action which sets the indicator which determines whether a
 * fToolbar in the Toolbox is hovered.
 *
 * {
 *     type: SET_TOOLBAR_HOVERED,
 *     hovered: boolean
 * }
 */
export const SET_TOOLBAR_HOVERED = 'SET_TOOLBAR_HOVERED';

/**
 * The type of the (redux) action which enables/disables the Toolbox.
 *
 * {
 *     type: SET_TOOLBOX_ENABLED,
 *     enabled: boolean
 * }
 */
export const SET_TOOLBOX_ENABLED = 'SET_TOOLBOX_ENABLED';

/**
 * The type of the action which sets a new Toolbox visibility timeout and its
 * delay.
 *
 * {
 *     type: SET_TOOLBOX_TIMEOUT,
 *     handler: Function,
 *     timeoutMS: number
 * }
 */
export const SET_TOOLBOX_TIMEOUT = 'SET_TOOLBOX_TIMEOUT';

/**
 * The type of the (redux) action which shows/hides the Toolbox.
 *
 * {
 *     type: SET_TOOLBOX_VISIBLE,
 *     visible: boolean
 * }
 */
export const SET_TOOLBOX_VISIBLE = 'SET_TOOLBOX_VISIBLE';

/**
 * The type of the redux action which toggles the toolbox visibility regardless of it's current state.
 *
 * {
 *     type: TOGGLE_TOOLBOX_VISIBLE
 * }
 */
export const TOGGLE_TOOLBOX_VISIBLE = 'TOGGLE_TOOLBOX_VISIBLE';

/**
 * The type of the redux action which sets whether the toolbox should be shifted up or not.
 *
 * {
 *     type: SET_TOOLBOX_SHIFT_UP
 * }
 */
export const SET_TOOLBOX_SHIFT_UP = 'SET_TOOLBOX_SHIFT_UP';


################################################################################

## File: .\jitsi-meet\react\features\toolbox\constants.ts

import { ToolbarButton } from './types';

/**
 * Thresholds for displaying toolbox buttons.
 */
export const THRESHOLDS = [
    {
        width: 565,
        order: [ 'microphone', 'camera', 'desktop', 'chat', 'raisehand', 'reactions', 'participants-pane', 'tileview' ]
    },
    {
        width: 520,
        order: [ 'microphone', 'camera', 'desktop', 'chat', 'raisehand', 'participants-pane', 'tileview' ]
    },
    {
        width: 470,
        order: [ 'microphone', 'camera', 'desktop', 'chat', 'raisehand', 'participants-pane' ]
    },
    {
        width: 420,
        order: [ 'microphone', 'camera', 'desktop', 'chat', 'participants-pane' ]
    },
    {
        width: 370,
        order: [ 'microphone', 'camera', 'chat', 'participants-pane' ]
    },
    {
        width: 225,
        order: [ 'microphone', 'camera', 'chat' ]
    },
    {
        width: 200,
        order: [ 'microphone', 'camera' ]
    }
];

/**
 * Main toolbar buttons priority used to determine which button should be picked to fill empty spaces for disabled
 * buttons.
 */
export const MAIN_TOOLBAR_BUTTONS_PRIORITY = [
    'microphone',
    'camera',
    'desktop',
    'chat',
    'raisehand',
    'reactions',
    'participants-pane',
    'tileview',
    'invite',
    'toggle-camera',
    'videoquality',
    'fullscreen',
    'security',
    'closedcaptions',
    'recording',
    'livestreaming',
    'linktosalesforce',
    'sharedvideo',
    'shareaudio',
    'noisesuppression',
    'whiteboard',
    'etherpad',
    'select-background',
    'stats',
    'settings',
    'shortcuts',
    'profile',
    'embedmeeting',
    'feedback',
    'download',
    'help'
];

export const TOOLBAR_TIMEOUT = 4000;

export const DRAWER_MAX_HEIGHT = '80dvh - 64px';

// Around 300 to be displayed above components like chat
export const ZINDEX_DIALOG_PORTAL = 302;

/**
 * Color for spinner displayed in the toolbar.
 */
export const SPINNER_COLOR = '#929292';

/**
 * The list of all possible UI buttons.
 *
 * @protected
 * @type Array<string>
 */
export const TOOLBAR_BUTTONS: ToolbarButton[] = [
    'camera',
    'chat',
    'closedcaptions',
    'desktop',
    'download',
    'embedmeeting',
    'etherpad',
    'feedback',
    'filmstrip',
    'fullscreen',
    'hangup',
    'help',
    'highlight',
    'invite',
    'linktosalesforce',
    'livestreaming',
    'microphone',
    'mute-everyone',
    'mute-video-everyone',
    'participants-pane',
    'profile',
    'raisehand',
    'recording',
    'security',
    'select-background',
    'settings',
    'shareaudio',
    'noisesuppression',
    'sharedvideo',
    'shortcuts',
    'stats',
    'tileview',
    'toggle-camera',
    'videoquality',
    'whiteboard'
];

/**
 * The toolbar buttons to show when in visitors mode.
 */
export const VISITORS_MODE_BUTTONS: ToolbarButton[] = [
    'chat',
    'closedcaptions',
    'hangup',
    'raisehand',
    'settings',
    'tileview',
    'fullscreen',
    'stats',
    'videoquality'
];


################################################################################

## File: .\jitsi-meet\react\features\toolbox\functions.any.ts

import { IReduxState } from '../app/types';
import { isJwtFeatureEnabledStateless } from '../base/jwt/functions';
import { IGUMPendingState } from '../base/media/types';
import { IParticipantFeatures } from '../base/participants/types';

/**
 * Indicates if the audio mute button is disabled or not.
 *
 * @param {IReduxState} state - The state from the Redux store.
 * @returns {boolean}
 */
export function isAudioMuteButtonDisabled(state: IReduxState) {
    const { available, muted, unmuteBlocked, gumPending } = state['features/base/media'].audio;
    const { startSilent } = state['features/base/config'];

    return Boolean(!available || startSilent || (muted && unmuteBlocked) || gumPending !== IGUMPendingState.NONE);
}

/**
 * Returns the buttons corresponding to features disabled through jwt.
 * This function is stateless as it returns a new array and may cause re-rendering.
 *
 * @param {boolean} isTranscribing - Whether there is currently a transcriber in the meeting.
 * @param {boolean} isModerator - Whether local participant is moderator.
 * @param {string | undefined} jwt - The jwt token.
 * @param {ILocalParticipant} localParticipantFeatures - The features of the local participant.
 * @returns {string[]} - The disabled by jwt buttons array.
 */
export function getJwtDisabledButtons(
        isTranscribing: boolean,
        isModerator: boolean,
        jwt: string | undefined,
        localParticipantFeatures?: IParticipantFeatures) {
    const acc = [];

    if (!isJwtFeatureEnabledStateless({
        jwt,
        localParticipantFeatures,
        feature: 'livestreaming',
        ifNoToken: isModerator,
        ifNotInFeatures: false
    })) {
        acc.push('livestreaming');
    }

    if (!isTranscribing && !isJwtFeatureEnabledStateless({
        jwt,
        localParticipantFeatures,
        feature: 'transcription',
        ifNoToken: isModerator,
        ifNotInFeatures: false
    })) {
        acc.push('closedcaptions');
    }

    return acc;
}


################################################################################

## File: .\jitsi-meet\react\features\toolbox\functions.native.ts

import { IReduxState } from '../app/types';
import { IStateful } from '../base/app/types';
import { hasAvailableDevices } from '../base/devices/functions';
import { TOOLBOX_ALWAYS_VISIBLE, TOOLBOX_ENABLED } from '../base/flags/constants';
import { getFeatureFlag } from '../base/flags/functions';
import { getParticipantCountWithFake } from '../base/participants/functions';
import { toState } from '../base/redux/functions';
import { isLocalVideoTrackDesktop } from '../base/tracks/functions';

export * from './functions.any';

const WIDTH = {
    FIT_9_ICONS: 560,
    FIT_8_ICONS: 500,
    FIT_7_ICONS: 440,
    FIT_6_ICONS: 380
};

/**
 * Returns a set of the buttons that are shown in the toolbar
 * but removed from the overflow menu, based on the width of the screen.
 *
 * @param {number} width - The width of the screen.
 * @returns {Set}
 */
export function getMovableButtons(width: number): Set<string> {
    let buttons: string[] = [];

    switch (true) {
    case width >= WIDTH.FIT_9_ICONS: {
        buttons = [ 'chat', 'togglecamera', 'screensharing', 'raisehand', 'tileview' ];
        break;
    }
    case width >= WIDTH.FIT_8_ICONS: {
        buttons = [ 'chat', 'togglecamera', 'raisehand', 'tileview' ];
        break;
    }

    case width >= WIDTH.FIT_7_ICONS: {
        buttons = [ 'chat', 'togglecamera', 'raisehand' ];
        break;
    }

    case width >= WIDTH.FIT_6_ICONS: {
        buttons = [ 'chat', 'togglecamera' ];
        break;
    }

    default: {
        buttons = [ 'chat' ];
    }
    }

    return new Set(buttons);
}

/**
 * Indicates if the desktop share button is disabled or not.
 *
 * @param {IReduxState} state - The state from the Redux store.
 * @returns {boolean}
 */
export function isDesktopShareButtonDisabled(state: IReduxState) {
    const { muted, unmuteBlocked } = state['features/base/media'].video;
    const videoOrShareInProgress = !muted || isLocalVideoTrackDesktop(state);

    return unmuteBlocked && !videoOrShareInProgress;
}

/**
 * Returns true if the toolbox is visible.
 *
 * @param {IStateful} stateful - A function or object that can be
 * resolved to Redux state by the function {@code toState}.
 * @returns {boolean}
 */
export function isToolboxVisible(stateful: IStateful) {
    const state = toState(stateful);
    const { toolbarConfig } = state['features/base/config'];
    const { alwaysVisible } = toolbarConfig || {};
    const { enabled, visible } = state['features/toolbox'];
    const participantCount = getParticipantCountWithFake(state);
    const alwaysVisibleFlag = getFeatureFlag(state, TOOLBOX_ALWAYS_VISIBLE, false);
    const enabledFlag = getFeatureFlag(state, TOOLBOX_ENABLED, true);

    return enabledFlag && enabled
        && (alwaysVisible || visible || participantCount === 1 || alwaysVisibleFlag);
}

/**
 * Indicates if the video mute button is disabled or not.
 *
 * @param {IReduxState} state - The state from the Redux store.
 * @returns {boolean}
 */
export function isVideoMuteButtonDisabled(state: IReduxState) {
    const { muted, unmuteBlocked } = state['features/base/media'].video;

    return !hasAvailableDevices(state, 'videoInput')
        || (unmuteBlocked && Boolean(muted))
        || isLocalVideoTrackDesktop(state);
}


################################################################################

## File: .\jitsi-meet\react\features\toolbox\functions.web.ts

import { IReduxState } from '../app/types';
import { hasAvailableDevices } from '../base/devices/functions';
import { MEET_FEATURES } from '../base/jwt/constants';
import { isJwtFeatureEnabled } from '../base/jwt/functions';
import { IGUMPendingState } from '../base/media/types';
import { isScreenMediaShared } from '../screen-share/functions';
import { isWhiteboardVisible } from '../whiteboard/functions';

import { MAIN_TOOLBAR_BUTTONS_PRIORITY, TOOLBAR_TIMEOUT } from './constants';
import { IMainToolbarButtonThresholds, IToolboxButton, NOTIFY_CLICK_MODE } from './types';

export * from './functions.any';

/**
 * Helper for getting the height of the toolbox.
 *
 * @returns {number} The height of the toolbox.
 */
export function getToolboxHeight() {
    const toolbox = document.getElementById('new-toolbox');

    return toolbox?.clientHeight || 0;
}

/**
 * Checks if the specified button is enabled.
 *
 * @param {string} buttonName - The name of the button. See {@link interfaceConfig}.
 * @param {Object|Array<string>} state - The redux state or the array with the enabled buttons.
 * @returns {boolean} - True if the button is enabled and false otherwise.
 */
export function isButtonEnabled(buttonName: string, state: IReduxState | Array<string>) {
    const buttons = Array.isArray(state) ? state : state['features/toolbox'].toolbarButtons || [];

    return buttons.includes(buttonName);
}

/**
 * Indicates if the toolbox is visible or not.
 *
 * @param {IReduxState} state - The state from the Redux store.
 * @returns {boolean} - True to indicate that the toolbox is visible, false -
 * otherwise.
 */
export function isToolboxVisible(state: IReduxState) {
    const { iAmRecorder, iAmSipGateway, toolbarConfig } = state['features/base/config'];
    const { alwaysVisible } = toolbarConfig || {};
    const {
        timeoutID,
        visible
    } = state['features/toolbox'];
    const { audioSettingsVisible, videoSettingsVisible } = state['features/settings'];
    const whiteboardVisible = isWhiteboardVisible(state);

    return Boolean(!iAmRecorder && !iAmSipGateway
            && (
                timeoutID
                || visible
                || alwaysVisible
                || audioSettingsVisible
                || videoSettingsVisible
                || whiteboardVisible
            ));
}

/**
 * Indicates if the audio settings button is disabled or not.
 *
 * @param {IReduxState} state - The state from the Redux store.
 * @returns {boolean}
 */
export function isAudioSettingsButtonDisabled(state: IReduxState) {

    return !(hasAvailableDevices(state, 'audioInput')
        || hasAvailableDevices(state, 'audioOutput'))
        || state['features/base/config'].startSilent;
}

/**
 * Indicates if the desktop share button is disabled or not.
 *
 * @param {IReduxState} state - The state from the Redux store.
 * @returns {boolean}
 */
export function isDesktopShareButtonDisabled(state: IReduxState) {
    const { muted, unmuteBlocked } = state['features/base/media'].video;
    const videoOrShareInProgress = !muted || isScreenMediaShared(state);
    const enabledInJwt = isJwtFeatureEnabled(state, MEET_FEATURES.SCREEN_SHARING, true, true);

    return !enabledInJwt || (unmuteBlocked && !videoOrShareInProgress);
}

/**
 * Indicates if the video settings button is disabled or not.
 *
 * @param {IReduxState} state - The state from the Redux store.
 * @returns {boolean}
 */
export function isVideoSettingsButtonDisabled(state: IReduxState) {
    return !hasAvailableDevices(state, 'videoInput');
}

/**
 * Indicates if the video mute button is disabled or not.
 *
 * @param {IReduxState} state - The state from the Redux store.
 * @returns {boolean}
 */
export function isVideoMuteButtonDisabled(state: IReduxState) {
    const { muted, unmuteBlocked, gumPending } = state['features/base/media'].video;

    return !hasAvailableDevices(state, 'videoInput')
        || (unmuteBlocked && Boolean(muted))
        || gumPending !== IGUMPendingState.NONE;
}

/**
 * If an overflow drawer should be displayed or not.
 * This is usually done for mobile devices or on narrow screens.
 *
 * @param {IReduxState} state - The state from the Redux store.
 * @returns {boolean}
 */
export function showOverflowDrawer(state: IReduxState) {
    return state['features/toolbox'].overflowDrawer;
}

/**
 * Returns true if the overflow menu button is displayed and false otherwise.
 *
 * @param {IReduxState} state - The state from the Redux store.
 * @returns {boolean} - True if the overflow menu button is displayed and false otherwise.
 */
export function showOverflowMenu(state: IReduxState) {
    return state['features/toolbox'].overflowMenuVisible;
}

/**
 * Indicates whether the toolbox is enabled or not.
 *
 * @param {IReduxState} state - The state from the Redux store.
 * @returns {boolean}
 */
export function isToolboxEnabled(state: IReduxState) {
    return state['features/toolbox'].enabled;
}

/**
 * Returns the toolbar timeout from config or the default value.
 *
 * @param {IReduxState} state - The state from the Redux store.
 * @returns {number} - Toolbar timeout in milliseconds.
 */
export function getToolbarTimeout(state: IReduxState) {
    const { toolbarConfig } = state['features/base/config'];

    return toolbarConfig?.timeout || TOOLBAR_TIMEOUT;
}

/**
 * Sets the notify click mode for the buttons.
 *
 * @param {Object} buttons - The list of toolbar buttons.
 * @param {Map} buttonsWithNotifyClick - The buttons notify click configuration.
 * @returns {void}
 */
function setButtonsNotifyClickMode(buttons: Object, buttonsWithNotifyClick: Map<string, NOTIFY_CLICK_MODE>) {
    if (typeof APP === 'undefined' || (buttonsWithNotifyClick?.size ?? 0) <= 0) {
        return;
    }

    Object.values(buttons).forEach((button: any) => {
        if (typeof button === 'object') {
            button.notifyMode = buttonsWithNotifyClick.get(button.key);
        }
    });
}

interface IGetVisibleButtonsParams {
    allButtons: { [key: string]: IToolboxButton; };
    buttonsWithNotifyClick: Map<string, NOTIFY_CLICK_MODE>;
    clientWidth: number;
    jwtDisabledButtons: string[];
    mainToolbarButtonsThresholds: IMainToolbarButtonThresholds;
    toolbarButtons: string[];
}

/**
 * Returns all buttons that need to be rendered.
 *
 * @param {IGetVisibleButtonsParams} params - The parameters needed to extract the visible buttons.
 * @returns {Object} - The visible buttons arrays .
 */
export function getVisibleButtons({
    allButtons,
    buttonsWithNotifyClick,
    toolbarButtons,
    clientWidth,
    jwtDisabledButtons,
    mainToolbarButtonsThresholds
}: IGetVisibleButtonsParams) {
    setButtonsNotifyClickMode(allButtons, buttonsWithNotifyClick);

    const filteredButtons = Object.keys(allButtons).filter(key =>
        typeof key !== 'undefined' // filter invalid buttons that may be comming from config.mainToolbarButtons
        // override
        && !jwtDisabledButtons.includes(key)
        && isButtonEnabled(key, toolbarButtons));


    const { order } = mainToolbarButtonsThresholds.find(({ width }) => clientWidth > width)
        || mainToolbarButtonsThresholds[mainToolbarButtonsThresholds.length - 1];

    const mainToolbarButtonKeysOrder = [
        ...order.filter(key => filteredButtons.includes(key)),
        ...MAIN_TOOLBAR_BUTTONS_PRIORITY.filter(key => !order.includes(key) && filteredButtons.includes(key)),
        ...filteredButtons.filter(key => !order.includes(key) && !MAIN_TOOLBAR_BUTTONS_PRIORITY.includes(key))
    ];

    const mainButtonsKeys = mainToolbarButtonKeysOrder.slice(0, order.length);
    const overflowMenuButtons = filteredButtons.reduce((acc, key) => {
        if (!mainButtonsKeys.includes(key)) {
            acc.push(allButtons[key]);
        }

        return acc;
    }, [] as IToolboxButton[]);

    // if we have 1 button in the overflow menu it is better to directly display it in the main toolbar by replacing
    // the "More" menu button with it.
    if (overflowMenuButtons.length === 1) {
        const button = overflowMenuButtons.shift()?.key;

        button && mainButtonsKeys.push(button);
    }

    return {
        mainMenuButtons: mainButtonsKeys.map(key => allButtons[key]),
        overflowMenuButtons
    };
}

/**
 * Returns the list of participant menu buttons that have that notify the api when clicked.
 *
 * @param {Object} state - The redux state.
 * @returns {Map<string, NOTIFY_CLICK_MODE>} - The list of participant menu buttons.
 */
export function getParticipantMenuButtonsWithNotifyClick(state: IReduxState): Map<string, NOTIFY_CLICK_MODE> {
    return state['features/toolbox'].participantMenuButtonsWithNotifyClick;
}

interface ICSSTransitionObject {
    delay: number;
    duration: number;
    easingFunction: string;
}

/**
 * Returns the time, timing function and delay for elements that are position above the toolbar and need to move along
 * with the toolbar.
 *
 * @param {boolean} isToolbarVisible - Whether the toolbar is visible or not.
 * @returns {ICSSTransitionObject}
 */
export function getTransitionParamsForElementsAboveToolbox(isToolbarVisible: boolean): ICSSTransitionObject {
    // The transistion time and delay is different to account for the time when the toolbar is about to hide/show but
    // the elements don't have to move.
    return isToolbarVisible ? {
        duration: 0.15,
        easingFunction: 'ease-in',
        delay: 0.15
    } : {
        duration: 0.24,
        easingFunction: 'ease-in',
        delay: 0
    };
}

/**
 * Converts a given object to a css transition value string.
 *
 * @param {ICSSTransitionObject} object - The object.
 * @returns {string}
 */
export function toCSSTransitionValue(object: ICSSTransitionObject) {
    const { delay, duration, easingFunction } = object;

    return `${duration}s ${easingFunction} ${delay}s`;
}


################################################################################

## File: .\jitsi-meet\react\features\toolbox\hooks.web.ts

import { useEffect } from 'react';
import { batch, useDispatch, useSelector } from 'react-redux';

import { ACTION_SHORTCUT_TRIGGERED, createShortcutEvent } from '../analytics/AnalyticsEvents';
import { sendAnalytics } from '../analytics/functions';
import { IReduxState } from '../app/types';
import { toggleDialog } from '../base/dialog/actions';
import { isIosMobileBrowser, isIpadMobileBrowser } from '../base/environment/utils';
import { HELP_BUTTON_ENABLED } from '../base/flags/constants';
import { getFeatureFlag } from '../base/flags/functions';
import JitsiMeetJS from '../base/lib-jitsi-meet';
import { raiseHand } from '../base/participants/actions';
import { getLocalParticipant, hasRaisedHand } from '../base/participants/functions';
import { isToggleCameraEnabled } from '../base/tracks/functions.web';
import { toggleChat } from '../chat/actions.web';
import ChatButton from '../chat/components/web/ChatButton';
import { useEmbedButton } from '../embed-meeting/hooks';
import { useEtherpadButton } from '../etherpad/hooks';
import { useFeedbackButton } from '../feedback/hooks.web';
import { setGifMenuVisibility } from '../gifs/actions';
import { isGifEnabled } from '../gifs/function.any';
import InviteButton from '../invite/components/add-people-dialog/web/InviteButton';
import { registerShortcut, unregisterShortcut } from '../keyboard-shortcuts/actions';
import { useKeyboardShortcutsButton } from '../keyboard-shortcuts/hooks';
import NoiseSuppressionButton from '../noise-suppression/components/NoiseSuppressionButton';
import {
    close as closeParticipantsPane,
    open as openParticipantsPane
} from '../participants-pane/actions.web';
import {
    getParticipantsPaneOpen,
    isParticipantsPaneEnabled
} from '../participants-pane/functions';
import { useParticipantPaneButton } from '../participants-pane/hooks.web';
import { addReactionToBuffer } from '../reactions/actions.any';
import { toggleReactionsMenuVisibility } from '../reactions/actions.web';
import RaiseHandContainerButton from '../reactions/components/web/RaiseHandContainerButtons';
import { REACTIONS } from '../reactions/constants';
import { shouldDisplayReactionsButtons } from '../reactions/functions.any';
import { useReactionsButton } from '../reactions/hooks.web';
import { useLiveStreamingButton, useRecordingButton } from '../recording/hooks.web';
import { isSalesforceEnabled } from '../salesforce/functions';
import { startScreenShareFlow } from '../screen-share/actions.web';
import ShareAudioButton from '../screen-share/components/web/ShareAudioButton';
import { isScreenAudioSupported, isScreenVideoShared } from '../screen-share/functions';
import { useSecurityDialogButton } from '../security/hooks.web';
import SettingsButton from '../settings/components/web/SettingsButton';
import { useSharedVideoButton } from '../shared-video/hooks';
import SpeakerStats from '../speaker-stats/components/web/SpeakerStats';
import { isSpeakerStatsDisabled } from '../speaker-stats/functions';
import { useSpeakerStatsButton } from '../speaker-stats/hooks.web';
import { useClosedCaptionButton } from '../subtitles/hooks.web';
import { toggleTileView } from '../video-layout/actions.any';
import { shouldDisplayTileView } from '../video-layout/functions.web';
import { useTileViewButton } from '../video-layout/hooks';
import VideoQualityButton from '../video-quality/components/VideoQualityButton.web';
import VideoQualityDialog from '../video-quality/components/VideoQualityDialog.web';
import { useVirtualBackgroundButton } from '../virtual-background/hooks';
import { useWhiteboardButton } from '../whiteboard/hooks';

import { setFullScreen } from './actions.web';
import DownloadButton from './components/DownloadButton';
import HelpButton from './components/HelpButton';
import AudioSettingsButton from './components/web/AudioSettingsButton';
import CustomOptionButton from './components/web/CustomOptionButton';
import FullscreenButton from './components/web/FullscreenButton';
import LinkToSalesforceButton from './components/web/LinkToSalesforceButton';
import ProfileButton from './components/web/ProfileButton';
import ShareDesktopButton from './components/web/ShareDesktopButton';
import ToggleCameraButton from './components/web/ToggleCameraButton';
import VideoSettingsButton from './components/web/VideoSettingsButton';
import { isButtonEnabled, isDesktopShareButtonDisabled } from './functions.web';
import { ICustomToolbarButton, IToolboxButton, ToolbarButton } from './types';


const microphone = {
    key: 'microphone',
    Content: AudioSettingsButton,
    group: 0
};

const camera = {
    key: 'camera',
    Content: VideoSettingsButton,
    group: 0
};

const profile = {
    key: 'profile',
    Content: ProfileButton,
    group: 1
};

const chat = {
    key: 'chat',
    Content: ChatButton,
    group: 2
};

const desktop = {
    key: 'desktop',
    Content: ShareDesktopButton,
    group: 2
};

// In Narrow layout and mobile web we are using drawer for popups and that is why it is better to include
// all forms of reactions in the overflow menu. Otherwise the toolbox will be hidden and the reactions popup
// misaligned.
const raisehand = {
    key: 'raisehand',
    Content: RaiseHandContainerButton,
    group: 2
};

const invite = {
    key: 'invite',
    Content: InviteButton,
    group: 2
};

const toggleCamera = {
    key: 'toggle-camera',
    Content: ToggleCameraButton,
    group: 2
};

const videoQuality = {
    key: 'videoquality',
    Content: VideoQualityButton,
    group: 2
};

const fullscreen = {
    key: 'fullscreen',
    Content: FullscreenButton,
    group: 2
};

const linkToSalesforce = {
    key: 'linktosalesforce',
    Content: LinkToSalesforceButton,
    group: 2
};

const shareAudio = {
    key: 'shareaudio',
    Content: ShareAudioButton,
    group: 3
};

const noiseSuppression = {
    key: 'noisesuppression',
    Content: NoiseSuppressionButton,
    group: 3
};

const settings = {
    key: 'settings',
    Content: SettingsButton,
    group: 4
};

const download = {
    key: 'download',
    Content: DownloadButton,
    group: 4
};

const help = {
    key: 'help',
    Content: HelpButton,
    group: 4
};

/**
 * A hook that returns the toggle camera button if it is enabled and undefined otherwise.
 *
 *  @returns {Object | undefined}
 */
function useToggleCameraButton() {
    const toggleCameraEnabled = useSelector(isToggleCameraEnabled);

    if (toggleCameraEnabled) {
        return toggleCamera;
    }
}

/**
 * A hook that returns the desktop sharing button if it is enabled and undefined otherwise.
 *
 *  @returns {Object | undefined}
 */
function getDesktopSharingButton() {
    if (JitsiMeetJS.isDesktopSharingEnabled()) {
        return desktop;
    }
}

/**
 * A hook that returns the fullscreen button if it is enabled and undefined otherwise.
 *
 *  @returns {Object | undefined}
 */
function getFullscreenButton() {
    if (!isIosMobileBrowser() || isIpadMobileBrowser()) {
        return fullscreen;
    }
}

/**
 * A hook that returns the "link to salesforce" button if it is enabled and undefined otherwise.
 *
 *  @returns {Object | undefined}
 */
function useLinkToSalesforceButton() {
    const _isSalesforceEnabled = useSelector(isSalesforceEnabled);

    if (_isSalesforceEnabled) {
        return linkToSalesforce;
    }
}


/**
 * A hook that returns the share audio button if it is enabled and undefined otherwise.
 *
 *  @returns {Object | undefined}
 */
function getShareAudioButton() {
    if (JitsiMeetJS.isDesktopSharingEnabled() && isScreenAudioSupported()) {
        return shareAudio;
    }
}

/**
 * A hook that returns the download button if it is enabled and undefined otherwise.
 *
 *  @returns {Object | undefined}
 */
function useDownloadButton() {
    const visible = useSelector(
        (state: IReduxState) => typeof state['features/base/config'].deploymentUrls?.downloadAppsUrl === 'string');

    if (visible) {
        return download;
    }
}

/**
 * A hook that returns the help button if it is enabled and undefined otherwise.
 *
 *  @returns {Object | undefined}
 */
function useHelpButton() {
    const visible = useSelector(
        (state: IReduxState) =>
            typeof state['features/base/config'].deploymentUrls?.userDocumentationURL === 'string'
                && getFeatureFlag(state, HELP_BUTTON_ENABLED, true));

    if (visible) {
        return help;
    }
}

/**
* Returns all buttons that could be rendered.
*
* @param {Object} _customToolbarButtons - An array containing custom buttons objects.
* @returns {Object} The button maps mainMenuButtons and overflowMenuButtons.
*/
export function useToolboxButtons(
        _customToolbarButtons?: ICustomToolbarButton[]): { [key: string]: IToolboxButton; } {
    const dekstopSharing = getDesktopSharingButton();
    const toggleCameraButton = useToggleCameraButton();
    const _fullscreen = getFullscreenButton();
    const security = useSecurityDialogButton();
    const reactions = useReactionsButton();
    const participants = useParticipantPaneButton();
    const tileview = useTileViewButton();
    const cc = useClosedCaptionButton();
    const recording = useRecordingButton();
    const liveStreaming = useLiveStreamingButton();
    const linktosalesforce = useLinkToSalesforceButton();
    const shareaudio = getShareAudioButton();
    const shareVideo = useSharedVideoButton();
    const whiteboard = useWhiteboardButton();
    const etherpad = useEtherpadButton();
    const virtualBackground = useVirtualBackgroundButton();
    const speakerStats = useSpeakerStatsButton();
    const shortcuts = useKeyboardShortcutsButton();
    const embed = useEmbedButton();
    const feedback = useFeedbackButton();
    const _download = useDownloadButton();
    const _help = useHelpButton();

    const buttons: { [key in ToolbarButton]?: IToolboxButton; } = {
        microphone,
        camera,
        profile,
        desktop: dekstopSharing,
        chat,
        raisehand,
        reactions,
        'participants-pane': participants,
        invite,
        tileview,
        'toggle-camera': toggleCameraButton,
        videoquality: videoQuality,
        fullscreen: _fullscreen,
        security,
        closedcaptions: cc,
        recording,
        livestreaming: liveStreaming,
        linktosalesforce,
        sharedvideo: shareVideo,
        shareaudio,
        noisesuppression: noiseSuppression,
        whiteboard,
        etherpad,
        'select-background': virtualBackground,
        stats: speakerStats,
        settings,
        shortcuts,
        embedmeeting: embed,
        feedback,
        download: _download,
        help: _help
    };
    const buttonKeys = Object.keys(buttons) as ToolbarButton[];

    buttonKeys.forEach(
            key => typeof buttons[key] === 'undefined' && delete buttons[key]);

    const customButtons = _customToolbarButtons?.reduce((prev, { backgroundColor, icon, id, text }) => {
        prev[id] = {
            backgroundColor,
            key: id,
            id,
            Content: CustomOptionButton,
            group: 4,
            icon,
            text
        };

        return prev;
    }, {} as { [key: string]: ICustomToolbarButton; });

    return {
        ...buttons,
        ...customButtons
    };
}


export const useKeyboardShortcuts = (toolbarButtons: Array<string>) => {
    const dispatch = useDispatch();
    const _isSpeakerStatsDisabled = useSelector(isSpeakerStatsDisabled);
    const _isParticipantsPaneEnabled = useSelector(isParticipantsPaneEnabled);
    const _shouldDisplayReactionsButtons = useSelector(shouldDisplayReactionsButtons);
    const _toolbarButtons = useSelector(
        (state: IReduxState) => toolbarButtons || state['features/toolbox'].toolbarButtons);
    const chatOpen = useSelector((state: IReduxState) => state['features/chat'].isOpen);
    const desktopSharingButtonDisabled = useSelector(isDesktopShareButtonDisabled);
    const desktopSharingEnabled = JitsiMeetJS.isDesktopSharingEnabled();
    const fullScreen = useSelector((state: IReduxState) => state['features/toolbox'].fullScreen);
    const gifsEnabled = useSelector(isGifEnabled);
    const participantsPaneOpen = useSelector(getParticipantsPaneOpen);
    const raisedHand = useSelector((state: IReduxState) => hasRaisedHand(getLocalParticipant(state)));
    const screenSharing = useSelector(isScreenVideoShared);
    const tileViewEnabled = useSelector(shouldDisplayTileView);

    /**
     * Creates an analytics keyboard shortcut event and dispatches an action for
     * toggling the display of chat.
     *
     * @private
     * @returns {void}
     */
    function onToggleChat() {
        sendAnalytics(createShortcutEvent(
            'toggle.chat',
            ACTION_SHORTCUT_TRIGGERED,
            {
                enable: !chatOpen
            }));

        // Checks if there was any text selected by the user.
        // Used for when we press simultaneously keys for copying
        // text messages from the chat board
        if (window.getSelection()?.toString() !== '') {
            return false;
        }

        dispatch(toggleChat());
    }

    /**
     * Creates an analytics keyboard shortcut event and dispatches an action for
     * toggling the display of the participants pane.
     *
     * @private
     * @returns {void}
     */
    function onToggleParticipantsPane() {
        sendAnalytics(createShortcutEvent(
            'toggle.participants-pane',
            ACTION_SHORTCUT_TRIGGERED,
            {
                enable: !participantsPaneOpen
            }));

        if (participantsPaneOpen) {
            dispatch(closeParticipantsPane());
        } else {
            dispatch(openParticipantsPane());
        }
    }

    /**
    * Creates an analytics keyboard shortcut event and dispatches an action for
    * toggling the display of Video Quality.
    *
    * @private
    * @returns {void}
    */
    function onToggleVideoQuality() {
        sendAnalytics(createShortcutEvent('video.quality'));

        dispatch(toggleDialog(VideoQualityDialog));
    }

    /**
     * Dispatches an action for toggling the tile view.
     *
     * @private
     * @returns {void}
     */
    function onToggleTileView() {
        sendAnalytics(createShortcutEvent(
            'toggle.tileview',
            ACTION_SHORTCUT_TRIGGERED,
            {
                enable: !tileViewEnabled
            }));

        dispatch(toggleTileView());
    }

    /**
     * Creates an analytics keyboard shortcut event and dispatches an action for
     * toggling full screen mode.
     *
     * @private
     * @returns {void}
     */
    function onToggleFullScreen() {
        sendAnalytics(createShortcutEvent(
            'toggle.fullscreen',
            ACTION_SHORTCUT_TRIGGERED,
            {
                enable: !fullScreen
            }));
        dispatch(setFullScreen(!fullScreen));
    }

    /**
     * Creates an analytics keyboard shortcut event and dispatches an action for
     * toggling raise hand.
     *
     * @private
     * @returns {void}
     */
    function onToggleRaiseHand() {
        sendAnalytics(createShortcutEvent(
            'toggle.raise.hand',
            ACTION_SHORTCUT_TRIGGERED,
            { enable: !raisedHand }));

        dispatch(raiseHand(!raisedHand));
    }

    /**
     * Creates an analytics keyboard shortcut event and dispatches an action for
     * toggling screensharing.
     *
     * @private
     * @returns {void}
     */
    function onToggleScreenshare() {
        // Ignore the shortcut if the button is disabled.
        if (desktopSharingButtonDisabled) {
            return;
        }
        sendAnalytics(createShortcutEvent(
            'toggle.screen.sharing',
            ACTION_SHORTCUT_TRIGGERED,
            {
                enable: !screenSharing
            }));

        if (desktopSharingEnabled && !desktopSharingButtonDisabled) {
            dispatch(startScreenShareFlow(!screenSharing));
        }
    }

    /**
     * Creates an analytics keyboard shortcut event and dispatches an action for
     * toggling speaker stats.
     *
     * @private
     * @returns {void}
     */
    function onSpeakerStats() {
        sendAnalytics(createShortcutEvent(
            'speaker.stats'
        ));

        dispatch(toggleDialog(SpeakerStats, {
            conference: APP.conference
        }));
    }

    useEffect(() => {
        const KEYBOARD_SHORTCUTS = [
            isButtonEnabled('videoquality', _toolbarButtons) && {
                character: 'A',
                exec: onToggleVideoQuality,
                helpDescription: 'toolbar.callQuality'
            },
            isButtonEnabled('chat', _toolbarButtons) && {
                character: 'C',
                exec: onToggleChat,
                helpDescription: 'keyboardShortcuts.toggleChat'
            },
            isButtonEnabled('desktop', _toolbarButtons) && {
                character: 'D',
                exec: onToggleScreenshare,
                helpDescription: 'keyboardShortcuts.toggleScreensharing'
            },
            _isParticipantsPaneEnabled && isButtonEnabled('participants-pane', _toolbarButtons) && {
                character: 'P',
                exec: onToggleParticipantsPane,
                helpDescription: 'keyboardShortcuts.toggleParticipantsPane'
            },
            isButtonEnabled('raisehand', _toolbarButtons) && {
                character: 'R',
                exec: onToggleRaiseHand,
                helpDescription: 'keyboardShortcuts.raiseHand'
            },
            isButtonEnabled('fullscreen', _toolbarButtons) && {
                character: 'S',
                exec: onToggleFullScreen,
                helpDescription: 'keyboardShortcuts.fullScreen'
            },
            isButtonEnabled('tileview', _toolbarButtons) && {
                character: 'W',
                exec: onToggleTileView,
                helpDescription: 'toolbar.tileViewToggle'
            },
            !_isSpeakerStatsDisabled && isButtonEnabled('stats', _toolbarButtons) && {
                character: 'T',
                exec: onSpeakerStats,
                helpDescription: 'keyboardShortcuts.showSpeakerStats'
            }
        ];

        KEYBOARD_SHORTCUTS.forEach(shortcut => {
            if (typeof shortcut === 'object') {
                dispatch(registerShortcut({
                    character: shortcut.character,
                    handler: shortcut.exec,
                    helpDescription: shortcut.helpDescription
                }));
            }
        });

        // If the buttons for sending reactions are not displayed we should disable the shortcuts too.
        if (_shouldDisplayReactionsButtons) {
            const REACTION_SHORTCUTS = Object.keys(REACTIONS).map(key => {
                const onShortcutSendReaction = () => {
                    dispatch(addReactionToBuffer(key));
                    sendAnalytics(createShortcutEvent(
                        `reaction.${key}`
                    ));
                };

                return {
                    character: REACTIONS[key].shortcutChar,
                    exec: onShortcutSendReaction,
                    helpDescription: `toolbar.reaction${key.charAt(0).toUpperCase()}${key.slice(1)}`,
                    altKey: true
                };
            });

            REACTION_SHORTCUTS.forEach(shortcut => {
                dispatch(registerShortcut({
                    alt: shortcut.altKey,
                    character: shortcut.character,
                    handler: shortcut.exec,
                    helpDescription: shortcut.helpDescription
                }));
            });

            if (gifsEnabled) {
                const onGifShortcut = () => {
                    batch(() => {
                        dispatch(toggleReactionsMenuVisibility());
                        dispatch(setGifMenuVisibility(true));
                    });
                };

                dispatch(registerShortcut({
                    character: 'G',
                    handler: onGifShortcut,
                    helpDescription: 'keyboardShortcuts.giphyMenu'
                }));
            }
        }

        return () => {
            [ 'A', 'C', 'D', 'P', 'R', 'S', 'W', 'T', 'G' ].forEach(letter =>
                dispatch(unregisterShortcut(letter)));

            if (_shouldDisplayReactionsButtons) {
                Object.keys(REACTIONS).map(key => REACTIONS[key].shortcutChar)
                    .forEach(letter =>
                        dispatch(unregisterShortcut(letter, true)));
            }
        };
    }, [
        _shouldDisplayReactionsButtons,
        chatOpen,
        desktopSharingButtonDisabled,
        desktopSharingEnabled,
        fullScreen,
        gifsEnabled,
        participantsPaneOpen,
        raisedHand,
        screenSharing,
        tileViewEnabled
    ]);
};


################################################################################

## File: .\jitsi-meet\react\features\toolbox\middleware.web.ts

import { batch } from 'react-redux';
import { AnyAction } from 'redux';

import { IReduxState } from '../app/types';
import { OVERWRITE_CONFIG, SET_CONFIG, UPDATE_CONFIG } from '../base/config/actionTypes';
import { NotifyClickButton } from '../base/config/configType';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import { I_AM_VISITOR_MODE } from '../visitors/actionTypes';
import { iAmVisitor } from '../visitors/functions';

import {
    CLEAR_TOOLBOX_TIMEOUT,
    SET_BUTTONS_WITH_NOTIFY_CLICK,
    SET_FULL_SCREEN,
    SET_PARTICIPANT_MENU_BUTTONS_WITH_NOTIFY_CLICK,
    SET_TOOLBAR_BUTTONS,
    SET_TOOLBOX_TIMEOUT
} from './actionTypes';
import { setMainToolbarThresholds } from './actions.web';
import { TOOLBAR_BUTTONS, VISITORS_MODE_BUTTONS } from './constants';
import { NOTIFY_CLICK_MODE } from './types';

import './subscriber.web';

/**
 * Middleware which intercepts Toolbox actions to handle changes to the
 * visibility timeout of the Toolbox.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {
    switch (action.type) {
    case CLEAR_TOOLBOX_TIMEOUT: {
        const { timeoutID } = store.getState()['features/toolbox'];

        clearTimeout(timeoutID ?? undefined);
        break;
    }
    case UPDATE_CONFIG:
    case OVERWRITE_CONFIG:
    case I_AM_VISITOR_MODE:
    case SET_CONFIG: {
        const result = next(action);
        const { dispatch, getState } = store;
        const state = getState();

        if (action.type !== I_AM_VISITOR_MODE) {
            const {
                customToolbarButtons,
                buttonsWithNotifyClick,
                participantMenuButtonsWithNotifyClick,
                customParticipantMenuButtons
            } = state['features/base/config'];

            batch(() => {
                if (action.type !== I_AM_VISITOR_MODE) {
                    dispatch(setMainToolbarThresholds());
                }
                dispatch({
                    type: SET_BUTTONS_WITH_NOTIFY_CLICK,
                    buttonsWithNotifyClick: _buildButtonsArray(buttonsWithNotifyClick, customToolbarButtons)
                });
                dispatch({
                    type: SET_PARTICIPANT_MENU_BUTTONS_WITH_NOTIFY_CLICK,
                    participantMenuButtonsWithNotifyClick:
                        _buildButtonsArray(participantMenuButtonsWithNotifyClick, customParticipantMenuButtons)
                });
            });
        }

        const toolbarButtons = _getToolbarButtons(state);

        dispatch({
            type: SET_TOOLBAR_BUTTONS,
            toolbarButtons
        });

        return result;
    }

    case SET_FULL_SCREEN:
        return _setFullScreen(next, action);

    case SET_TOOLBOX_TIMEOUT: {
        const { timeoutID } = store.getState()['features/toolbox'];
        const { handler, timeoutMS }: { handler: Function; timeoutMS: number; } = action;

        clearTimeout(timeoutID ?? undefined);
        action.timeoutID = setTimeout(handler, timeoutMS);

        break;
    }
    }

    return next(action);
});

type DocumentElement = {
    requestFullscreen?: Function;
    webkitRequestFullscreen?: Function;
};

/**
 * Makes an external request to enter or exit full screen mode.
 *
 * @param {Dispatch} next - The redux dispatch function to dispatch the
 * specified action to the specified store.
 * @param {Action} action - The redux action SET_FULL_SCREEN which is being
 * dispatched in the specified store.
 * @private
 * @returns {Object} The value returned by {@code next(action)}.
 */
function _setFullScreen(next: Function, action: AnyAction) {
    const result = next(action);

    const { fullScreen } = action;

    if (fullScreen) {
        const documentElement: DocumentElement
            = document.documentElement || {};

        if (typeof documentElement.requestFullscreen === 'function') {
            documentElement.requestFullscreen();
        } else if (
            typeof documentElement.webkitRequestFullscreen === 'function') {
            documentElement.webkitRequestFullscreen();
        }

        return result;
    }

    if (typeof document.exitFullscreen === 'function') {
        document.exitFullscreen();
    } else if (typeof document.webkitExitFullscreen === 'function') {
        document.webkitExitFullscreen();
    }

    return result;
}

/**
 * Common logic to gather buttons that have to notify the api when clicked.
 *
 * @param {Array} buttonsWithNotifyClick - The array of systme buttons that need to notify the api.
 * @param {Array} customButtons - The custom buttons.
 * @returns {Array}
 */
function _buildButtonsArray(
        buttonsWithNotifyClick?: NotifyClickButton[],
        customButtons?: {
            icon: string;
            id: string;
            text: string;
        }[]
): Map<string, NOTIFY_CLICK_MODE> {
    const customButtonsWithNotifyClick = customButtons?.map(
        ({ id }) => ([ id, NOTIFY_CLICK_MODE.ONLY_NOTIFY ]) as [string, NOTIFY_CLICK_MODE]) ?? [];
    const buttons = (Array.isArray(buttonsWithNotifyClick) ? buttonsWithNotifyClick : [])
        .filter(button => typeof button === 'string' || (typeof button === 'object' && typeof button.key === 'string'))
        .map(button => {
            if (typeof button === 'string') {
                return [ button, NOTIFY_CLICK_MODE.PREVENT_AND_NOTIFY ] as [string, NOTIFY_CLICK_MODE];
            }

            return [
                button.key,
                button.preventExecution ? NOTIFY_CLICK_MODE.PREVENT_AND_NOTIFY : NOTIFY_CLICK_MODE.ONLY_NOTIFY
            ] as [string, NOTIFY_CLICK_MODE];
        });

    return new Map([ ...customButtonsWithNotifyClick, ...buttons ]);
}

/**
 * Returns the list of enabled toolbar buttons.
 *
 * @param {Object} state - The redux state.
 * @returns {Array<string>} - The list of enabled toolbar buttons.
 */
function _getToolbarButtons(state: IReduxState): Array<string> {
    const { toolbarButtons, customToolbarButtons } = state['features/base/config'];
    const customButtons = customToolbarButtons?.map(({ id }) => id);
    let buttons = Array.isArray(toolbarButtons) ? toolbarButtons : TOOLBAR_BUTTONS;

    if (iAmVisitor(state)) {
        buttons = VISITORS_MODE_BUTTONS.filter(button => buttons.indexOf(button) > -1);
    }

    if (customButtons) {
        return [ ...buttons, ...customButtons ];
    }

    return buttons;
}


################################################################################

## File: .\jitsi-meet\react\features\toolbox\reducer.ts

import ReducerRegistry from '../base/redux/ReducerRegistry';
import { set } from '../base/redux/functions';

import {
    CLEAR_TOOLBOX_TIMEOUT,
    FULL_SCREEN_CHANGED,
    SET_BUTTONS_WITH_NOTIFY_CLICK,
    SET_HANGUP_MENU_VISIBLE,
    SET_MAIN_TOOLBAR_BUTTONS_THRESHOLDS,
    SET_OVERFLOW_DRAWER,
    SET_OVERFLOW_MENU_VISIBLE,
    SET_PARTICIPANT_MENU_BUTTONS_WITH_NOTIFY_CLICK,
    SET_TOOLBAR_BUTTONS,
    SET_TOOLBAR_HOVERED,
    SET_TOOLBOX_ENABLED,
    SET_TOOLBOX_SHIFT_UP,
    SET_TOOLBOX_TIMEOUT,
    SET_TOOLBOX_VISIBLE,
    TOGGLE_TOOLBOX_VISIBLE
} from './actionTypes';
import { THRESHOLDS } from './constants';
import { IMainToolbarButtonThresholds, NOTIFY_CLICK_MODE } from './types';

/**
 * Initial state of toolbox's part of Redux store.
 */
const INITIAL_STATE = {
    buttonsWithNotifyClick: new Map(),

    /**
     * The indicator which determines whether the Toolbox is enabled.
     *
     * @type {boolean}
     */
    enabled: true,

    /**
     * The indicator which determines whether the hangup menu is visible.
     *
     * @type {boolean}
     */
    hangupMenuVisible: false,

    /**
     * The indicator which determines whether a Toolbar in the Toolbox is
     * hovered.
     *
     * @type {boolean}
     */
    hovered: false,

    /**
     * The thresholds for screen size and visible main toolbar buttons.
     */
    mainToolbarButtonsThresholds: THRESHOLDS,

    participantMenuButtonsWithNotifyClick: new Map(),

    /**
     * The indicator which determines whether the overflow menu(s) are to be displayed as drawers.
     *
     * @type {boolean}
     */
    overflowDrawer: false,

    /**
     * The indicator which determines whether the OverflowMenu is visible.
     *
     * @type {boolean}
     */
    overflowMenuVisible: false,

    /**
     * Whether to shift the toolbar up (in case it overlaps the tiles names).
     */
    shiftUp: false,

    /**
     * A number, non-zero value which identifies the timer created by a call
     * to setTimeout().
     *
     * @type {number|null}
     */
    timeoutID: null,

    /**
     * The list of enabled toolbar buttons.
     *
     * @type {Array<string>}
     */
    toolbarButtons: [],


    /**
     * The indicator that determines whether the Toolbox is visible.
     *
     * @type {boolean}
     */
    visible: false
};

export interface IToolboxState {
    buttonsWithNotifyClick: Map<string, NOTIFY_CLICK_MODE>;
    enabled: boolean;
    fullScreen?: boolean;
    hangupMenuVisible: boolean;
    hovered: boolean;
    mainToolbarButtonsThresholds: IMainToolbarButtonThresholds;
    overflowDrawer: boolean;
    overflowMenuVisible: boolean;
    participantMenuButtonsWithNotifyClick: Map<string, NOTIFY_CLICK_MODE>;
    shiftUp: boolean;
    timeoutID?: number | null;
    toolbarButtons: Array<string>;
    visible: boolean;
}

ReducerRegistry.register<IToolboxState>(
    'features/toolbox',
    (state = INITIAL_STATE, action): IToolboxState => {
        switch (action.type) {
        case CLEAR_TOOLBOX_TIMEOUT:
            return {
                ...state,
                timeoutID: undefined
            };

        case FULL_SCREEN_CHANGED:
            return {
                ...state,
                fullScreen: action.fullScreen
            };

        case SET_HANGUP_MENU_VISIBLE:
            return {
                ...state,
                hangupMenuVisible: action.visible
            };

        case SET_OVERFLOW_DRAWER:
            return {
                ...state,
                overflowDrawer: action.displayAsDrawer
            };

        case SET_OVERFLOW_MENU_VISIBLE:
            return {
                ...state,
                overflowMenuVisible: action.visible
            };

        case SET_TOOLBAR_BUTTONS:
            return {
                ...state,
                toolbarButtons: action.toolbarButtons
            };
        case SET_BUTTONS_WITH_NOTIFY_CLICK:
            return {
                ...state,
                buttonsWithNotifyClick: action.buttonsWithNotifyClick
            };

        case SET_MAIN_TOOLBAR_BUTTONS_THRESHOLDS:
            return {
                ...state,
                mainToolbarButtonsThresholds: action.mainToolbarButtonsThresholds
            };
        case SET_TOOLBAR_HOVERED:
            return {
                ...state,
                hovered: action.hovered
            };

        case SET_TOOLBOX_ENABLED:
            return {
                ...state,
                enabled: action.enabled
            };

        case SET_TOOLBOX_TIMEOUT:
            return {
                ...state,
                timeoutID: action.timeoutID
            };

        case SET_TOOLBOX_SHIFT_UP:
            return {
                ...state,
                shiftUp: action.shiftUp
            };

        case SET_TOOLBOX_VISIBLE:
            return set(state, 'visible', action.visible);

        case SET_PARTICIPANT_MENU_BUTTONS_WITH_NOTIFY_CLICK:
            return {
                ...state,
                participantMenuButtonsWithNotifyClick: action.participantMenuButtonsWithNotifyClick
            };

        case TOGGLE_TOOLBOX_VISIBLE:
            return set(state, 'visible', !state.visible);
        }

        return state;
    });


################################################################################

## File: .\jitsi-meet\react\features\toolbox\subscriber.web.ts

import { throttle } from 'lodash-es';

import { IReduxState, IStore } from '../app/types';
import { getParticipantCount } from '../base/participants/functions';
import StateListenerRegistry from '../base/redux/StateListenerRegistry';
import { DEFAULT_MAX_COLUMNS } from '../filmstrip/constants';
import { isLayoutTileView } from '../video-layout/functions.any';

import { setShiftUp } from './actions.any';
import { isAudioMuteButtonDisabled } from './functions.any';

/**
 * Notifies when audio availability changes.
 */
StateListenerRegistry.register(
    /* selector */ (state: IReduxState) => isAudioMuteButtonDisabled(state),
    /* listener */ (disabled: boolean, store: IStore, previousDisabled: boolean) => {
        if (disabled !== previousDisabled) {
            APP.API.notifyAudioAvailabilityChanged(!disabled);
        }
    }
);


const checkToolboxOverlap = (clientHeight: number, store: IStore) => {
    let toolboxRect = document.querySelector('.toolbox-content-items')?.getBoundingClientRect();

    if (!toolboxRect) {
        return;
    }
    const tiles = document.querySelectorAll('span.videocontainer');

    if (!tiles.length) {
        return;
    }

    const toolboxHeight = 48 + 12; // height + padding
    const bottomMargin = 16;

    // Set top and bottom manually to avoid wrong coordinates
    // caused by the hiding/ showing of the toolbox.
    toolboxRect = {
        ...toolboxRect,
        top: clientHeight - toolboxHeight - bottomMargin,
        bottom: clientHeight - bottomMargin,
        left: toolboxRect.left,
        right: toolboxRect.right
    };
    let isIntersecting = false;

    const rows = store.getState()['features/filmstrip'].tileViewDimensions?.gridDimensions?.rows;
    const noOfTilesToCheck = rows === 1 ? tiles.length : DEFAULT_MAX_COLUMNS - 1;

    for (let i = 1; i < Math.max(noOfTilesToCheck, tiles.length); i++) {
        const tile = tiles[tiles.length - i];
        const indicatorsRect = tile?.querySelector('.bottom-indicators')?.getBoundingClientRect();

        if (!indicatorsRect) {
            // eslint-disable-next-line no-continue
            continue;
        }

        if (indicatorsRect.top <= toolboxRect.bottom
            && indicatorsRect.right >= toolboxRect.left
            && indicatorsRect.bottom >= toolboxRect.top
            && indicatorsRect.left <= toolboxRect.right
        ) {
            isIntersecting = true;
            break;
        }
    }

    store.dispatch(setShiftUp(isIntersecting));
};

const throttledCheckOverlap = throttle(checkToolboxOverlap, 100, {
    leading: false,
    trailing: true
});

/**
 * Listens for changes in the selected layout to calculate the dimensions of the tile view grid and horizontal view.
 */
StateListenerRegistry.register(
    /* selector */ state => {
        const { clientHeight, clientWidth } = state['features/base/responsive-ui'];

        return {
            participantCount: getParticipantCount(state),
            clientHeight,
            clientWidth,
            isTileView: isLayoutTileView(state)
        };
    },
    /* listener */({ clientHeight, isTileView }, store, previousState) => {
        if (!isTileView) {
            if (previousState?.isTileView) {
                store.dispatch(setShiftUp(false));
            }

            return;
        }
        throttledCheckOverlap(clientHeight, store);

    }, {
        deepEquals: true
    });


################################################################################

## File: .\jitsi-meet\react\features\toolbox\types.ts

import { ComponentType } from 'react';

import { CustomOptionButton } from './components';

export interface IToolboxButton {
    Content: ComponentType<any>;
    group: number;
    key: string;
}

export type ToolbarButton = 'camera' |
    'chat' |
    'closedcaptions' |
    'desktop' |
    'download' |
    'embedmeeting' |
    'etherpad' |
    'feedback' |
    'filmstrip' |
    'fullscreen' |
    'hangup' |
    'help' |
    'highlight' |
    'invite' |
    'linktosalesforce' |
    'livestreaming' |
    'microphone' |
    'mute-everyone' |
    'mute-video-everyone' |
    'noisesuppression' |
    'participants-pane' |
    'profile' |
    'raisehand' |
    'reactions' |
    'recording' |
    'security' |
    'select-background' |
    'settings' |
    'shareaudio' |
    'sharedvideo' |
    'shortcuts' |
    'stats' |
    'tileview' |
    'toggle-camera' |
    'videoquality' |
    'whiteboard' |
    '__end';

export enum NOTIFY_CLICK_MODE {
    ONLY_NOTIFY = 'ONLY_NOTIFY',
    PREVENT_AND_NOTIFY = 'PREVENT_AND_NOTIFY'
}

export type IMainToolbarButtonThresholds = Array<{
    order: Array<ToolbarButton | string>;
    width: number;
}>;

export interface ICustomToolbarButton {
    Content?: typeof CustomOptionButton;
    backgroundColor?: string;
    group?: number;
    icon: string;
    id: string;
    key?: string;
    text: string;
}


################################################################################

## File: .\jitsi-meet\react\features\toolbox\components\DownloadButton.ts

import { connect } from 'react-redux';

import { createToolbarEvent } from '../../analytics/AnalyticsEvents';
import { sendAnalytics } from '../../analytics/functions';
import { IReduxState } from '../../app/types';
import { translate } from '../../base/i18n/functions';
import { IconDownload } from '../../base/icons/svg';
import AbstractButton, { IProps as AbstractButtonProps } from '../../base/toolbox/components/AbstractButton';
import { openURLInBrowser } from '../../base/util/openURLInBrowser';

interface IProps extends AbstractButtonProps {

    /**
     * The URL to the applications page.
     */
    _downloadAppsUrl: string;
}

/**
 * Implements an {@link AbstractButton} to open the applications page in a new window.
 */
class DownloadButton extends AbstractButton<IProps> {
    accessibilityLabel = 'toolbar.accessibilityLabel.download';
    icon = IconDownload;
    label = 'toolbar.download';
    tooltip = 'toolbar.download';

    /**
     * Handles clicking / pressing the button, and opens a new window with the user documentation.
     *
     * @private
     * @returns {void}
     */
    _handleClick() {
        const { _downloadAppsUrl } = this.props;

        sendAnalytics(createToolbarEvent('download.pressed'));
        openURLInBrowser(_downloadAppsUrl);
    }
}


/**
 * Maps part of the redux state to the component's props.
 *
 * @param {Object} state - The redux store/state.
 * @returns {Object}
 */
function _mapStateToProps(state: IReduxState) {
    const { downloadAppsUrl } = state['features/base/config'].deploymentUrls || {};
    const visible = typeof downloadAppsUrl === 'string';

    return {
        _downloadAppsUrl: downloadAppsUrl ?? '',
        visible
    };
}

export default translate(connect(_mapStateToProps)(DownloadButton));


################################################################################

## File: .\jitsi-meet\react\features\toolbox\components\HangupButton.ts

import { once } from 'lodash-es';
import { connect } from 'react-redux';

import { createToolbarEvent } from '../../analytics/AnalyticsEvents';
import { sendAnalytics } from '../../analytics/functions';
import { leaveConference } from '../../base/conference/actions';
import { translate } from '../../base/i18n/functions';
import { IProps as AbstractButtonProps } from '../../base/toolbox/components/AbstractButton';
import AbstractHangupButton from '../../base/toolbox/components/AbstractHangupButton';

/**
 * Component that renders a toolbar button for leaving the current conference.
 *
 * @augments AbstractHangupButton
 */
class HangupButton extends AbstractHangupButton<AbstractButtonProps> {
    _hangup: Function;

    accessibilityLabel = 'toolbar.accessibilityLabel.hangup';
    label = 'toolbar.hangup';
    tooltip = 'toolbar.hangup';

    /**
     * Initializes a new HangupButton instance.
     *
     * @param {Props} props - The read-only properties with which the new
     * instance is to be initialized.
     */
    constructor(props: AbstractButtonProps) {
        super(props);

        this._hangup = once(() => {
            sendAnalytics(createToolbarEvent('hangup'));
            this.props.dispatch(leaveConference());
        });
    }

    /**
     * Helper function to perform the actual hangup action.
     *
     * @override
     * @protected
     * @returns {void}
     */
    _doHangup() {
        this._hangup();
    }
}

export default translate(connect()(HangupButton));


################################################################################

## File: .\jitsi-meet\react\features\toolbox\components\HelpButton.ts

import { connect } from 'react-redux';

import { createToolbarEvent } from '../../analytics/AnalyticsEvents';
import { sendAnalytics } from '../../analytics/functions';
import { IReduxState } from '../../app/types';
import { HELP_BUTTON_ENABLED } from '../../base/flags/constants';
import { getFeatureFlag } from '../../base/flags/functions';
import { translate } from '../../base/i18n/functions';
import { IconHelp } from '../../base/icons/svg';
import AbstractButton, { IProps as AbstractButtonProps } from '../../base/toolbox/components/AbstractButton';
import { openURLInBrowser } from '../../base/util/openURLInBrowser';

interface IProps extends AbstractButtonProps {

    /**
     * The URL to the user documentation.
     */
    _userDocumentationURL: string;
}

/**
 * Implements an {@link AbstractButton} to open the user documentation in a new window.
 */
class HelpButton extends AbstractButton<IProps> {
    accessibilityLabel = 'toolbar.accessibilityLabel.help';
    icon = IconHelp;
    label = 'toolbar.help';
    tooltip = 'toolbar.help';

    /**
     * Handles clicking / pressing the button, and opens a new window with the user documentation.
     *
     * @private
     * @returns {void}
     */
    _handleClick() {
        const { _userDocumentationURL } = this.props;

        sendAnalytics(createToolbarEvent('help.pressed'));
        openURLInBrowser(_userDocumentationURL);
    }
}


/**
 * Maps part of the redux state to the component's props.
 *
 * @param {Object} state - The redux store/state.
 * @returns {Object}
 */
function _mapStateToProps(state: IReduxState) {
    const { userDocumentationURL } = state['features/base/config'].deploymentUrls || {};
    const enabled = getFeatureFlag(state, HELP_BUTTON_ENABLED, true);
    const visible = typeof userDocumentationURL === 'string' && enabled;

    return {
        _userDocumentationURL: userDocumentationURL ?? '',
        visible
    };
}

export default translate(connect(_mapStateToProps)(HelpButton));


################################################################################

## File: .\jitsi-meet\react\features\toolbox\components\index.native.ts

export { default as CustomOptionButton } from './native/CustomOptionButton';


################################################################################

## File: .\jitsi-meet\react\features\toolbox\components\index.web.ts

export { default as CustomOptionButton } from './web/CustomOptionButton';


################################################################################

## File: .\jitsi-meet\react\features\toolbox\components\native\AudioOnlyButton.ts

import { connect } from 'react-redux';

import { IReduxState } from '../../../app/types';
import { setAudioOnly, toggleAudioOnly } from '../../../base/audio-only/actions';
import { AUDIO_ONLY_BUTTON_ENABLED } from '../../../base/flags/constants';
import { getFeatureFlag } from '../../../base/flags/functions';
import { translate } from '../../../base/i18n/functions';
import { IconAudioOnly, IconAudioOnlyOff } from '../../../base/icons/svg';
import AbstractButton, { IProps as AbstractButtonProps } from '../../../base/toolbox/components/AbstractButton';
import {
    navigate
} from '../../../mobile/navigation/components/conference/ConferenceNavigationContainerRef';
import { screen } from '../../../mobile/navigation/routes';

/**
 * The type of the React {@code Component} props of {@link AudioOnlyButton}.
 */
interface IProps extends AbstractButtonProps {

    /**
     * Whether the current conference is in audio only mode or not.
     */
    _audioOnly: boolean;

    /**
     * Indicates whether the car mode is enabled.
     */
    _startCarMode?: boolean;
}

/**
 * An implementation of a button for toggling the audio-only mode.
 */
class AudioOnlyButton extends AbstractButton<IProps> {
    accessibilityLabel = 'toolbar.accessibilityLabel.audioOnly';
    icon = IconAudioOnly;
    label = 'toolbar.audioOnlyOn';
    toggledIcon = IconAudioOnlyOff;
    toggledLabel = 'toolbar.audioOnlyOff';

    /**
     * Handles clicking / pressing the button.
     *
     * @override
     * @protected
     * @returns {void}
     */
    _handleClick() {
        const { _audioOnly, _startCarMode, dispatch } = this.props;

        if (!_audioOnly && _startCarMode) {
            dispatch(setAudioOnly(true));
            navigate(screen.conference.carmode);
        } else {
            dispatch(toggleAudioOnly());
        }
    }


    /**
     * Indicates whether this button is in toggled state or not.
     *
     * @override
     * @protected
     * @returns {boolean}
     */
    _isToggled() {
        return this.props._audioOnly;
    }
}

/**
 * Maps (parts of) the redux state to the associated props for the
 * {@code AudioOnlyButton} component.
 *
 * @param {Object} state - The Redux state.
 * @param {Object} ownProps - The properties explicitly passed to the component instance.
 * @private
 * @returns {{
 *     _audioOnly: boolean
 * }}
 */
function _mapStateToProps(state: IReduxState, ownProps: any) {
    const { enabled: audioOnly } = state['features/base/audio-only'];
    const enabledInFeatureFlags = getFeatureFlag(state, AUDIO_ONLY_BUTTON_ENABLED, true);
    const { startCarMode } = state['features/base/settings'];
    const { visible = enabledInFeatureFlags } = ownProps;

    return {
        _audioOnly: Boolean(audioOnly),
        _startCarMode: startCarMode,
        visible
    };
}

export default translate(connect(_mapStateToProps)(AudioOnlyButton));


################################################################################

## File: .\jitsi-meet\react\features\toolbox\components\native\LinkToSalesforceButton.ts

import { connect } from 'react-redux';

import { createToolbarEvent } from '../../../analytics/AnalyticsEvents';
import { sendAnalytics } from '../../../analytics/functions';
import { IReduxState } from '../../../app/types';
import { translate } from '../../../base/i18n/functions';
import { IconCloudUpload } from '../../../base/icons/svg';
import AbstractButton, { IProps as AbstractButtonProps } from '../../../base/toolbox/components/AbstractButton';
import { navigate }
    from '../../../mobile/navigation/components/conference/ConferenceNavigationContainerRef';
import { screen } from '../../../mobile/navigation/routes';
import { isSalesforceEnabled } from '../../../salesforce/functions';

/**
 * Implementation of a button for opening the Salesforce link dialog.
 */
class LinkToSalesforceButton extends AbstractButton<AbstractButtonProps> {
    accessibilityLabel = 'toolbar.accessibilityLabel.linkToSalesforce';
    icon = IconCloudUpload;
    label = 'toolbar.linkToSalesforce';

    /**
     * Handles clicking / pressing the button, and opens the Salesforce link dialog.
     *
     * @protected
     * @returns {void}
     */
    _handleClick() {
        sendAnalytics(createToolbarEvent('link.to.salesforce'));

        return navigate(screen.conference.salesforce);
    }
}

/**
 * Function that maps parts of Redux state tree into component props.
 *
 * @param {Object} state - Redux state.
 * @private
 * @returns {Props}
 */
function mapStateToProps(state: IReduxState) {
    return {
        visible: isSalesforceEnabled(state)
    };
}

export default translate(connect(mapStateToProps)(LinkToSalesforceButton));


################################################################################

## File: .\jitsi-meet\react\features\toolbox\components\native\OverflowMenuButton.ts

import { connect } from 'react-redux';

import { IReduxState } from '../../../app/types';
import { openSheet } from '../../../base/dialog/actions';
import { OVERFLOW_MENU_ENABLED } from '../../../base/flags/constants';
import { getFeatureFlag } from '../../../base/flags/functions';
import { translate } from '../../../base/i18n/functions';
import { IconDotsHorizontal } from '../../../base/icons/svg';
import AbstractButton, { IProps as AbstractButtonProps } from '../../../base/toolbox/components/AbstractButton';

import OverflowMenu from './OverflowMenu';

/**
 * An implementation of a button for showing the {@code OverflowMenu}.
 */
class OverflowMenuButton extends AbstractButton<AbstractButtonProps> {
    accessibilityLabel = 'toolbar.accessibilityLabel.moreActions';
    icon = IconDotsHorizontal;
    label = 'toolbar.moreActions';

    /**
     * Handles clicking / pressing this {@code OverflowMenuButton}.
     *
     * @protected
     * @returns {void}
     */
    _handleClick() {
        this.props.dispatch(openSheet(OverflowMenu));
    }
}

/**
 * Maps (parts of) the redux state to the associated props for the
 * {@code OverflowMenuButton} component.
 *
 * @param {Object} state - The Redux state.
 * @private
 * @returns {Props}
 */
function _mapStateToProps(state: IReduxState) {
    const enabledFlag = getFeatureFlag(state, OVERFLOW_MENU_ENABLED, true);

    return {
        visible: enabledFlag
    };
}

export default translate(connect(_mapStateToProps)(OverflowMenuButton));


################################################################################

## File: .\jitsi-meet\react\features\toolbox\components\native\RaiseHandButton.ts

import { connect } from 'react-redux';

import { createToolbarEvent } from '../../../analytics/AnalyticsEvents';
import { sendAnalytics } from '../../../analytics/functions';
import { IReduxState } from '../../../app/types';
import { RAISE_HAND_ENABLED } from '../../../base/flags/constants';
import { getFeatureFlag } from '../../../base/flags/functions';
import { translate } from '../../../base/i18n/functions';
import { IconRaiseHand } from '../../../base/icons/svg';
import { raiseHand } from '../../../base/participants/actions';
import {
    getLocalParticipant,
    hasRaisedHand
} from '../../../base/participants/functions';
import { ILocalParticipant } from '../../../base/participants/types';
import AbstractButton, { IProps as AbstractButtonProps } from '../../../base/toolbox/components/AbstractButton';

/**
 * The type of the React {@code Component} props of {@link RaiseHandButton}.
 */
interface IProps extends AbstractButtonProps {

    /**
     * The local participant.
     */
    _localParticipant?: ILocalParticipant;

    /**
     * Whether the participant raised their hand or not.
     */
    _raisedHand: boolean;
}

/**
 * An implementation of a button to raise or lower hand.
 */
class RaiseHandButton extends AbstractButton<IProps> {
    accessibilityLabel = 'toolbar.accessibilityLabel.raiseHand';
    icon = IconRaiseHand;
    label = 'toolbar.raiseYourHand';
    toggledLabel = 'toolbar.lowerYourHand';

    /**
     * Handles clicking / pressing the button.
     *
     * @override
     * @protected
     * @returns {void}
     */
    _handleClick() {
        this._toggleRaisedHand();
    }

    /**
     * Indicates whether this button is in toggled state or not.
     *
     * @override
     * @protected
     * @returns {boolean}
     */
    _isToggled() {
        return this.props._raisedHand;
    }

    /**
     * Toggles the rased hand status of the local participant.
     *
     * @returns {void}
     */
    _toggleRaisedHand() {
        const enable = !this.props._raisedHand;

        sendAnalytics(createToolbarEvent('raise.hand', { enable }));

        this.props.dispatch(raiseHand(enable));
    }
}

/**
 * Maps part of the Redux state to the props of this component.
 *
 * @param {Object} state - The Redux state.
 * @param {Object} ownProps - The properties explicitly passed to the component instance.
 * @private
 * @returns {IProps}
 */
function _mapStateToProps(state: IReduxState, ownProps: any) {
    const _localParticipant = getLocalParticipant(state);
    const enabled = getFeatureFlag(state, RAISE_HAND_ENABLED, true);
    const { visible = enabled } = ownProps;

    return {
        _localParticipant,
        _raisedHand: hasRaisedHand(_localParticipant),
        visible
    };
}

export default translate(connect(_mapStateToProps)(RaiseHandButton));


################################################################################

## File: .\jitsi-meet\react\features\toolbox\components\native\ScreenSharingAndroidButton.ts

import { connect } from 'react-redux';

import { IReduxState } from '../../../app/types';
import { ANDROID_SCREENSHARING_ENABLED } from '../../../base/flags/constants';
import { getFeatureFlag } from '../../../base/flags/functions';
import { translate } from '../../../base/i18n/functions';
import { IconScreenshare } from '../../../base/icons/svg';
import AbstractButton, { IProps as AbstractButtonProps } from '../../../base/toolbox/components/AbstractButton';
import { toggleScreensharing } from '../../../base/tracks/actions.native';
import { isLocalVideoTrackDesktop } from '../../../base/tracks/functions.native';

/**
 * The type of the React {@code Component} props of {@link ScreenSharingAndroidButton}.
 */
interface IProps extends AbstractButtonProps {

    /**
     * True if the button needs to be disabled.
     */
    _disabled: boolean;

    /**
     * Whether video is currently muted or not.
     */
    _screensharing: boolean;
}

/**
 * An implementation of a button for toggling screen sharing.
 */
class ScreenSharingAndroidButton extends AbstractButton<IProps> {
    accessibilityLabel = 'toolbar.accessibilityLabel.shareYourScreen';
    icon = IconScreenshare;
    label = 'toolbar.startScreenSharing';
    toggledLabel = 'toolbar.stopScreenSharing';

    /**
     * Handles clicking / pressing the button.
     *
     * @override
     * @protected
     * @returns {void}
     */
    _handleClick() {
        const enable = !this._isToggled();

        this.props.dispatch(toggleScreensharing(enable));
    }

    /**
     * Returns a boolean value indicating if this button is disabled or not.
     *
     * @protected
     * @returns {boolean}
     */
    _isDisabled() {
        return this.props._disabled;
    }

    /**
     * Indicates whether this button is in toggled state or not.
     *
     * @override
     * @protected
     * @returns {boolean}
     */
    _isToggled() {
        return this.props._screensharing;
    }
}

/**
 * Maps (parts of) the redux state to the associated props for the
 * {@code ToggleCameraButton} component.
 *
 * @param {Object} state - The Redux state.
 * @private
 * @returns {{
 *     _screensharing: boolean
 * }}
 */
function _mapStateToProps(state: IReduxState) {
    const enabled = getFeatureFlag(state, ANDROID_SCREENSHARING_ENABLED, true);

    return {
        _screensharing: isLocalVideoTrackDesktop(state),
        visible: enabled
    };
}

export default translate(connect(_mapStateToProps)(ScreenSharingAndroidButton));


################################################################################

## File: .\jitsi-meet\react\features\toolbox\components\native\styles.ts

import ColorSchemeRegistry from '../../../base/color-scheme/ColorSchemeRegistry';
import { schemeColor } from '../../../base/color-scheme/functions';
import BaseTheme from '../../../base/ui/components/BaseTheme.native';

const BUTTON_SIZE = 48;

// Toolbox, toolbar:

/**
 * The style of toolbar buttons.
 */
const toolbarButton = {
    borderRadius: BaseTheme.shape.borderRadius,
    borderWidth: 0,
    flex: 0,
    flexDirection: 'row',
    height: BUTTON_SIZE,
    justifyContent: 'center',
    marginHorizontal: 6,
    marginVertical: 6,
    width: BUTTON_SIZE
};

/**
 * The icon style of the toolbar buttons.
 */
const toolbarButtonIcon = {
    alignSelf: 'center',
    color: BaseTheme.palette.icon04,
    fontSize: 24
};


/**
 * The icon style of toolbar buttons which display white icons.
 */
const whiteToolbarButtonIcon = {
    ...toolbarButtonIcon,
    color: BaseTheme.palette.icon01
};

/**
 * The style of reaction buttons.
 */
const reactionButton = {
    ...toolbarButton,
    backgroundColor: 'transparent',
    alignItems: 'center',
    marginTop: 0,
    marginHorizontal: 0
};

const gifButton = {
    ...reactionButton,
    backgroundColor: '#000'
};

/**
 * The style of the emoji on the reaction buttons.
 */
const reactionEmoji = {
    fontSize: 20,
    color: BaseTheme.palette.icon01
};

const reactionMenu = {
    flexDirection: 'column',
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: BaseTheme.palette.ui01,
    padding: BaseTheme.spacing[3]
};

/**
 * The Toolbox and toolbar related styles.
 */
const styles = {

    sheetGestureRecognizer: {
        alignItems: 'stretch',
        flexDirection: 'column'
    },

    /**
     * The style of the toolbar.
     */
    toolbox: {
        alignItems: 'center',
        backgroundColor: BaseTheme.palette.uiBackground,
        borderTopLeftRadius: 3,
        borderTopRightRadius: 3,
        flexDirection: 'row',
        justifyContent: 'space-between'
    },

    /**
     * The style of the root/top-level container of {@link Toolbox}.
     */
    toolboxContainer: {
        backgroundColor: BaseTheme.palette.uiBackground,
        flexDirection: 'column',
        maxWidth: 580,
        marginLeft: 'auto',
        marginRight: 'auto',
        width: '100%'
    },

    iconImageStyles: {
        height: BaseTheme.spacing[4],
        width: BaseTheme.spacing[4]
    }
};

export default styles;

/**
 * Color schemed styles for the @{Toolbox} component.
 */
ColorSchemeRegistry.register('Toolbox', {
    /**
     * Styles for buttons in the toolbar.
     */
    buttonStyles: {
        iconStyle: toolbarButtonIcon,
        style: toolbarButton
    },

    buttonStylesBorderless: {
        iconStyle: whiteToolbarButtonIcon,
        style: {
            ...toolbarButton,
            backgroundColor: 'transparent'
        },
        underlayColor: 'transparent'
    },

    backgroundToggle: {
        backgroundColor: BaseTheme.palette.ui04
    },

    hangupMenuContainer: {
        marginHorizontal: BaseTheme.spacing[2],
        marginVertical: BaseTheme.spacing[2]
    },

    hangupButton: {
        flex: 1,
        marginHorizontal: BaseTheme.spacing[2],
        marginVertical: BaseTheme.spacing[2]
    },

    hangupButtonStyles: {
        iconStyle: whiteToolbarButtonIcon,
        style: {
            ...toolbarButton,
            backgroundColor: schemeColor('hangup')
        },
        underlayColor: BaseTheme.palette.ui04
    },

    reactionDialog: {
        position: 'absolute',
        width: '100%',
        height: '100%',
        backgroundColor: 'transparent'
    },

    overflowReactionMenu: reactionMenu,

    reactionMenu: {
        ...reactionMenu,
        borderRadius: 3,
        width: 360
    },

    reactionRow: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
        width: '100%'
    },

    reactionButton: {
        gifButton,
        style: reactionButton,
        underlayColor: BaseTheme.palette.ui04,
        emoji: reactionEmoji
    },

    emojiAnimation: {
        color: BaseTheme.palette.icon01,
        position: 'absolute',
        zIndex: 1001,
        elevation: 2,
        fontSize: 20,
        left: '50%',
        top: '100%'
    },

    /**
     * Styles for toggled buttons in the toolbar.
     */
    toggledButtonStyles: {
        iconStyle: whiteToolbarButtonIcon,
        style: {
            ...toolbarButton
        },
        underlayColor: 'transparent'
    }
});


################################################################################

## File: .\jitsi-meet\react\features\toolbox\components\native\ToggleCameraButton.ts

import { connect } from 'react-redux';

import { IReduxState } from '../../../app/types';
import { translate } from '../../../base/i18n/functions';
import { IconCameraRefresh } from '../../../base/icons/svg';
import { toggleCameraFacingMode } from '../../../base/media/actions';
import { MEDIA_TYPE } from '../../../base/media/constants';
import AbstractButton, { IProps as AbstractButtonProps } from '../../../base/toolbox/components/AbstractButton';
import { isLocalTrackMuted } from '../../../base/tracks/functions.native';

/**
 * The type of the React {@code Component} props of {@link ToggleCameraButton}.
 */
interface IProps extends AbstractButtonProps {

    /**
     * Whether the current conference is in audio only mode or not.
     */
    _audioOnly: boolean;

    /**
     * Whether video is currently muted or not.
     */
    _videoMuted: boolean;
}

/**
 * An implementation of a button for toggling the camera facing mode.
 */
class ToggleCameraButton extends AbstractButton<IProps> {
    accessibilityLabel = 'toolbar.accessibilityLabel.toggleCamera';
    icon = IconCameraRefresh;
    label = 'toolbar.toggleCamera';

    /**
     * Handles clicking / pressing the button.
     *
     * @override
     * @protected
     * @returns {void}
     */
    _handleClick() {
        this.props.dispatch(toggleCameraFacingMode());
    }

    /**
     * Indicates whether this button is disabled or not.
     *
     * @override
     * @protected
     * @returns {boolean}
     */
    _isDisabled() {
        return this.props._audioOnly || this.props._videoMuted;
    }
}

/**
 * Maps (parts of) the redux state to the associated props for the
 * {@code ToggleCameraButton} component.
 *
 * @param {Object} state - The Redux state.
 * @private
 * @returns {{
 *     _audioOnly: boolean,
 *     _videoMuted: boolean
 * }}
 */
function _mapStateToProps(state: IReduxState) {
    const { enabled: audioOnly } = state['features/base/audio-only'];
    const tracks = state['features/base/tracks'];

    return {
        _audioOnly: Boolean(audioOnly),
        _videoMuted: isLocalTrackMuted(tracks, MEDIA_TYPE.VIDEO)
    };
}

export default translate(connect(_mapStateToProps)(ToggleCameraButton));


################################################################################

## File: .\jitsi-meet\react\features\toolbox\components\native\ToggleSelfViewButton.ts

import { connect } from 'react-redux';

import { IReduxState } from '../../../app/types';
import { translate } from '../../../base/i18n/functions';
import { IconAudioOnlyOff } from '../../../base/icons/svg';
import { updateSettings } from '../../../base/settings/actions';
import AbstractButton, { IProps as AbstractButtonProps } from '../../../base/toolbox/components/AbstractButton';

/**
 * The type of the React {@code Component} props of {@link ToggleSelfViewButton}.
 */
interface IProps extends AbstractButtonProps {

    /**
     * Whether the self view is disabled or not.
     */
    _disableSelfView: boolean;
}

/**
 * An implementation of a button for toggling the self view.
 */
class ToggleSelfViewButton extends AbstractButton<IProps> {
    accessibilityLabel = 'toolbar.accessibilityLabel.selfView';
    icon = IconAudioOnlyOff;
    label = 'videothumbnail.hideSelfView';
    toggledLabel = 'videothumbnail.showSelfView';

    /**
     * Handles clicking / pressing the button.
     *
     * @override
     * @protected
     * @returns {void}
     */
    _handleClick() {
        const { _disableSelfView, dispatch } = this.props;

        dispatch(updateSettings({
            disableSelfView: !_disableSelfView
        }));
    }

    /**
     * Indicates whether this button is in toggled state or not.
     *
     * @override
     * @protected
     * @returns {boolean}
     */
    _isToggled() {
        return this.props._disableSelfView;
    }
}

/**
 * Maps (parts of) the redux state to the associated props for the
 * {@code ToggleSelfViewButton} component.
 *
 * @param {Object} state - The Redux state.
 * @private
 * @returns {{
 *     _disableSelfView: boolean
 * }}
 */
function _mapStateToProps(state: IReduxState) {
    const { disableSelfView } = state['features/base/settings'];

    return {
        _disableSelfView: Boolean(disableSelfView)
    };
}

export default translate(connect(_mapStateToProps)(ToggleSelfViewButton));


################################################################################

## File: .\jitsi-meet\react\features\toolbox\components\web\DialogPortal.ts

import { ReactNode, useEffect, useRef, useState } from 'react';
import ReactDOM from 'react-dom';
import { useSelector } from 'react-redux';

import { IReduxState } from '../../../app/types';
import { debounce } from '../../../base/config/functions.any';
import { ZINDEX_DIALOG_PORTAL } from '../../constants';

interface IProps {

    /**
    * The component(s) to be displayed within the drawer portal.
    */
    children: ReactNode;

    /**
     * Custom class name to apply on the container div.
     */
    className?: string;

    /**
     * Function used to get the reference to the container div.
     */
    getRef?: Function;

    /**
     * Function called when the portal target becomes actually visible.
     */
    onVisible?: Function;

    /**
     * Function used to get the updated size info of the container on it's resize.
     */
    setSize?: Function;

    /**
     * Custom style to apply to the container div.
     */
    style?: any;

    /**
     * The selector for the element we consider the content container.
     * This is used to determine the correct size of the portal content.
     */
    targetSelector?: string;
}

/**
 * Component meant to render a drawer at the bottom of the screen,
 * by creating a portal containing the component's children.
 *
 * @returns {ReactElement}
 */
function DialogPortal({ children, className, style, getRef, setSize, targetSelector, onVisible }: IProps) {
    const clientWidth = useSelector((state: IReduxState) => state['features/base/responsive-ui'].clientWidth);
    const [ portalTarget ] = useState(() => {
        const portalDiv = document.createElement('div');

        portalDiv.style.visibility = 'hidden';

        return portalDiv;
    });
    const timerRef = useRef<number>();

    useEffect(() => {
        if (style) {
            for (const styleProp of Object.keys(style)) {
                const objStyle: any = portalTarget.style;

                objStyle[styleProp] = style[styleProp];
            }
        }
        if (className) {
            portalTarget.className = className;
        }
    }, [ style, className ]);

    useEffect(() => {
        if (portalTarget && getRef) {
            getRef(portalTarget);
            portalTarget.style.zIndex = `${ZINDEX_DIALOG_PORTAL}`;
        }
    }, [ portalTarget, getRef ]);

    useEffect(() => {
        const size = {
            width: 1,
            height: 1
        };
        const debouncedResizeCallback = debounce((entries: ResizeObserverEntry[]) => {
            const { contentRect } = entries[0];

            if (contentRect.width !== size.width || contentRect.height !== size.height) {
                setSize?.(contentRect);
                clearTimeout(timerRef.current);
                timerRef.current = window.setTimeout(() => {
                    portalTarget.style.visibility = 'visible';
                    onVisible?.();
                }, 100);
            }
        }, 20); // 20ms delay

        // Create and observe ResizeObserver
        const observer = new ResizeObserver(debouncedResizeCallback);
        const target = targetSelector ? portalTarget.querySelector(targetSelector) : portalTarget;

        if (document.body) {
            document.body.appendChild(portalTarget);
            observer.observe(target ?? portalTarget);
        }

        return () => {
            observer.unobserve(target ?? portalTarget);
            if (document.body) {
                document.body.removeChild(portalTarget);
            }
        };
    }, [ clientWidth ]);

    return ReactDOM.createPortal(
        children,
        portalTarget
    );
}

export default DialogPortal;


################################################################################

## File: .\jitsi-meet\react\features\toolbox\components\web\FullscreenButton.ts

import { connect } from 'react-redux';

import { createToolbarEvent } from '../../../analytics/AnalyticsEvents';
import { sendAnalytics } from '../../../analytics/functions';
import { IReduxState } from '../../../app/types';
import { isIosMobileBrowser } from '../../../base/environment/utils';
import { translate } from '../../../base/i18n/functions';
import { IconEnterFullscreen, IconExitFullscreen } from '../../../base/icons/svg';
import AbstractButton, { IProps as AbstractButtonProps } from '../../../base/toolbox/components/AbstractButton';
import { closeOverflowMenuIfOpen, setFullScreen } from '../../actions.web';

interface IProps extends AbstractButtonProps {

    /**
    * Whether or not the app is currently in full screen.
    */
    _fullScreen?: boolean;
}

/**
 * Implementation of a button for toggling fullscreen state.
 */
class FullscreenButton extends AbstractButton<IProps> {
    accessibilityLabel = 'toolbar.accessibilityLabel.enterFullScreen';
    toggledAccessibilityLabel = 'toolbar.accessibilityLabel.exitFullScreen';
    label = 'toolbar.enterFullScreen';
    toggledLabel = 'toolbar.exitFullScreen';
    tooltip = 'toolbar.enterFullScreen';
    toggledTooltip = 'toolbar.exitFullScreen';
    toggledIcon = IconExitFullscreen;
    icon = IconEnterFullscreen;

    /**
     * Indicates whether this button is in toggled state or not.
     *
     * @override
     * @protected
     * @returns {boolean}
     */
    _isToggled() {
        return this.props._fullScreen;
    }

    /**
    * Handles clicking the button, and toggles fullscreen.
    *
    * @private
    * @returns {void}
    */
    _handleClick() {
        const { dispatch, _fullScreen } = this.props;

        sendAnalytics(createToolbarEvent(
            'toggle.fullscreen',
            {
                enable: !_fullScreen
            }));
        dispatch(closeOverflowMenuIfOpen());

        dispatch(setFullScreen(!_fullScreen));
    }
}

/**
 * Function that maps parts of Redux state tree into component props.
 *
 * @param {Object} state - Redux state.
 * @returns {Object}
 */
const mapStateToProps = (state: IReduxState) => {
    return {
        _fullScreen: state['features/toolbox'].fullScreen,
        visible: !isIosMobileBrowser()
    };
};

export default translate(connect(mapStateToProps)(FullscreenButton));


################################################################################

## File: .\jitsi-meet\react\features\toolbox\components\web\LinkToSalesforceButton.ts

import { connect } from 'react-redux';

import { createToolbarEvent } from '../../../analytics/AnalyticsEvents';
import { sendAnalytics } from '../../../analytics/functions';
import { IReduxState } from '../../../app/types';
import { openDialog } from '../../../base/dialog/actions';
import { translate } from '../../../base/i18n/functions';
import { IconCloudUpload } from '../../../base/icons/svg';
import AbstractButton, { IProps as AbstractButtonProps } from '../../../base/toolbox/components/AbstractButton';
import SalesforceLinkDialog from '../../../salesforce/components/web/SalesforceLinkDialog';
import { isSalesforceEnabled } from '../../../salesforce/functions';

/**
 * Implementation of a button for opening the Salesforce link dialog.
 */
class LinkToSalesforce extends AbstractButton<AbstractButtonProps> {
    accessibilityLabel = 'toolbar.accessibilityLabel.linkToSalesforce';
    icon = IconCloudUpload;
    label = 'toolbar.linkToSalesforce';
    tooltip = 'toolbar.linkToSalesforce';

    /**
     * Handles clicking / pressing the button, and opens the Salesforce link dialog.
     *
     * @protected
     * @returns {void}
     */
    _handleClick() {
        const { dispatch } = this.props;

        sendAnalytics(createToolbarEvent('link.to.salesforce'));
        dispatch(openDialog(SalesforceLinkDialog));
    }
}

/**
 * Function that maps parts of Redux state tree into component props.
 *
 * @param {Object} state - Redux state.
 * @returns {Object}
 */
const mapStateToProps = (state: IReduxState) => {
    return {
        visible: isSalesforceEnabled(state)
    };
};

export default translate(connect(mapStateToProps)(LinkToSalesforce));


################################################################################

## File: .\jitsi-meet\react\features\toolbox\components\web\OverflowToggleButton.ts

import { connect } from 'react-redux';

import { translate } from '../../../base/i18n/functions';
import { IconDotsHorizontal } from '../../../base/icons/svg';
import AbstractButton, { IProps as AbstractButtonProps } from '../../../base/toolbox/components/AbstractButton';


/**
 * The type of the React {@code Component} props of {@link OverflowToggleButton}.
 */
interface IProps extends AbstractButtonProps {

    /**
     * Whether the more options menu is open.
     */
    isOpen: boolean;

    /**
     * External handler for key down action.
     */
    onKeyDown: Function;
}

/**
 * Implementation of a button for toggling the overflow menu.
 */
class OverflowToggleButton extends AbstractButton<IProps> {
    accessibilityLabel = 'toolbar.accessibilityLabel.moreActions';
    toggledAccessibilityLabel = 'toolbar.accessibilityLabel.closeMoreActions';
    icon = IconDotsHorizontal;
    label = 'toolbar.moreActions';
    toggledLabel = 'toolbar.moreActions';
    tooltip = 'toolbar.moreActions';

    /**
     * Indicates whether this button is in toggled state or not.
     *
     * @override
     * @protected
     * @returns {boolean}
     */
    _isToggled() {
        return this.props.isOpen;
    }

    /**
     * Indicates whether a key was pressed.
     *
     * @override
     * @protected
     * @returns {boolean}
     */
    _onKeyDown() {
        this.props.onKeyDown();
    }
}


export default connect()(translate(OverflowToggleButton));


################################################################################

## File: .\jitsi-meet\react\features\toolbox\components\web\ProfileButton.ts

import { connect } from 'react-redux';

import { createToolbarEvent } from '../../../analytics/AnalyticsEvents';
import { sendAnalytics } from '../../../analytics/functions';
import { IReduxState } from '../../../app/types';
import { translate } from '../../../base/i18n/functions';
import { getLocalParticipant } from '../../../base/participants/functions';
import { ILocalParticipant } from '../../../base/participants/types';
import AbstractButton, { IProps as AbstractButtonProps } from '../../../base/toolbox/components/AbstractButton';
import { openSettingsDialog } from '../../../settings/actions';
import { SETTINGS_TABS } from '../../../settings/constants';

import ProfileButtonAvatar from './ProfileButtonAvatar';

/**
 * The type of the React {@code Component} props of {@link ProfileButton}.
 */
interface IProps extends AbstractButtonProps {

    /**
     * Default displayed name for local participant.
     */
    _defaultLocalDisplayName: string;

    /**
     * The redux representation of the local participant.
     */
    _localParticipant?: ILocalParticipant;

    /**
      * Whether the button support clicking or not.
      */
    _unclickable: boolean;
}

/**
 * Implementation of a button for opening profile dialog.
 */
class ProfileButton extends AbstractButton<IProps> {
    accessibilityLabel = 'toolbar.accessibilityLabel.profile';
    icon = ProfileButtonAvatar;

    /**
     * Retrieves the label.
     *
     * @returns {string}
     */
    _getLabel() {
        const {
            _defaultLocalDisplayName,
            _localParticipant
        } = this.props;
        let displayName;

        if (_localParticipant?.name) {
            displayName = _localParticipant.name;
        } else {
            displayName = _defaultLocalDisplayName;
        }

        return displayName;
    }

    /**
     * Retrieves the tooltip.
     *
     * @returns {string}
     */
    _getTooltip() {
        return this._getLabel();
    }

    /**
     * Handles clicking / pressing the button, and opens the appropriate dialog.
     *
     * @protected
     * @returns {void}
     */
    _handleClick() {
        const { dispatch, _unclickable } = this.props;

        if (!_unclickable) {
            sendAnalytics(createToolbarEvent('profile'));
            dispatch(openSettingsDialog(SETTINGS_TABS.PROFILE));
        }
    }

    /**
     * Indicates whether the button should be disabled or not.
     *
     * @protected
     * @returns {void}
     */
    _isDisabled() {
        return this.props._unclickable;
    }
}

/**
 * Function that maps parts of Redux state tree into component props.
 *
 * @param {Object} state - Redux state.
 * @returns {Object}
 */
const mapStateToProps = (state: IReduxState) => {
    const { defaultLocalDisplayName } = state['features/base/config'];

    return {
        _defaultLocalDisplayName: defaultLocalDisplayName ?? '',
        _localParticipant: getLocalParticipant(state),
        _unclickable: !interfaceConfig.SETTINGS_SECTIONS.includes('profile'),
        customClass: 'profile-button-avatar'
    };
};

export default translate(connect(mapStateToProps)(ProfileButton));


################################################################################

## File: .\jitsi-meet\react\features\toolbox\components\web\ShareDesktopButton.ts

import { connect } from 'react-redux';

import { createToolbarEvent } from '../../../analytics/AnalyticsEvents';
import { sendAnalytics } from '../../../analytics/functions';
import { IReduxState } from '../../../app/types';
import { translate } from '../../../base/i18n/functions';
import { IconScreenshare } from '../../../base/icons/svg';
import JitsiMeetJS from '../../../base/lib-jitsi-meet/_';
import AbstractButton, { IProps as AbstractButtonProps } from '../../../base/toolbox/components/AbstractButton';
import { startScreenShareFlow } from '../../../screen-share/actions.web';
import { isScreenVideoShared } from '../../../screen-share/functions';
import { closeOverflowMenuIfOpen } from '../../actions.web';
import { isDesktopShareButtonDisabled } from '../../functions.web';

interface IProps extends AbstractButtonProps {

    /**
     * Whether or not screen-sharing is initialized.
     */
    _desktopSharingEnabled: boolean;

    /**
     * Whether or not the local participant is screen-sharing.
     */
    _screensharing: boolean;
}

/**
 * Implementation of a button for sharing desktop / windows.
 */
class ShareDesktopButton extends AbstractButton<IProps> {
    accessibilityLabel = 'toolbar.accessibilityLabel.shareYourScreen';
    toggledAccessibilityLabel = 'toolbar.accessibilityLabel.stopScreenSharing';
    label = 'toolbar.startScreenSharing';
    icon = IconScreenshare;
    toggledLabel = 'toolbar.stopScreenSharing';

    /**
     * Retrieves tooltip dynamically.
     *
     * @returns {string}
     */
    _getTooltip() {
        const { _desktopSharingEnabled, _screensharing } = this.props;

        if (_desktopSharingEnabled) {
            if (_screensharing) {
                return 'toolbar.stopScreenSharing';
            }

            return 'toolbar.startScreenSharing';
        }

        return 'dialog.shareYourScreenDisabled';
    }

    /**
     * Indicates whether this button is in toggled state or not.
     *
     * @override
     * @protected
     * @returns {boolean}
     */
    _isToggled() {
        return this.props._screensharing;
    }

    /**
     * Indicates whether this button is in disabled state or not.
     *
     * @override
     * @protected
     * @returns {boolean}
     */
    _isDisabled() {
        return !this.props._desktopSharingEnabled;
    }

    /**
     * Handles clicking the button, and toggles the chat.
     *
     * @private
     * @returns {void}
     */
    _handleClick() {
        const { dispatch, _screensharing } = this.props;

        sendAnalytics(createToolbarEvent(
            'toggle.screen.sharing',
            { enable: !_screensharing }));

        dispatch(closeOverflowMenuIfOpen());
        dispatch(startScreenShareFlow(!_screensharing));
    }
}

/**
 * Function that maps parts of Redux state tree into component props.
*
 * @param {Object} state - Redux state.
 * @returns {Object}
 */
const mapStateToProps = (state: IReduxState) => {
    // Disable the screen-share button if the video sender limit is reached and there is no video or media share in
    // progress.
    const desktopSharingEnabled
        = JitsiMeetJS.isDesktopSharingEnabled() && !isDesktopShareButtonDisabled(state);

    return {
        _desktopSharingEnabled: desktopSharingEnabled,
        _screensharing: isScreenVideoShared(state),
        visible: JitsiMeetJS.isDesktopSharingEnabled()
    };
};

export default translate(connect(mapStateToProps)(ShareDesktopButton));


################################################################################

## File: .\jitsi-meet\react\features\toolbox\components\web\ToggleCameraButton.ts

import { connect } from 'react-redux';

import { IReduxState } from '../../../app/types';
import { translate } from '../../../base/i18n/functions';
import { IconCameraRefresh } from '../../../base/icons/svg';
import { MEDIA_TYPE } from '../../../base/media/constants';
import AbstractButton, { IProps as AbstractButtonProps } from '../../../base/toolbox/components/AbstractButton';
import { toggleCamera } from '../../../base/tracks/actions';
import { isLocalTrackMuted, isToggleCameraEnabled } from '../../../base/tracks/functions';
import { setOverflowMenuVisible } from '../../actions.web';

/**
 * The type of the React {@code Component} props of {@link ToggleCameraButton}.
 */
interface IProps extends AbstractButtonProps {

    /**
     * Whether the current conference is in audio only mode or not.
     */
    _audioOnly: boolean;

    /**
     * Whether video is currently muted or not.
     */
    _videoMuted: boolean;
}

/**
 * An implementation of a button for toggling the camera facing mode.
 */
class ToggleCameraButton extends AbstractButton<IProps> {
    accessibilityLabel = 'toolbar.accessibilityLabel.toggleCamera';
    icon = IconCameraRefresh;
    label = 'toolbar.toggleCamera';

    /**
     * Handles clicking/pressing the button.
     *
     * @returns {void}
     */
    _handleClick() {
        const { dispatch } = this.props;

        dispatch(toggleCamera());
        dispatch(setOverflowMenuVisible(false));
    }

    /**
     * Whether this button is disabled or not.
     *
     * @returns {boolean}
     */
    _isDisabled() {
        return this.props._audioOnly || this.props._videoMuted;
    }
}

/**
 * Maps (parts of) the redux state to the associated props for the
 * {@code ToggleCameraButton} component.
 *
 * @param {Object} state - The Redux state.
 * @returns {IProps}
 */
function mapStateToProps(state: IReduxState) {
    const { enabled: audioOnly } = state['features/base/audio-only'];
    const tracks = state['features/base/tracks'];

    return {
        _audioOnly: Boolean(audioOnly),
        _videoMuted: isLocalTrackMuted(tracks, MEDIA_TYPE.VIDEO),
        visible: isToggleCameraEnabled(state)
    };
}

export default translate(connect(mapStateToProps)(ToggleCameraButton));


################################################################################

## File: .\jitsi-meet\react\features\transcribing\actions.ts

import {
    TRANSCRIBER_JOINED,
    TRANSCRIBER_LEFT
} from './actionTypes';

/**
 * Notify that the transcriber, with a unique ID, has joined.
 *
 * @param {string} participantId - The participant id of the transcriber.
 * @returns {{
 *     type: TRANSCRIBER_JOINED,
 *     participantId: string
 * }}
 */
export function transcriberJoined(participantId: string) {
    return {
        type: TRANSCRIBER_JOINED,
        transcriberJID: participantId
    };
}

/**
 * Notify that the transcriber, with a unique ID, has left.
 *
 * @param {string} participantId - The participant id of the transcriber.
 * @param {boolean} abruptly - The transcriber did not exit the conference gracefully with switching off first.
 * It maybe there was some backend problem, like network.
 * @returns {{
 *     type: TRANSCRIBER_LEFT,
 *     participantId: string,
 *     abruptly: boolean
 * }}
 */
export function transcriberLeft(participantId: string, abruptly: boolean) {
    return {
        type: TRANSCRIBER_LEFT,
        transcriberJID: participantId,
        abruptly
    };
}


################################################################################

## File: .\jitsi-meet\react\features\transcribing\actionTypes.ts

/**
 * The type of Redux action triggering storage of participantId of transcriber,
 * so that it can later be kicked
 *
 * {
 *     type: TRANSCRIBER_JOINED,
 *     participantId: String
 * }
 * @private
 */
export const TRANSCRIBER_JOINED = 'TRANSCRIBER_JOINED';

/**
 * The type of Redux action signalling that the transcriber has left
 *
 * {
 *     type: TRANSCRIBER_LEFT,
 *     participantId: String
 * }
 * @private
 */
export const TRANSCRIBER_LEFT = 'TRANSCRIBER_LEFT';


################################################################################

## File: .\jitsi-meet\react\features\transcribing\functions.ts

import i18next from 'i18next';

import { IReduxState } from '../app/types';
import { IConfig } from '../base/config/configType';
import { isJwtFeatureEnabled } from '../base/jwt/functions';
import { isLocalParticipantModerator } from '../base/participants/functions';

import JITSI_TO_BCP47_MAP from './jitsi-bcp47-map.json';
import logger from './logger';
import TRANSCRIBER_LANGS from './transcriber-langs.json';

const DEFAULT_TRANSCRIBER_LANG = 'en-US';

/**
 * Determine which language to use for transcribing.
 *
 * @param {*} config - Application config.
 * @returns {string}
 */
export function determineTranscriptionLanguage(config: IConfig) {
    const { transcription } = config;

    // if transcriptions are not enabled nothing to determine
    if (!transcription?.enabled) {
        return undefined;
    }

    // Depending on the config either use the language that the app automatically detected or the hardcoded
    // config BCP47 value.
    // Jitsi language detections uses custom language tags, but the transcriber expects BCP-47 compliant tags,
    // we use a mapping file to convert them.
    const bcp47Locale = transcription?.useAppLanguage ?? true
        ? JITSI_TO_BCP47_MAP[i18next.language as keyof typeof JITSI_TO_BCP47_MAP]
        : transcription?.preferredLanguage;

    // Check if the obtained language is supported by the transcriber
    let safeBCP47Locale = TRANSCRIBER_LANGS[bcp47Locale as keyof typeof TRANSCRIBER_LANGS] && bcp47Locale;

    if (!safeBCP47Locale) {
        safeBCP47Locale = DEFAULT_TRANSCRIBER_LANG;
        logger.warn(`Transcriber language ${bcp47Locale} is not supported, using default ${DEFAULT_TRANSCRIBER_LANG}`);
    }

    logger.info(`Transcriber language set to ${safeBCP47Locale}`);

    return safeBCP47Locale;
}

/**
 * Returns whether there is transcribing.
 *
 * @param {IReduxState} state - The redux state to search in.
 * @returns {boolean}
 */
export function isTranscribing(state: IReduxState) {
    return state['features/transcribing'].isTranscribing;
}

/**
 * Returns true if there is a recorder transcription session running.
 * NOTE: If only the subtitles are running this function will return false.
 *
 * @param {Object} state - The redux state to search in.
 * @returns {boolean}
 */
export function isRecorderTranscriptionsRunning(state: IReduxState) {
    const { metadata } = state['features/base/conference'];

    return isTranscribing(state) && Boolean(metadata?.recording?.isTranscribingEnabled);
}

/**
 * Checks whether the participant can start the transcription.
 *
 * @param {IReduxState} state - The redux state.
 * @returns {boolean} - True if the participant can start the transcription.
 */
export function canAddTranscriber(state: IReduxState) {
    const { transcription } = state['features/base/config'];
    const isModerator = isLocalParticipantModerator(state);
    const isTranscribingAllowed = isJwtFeatureEnabled(state, 'transcription', isModerator, false);

    return Boolean(transcription?.enabled) && isTranscribingAllowed;
}


################################################################################

## File: .\jitsi-meet\react\features\transcribing\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/transcribing');


################################################################################

## File: .\jitsi-meet\react\features\transcribing\middleware.ts

import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import { showErrorNotification } from '../notifications/actions';
import { NOTIFICATION_TIMEOUT_TYPE } from '../notifications/constants';

import { TRANSCRIBER_LEFT } from './actionTypes';

/**
 * Implements the middleware of the feature transcribing.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(({ dispatch }) => next => action => {
    switch (action.type) {
    case TRANSCRIBER_LEFT:
        if (action.abruptly) {
            dispatch(showErrorNotification({
                titleKey: 'transcribing.failed'
            }, NOTIFICATION_TIMEOUT_TYPE.LONG));
        }
        break;
    }

    return next(action);
});


################################################################################

## File: .\jitsi-meet\react\features\transcribing\reducer.ts

import ReducerRegistry from '../base/redux/ReducerRegistry';

import {
    TRANSCRIBER_JOINED,
    TRANSCRIBER_LEFT
} from './actionTypes';

/**
 * Returns initial state for transcribing feature part of Redux store.
 *
 * @returns {{
 * isTranscribing: boolean,
 * transcriberJID: null
 * }}
 * @private
 */
function _getInitialState() {
    return {
        /**
         * Indicates whether there is currently an active transcriber in the
         * room.
         *
         * @type {boolean}
         */
        isTranscribing: false,

        /**
         * The JID of the active transcriber.
         *
         * @type { string }
         */
        transcriberJID: null
    };
}

export interface ITranscribingState {
    isTranscribing: boolean;
    transcriberJID?: string | null;
}

/**
 * Reduces the Redux actions of the feature features/transcribing.
 */
ReducerRegistry.register<ITranscribingState>('features/transcribing',
    (state = _getInitialState(), action): ITranscribingState => {
        switch (action.type) {
        case TRANSCRIBER_JOINED:
            return {
                ...state,
                isTranscribing: true,
                transcriberJID: action.transcriberJID
            };
        case TRANSCRIBER_LEFT:
            return {
                ...state,
                isTranscribing: false,
                transcriberJID: undefined
            };
        default:
            return state;
        }
    });


################################################################################

## File: .\jitsi-meet\react\features\transcribing\subscriber.ts

import { batch } from 'react-redux';

import { IStore } from '../app/types';
import { JitsiRecordingConstants } from '../base/lib-jitsi-meet';
import StateListenerRegistry from '../base/redux/StateListenerRegistry';
import { playSound } from '../base/sounds/actions';
import { showNotification } from '../notifications/actions';
import { NOTIFICATION_TIMEOUT_TYPE } from '../notifications/constants';
import { RECORDING_OFF_SOUND_ID, RECORDING_ON_SOUND_ID } from '../recording/constants';
import { isLiveStreamingRunning, isRecordingRunning } from '../recording/functions';

import { isRecorderTranscriptionsRunning } from './functions';

/**
 * Listens for large video participant ID changes.
 */
StateListenerRegistry.register(
    /* selector */ isRecorderTranscriptionsRunning,
    /* listener */ (isRecorderTranscriptionsRunningValue, { getState, dispatch }) => {
        if (isRecorderTranscriptionsRunningValue) {
            notifyTranscribingStatusChanged(getState, true);
            maybeEmitRecordingNotification(dispatch, getState, true);
        } else {
            notifyTranscribingStatusChanged(getState, false);
            maybeEmitRecordingNotification(dispatch, getState, false);
        }
    }
);

/**
 * Emit a recording started / stopped notification if the transcription started / stopped. Only
 * if there is no recording in progress.
 *
 * @param {Dispatch} dispatch - The Redux dispatch function.
 * @param {Function} getState - The Redux state.
 * @param {boolean} on - Whether the transcription is on or not.
 *
 * @returns {void}
 */
function maybeEmitRecordingNotification(dispatch: IStore['dispatch'], getState: IStore['getState'], on: boolean) {
    const state = getState();
    const { sessionDatas } = state['features/recording'];
    const { mode: modeConstants, status: statusConstants } = JitsiRecordingConstants;

    if (sessionDatas.some(sd => sd.mode === modeConstants.FILE && sd.status === statusConstants.ON)) {
        // If a recording is still ongoing, don't send any notification.
        return;
    }

    batch(() => {
        dispatch(showNotification({
            descriptionKey: on ? 'recording.on' : 'recording.off',
            titleKey: 'dialog.recording'
        }, NOTIFICATION_TIMEOUT_TYPE.SHORT));
        dispatch(playSound(on ? RECORDING_ON_SOUND_ID : RECORDING_OFF_SOUND_ID));
    });
}

/**
 * Notify external application (if API is enabled) that transcribing has started or stopped.
 *
 * @param {Function} getState - The Redux state.
 * @param {boolean} on - True if transcribing is on, false otherwise.
 * @returns {void}
 */
function notifyTranscribingStatusChanged(getState: IStore['getState'], on: boolean) {
    if (typeof APP !== 'undefined') {
        const state = getState();
        const isRecording = isRecordingRunning(state);
        const isStreaming = isLiveStreamingRunning(state);
        const mode = isRecording ? JitsiRecordingConstants.mode.FILE : JitsiRecordingConstants.mode.STREAM;

        APP.API.notifyRecordingStatusChanged(isRecording || isStreaming, mode, undefined, on);
        APP.API.notifyTranscribingStatusChanged(on);
    }
}


################################################################################

## File: .\jitsi-meet\react\features\unsupported-browser\components\browserLinks.ts

/**
 * The URL at which Google Chrome is available for download.
 *
 * @type {string}
 */
export const CHROME = 'https://www.google.com/chrome/';

/**
 * The URL at which Chromium is available for download.
 *
 * @type {string}
 */
export const CHROMIUM = 'https://www.chromium.org/';

/**
 * The URL at which Microsoft Edge is available for download.
 *
 * @type {string}
 */
export const EDGE
    = 'https://www.microsoft.com/en-us/windows/microsoft-edge';

/**
 * The URL at which Mozilla Firefox is available for download.
 *
 * @type {string}
 */
export const FIREFOX = 'https://www.getfirefox.com/';

/**
 * The URL at which Safari is available for download.
 *
 * @type {string}
 */
export const SAFARI = 'https://support.apple.com/downloads/safari';


################################################################################

## File: .\jitsi-meet\react\features\unsupported-browser\components\JaasUnsupportedDesktopBrowser.ts

export { default } from './DefaultUnsupportedDesktopBrowser';


################################################################################

## File: .\jitsi-meet\react\features\video-layout\actions.any.ts

import { IStore } from '../app/types';
import { isTileViewModeDisabled } from '../filmstrip/functions.any';

import {
    SET_TILE_VIEW,
    VIRTUAL_SCREENSHARE_REMOTE_PARTICIPANTS_UPDATED
} from './actionTypes';
import { shouldDisplayTileView } from './functions';

/**
 * Creates a (redux) action which signals that the list of known remote virtual screen share participant ids has
 * changed.
 *
 * @param {string} participantIds - The remote virtual screen share participants.
 * @returns {{
 *     type: VIRTUAL_SCREENSHARE_REMOTE_PARTICIPANTS_UPDATED,
 *     participantIds: Array<string>
 * }}
 */
export function virtualScreenshareParticipantsUpdated(participantIds: Array<string>) {
    return {
        type: VIRTUAL_SCREENSHARE_REMOTE_PARTICIPANTS_UPDATED,
        participantIds
    };
}

/**
 * Creates a (redux) action which signals to set the UI layout to be tiled view
 * or not.
 *
 * @param {boolean} enabled - Whether or not tile view should be shown.
 * @returns {{
 *     type: SET_TILE_VIEW,
 *     enabled: ?boolean
 * }}
 */
export function setTileView(enabled?: boolean) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const tileViewDisabled = isTileViewModeDisabled(getState());

        !tileViewDisabled && dispatch({
            type: SET_TILE_VIEW,
            enabled
        });
    };
}

/**
 * Creates a (redux) action which signals either to exit tile view if currently
 * enabled or enter tile view if currently disabled.
 *
 * @returns {Function}
 */
export function toggleTileView() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const tileViewActive = shouldDisplayTileView(getState());

        dispatch(setTileView(!tileViewActive));
    };
}


################################################################################

## File: .\jitsi-meet\react\features\video-layout\actions.native.ts

import { SET_CAR_MODE } from './actionTypes';

export * from './actions.any';

/**
 * Creates a (redux) action which tells whether we are in carmode.
 *
 * @param {boolean} enabled - Whether we are in carmode.
 * @returns {{
 *     type: SET_CAR_MODE,
 *    enabled: boolean
 * }}
 */
export function setIsCarmode(enabled: boolean) {
    return {
        type: SET_CAR_MODE,
        enabled
    };
}


################################################################################

## File: .\jitsi-meet\react\features\video-layout\actions.web.ts

export * from './actions.any';


################################################################################

## File: .\jitsi-meet\react\features\video-layout\actionTypes.ts

/**
 * The type of the action which tells whether we are in carmode.
 *
 * @returns {{
 *     type: SET_CAR_MODE,
 *     enabled: boolean
 * }}
 */
export const SET_CAR_MODE = ' SET_CAR_MODE';

/**
 * The type of the action which enables or disables the feature for showing
 * video thumbnails in a two-axis tile view.
 *
 * @returns {{
 *     type: SET_TILE_VIEW,
 *     enabled: boolean
 * }}
 */
export const SET_TILE_VIEW = 'SET_TILE_VIEW';

/**
 * The type of the action which sets the list of known remote virtual screen share participant IDs.
 *
 * @returns {{
 *     type: VIRTUAL_SCREENSHARE_REMOTE_PARTICIPANTS_UPDATED,
 *     participantIds: Array<string>
 * }}
 */
export const VIRTUAL_SCREENSHARE_REMOTE_PARTICIPANTS_UPDATED = 'VIRTUAL_SCREENSHARE_REMOTE_PARTICIPANTS_UPDATED';


################################################################################

## File: .\jitsi-meet\react\features\video-layout\constants.ts

/**
 * An enumeration of the different display layouts supported by the application.
 *
 * @type {Object}
 */
export const LAYOUTS = {
    HORIZONTAL_FILMSTRIP_VIEW: 'horizontal-filmstrip-view',
    TILE_VIEW: 'tile-view',
    VERTICAL_FILMSTRIP_VIEW: 'vertical-filmstrip-view',
    STAGE_FILMSTRIP_VIEW: 'stage-filmstrip-view'
};


/**
 * The CSS class to apply so CSS can modify the app layout.
 *
 * @private
 */
export const LAYOUT_CLASSNAMES = {
    [LAYOUTS.HORIZONTAL_FILMSTRIP_VIEW]: 'horizontal-filmstrip',
    [LAYOUTS.TILE_VIEW]: 'tile-view',
    [LAYOUTS.VERTICAL_FILMSTRIP_VIEW]: 'vertical-filmstrip',
    [LAYOUTS.STAGE_FILMSTRIP_VIEW]: 'stage-filmstrip'
};


################################################################################

## File: .\jitsi-meet\react\features\video-layout\functions.any.ts

import { IReduxState, IStore } from '../app/types';
import { TILE_VIEW_ENABLED } from '../base/flags/constants';
import { getFeatureFlag } from '../base/flags/functions';
import { pinParticipant } from '../base/participants/actions';
import { getParticipantCount, getPinnedParticipant } from '../base/participants/functions';
import { FakeParticipant } from '../base/participants/types';
import { isStageFilmstripAvailable, isTileViewModeDisabled } from '../filmstrip/functions';
import { isVideoPlaying } from '../shared-video/functions';
import { VIDEO_QUALITY_LEVELS } from '../video-quality/constants';
import { getReceiverVideoQualityLevel } from '../video-quality/functions';
import { getMinHeightForQualityLvlMap } from '../video-quality/selector';

import { LAYOUTS } from './constants';

/**
 * A selector for retrieving the current automatic pinning setting.
 *
 * @private
 * @returns {string|undefined} The string "remote-only" is returned if only
 * remote screen sharing should be automatically pinned, any other truthy value
 * means automatically pin all screen shares. Falsy means do not automatically
 * pin any screen shares.
 */
export function getAutoPinSetting() {
    return typeof interfaceConfig === 'object'
        ? interfaceConfig.AUTO_PIN_LATEST_SCREEN_SHARE
        : 'remote-only';
}

/**
 * Returns the {@code LAYOUTS} constant associated with the layout
 * the application should currently be in.
 *
 * @param {Object} state - The redux state.
 * @returns {string}
 */
export function getCurrentLayout(state: IReduxState) {
    if (navigator.product === 'ReactNative') {
        // FIXME: what should this return?
        return undefined;
    } else if (shouldDisplayTileView(state)) {
        return LAYOUTS.TILE_VIEW;
    } else if (interfaceConfig.VERTICAL_FILMSTRIP) {
        if (isStageFilmstripAvailable(state, 2)) {
            return LAYOUTS.STAGE_FILMSTRIP_VIEW;
        }

        return LAYOUTS.VERTICAL_FILMSTRIP_VIEW;
    }

    return LAYOUTS.HORIZONTAL_FILMSTRIP_VIEW;
}

/**
 * Selector for determining if the UI layout should be in tile view. Tile view
 * is determined by more than just having the tile view setting enabled, as
 * one-on-one calls should not be in tile view, as well as etherpad editing.
 *
 * @param {Object} state - The redux state.
 * @returns {boolean} True if tile view should be displayed.
 */
export function shouldDisplayTileView(state: IReduxState) {
    const tileViewDisabled = isTileViewModeDisabled(state);

    if (tileViewDisabled) {
        return false;
    }

    const { tileViewEnabled } = state['features/video-layout'] ?? {};

    if (tileViewEnabled !== undefined) {
        // If the user explicitly requested a view mode, we
        // do that.
        return tileViewEnabled;
    }

    const tileViewEnabledFeatureFlag = getFeatureFlag(state, TILE_VIEW_ENABLED, true);
    const { disableTileView } = state['features/base/config'];

    if (disableTileView || !tileViewEnabledFeatureFlag) {
        return false;
    }

    const participantCount = getParticipantCount(state);
    const { iAmRecorder } = state['features/base/config'];

    // None tile view mode is easier to calculate (no need for many negations), so we do
    // that and negate it only once.
    const shouldDisplayNormalMode = Boolean(

        // Reasons for normal mode:

        // Editing etherpad
        state['features/etherpad']?.editing

        // We pinned a participant
        || getPinnedParticipant(state)

        // It's a 1-on-1 meeting
        || participantCount < 3

        // There is a shared YouTube video in the meeting
        || isVideoPlaying(state)

        // We want jibri to use stage view by default
        || iAmRecorder
    );

    return !shouldDisplayNormalMode;
}

/**
 * Private helper to automatically pin the latest screen share stream or unpin
 * if there are no more screen share streams.
 *
 * @param {Array<string>} screenShares - Array containing the list of all the screen sharing endpoints
 * before the update was triggered (including the ones that have been removed from redux because of the update).
 * @param {Store} store - The redux store.
 * @returns {void}
 */
export function updateAutoPinnedParticipant(
        screenShares: Array<string>, { dispatch, getState }: IStore) {
    const state = getState();
    const remoteScreenShares = state['features/video-layout'].remoteScreenShares;
    const pinned = getPinnedParticipant(getState);

    // if the pinned participant is shared video or some other fake participant we want to skip auto-pinning
    if (pinned?.fakeParticipant && pinned.fakeParticipant !== FakeParticipant.RemoteScreenShare) {
        return;
    }

    // Unpin the screen share when the screen sharing participant leaves. Switch to tile view if no other
    // participant was pinned before screen share was auto-pinned, pin the previously pinned participant otherwise.
    if (!remoteScreenShares?.length) {
        let participantId = null;

        if (pinned && !screenShares.find(share => share === pinned.id)) {
            participantId = pinned.id;
        }
        dispatch(pinParticipant(participantId));

        return;
    }

    const latestScreenShareParticipantId = remoteScreenShares[remoteScreenShares.length - 1];

    if (latestScreenShareParticipantId) {
        dispatch(pinParticipant(latestScreenShareParticipantId));
    }
}

/**
 * Selector for whether we are currently in tile view.
 *
 * @param {Object} state - The redux state.
 * @returns {boolean}
 */
export function isLayoutTileView(state: IReduxState) {
    return getCurrentLayout(state) === LAYOUTS.TILE_VIEW;
}

/**
 * Returns the video quality for the given height.
 *
 * @param {number|undefined} height - Height of the video container.
 * @returns {number}
 */
function getVideoQualityForHeight(height: number) {
    if (!height) {
        return VIDEO_QUALITY_LEVELS.LOW;
    }
    const levels = Object.values(VIDEO_QUALITY_LEVELS)
        .map(Number)
        .sort((a, b) => a - b);

    for (const level of levels) {
        if (height <= level) {
            return level;
        }
    }

    return VIDEO_QUALITY_LEVELS.ULTRA;
}

/**
 * Returns the video quality level for the resizable filmstrip thumbnail height.
 *
 * @param {number} height - The height of the thumbnail.
 * @param {Object} state - Redux state.
 * @returns {number}
 */
export function getVideoQualityForResizableFilmstripThumbnails(height: number, state: IReduxState) {
    if (!height) {
        return VIDEO_QUALITY_LEVELS.LOW;
    }

    return getReceiverVideoQualityLevel(height, getMinHeightForQualityLvlMap(state));
}

/**
 * Returns the video quality level for the screen sharing filmstrip thumbnail height.
 *
 * @param {number} height - The height of the thumbnail.
 * @param {Object} state - Redux state.
 * @returns {number}
 */
export function getVideoQualityForScreenSharingFilmstrip(height: number, state: IReduxState) {
    if (!height) {
        return VIDEO_QUALITY_LEVELS.LOW;
    }

    return getReceiverVideoQualityLevel(height, getMinHeightForQualityLvlMap(state));
}

/**
 * Returns the video quality for the large video.
 *
 * @param {number} largeVideoHeight - The height of the large video.
 * @returns {number} - The video quality for the large video.
 */
export function getVideoQualityForLargeVideo(largeVideoHeight: number) {
    return getVideoQualityForHeight(largeVideoHeight);
}

/**
 * Returns the video quality level for the thumbnails in the stage filmstrip.
 *
 * @param {number} height - The height of the thumbnails.
 * @param {Object} state - Redux state.
 * @returns {number}
 */
export function getVideoQualityForStageThumbnails(height: number, state: IReduxState) {
    if (!height) {
        return VIDEO_QUALITY_LEVELS.LOW;
    }

    return getReceiverVideoQualityLevel(height, getMinHeightForQualityLvlMap(state));
}


################################################################################

## File: .\jitsi-meet\react\features\video-layout\functions.native.ts

export * from './functions.any';


################################################################################

## File: .\jitsi-meet\react\features\video-layout\functions.web.ts

import { IReduxState } from '../app/types';
import {
    ABSOLUTE_MAX_COLUMNS,
    DEFAULT_MAX_COLUMNS,
    TILE_PORTRAIT_ASPECT_RATIO
} from '../filmstrip/constants';
import {
    getNumberOfPartipantsForTileView,
    getThumbnailMinHeight,
    getTileDefaultAspectRatio
} from '../filmstrip/functions.web';

export * from './functions.any';

/**
 * Returns how many columns should be displayed in tile view. The number
 * returned will be between 1 and 7, inclusive.
 *
 * @param {Object} state - The redux store state.
 * @param {Object} options - Object with custom values used to override the values that we get from redux by default.
 * @param {number} options.width - Custom width to be used.
 * @param {boolean} options.disableResponsiveTiles - Custom value to be used instead of config.disableResponsiveTiles.
 * @param {boolean} options.disableTileEnlargement - Custom value to be used instead of config.disableTileEnlargement.
 * @returns {number}
 */
export function getMaxColumnCount(state: IReduxState, options: {
    disableResponsiveTiles?: boolean; disableTileEnlargement?: boolean; width?: number | null; } = {}) {
    if (typeof interfaceConfig === 'undefined') {
        return DEFAULT_MAX_COLUMNS;
    }

    const {
        disableResponsiveTiles: configDisableResponsiveTiles,
        disableTileEnlargement: configDisableTileEnlargement
    } = state['features/base/config'];
    const {
        width,
        disableResponsiveTiles = configDisableResponsiveTiles,
        disableTileEnlargement = configDisableTileEnlargement
    } = options;
    const { clientWidth } = state['features/base/responsive-ui'];
    const widthToUse = width || clientWidth;
    const configuredMax = interfaceConfig.TILE_VIEW_MAX_COLUMNS;

    if (disableResponsiveTiles) {
        return Math.min(Math.max(configuredMax || DEFAULT_MAX_COLUMNS, 1), ABSOLUTE_MAX_COLUMNS);
    }

    if (typeof interfaceConfig.TILE_VIEW_MAX_COLUMNS !== 'undefined' && interfaceConfig.TILE_VIEW_MAX_COLUMNS > 0) {
        return Math.max(configuredMax, 1);
    }

    const aspectRatio = disableTileEnlargement
        ? getTileDefaultAspectRatio(true, disableTileEnlargement, widthToUse)
        : TILE_PORTRAIT_ASPECT_RATIO;
    const minHeight = getThumbnailMinHeight(widthToUse);
    const minWidth = aspectRatio * minHeight;

    return Math.floor(widthToUse / minWidth);
}

/**
 * Returns the cell count dimensions for tile view. Tile view tries to uphold
 * equal count of tiles for height and width, until maxColumn is reached in
 * which rows will be added but no more columns.
 *
 * @param {Object} state - The redux store state.
 * @param {boolean} stageFilmstrip - Whether the dimensions should be calculated for the stage filmstrip.
 * @returns {Object} An object is return with the desired number of columns,
 * rows, and visible rows (the rest should overflow) for the tile view layout.
 */
export function getNotResponsiveTileViewGridDimensions(state: IReduxState, stageFilmstrip = false) {
    const maxColumns = getMaxColumnCount(state);
    const { activeParticipants } = state['features/filmstrip'];
    const numberOfParticipants = stageFilmstrip ? activeParticipants.length : getNumberOfPartipantsForTileView(state);
    const columnsToMaintainASquare = Math.ceil(Math.sqrt(numberOfParticipants));
    const columns = Math.min(columnsToMaintainASquare, maxColumns);
    const rows = Math.ceil(numberOfParticipants / columns);
    const minVisibleRows = Math.min(maxColumns, rows);

    return {
        columns,
        minVisibleRows,
        rows
    };
}


################################################################################

## File: .\jitsi-meet\react\features\video-layout\hooks.ts

import { useSelector } from 'react-redux';

import { IReduxState } from '../app/types';
import { TILE_VIEW_ENABLED } from '../base/flags/constants';
import { getFeatureFlag } from '../base/flags/functions';

import TileViewButton from './components/TileViewButton';

const tileview = {
    key: 'tileview',
    Content: TileViewButton,
    group: 2
};

/**
 * A hook that returns the tile view button if it is enabled and undefined otherwise.
 *
 *  @returns {Object | undefined}
 */
export function useTileViewButton() {
    const tileViewEnabled = useSelector((state: IReduxState) => getFeatureFlag(state, TILE_VIEW_ENABLED, true));

    if (tileViewEnabled) {
        return tileview;
    }
}


################################################################################

## File: .\jitsi-meet\react\features\video-layout\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/video-layout');


################################################################################

## File: .\jitsi-meet\react\features\video-layout\middleware.any.ts

import { IStore } from '../app/types';
import { getCurrentConference } from '../base/conference/functions';
import { PARTICIPANT_LEFT, PIN_PARTICIPANT } from '../base/participants/actionTypes';
import { pinParticipant } from '../base/participants/actions';
import { getParticipantById, getPinnedParticipant } from '../base/participants/functions';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import StateListenerRegistry from '../base/redux/StateListenerRegistry';
import { SET_DOCUMENT_EDITING_STATUS } from '../etherpad/actionTypes';
import { isStageFilmstripEnabled } from '../filmstrip/functions';
import { isFollowMeActive } from '../follow-me/functions';

import { SET_TILE_VIEW } from './actionTypes';
import { setTileView } from './actions';
import { getAutoPinSetting, updateAutoPinnedParticipant } from './functions';

import './subscriber';

let previousTileViewEnabled: boolean | undefined;

/**
 * Middleware which intercepts actions and updates tile view related state.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {

    // we want to extract the leaving participant and check its type before actually the participant being removed.
    let shouldUpdateAutoPin = false;

    switch (action.type) {
    case PARTICIPANT_LEFT: {
        if (!getAutoPinSetting() || isFollowMeActive(store)) {
            break;
        }
        shouldUpdateAutoPin = Boolean(getParticipantById(store.getState(), action.participant.id)?.fakeParticipant);
        break;
    }
    }

    const result = next(action);

    switch (action.type) {

    // Actions that temporarily clear the user preferred state of tile view,
    // then re-set it when needed.
    case PIN_PARTICIPANT: {
        const pinnedParticipant = action.participant?.id;

        if (pinnedParticipant) {
            _storeTileViewStateAndClear(store);
        } else {
            _restoreTileViewState(store);
        }
        break;
    }
    case SET_DOCUMENT_EDITING_STATUS:
        if (action.editing) {
            _storeTileViewStateAndClear(store);
        } else {
            _restoreTileViewState(store);
        }
        break;

    // Things to update when tile view state changes
    case SET_TILE_VIEW: {
        const state = store.getState();
        const stageFilmstrip = isStageFilmstripEnabled(state);

        if (action.enabled && !stageFilmstrip && getPinnedParticipant(state)) {
            store.dispatch(pinParticipant(null));
        }
        break;
    }
    }

    if (shouldUpdateAutoPin) {
        const screenShares = store.getState()['features/video-layout'].remoteScreenShares || [];

        updateAutoPinnedParticipant(screenShares, store);
    }

    return result;
});

/**
 * Set up state change listener to perform maintenance tasks when the conference
 * is left or failed.
 */
StateListenerRegistry.register(
    state => getCurrentConference(state),
    (conference, { dispatch }, previousConference) => {
        if (conference !== previousConference) {
            // conference changed, left or failed...
            // Clear tile view state.
            dispatch(setTileView());
        }
    });

/**
 * Restores tile view state, if it wasn't updated since then.
 *
 * @param {Object} store - The Redux Store.
 * @returns {void}
 */
function _restoreTileViewState({ dispatch, getState }: IStore) {
    const { tileViewEnabled } = getState()['features/video-layout'];

    if (tileViewEnabled === undefined && previousTileViewEnabled !== undefined) {
        dispatch(setTileView(previousTileViewEnabled));
    }

    previousTileViewEnabled = undefined;
}

/**
 * Stores the current tile view state and clears it.
 *
 * @param {Object} store - The Redux Store.
 * @returns {void}
 */
function _storeTileViewStateAndClear({ dispatch, getState }: IStore) {
    const { tileViewEnabled } = getState()['features/video-layout'];

    if (tileViewEnabled !== undefined) {
        previousTileViewEnabled = tileViewEnabled;
        dispatch(setTileView(undefined));
    }
}


################################################################################

## File: .\jitsi-meet\react\features\video-layout\middleware.native.ts

import { setVideoMuted } from '../base/media/actions';
import { VIDEO_MUTISM_AUTHORITY } from '../base/media/constants';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import { CLIENT_RESIZED } from '../base/responsive-ui/actionTypes';
import { setLargeVideoDimensions } from '../large-video/actions.any';

import { SET_CAR_MODE } from './actionTypes';
import './middleware.any';

/**
 * Middleware which intercepts actions and updates the legacy component.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(store => next => action => {
    const result = next(action);
    const { dispatch } = store;

    switch (action.type) {
    case SET_CAR_MODE:
        dispatch(setVideoMuted(action.enabled, VIDEO_MUTISM_AUTHORITY.CAR_MODE));
        break;
    case CLIENT_RESIZED: {
        const { clientHeight, clientWidth } = store.getState()['features/base/responsive-ui'];

        // On mobile the large video should always fill the screen.
        dispatch(setLargeVideoDimensions(clientHeight, clientWidth));
        break;
    }
    }

    return result;
});


################################################################################

## File: .\jitsi-meet\react\features\video-layout\middleware.web.ts

// @ts-expect-error
import VideoLayout from '../../../modules/UI/videolayout/VideoLayout.js';
import { CONFERENCE_WILL_INIT, CONFERENCE_WILL_LEAVE } from '../base/conference/actionTypes';
import { MEDIA_TYPE } from '../base/media/constants';
import { PARTICIPANT_JOINED } from '../base/participants/actionTypes';
import { getLocalParticipant } from '../base/participants/functions';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import { TRACK_ADDED, TRACK_REMOVED, TRACK_STOPPED } from '../base/tracks/actionTypes';
import { PARTICIPANTS_PANE_CLOSE, PARTICIPANTS_PANE_OPEN } from '../participants-pane/actionTypes';

import './middleware.any';

/**
 * Middleware which intercepts actions and updates the legacy component
 * {@code VideoLayout} as needed. The purpose of this middleware is to redux-ify
 * {@code VideoLayout} without having to simultaneously react-ifying it.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
// eslint-disable-next-line no-unused-vars
MiddlewareRegistry.register(store => next => action => {
    // Purposefully perform additional actions after state update to mimic
    // being connected to the store for updates.
    const result = next(action);

    switch (action.type) {
    case CONFERENCE_WILL_INIT:
        // Reset VideoLayout. It's destroyed on CONFERENCE_WILL_LEAVE so re-initialize it.
        VideoLayout.initLargeVideo();
        VideoLayout.resizeVideoArea();
        break;
    case CONFERENCE_WILL_LEAVE:
        VideoLayout.reset();
        break;

    case PARTICIPANT_JOINED:
        if (!action.participant.local) {
            VideoLayout.updateVideoMutedForNoTracks(action.participant.id);
        }
        break;

    case PARTICIPANTS_PANE_CLOSE:
    case PARTICIPANTS_PANE_OPEN:
        VideoLayout.resizeVideoArea();
        break;

    case TRACK_ADDED:
        if (action.track.mediaType !== MEDIA_TYPE.AUDIO) {
            VideoLayout._updateLargeVideoIfDisplayed(action.track.participantId, true);
        }

        break;

    case TRACK_STOPPED: {
        if (action.track.jitsiTrack.isLocal()) {
            const participant = getLocalParticipant(store.getState);

            VideoLayout._updateLargeVideoIfDisplayed(participant?.id);
        }
        break;
    }
    case TRACK_REMOVED:
        if (!action.track.local && action.track.mediaType !== MEDIA_TYPE.AUDIO) {
            VideoLayout.updateVideoMutedForNoTracks(action.track.jitsiTrack.getParticipantId());
        }

        break;
    }

    return result;
});


################################################################################

## File: .\jitsi-meet\react\features\video-layout\reducer.ts

import ReducerRegistry from '../base/redux/ReducerRegistry';

import {
    SET_CAR_MODE,
    SET_TILE_VIEW,
    VIRTUAL_SCREENSHARE_REMOTE_PARTICIPANTS_UPDATED
} from './actionTypes';

const DEFAULT_STATE = {
    /**
     * Whether we are in carmode.
     *
     * @public
     * @type {boolean}
     */
    carMode: false,

    remoteScreenShares: [],

    /**
     * The indicator which determines whether the video layout should display
     * video thumbnails in a tiled layout.
     *
     * Note: undefined means that the user hasn't requested anything in particular yet, so
     * we use our auto switching rules.
     *
     * @public
     * @type {boolean}
     */
    tileViewEnabled: undefined
};

export interface IVideoLayoutState {
    carMode: boolean;
    remoteScreenShares: string[];
    tileViewEnabled?: boolean;
}

const STORE_NAME = 'features/video-layout';

ReducerRegistry.register<IVideoLayoutState>(STORE_NAME, (state = DEFAULT_STATE, action): IVideoLayoutState => {
    switch (action.type) {
    case VIRTUAL_SCREENSHARE_REMOTE_PARTICIPANTS_UPDATED:
        return {
            ...state,
            remoteScreenShares: action.participantIds
        };

    case SET_CAR_MODE:
        return {
            ...state,
            carMode: action.enabled
        };

    case SET_TILE_VIEW:
        return {
            ...state,
            tileViewEnabled: action.enabled
        };
    }

    return state;
});


################################################################################

## File: .\jitsi-meet\react\features\video-layout\subscriber.ts

import StateListenerRegistry from '../base/redux/StateListenerRegistry';
import { equals } from '../base/redux/functions';
import { isFollowMeActive } from '../follow-me/functions';

import { virtualScreenshareParticipantsUpdated } from './actions';
import { getAutoPinSetting, updateAutoPinnedParticipant } from './functions';

StateListenerRegistry.register(
    /* selector */ state => state['features/base/participants'].sortedRemoteVirtualScreenshareParticipants,
    /* listener */ (sortedRemoteVirtualScreenshareParticipants, store) => {
        const oldScreenSharesOrder = store.getState()['features/video-layout'].remoteScreenShares || [];
        const knownSharingParticipantIds = [ ...sortedRemoteVirtualScreenshareParticipants.keys() ];

        // Filter out any participants which are no longer screen sharing
        // by looping through the known sharing participants and removing any
        // participant IDs which are no longer sharing.
        const newScreenSharesOrder = oldScreenSharesOrder.filter(
            participantId => knownSharingParticipantIds.includes(participantId));

        // Make sure all new sharing participant get added to the end of the
        // known screen shares.
        knownSharingParticipantIds.forEach(participantId => {
            if (!newScreenSharesOrder.includes(participantId)) {
                newScreenSharesOrder.push(participantId);
            }
        });

        if (!equals(oldScreenSharesOrder, newScreenSharesOrder)) {
            store.dispatch(virtualScreenshareParticipantsUpdated(newScreenSharesOrder));

            if (getAutoPinSetting() && !isFollowMeActive(store)) {
                updateAutoPinnedParticipant(oldScreenSharesOrder, store);
            }
        }
    });


################################################################################

## File: .\jitsi-meet\react\features\video-layout\components\TileViewButton.ts

import { batch, connect } from 'react-redux';

import { createToolbarEvent } from '../../analytics/AnalyticsEvents';
import { sendAnalytics } from '../../analytics/functions';
import { IReduxState } from '../../app/types';
import { TILE_VIEW_ENABLED } from '../../base/flags/constants';
import { getFeatureFlag } from '../../base/flags/functions';
import { translate } from '../../base/i18n/functions';
import { IconTileView } from '../../base/icons/svg';
import AbstractButton, { IProps as AbstractButtonProps } from '../../base/toolbox/components/AbstractButton';
import { setOverflowMenuVisible } from '../../toolbox/actions';
import { setTileView } from '../actions';
import { shouldDisplayTileView } from '../functions';
import logger from '../logger';

/**
 * The type of the React {@code Component} props of {@link TileViewButton}.
 */
interface IProps extends AbstractButtonProps {

    /**
     * Whether or not tile view layout has been enabled as the user preference.
     */
    _tileViewEnabled: boolean;
}

/**
 * Component that renders a toolbar button for toggling the tile layout view.
 *
 * @augments AbstractButton
 */
class TileViewButton<P extends IProps> extends AbstractButton<P> {
    accessibilityLabel = 'toolbar.accessibilityLabel.enterTileView';
    toggledAccessibilityLabel = 'toolbar.accessibilityLabel.exitTileView';
    icon = IconTileView;
    label = 'toolbar.enterTileView';
    toggledLabel = 'toolbar.exitTileView';
    tooltip = 'toolbar.tileViewToggle';

    /**
     * Handles clicking / pressing the button.
     *
     * @override
     * @protected
     * @returns {void}
     */
    _handleClick() {
        const { _tileViewEnabled, dispatch } = this.props;

        const value = !_tileViewEnabled;

        sendAnalytics(createToolbarEvent(
            'tileview.button',
            {
                'is_enabled': value
            }));

        logger.debug(`Tile view ${value ? 'enable' : 'disable'}`);
        batch(() => {
            dispatch(setTileView(value));
            navigator.product !== 'ReactNative' && dispatch(setOverflowMenuVisible(false));
        });

    }

    /**
     * Indicates whether this button is in toggled state or not.
     *
     * @override
     * @protected
     * @returns {boolean}
     */
    _isToggled() {
        return this.props._tileViewEnabled;
    }
}

/**
 * Maps (parts of) the redux state to the associated props for the
 * {@code TileViewButton} component.
 *
 * @param {Object} state - The Redux state.
 * @param {Object} ownProps - The properties explicitly passed to the component instance.
 * @returns {IProps}
 */
function _mapStateToProps(state: IReduxState, ownProps: any) {
    const enabled = getFeatureFlag(state, TILE_VIEW_ENABLED, true);
    const { visible = enabled } = ownProps;

    return {
        _tileViewEnabled: shouldDisplayTileView(state),
        visible
    };
}

export default translate(connect(_mapStateToProps)(TileViewButton));


################################################################################

## File: .\jitsi-meet\react\features\video-menu\actions.any.ts

import {
    AUDIO_MUTE,
    VIDEO_MUTE,
    createRemoteMuteConfirmedEvent,
    createToolbarEvent
} from '../analytics/AnalyticsEvents';
import { sendAnalytics } from '../analytics/functions';
import { IStore } from '../app/types';
import { rejectParticipantAudio, rejectParticipantVideo, showModeratedNotification } from '../av-moderation/actions';
import { shouldShowModeratedNotification } from '../av-moderation/functions';
import { setAudioMuted, setVideoMuted } from '../base/media/actions';
import { MEDIA_TYPE, MediaType, VIDEO_MUTISM_AUTHORITY } from '../base/media/constants';
import { muteRemoteParticipant } from '../base/participants/actions';
import { getLocalParticipant, getRemoteParticipants } from '../base/participants/functions';
import { toggleScreensharing } from '../base/tracks/actions';
import { isModerationNotificationDisplayed } from '../notifications/functions';

import logger from './logger';

/**
 * Mutes the local participant.
 *
 * @param {boolean} enable - Whether to mute or unmute.
 * @param {MEDIA_TYPE} mediaType - The type of the media channel to mute.
 * @param {boolean} stopScreenSharing - Whether or not to stop the screensharing.
 * @returns {Function}
 */
export function muteLocal(enable: boolean, mediaType: MediaType, stopScreenSharing = false) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const isAudio = mediaType === MEDIA_TYPE.AUDIO;

        if (!isAudio && mediaType !== MEDIA_TYPE.VIDEO) {
            logger.error(`Unsupported media type: ${mediaType}`);

            return;
        }

        // check for A/V Moderation when trying to unmute
        if (!enable && shouldShowModeratedNotification(MEDIA_TYPE.AUDIO, getState())) {
            if (!isModerationNotificationDisplayed(MEDIA_TYPE.AUDIO, getState())) {
                dispatch(showModeratedNotification(MEDIA_TYPE.AUDIO));
            }

            return;
        }

        if (enable && stopScreenSharing) {
            dispatch(toggleScreensharing(false, false));
        }

        sendAnalytics(createToolbarEvent(isAudio ? AUDIO_MUTE : VIDEO_MUTE, { enable }));
        dispatch(isAudio ? setAudioMuted(enable, /* ensureTrack */ true)
            : setVideoMuted(enable, VIDEO_MUTISM_AUTHORITY.USER, /* ensureTrack */ true));

        // FIXME: The old conference logic still relies on this event being emitted.
        if (typeof APP !== 'undefined') {
            isAudio ? APP.conference.muteAudio(enable) : APP.conference.muteVideo(enable, false);
        }
    };
}

/**
 * Mutes the remote participant with the given ID.
 *
 * @param {string} participantId - ID of the participant to mute.
 * @param {MEDIA_TYPE} mediaType - The type of the media channel to mute.
 * @returns {Function}
 */
export function muteRemote(participantId: string, mediaType: MediaType) {
    return (dispatch: IStore['dispatch']) => {
        if (mediaType !== MEDIA_TYPE.AUDIO && mediaType !== MEDIA_TYPE.VIDEO) {
            logger.error(`Unsupported media type: ${mediaType}`);

            return;
        }
        sendAnalytics(createRemoteMuteConfirmedEvent(participantId, mediaType));
        dispatch(muteRemoteParticipant(participantId, mediaType));
    };
}

/**
 * Mutes all participants.
 *
 * @param {Array<string>} exclude - Array of participant IDs to not mute.
 * @param {MEDIA_TYPE} mediaType - The media type to mute.
 * @returns {Function}
 */
export function muteAllParticipants(exclude: Array<string>, mediaType: MediaType) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const localId = getLocalParticipant(state)?.id ?? '';

        if (!exclude.includes(localId)) {
            dispatch(muteLocal(true, mediaType, mediaType !== MEDIA_TYPE.AUDIO));
        }

        getRemoteParticipants(state).forEach((p, id) => {
            if (exclude.includes(id)) {
                return;
            }

            dispatch(muteRemote(id, mediaType));
            if (mediaType === MEDIA_TYPE.AUDIO) {
                dispatch(rejectParticipantAudio(id));
            } else {
                dispatch(rejectParticipantVideo(id));
            }
        });
    };
}


################################################################################

## File: .\jitsi-meet\react\features\video-menu\actions.native.ts

export * from './actions.any';


################################################################################

## File: .\jitsi-meet\react\features\video-menu\actions.web.ts

import { SHOW_CONNECTION_INFO } from '../base/connection/actionTypes';

export * from './actions.any';

/**
 * Sets whether to render the connection status info into the Popover of the thumbnail or the context menu buttons.
 *
 * @param {boolean} showConnectionInfo - Whether it should show the connection
 * info or the context menu buttons on thumbnail popover.
 * @returns {Object}
 */
export function renderConnectionStatus(showConnectionInfo: boolean) {
    return {
        type: SHOW_CONNECTION_INFO,
        showConnectionInfo
    };
}


################################################################################

## File: .\jitsi-meet\react\features\video-menu\constants.ts

/**
 * Used to set maximumValue for native volume slider.
 * Slider double-precision floating-point number indicating the volume,
 * from 0 mute to 1 max, which converts to 0 mute to 19 max in our case.
 * 0 as muted, 10 as standard and 19 as max remote participant volume level.
 */
export const NATIVE_VOLUME_SLIDER_SCALE = 19;

/**
 * Used to modify initialValue, which is expected to be a decimal value between
 * 0 and 1, and converts it to a number representable by an input slider, which
 * recognizes whole numbers.
 */
export const VOLUME_SLIDER_SCALE = 100;

/**
 * Participant context menu button keys.
 */
export const PARTICIPANT_MENU_BUTTONS = {
    ALLOW_VIDEO: 'allow-video',
    ASK_UNMUTE: 'ask-unmute',
    CONN_STATUS: 'conn-status',
    DEMOTE: 'demote',
    FLIP_LOCAL_VIDEO: 'flip-local-video',
    GRANT_MODERATOR: 'grant-moderator',
    HIDE_SELF_VIEW: 'hide-self-view',
    KICK: 'kick',
    LOWER_PARTICIPANT_HAND: 'lower-participant-hand',
    MUTE: 'mute',
    MUTE_OTHERS: 'mute-others',
    MUTE_OTHERS_VIDEO: 'mute-others-video',
    MUTE_VIDEO: 'mute-video',
    PIN_TO_STAGE: 'pinToStage',
    PRIVATE_MESSAGE: 'privateMessage',
    REMOTE_CONTROL: 'remote-control',
    SEND_PARTICIPANT_TO_ROOM: 'send-participant-to-room',
    VERIFY: 'verify'
};


################################################################################

## File: .\jitsi-meet\react\features\video-menu\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/video-menu');


################################################################################

## File: .\jitsi-meet\react\features\video-menu\types.ts

export interface IButtonProps {

    /**
     * Callback to execute when the button is clicked.
     */
    notifyClick?: Function;

    /**
     * Notify mode for the `participantMenuButtonClicked` event -
     * whether to only notify or to also prevent button click routine.
     */
    notifyMode?: string;

    /**
     * The ID of the participant that's linked to the button.
     */
    participantID: string;
}


################################################################################

## File: .\jitsi-meet\react\features\video-menu\components\AbstractGrantModeratorButton.ts

import { IReduxState } from '../../app/types';
import { openDialog } from '../../base/dialog/actions';
import { IconModerator } from '../../base/icons/svg';
import { PARTICIPANT_ROLE } from '../../base/participants/constants';
import { getLocalParticipant, getParticipantById, isParticipantModerator } from '../../base/participants/functions';
import AbstractButton, { IProps as AbstractButtonProps } from '../../base/toolbox/components/AbstractButton';

import { GrantModeratorDialog } from './';

export interface IProps extends AbstractButtonProps {

    /**
     * The ID of the participant for whom to grant moderator status.
     */
    participantID: string;
}

/**
 * An abstract remote video menu button which kicks the remote participant.
 */
export default class AbstractGrantModeratorButton extends AbstractButton<IProps> {
    accessibilityLabel = 'toolbar.accessibilityLabel.grantModerator';
    icon = IconModerator;
    label = 'videothumbnail.grantModerator';

    /**
   * Handles clicking / pressing the button, and kicks the participant.
   *
   * @private
   * @returns {void}
   */
    _handleClick() {
        const { dispatch, participantID } = this.props;

        dispatch(openDialog(GrantModeratorDialog, { participantID }));
    }
}

/**
 * Function that maps parts of Redux state tree into component props.
 *
 * @param {Object} state - Redux state.
 * @param {Object} ownProps - Properties of component.
 * @private
 * @returns {{
 *     visible: boolean
 * }}
 */
export function _mapStateToProps(state: IReduxState, ownProps: any) {
    const { participantID } = ownProps;

    const localParticipant = getLocalParticipant(state);
    const targetParticipant = getParticipantById(state, participantID);

    return {
        visible: Boolean(localParticipant?.role === PARTICIPANT_ROLE.MODERATOR)
            && !isParticipantModerator(targetParticipant)
    };
}


################################################################################

## File: .\jitsi-meet\react\features\video-menu\components\AbstractGrantModeratorDialog.ts

import { Component } from 'react';
import { WithTranslation } from 'react-i18next';

import { createRemoteVideoMenuButtonEvent } from '../../analytics/AnalyticsEvents';
import { sendAnalytics } from '../../analytics/functions';
import { IReduxState, IStore } from '../../app/types';
import { grantModerator } from '../../base/participants/actions';
import { getParticipantById } from '../../base/participants/functions';

interface IProps extends WithTranslation {

    /**
     * The Redux dispatch function.
     */
    dispatch: IStore['dispatch'];

    /**
     * The ID of the remote participant to be granted moderator rights.
     */
    participantID: string;

    /**
     * The name of the remote participant to be granted moderator rights.
     */
    participantName?: string;
}

/**
 * Abstract dialog to confirm granting moderator to a participant.
 */
export default class AbstractGrantModeratorDialog
    extends Component<IProps> {
    /**
     * Initializes a new {@code AbstractGrantModeratorDialog} instance.
     *
     * @inheritdoc
     */
    constructor(props: IProps) {
        super(props);

        this._onSubmit = this._onSubmit.bind(this);
    }

    /**
     * Callback for the confirm button.
     *
     * @private
     * @returns {boolean} - True (to note that the modal should be closed).
     */
    _onSubmit() {
        const { dispatch, participantID } = this.props;

        sendAnalytics(createRemoteVideoMenuButtonEvent(
            'grant.moderator.button',
            {
                'participant_id': participantID
            }));

        dispatch(grantModerator(participantID));

        return true;
    }
}

/**
 * Maps (parts of) the Redux state to the associated {@code AbstractMuteEveryoneDialog}'s props.
 *
 * @param {IReduxState} state - The redux state.
 * @param {Object} ownProps - The properties explicitly passed to the component.
 * @returns {IProps}
 */
export function abstractMapStateToProps(state: IReduxState, ownProps: IProps) {

    return {
        participantName: getParticipantById(state, ownProps.participantID)?.name
    };
}


################################################################################

## File: .\jitsi-meet\react\features\video-menu\components\AbstractKickButton.ts

import { openDialog } from '../../base/dialog/actions';
import { IconUserDeleted } from '../../base/icons/svg';
import AbstractButton, { IProps as AbstractButtonProps } from '../../base/toolbox/components/AbstractButton';

import { KickRemoteParticipantDialog } from './';

export interface IProps extends AbstractButtonProps {

    /**
     * The ID of the participant that this button is supposed to kick.
     */
    participantID: string;
}

/**
 * An abstract remote video menu button which kicks the remote participant.
 */
export default class AbstractKickButton extends AbstractButton<IProps> {
    accessibilityLabel = 'toolbar.accessibilityLabel.kick';
    icon = IconUserDeleted;
    label = 'videothumbnail.kick';

    /**
     * Handles clicking / pressing the button, and kicks the participant.
     *
     * @private
     * @returns {void}
     */
    _handleClick() {
        const { dispatch, participantID } = this.props;

        dispatch(openDialog(KickRemoteParticipantDialog, { participantID }));
    }
}


################################################################################

## File: .\jitsi-meet\react\features\video-menu\components\AbstractKickRemoteParticipantDialog.ts

import { Component } from 'react';
import { WithTranslation } from 'react-i18next';

import { createRemoteVideoMenuButtonEvent } from '../../analytics/AnalyticsEvents';
import { sendAnalytics } from '../../analytics/functions';
import { IStore } from '../../app/types';
import { kickParticipant } from '../../base/participants/actions';

interface IProps extends WithTranslation {

    /**
     * The Redux dispatch function.
     */
    dispatch: IStore['dispatch'];

    /**
     * The ID of the remote participant to be kicked.
     */
    participantID: string;
}

/**
 * Abstract dialog to confirm a remote participant kick action.
 */
export default class AbstractKickRemoteParticipantDialog
    extends Component<IProps> {
    /**
     * Initializes a new {@code AbstractKickRemoteParticipantDialog} instance.
     *
     * @inheritdoc
     */
    constructor(props: IProps) {
        super(props);

        this._onSubmit = this._onSubmit.bind(this);
    }

    /**
     * Callback for the confirm button.
     *
     * @private
     * @returns {boolean} - True (to note that the modal should be closed).
     */
    _onSubmit() {
        const { dispatch, participantID } = this.props;

        sendAnalytics(createRemoteVideoMenuButtonEvent(
            'kick.button',
            {
                'participant_id': participantID
            }));

        dispatch(kickParticipant(participantID));

        return true;
    }
}


################################################################################

## File: .\jitsi-meet\react\features\video-menu\components\AbstractMuteButton.ts

import { createRemoteVideoMenuButtonEvent } from '../../analytics/AnalyticsEvents';
import { sendAnalytics } from '../../analytics/functions';
import { IReduxState } from '../../app/types';
import { rejectParticipantAudio } from '../../av-moderation/actions';
import { IconMicSlash } from '../../base/icons/svg';
import { MEDIA_TYPE } from '../../base/media/constants';
import AbstractButton, { IProps as AbstractButtonProps } from '../../base/toolbox/components/AbstractButton';
import { isRemoteTrackMuted } from '../../base/tracks/functions.any';
import { muteRemote } from '../actions.any';

export interface IProps extends AbstractButtonProps {

    /**
     * Boolean to indicate if the audio track of the participant is muted or
     * not.
     */
    _audioTrackMuted: boolean;

    /**
     * The ID of the participant object that this button is supposed to
     * mute/unmute.
     */
    participantID: string;
}

/**
 * An abstract remote video menu button which mutes the remote participant.
 */
export default class AbstractMuteButton extends AbstractButton<IProps> {
    accessibilityLabel = 'toolbar.accessibilityLabel.remoteMute';
    icon = IconMicSlash;
    label = 'videothumbnail.domute';
    toggledLabel = 'videothumbnail.muted';

    /**
     * Handles clicking / pressing the button, and mutes the participant.
     *
     * @private
     * @returns {void}
     */
    _handleClick() {
        const { dispatch, participantID } = this.props;

        sendAnalytics(createRemoteVideoMenuButtonEvent(
            'mute',
            {
                'participant_id': participantID
            }));

        dispatch(muteRemote(participantID, MEDIA_TYPE.AUDIO));
        dispatch(rejectParticipantAudio(participantID));
    }

    /**
     * Renders the item disabled if the participant is muted.
     *
     * @inheritdoc
     */
    _isDisabled() {
        return this.props._audioTrackMuted;
    }

    /**
     * Renders the item toggled if the participant is muted.
     *
     * @inheritdoc
     */
    _isToggled() {
        return this.props._audioTrackMuted;
    }
}

/**
 * Function that maps parts of Redux state tree into component props.
 *
 * @param {Object} state - Redux state.
 * @param {Object} ownProps - Properties of component.
 * @private
 * @returns {{
 *      _audioTrackMuted: boolean
 *  }}
 */
export function _mapStateToProps(state: IReduxState, ownProps: any) {
    const tracks = state['features/base/tracks'];

    return {
        _audioTrackMuted: isRemoteTrackMuted(
            tracks, MEDIA_TYPE.AUDIO, ownProps.participantID)
    };
}


################################################################################

## File: .\jitsi-meet\react\features\video-menu\components\AbstractMuteEveryoneDialog.ts

import { IReduxState } from '../../app/types';
import { requestDisableAudioModeration, requestEnableAudioModeration } from '../../av-moderation/actions';
import { isEnabledFromState, isSupported } from '../../av-moderation/functions';
import { MEDIA_TYPE } from '../../base/media/constants';
import { getLocalParticipant, getParticipantDisplayName } from '../../base/participants/functions';
import { muteAllParticipants } from '../actions';

import AbstractMuteRemoteParticipantDialog, {
    type IProps as AbstractProps
} from './AbstractMuteRemoteParticipantDialog';

/**
 * The type of the React {@code Component} props of
 * {@link AbstractMuteEveryoneDialog}.
 */
export interface IProps extends AbstractProps {
    content?: string;
    exclude: Array<string>;
    isAudioModerationEnabled?: boolean;
    isModerationSupported?: boolean;
    showAdvancedModerationToggle: boolean;
    title: string;
}

interface IState {
    audioModerationEnabled?: boolean;
    content: string;
}

/**
 *
 * An abstract Component with the contents for a dialog that asks for confirmation
 * from the user before muting all remote participants.
 *
 * @augments AbstractMuteRemoteParticipantDialog
 */
export default class AbstractMuteEveryoneDialog<P extends IProps> extends
    AbstractMuteRemoteParticipantDialog<P, IState> {
    static defaultProps = {
        exclude: [],
        muteLocal: false
    };

    /**
     * Initializes a new {@code AbstractMuteRemoteParticipantDialog} instance.
     *
     * @param {Object} props - The read-only properties with which the new
     * instance is to be initialized.
     */
    constructor(props: P) {
        super(props);

        this.state = {
            audioModerationEnabled: props.isAudioModerationEnabled,
            content: props.content || props.t(props.isAudioModerationEnabled
                ? 'dialog.muteEveryoneDialogModerationOn' : 'dialog.muteEveryoneDialog'
            )
        };

        // Bind event handlers so they are only bound once per instance.
        this._onSubmit = this._onSubmit.bind(this);
        this._onToggleModeration = this._onToggleModeration.bind(this);
    }

    /**
      * Toggles advanced moderation switch.
      *
      * @returns {void}
      */
    _onToggleModeration() {
        this.setState(state => {
            return {
                audioModerationEnabled: !state.audioModerationEnabled,
                content: this.props.t(state.audioModerationEnabled
                    ? 'dialog.muteEveryoneDialog' : 'dialog.muteEveryoneDialogModerationOn'
                )
            };
        });
    }

    /**
     * Callback to be invoked when the value of this dialog is submitted.
     *
     * @returns {boolean}
     */
    _onSubmit() {
        const {
            dispatch,
            exclude
        } = this.props;

        dispatch(muteAllParticipants(exclude, MEDIA_TYPE.AUDIO));
        if (this.state.audioModerationEnabled) {
            dispatch(requestEnableAudioModeration());
        } else if (this.state.audioModerationEnabled !== undefined) {
            dispatch(requestDisableAudioModeration());
        }

        return true;
    }
}

/**
 * Maps (parts of) the Redux state to the associated {@code AbstractMuteEveryoneDialog}'s props.
 *
 * @param {IReduxState} state - The redux state.
 * @param {Object} ownProps - The properties explicitly passed to the component.
 * @returns {IProps}
 */
export function abstractMapStateToProps(state: IReduxState, ownProps: IProps) {
    const { exclude = [], t } = ownProps;

    const whom = exclude
        // eslint-disable-next-line no-confusing-arrow
        .map(id => id === getLocalParticipant(state)?.id
            ? t('dialog.muteEveryoneSelf')
            : getParticipantDisplayName(state, id))
        .join(', ');

    return whom.length ? {
        content: t('dialog.muteEveryoneElseDialog'),
        title: t('dialog.muteEveryoneElseTitle', { whom })
    } : {
        title: t('dialog.muteEveryoneTitle'),
        isAudioModerationEnabled: isEnabledFromState(MEDIA_TYPE.AUDIO, state),
        isModerationSupported: isSupported()(state)
    };
}


################################################################################

## File: .\jitsi-meet\react\features\video-menu\components\AbstractMuteEveryoneElseButton.ts

import { createToolbarEvent } from '../../analytics/AnalyticsEvents';
import { sendAnalytics } from '../../analytics/functions';
import { openDialog } from '../../base/dialog/actions';
import { IconMicSlash } from '../../base/icons/svg';
import AbstractButton, { IProps as AbstractButtonProps } from '../../base/toolbox/components/AbstractButton';

import { MuteEveryoneDialog } from './';

export interface IProps extends AbstractButtonProps {

    /**
     * The ID of the participant object that this button is supposed to keep unmuted.
     */
    participantID: string;
}

/**
 * An abstract remote video menu button which mutes all the other participants.
 */
export default class AbstractMuteEveryoneElseButton extends AbstractButton<IProps> {
    accessibilityLabel = 'toolbar.accessibilityLabel.muteEveryoneElse';
    icon = IconMicSlash;
    label = 'videothumbnail.domuteOthers';

    /**
     * Handles clicking / pressing the button, and opens a confirmation dialog.
     *
     * @private
     * @returns {void}
     */
    _handleClick() {
        const { dispatch, participantID } = this.props;

        sendAnalytics(createToolbarEvent('mute.everyoneelse.pressed'));
        dispatch(openDialog(MuteEveryoneDialog, { exclude: [ participantID ] }));
    }
}


################################################################################

## File: .\jitsi-meet\react\features\video-menu\components\AbstractMuteEveryoneElsesVideoButton.ts

import { createToolbarEvent } from '../../analytics/AnalyticsEvents';
import { sendAnalytics } from '../../analytics/functions';
import { openDialog } from '../../base/dialog/actions';
import { IconVideoOff } from '../../base/icons/svg';
import AbstractButton, { IProps as AbstractButtonProps } from '../../base/toolbox/components/AbstractButton';

import { MuteEveryonesVideoDialog } from './';

export interface IProps extends AbstractButtonProps {

    /**
     * The ID of the participant object that this button is supposed to keep unmuted.
     */
    participantID: string;
}

/**
 * An abstract remote video menu button which disables the camera of all the other participants.
 */
export default class AbstractMuteEveryoneElsesVideoButton extends AbstractButton<IProps> {
    accessibilityLabel = 'toolbar.accessibilityLabel.muteEveryoneElsesVideoStream';
    icon = IconVideoOff;
    label = 'videothumbnail.domuteVideoOfOthers';

    /**
     * Handles clicking / pressing the button, and opens a confirmation dialog.
     *
     * @private
     * @returns {void}
     */
    _handleClick() {
        const { dispatch, participantID } = this.props;

        sendAnalytics(createToolbarEvent('mute.everyoneelsesvideo.pressed'));
        dispatch(openDialog(MuteEveryonesVideoDialog, { exclude: [ participantID ] }));
    }
}


################################################################################

## File: .\jitsi-meet\react\features\video-menu\components\AbstractMuteEveryonesVideoDialog.ts

import { IReduxState } from '../../app/types';
import { requestDisableVideoModeration, requestEnableVideoModeration } from '../../av-moderation/actions';
import { isEnabledFromState, isSupported } from '../../av-moderation/functions';
import { MEDIA_TYPE } from '../../base/media/constants';
import { getLocalParticipant, getParticipantDisplayName } from '../../base/participants/functions';
import { muteAllParticipants } from '../actions';

import AbstractMuteRemoteParticipantsVideoDialog, {
    type IProps as AbstractProps
} from './AbstractMuteRemoteParticipantsVideoDialog';

/**
 * The type of the React {@code Component} props of
 * {@link AbstractMuteEveryonesVideoDialog}.
 */
export interface IProps extends AbstractProps {
    content?: string;
    exclude: Array<string>;
    isModerationSupported?: boolean;
    isVideoModerationEnabled?: boolean;
    showAdvancedModerationToggle: boolean;
    title: string;
}

interface IState {
    content: string;
    moderationEnabled?: boolean;
}

/**
 *
 * An abstract Component with the contents for a dialog that asks for confirmation
 * from the user before disabling all remote participants cameras.
 *
 * @augments AbstractMuteRemoteParticipantsVideoDialog
 */
export default class AbstractMuteEveryonesVideoDialog<P extends IProps>
    extends AbstractMuteRemoteParticipantsVideoDialog<P, IState> {
    static defaultProps = {
        exclude: [],
        muteLocal: false
    };

    /**
     * Initializes a new {@code AbstractMuteRemoteParticipantsVideoDialog} instance.
     *
     * @param {Object} props - The read-only properties with which the new
     * instance is to be initialized.
     */
    constructor(props: P) {
        super(props);

        this.state = {
            moderationEnabled: props.isVideoModerationEnabled,
            content: props.content || props.t(props.isVideoModerationEnabled
                ? 'dialog.muteEveryonesVideoDialogModerationOn' : 'dialog.muteEveryonesVideoDialog'
            )
        };

        // Bind event handlers so they are only bound once per instance.
        this._onSubmit = this._onSubmit.bind(this);
        this._onToggleModeration = this._onToggleModeration.bind(this);
    }

    /**
     * Toggles advanced moderation switch.
     *
     * @returns {void}
     */
    _onToggleModeration() {
        this.setState(state => {
            return {
                moderationEnabled: !state.moderationEnabled,
                content: this.props.t(state.moderationEnabled
                    ? 'dialog.muteEveryonesVideoDialog' : 'dialog.muteEveryonesVideoDialogModerationOn'
                )
            };
        });
    }

    /**
     * Callback to be invoked when the value of this dialog is submitted.
     *
     * @returns {boolean}
     */
    _onSubmit() {
        const {
            dispatch,
            exclude
        } = this.props;

        dispatch(muteAllParticipants(exclude, MEDIA_TYPE.VIDEO));
        if (this.state.moderationEnabled) {
            dispatch(requestEnableVideoModeration());
        } else if (this.state.moderationEnabled !== undefined) {
            dispatch(requestDisableVideoModeration());
        }

        return true;
    }
}

/**
 * Maps (parts of) the Redux state to the associated {@code AbstractMuteEveryonesVideoDialog}'s props.
 *
 * @param {IReduxState} state - The redux state.
 * @param {Object} ownProps - The properties explicitly passed to the component.
 * @returns {IProps}
 */
export function abstractMapStateToProps(state: IReduxState, ownProps: IProps) {
    const { exclude = [], t } = ownProps;
    const isVideoModerationEnabled = isEnabledFromState(MEDIA_TYPE.VIDEO, state);

    const whom = exclude
        // eslint-disable-next-line no-confusing-arrow
        .map(id => id === getLocalParticipant(state)?.id
            ? t('dialog.muteEveryoneSelf')
            : getParticipantDisplayName(state, id))
        .join(', ');

    return whom.length ? {
        content: t('dialog.muteEveryoneElsesVideoDialog'),
        title: t('dialog.muteEveryoneElsesVideoTitle', { whom })
    } : {
        title: t('dialog.muteEveryonesVideoTitle'),
        isVideoModerationEnabled,
        isModerationSupported: isSupported()(state)
    };
}


################################################################################

## File: .\jitsi-meet\react\features\video-menu\components\AbstractMuteRemoteParticipantDialog.ts

import { Component } from 'react';
import { WithTranslation } from 'react-i18next';

import { IStore } from '../../app/types';
import { MEDIA_TYPE } from '../../base/media/constants';
import { muteRemote } from '../actions';

/**
 * The type of the React {@code Component} props of
 * {@link AbstractMuteRemoteParticipantDialog}.
 */
export interface IProps extends WithTranslation {

    /**
     * The Redux dispatch function.
     */
    dispatch: IStore['dispatch'];

    /**
     * The ID of the remote participant to be muted.
     */
    participantID: string;
}

/**
 * Abstract dialog to confirm a remote participant mute action.
 *
 * @augments Component
 */
export default class AbstractMuteRemoteParticipantDialog<P extends IProps = IProps, State=void>
    extends Component<P, State> {
    /**
     * Initializes a new {@code AbstractMuteRemoteParticipantDialog} instance.
     *
     * @param {Object} props - The read-only properties with which the new
     * instance is to be initialized.
     */
    constructor(props: P) {
        super(props);

        // Bind event handlers so they are only bound once per instance.
        this._onSubmit = this._onSubmit.bind(this);
    }

    /**
     * Handles the submit button action.
     *
     * @private
     * @returns {boolean} - True (to note that the modal should be closed).
     */
    _onSubmit() {
        const { dispatch, participantID } = this.props;

        dispatch(muteRemote(participantID, MEDIA_TYPE.AUDIO));

        return true;
    }
}


################################################################################

## File: .\jitsi-meet\react\features\video-menu\components\AbstractMuteRemoteParticipantsVideoDialog.ts

import { Component } from 'react';
import { WithTranslation } from 'react-i18next';

import { IReduxState, IStore } from '../../app/types';
import { rejectParticipantVideo } from '../../av-moderation/actions';
import { isEnabledFromState } from '../../av-moderation/functions';
import { MEDIA_TYPE } from '../../base/media/constants';
import { muteRemote } from '../actions';

/**
 * The type of the React {@code Component} props of
 * {@link AbstractMuteRemoteParticipantsVideoDialog}.
 */
export interface IProps extends WithTranslation {

    /**
     * The Redux dispatch function.
     */
    dispatch: IStore['dispatch'];

    /**
     * Whether or not video moderation is on.
     */
    isVideoModerationOn: boolean;

    /**
     * The ID of the remote participant to be muted.
     */
    participantID: string;
}

/**
 * Abstract dialog to confirm a remote participant video ute action.
 *
 * @augments Component
 */
export default class AbstractMuteRemoteParticipantsVideoDialog<P extends IProps = IProps, State=any>
    extends Component<P, State> {
    /**
     * Initializes a new {@code AbstractMuteRemoteParticipantsVideoDialog} instance.
     *
     * @param {Object} props - The read-only properties with which the new
     * instance is to be initialized.
     */
    constructor(props: P) {
        super(props);

        // Bind event handlers so they are only bound once per instance.
        this._onSubmit = this._onSubmit.bind(this);
    }

    /**
     * Handles the submit button action.
     *
     * @private
     * @returns {boolean} - True (to note that the modal should be closed).
     */
    _onSubmit() {
        const { dispatch, participantID } = this.props;

        dispatch(muteRemote(participantID, MEDIA_TYPE.VIDEO));
        dispatch(rejectParticipantVideo(participantID));

        return true;
    }
}

/**
 * Maps (parts of) the redux state to the associated
 * {@code AbstractDialogContainer}'s props.
 *
 * @param {IReduxState} state - The redux state.
 * @private
 * @returns {Object}
 */
export function abstractMapStateToProps(state: IReduxState) {
    return {
        isVideoModerationOn: isEnabledFromState(MEDIA_TYPE.VIDEO, state)
    };
}


################################################################################

## File: .\jitsi-meet\react\features\video-menu\components\AbstractMuteVideoButton.ts

import { createRemoteVideoMenuButtonEvent } from '../../analytics/AnalyticsEvents';
import { sendAnalytics } from '../../analytics/functions';
import { IReduxState } from '../../app/types';
import { openDialog } from '../../base/dialog/actions';
import { IconVideoOff } from '../../base/icons/svg';
import { MEDIA_TYPE } from '../../base/media/constants';
import AbstractButton, { IProps as AbstractButtonProps } from '../../base/toolbox/components/AbstractButton';
import { isRemoteTrackMuted } from '../../base/tracks/functions.any';

import { MuteRemoteParticipantsVideoDialog } from './';

export interface IProps extends AbstractButtonProps {

    /**
     * Boolean to indicate if the video track of the participant is muted or
     * not.
     */
    _videoTrackMuted: boolean;

    /**
     * The ID of the participant object that this button is supposed to
     * mute/unmute.
     */
    participantID: string;
}

/**
 * An abstract remote video menu button which mutes the remote participant.
 */
export default class AbstractMuteVideoButton extends AbstractButton<IProps> {
    accessibilityLabel = 'toolbar.accessibilityLabel.remoteVideoMute';
    icon = IconVideoOff;
    label = 'videothumbnail.domuteVideo';
    toggledLabel = 'videothumbnail.videoMuted';

    /**
     * Handles clicking / pressing the button, and mutes the participant.
     *
     * @private
     * @returns {void}
     */
    _handleClick() {
        const { dispatch, participantID } = this.props;

        sendAnalytics(createRemoteVideoMenuButtonEvent(
            'video.mute.button',
            {
                'participant_id': participantID
            }));

        dispatch(openDialog(MuteRemoteParticipantsVideoDialog, { participantID }));
    }

    /**
     * Renders the item disabled if the participant is muted.
     *
     * @inheritdoc
     */
    _isDisabled() {
        return this.props._videoTrackMuted;
    }

    /**
     * Renders the item toggled if the participant is muted.
     *
     * @inheritdoc
     */
    _isToggled() {
        return this.props._videoTrackMuted;
    }
}

/**
 * Function that maps parts of Redux state tree into component props.
 *
 * @param {Object} state - Redux state.
 * @param {Object} ownProps - Properties of component.
 * @private
 * @returns {{
 *      _videoTrackMuted: boolean
 *  }}
 */
export function _mapStateToProps(state: IReduxState, ownProps: any) {
    const tracks = state['features/base/tracks'];

    return {
        _videoTrackMuted: isRemoteTrackMuted(
            tracks, MEDIA_TYPE.VIDEO, ownProps.participantID)
    };
}


################################################################################

## File: .\jitsi-meet\react\features\video-menu\components\index.native.ts

/* eslint-disable lines-around-comment */
// @ts-ignore
export { default as DemoteToVisitorDialog } from './native/DemoteToVisitorDialog';
// @ts-ignore
export { default as GrantModeratorDialog } from './native/GrantModeratorDialog';
// @ts-ignore
export { default as KickRemoteParticipantDialog } from './native/KickRemoteParticipantDialog';
// @ts-ignore
export { default as MuteEveryoneDialog } from './native/MuteEveryoneDialog';
// @ts-ignore
export { default as MuteEveryonesVideoDialog } from './native/MuteEveryonesVideoDialog';
// @ts-ignore
export { default as MuteRemoteParticipantsVideoDialog } from './native/MuteRemoteParticipantsVideoDialog';


################################################################################

## File: .\jitsi-meet\react\features\video-menu\components\index.web.ts

export { default as DemoteToVisitorDialog } from './web/DemoteToVisitorDialog';
export { default as GrantModeratorDialog } from './web/GrantModeratorDialog';
export { default as KickRemoteParticipantDialog } from './web/KickRemoteParticipantDialog';
export { default as MuteEveryoneDialog } from './web/MuteEveryoneDialog';
export { default as MuteEveryonesVideoDialog } from './web/MuteEveryonesVideoDialog';
export { default as MuteRemoteParticipantsVideoDialog } from './web/MuteRemoteParticipantsVideoDialog';


################################################################################

## File: .\jitsi-meet\react\features\video-menu\components\native\AskUnmuteButton.ts

import { connect } from 'react-redux';

import { IReduxState } from '../../../app/types';
import { approveParticipant } from '../../../av-moderation/actions';
import { isSupported } from '../../../av-moderation/functions';
import { translate } from '../../../base/i18n/functions';
import { IconMic, IconVideo } from '../../../base/icons/svg';
import { MEDIA_TYPE } from '../../../base/media/constants';
import { getParticipantById, isLocalParticipantModerator } from '../../../base/participants/functions';
import AbstractButton, { IProps as AbstractButtonProps } from '../../../base/toolbox/components/AbstractButton';
import { isForceMuted } from '../../../participants-pane/functions';

export interface IProps extends AbstractButtonProps {

    /**
     * Whether or not the participant is audio force muted.
     */
    isAudioForceMuted: boolean;

    /**
     * Whether or not the participant is video force muted.
     */
    isVideoForceMuted: boolean;

    /**
     * The ID of the participant object that this button is supposed to
     * ask to unmute.
     */
    participantID: string;
}

/**
 * An abstract remote video menu button which asks the remote participant to unmute.
 */
class AskUnmuteButton extends AbstractButton<IProps> {
    accessibilityLabel = 'participantsPane.actions.askUnmute';
    icon = IconMic;
    label = 'participantsPane.actions.askUnmute';

    /**
     * Gets the current label.
     *
     * @returns {string}
     */
    _getLabel() {
        const { isAudioForceMuted, isVideoForceMuted } = this.props;

        if (!isAudioForceMuted && isVideoForceMuted) {
            return 'participantsPane.actions.allowVideo';
        }

        return this.label;
    }

    /**
     * Gets the current icon.
     *
     * @returns {string}
     */
    _getIcon() {
        const { isAudioForceMuted, isVideoForceMuted } = this.props;

        if (!isAudioForceMuted && isVideoForceMuted) {
            return IconVideo;
        }

        return this.icon;
    }

    /**
     * Handles clicking / pressing the button, and asks the participant to unmute.
     *
     * @private
     * @returns {void}
     */
    _handleClick() {
        const { dispatch, participantID } = this.props;

        dispatch(approveParticipant(participantID));
    }
}

/**
 * Maps part of the Redux state to the props of this component.
 *
 * @param {Object} state - The Redux state.
 * @param {Object} ownProps - Properties of component.
 * @returns {IProps}
 */
function mapStateToProps(state: IReduxState, ownProps: any) {
    const { participantID } = ownProps;
    const participant = getParticipantById(state, participantID);

    return {
        isAudioForceMuted: isForceMuted(participant, MEDIA_TYPE.AUDIO, state),
        isVideoForceMuted: isForceMuted(participant, MEDIA_TYPE.VIDEO, state),
        visible: isLocalParticipantModerator(state) && isSupported()(state)
    };
}

export default translate(connect(mapStateToProps)(AskUnmuteButton));


################################################################################

## File: .\jitsi-meet\react\features\video-menu\components\native\ConnectionStatusButton.ts

import { connect } from 'react-redux';

import { translate } from '../../../base/i18n/functions';
import { IconInfoCircle } from '../../../base/icons/svg';
import AbstractButton, { IProps as AbstractButtonProps } from '../../../base/toolbox/components/AbstractButton';
import { showConnectionStatus } from '../../../participants-pane/actions.native';

export interface IProps extends AbstractButtonProps {

    /**
     * The ID of the participant that this button is supposed to pin.
     */
    participantID: string;
}

/**
 * A remote video menu button which shows the connection statistics.
 */
class ConnectionStatusButton extends AbstractButton<IProps> {
    icon = IconInfoCircle;
    label = 'videothumbnail.connectionInfo';

    /**
     * Handles clicking / pressing the button, and kicks the participant.
     *
     * @private
     * @returns {void}
     */
    _handleClick() {
        const { dispatch, participantID } = this.props;

        dispatch(showConnectionStatus(participantID));
    }
}

export default translate(connect()(ConnectionStatusButton));


################################################################################

## File: .\jitsi-meet\react\features\video-menu\components\native\DemoteToVisitorButton.ts

import { connect } from 'react-redux';

import { IReduxState } from '../../../app/types';
import { openDialog } from '../../../base/dialog/actions';
import { translate } from '../../../base/i18n/functions';
import { IconUsers } from '../../../base/icons/svg';
import AbstractButton, { IProps as AbstractButtonProps } from '../../../base/toolbox/components/AbstractButton';

import DemoteToVisitorDialog from './DemoteToVisitorDialog';

interface IProps extends AbstractButtonProps {

    /**
     * The ID of the participant that this button is supposed to kick.
     */
    participantID: string;
}

/**
 * Implements a React {@link Component} which displays a button for demoting a participant to visitor.
 */
class DemoteToVisitorButton extends AbstractButton<IProps> {
    accessibilityLabel = 'videothumbnail.demote';
    icon = IconUsers;
    label = 'videothumbnail.demote';

    /**
     * Handles clicking / pressing the button, and demoting the participant.
     *
     * @private
     * @returns {void}
     */
    _handleClick() {
        const { dispatch, participantID } = this.props;

        dispatch(openDialog(DemoteToVisitorDialog, { participantID }));
    }
}

/**
 * Maps part of the Redux state to the props of this component.
 *
 * @param {Object} state - The Redux state.
 * @returns {Props}
 */
function _mapStateToProps(state: IReduxState) {
    return {
        visible: state['features/visitors'].supported
    };
}

export default translate(connect(_mapStateToProps)(DemoteToVisitorButton));


################################################################################

## File: .\jitsi-meet\react\features\video-menu\components\native\GrantModeratorButton.ts

import { connect } from 'react-redux';

import { translate } from '../../../base/i18n/functions';
import AbstractGrantModeratorButton, {
    _mapStateToProps
} from '../AbstractGrantModeratorButton';

export default translate(connect(_mapStateToProps)(AbstractGrantModeratorButton));


################################################################################

## File: .\jitsi-meet\react\features\video-menu\components\native\KickButton.ts

import { connect } from 'react-redux';

import { IReduxState } from '../../../app/types';
import { translate } from '../../../base/i18n/functions';
import { isLocalParticipantModerator } from '../../../base/participants/functions';
import AbstractKickButton from '../AbstractKickButton';

/**
 * Maps part of the Redux state to the props of this component.
 *
 * @param {Object} state - The Redux state.
 * @returns {Props}
 */
function _mapStateToProps(state: IReduxState) {
    return {
        visible: isLocalParticipantModerator(state)
    };
}

export default translate(connect(_mapStateToProps)(AbstractKickButton));


################################################################################

## File: .\jitsi-meet\react\features\video-menu\components\native\MuteButton.ts

import { connect } from 'react-redux';

import { IReduxState } from '../../../app/types';
import { translate } from '../../../base/i18n/functions';
import { isLocalParticipantModerator } from '../../../base/participants/functions';
import AbstractMuteButton, { _mapStateToProps as _abstractMapStateToProps } from '../AbstractMuteButton';

/**
 * Maps part of the Redux state to the props of this component.
 *
 * @param {Object} state - The Redux state.
 * @param {Object} ownProps - Properties of component.
 * @returns {Props}
 */
function _mapStateToProps(state: IReduxState, ownProps: any) {
    return {
        ..._abstractMapStateToProps(state, ownProps),
        visible: isLocalParticipantModerator(state)
    };
}

export default translate(connect(_mapStateToProps)(AbstractMuteButton));


################################################################################

## File: .\jitsi-meet\react\features\video-menu\components\native\MuteEveryoneElseButton.ts

import { connect } from 'react-redux';

import { IReduxState } from '../../../app/types';
import { translate } from '../../../base/i18n/functions';
import { isLocalParticipantModerator } from '../../../base/participants/functions';
import AbstractMuteEveryoneElseButton from '../AbstractMuteEveryoneElseButton';

/**
 * Maps part of the Redux state to the props of this component.
 *
 * @param {Object} state - The Redux state.
 * @returns {Props}
 */
function _mapStateToProps(state: IReduxState) {
    return {
        visible: isLocalParticipantModerator(state)
    };
}

export default translate(connect(_mapStateToProps)(AbstractMuteEveryoneElseButton));


################################################################################

## File: .\jitsi-meet\react\features\video-menu\components\native\MuteVideoButton.ts

import { connect } from 'react-redux';

import { IReduxState } from '../../../app/types';
import { translate } from '../../../base/i18n/functions';
import { isLocalParticipantModerator } from '../../../base/participants/functions';
import AbstractMuteVideoButton, { _mapStateToProps as _abstractMapStateToProps } from '../AbstractMuteVideoButton';

/**
 * Maps part of the Redux state to the props of this component.
 *
 * @param {Object} state - The Redux state.
 * @param {Object} ownProps - Properties of component.
 * @returns {Props}
 */
function _mapStateToProps(state: IReduxState, ownProps: any) {
    return {
        ..._abstractMapStateToProps(state, ownProps),
        visible: isLocalParticipantModerator(state)
    };
}

export default translate(connect(_mapStateToProps)(AbstractMuteVideoButton));


################################################################################

## File: .\jitsi-meet\react\features\video-menu\components\native\PinButton.ts

import { connect } from 'react-redux';

import { IReduxState } from '../../../app/types';
import { translate } from '../../../base/i18n/functions';
import { IconEnlarge } from '../../../base/icons/svg';
import { pinParticipant } from '../../../base/participants/actions';
import AbstractButton, { IProps as AbstractButtonProps } from '../../../base/toolbox/components/AbstractButton';
import { shouldDisplayTileView } from '../../../video-layout/functions';

export interface IProps extends AbstractButtonProps {

    /**
     * True if tile view is currently enabled.
     */
    _tileViewEnabled?: boolean;

    /**
     * The ID of the participant that this button is supposed to pin.
     */
    participantID: string;
}

/**
 * A remote video menu button which pins a participant and exist the tile view.
 */
class PinButton extends AbstractButton<IProps> {
    accessibilityLabel = 'toolbar.accessibilityLabel.show';
    icon = IconEnlarge;
    label = 'videothumbnail.show';

    /**
     * Handles clicking / pressing the button, and kicks the participant.
     *
     * @private
     * @returns {void}
     */
    _handleClick() {
        const { dispatch } = this.props;

        // Pin participant, it will automatically exit the tile view
        dispatch(pinParticipant(this.props.participantID));
    }
}

/**
 * Maps part of the Redux state to the props of this component.
 *
 * @param {Object} state - The Redux state.
 * @returns {IProps}
 */
function _mapStateToProps(state: IReduxState) {
    const { isOpen } = state['features/participants-pane'];

    return {
        visible: !isOpen && shouldDisplayTileView(state)
    };
}

export default translate(connect(_mapStateToProps)(PinButton));


################################################################################

## File: .\jitsi-meet\react\features\video-menu\components\native\SendToBreakoutRoom.ts

import { connect } from 'react-redux';

import { createBreakoutRoomsEvent } from '../../../analytics/AnalyticsEvents';
import { sendAnalytics } from '../../../analytics/functions';
import { IReduxState } from '../../../app/types';
import { translate } from '../../../base/i18n/functions';
import { IconRingGroup } from '../../../base/icons/svg';
import { isLocalParticipantModerator } from '../../../base/participants/functions';
import AbstractButton, { IProps as AbstractButtonProps } from '../../../base/toolbox/components/AbstractButton';
import { sendParticipantToRoom } from '../../../breakout-rooms/actions';
import { IRoom } from '../../../breakout-rooms/types';

export interface IProps extends AbstractButtonProps {

    /**
     * ID of the participant to send to breakout room.
     */
    participantID: string;

    /**
     * Room to send participant to.
     */
    room: IRoom;
}

/**
 * An abstract remote video menu button which sends the remote participant to a breakout room.
 */
class SendToBreakoutRoom extends AbstractButton<IProps> {
    accessibilityLabel = 'breakoutRooms.actions.sendToBreakoutRoom';
    icon = IconRingGroup;

    /**
     * Gets the current label.
     *
     * @returns {string}
     */
    _getLabel() {
        const { t, room } = this.props;

        return room.name || t('breakoutRooms.mainRoom');
    }

    /**
     * Handles clicking / pressing the button, and asks the participant to unmute.
     *
     * @private
     * @returns {void}
     */
    _handleClick() {
        const { dispatch, participantID, room } = this.props;

        sendAnalytics(createBreakoutRoomsEvent('send.participant.to.room'));
        dispatch(sendParticipantToRoom(participantID, room.id));
    }
}

/**
 * Maps part of the Redux state to the props of this component.
 *
 * @param {Object} state - The Redux state.
 * @param {Object} ownProps - Properties of component.
 * @returns {IProps}
 */
function mapStateToProps(state: IReduxState) {
    return {
        visible: isLocalParticipantModerator(state)
    };
}

export default translate(connect(mapStateToProps)(SendToBreakoutRoom));


################################################################################

## File: .\jitsi-meet\react\features\video-menu\components\native\styles.ts

import {
    MD_FONT_SIZE,
    MD_ITEM_HEIGHT,
    MD_ITEM_MARGIN_PADDING
} from '../../../base/dialog/components/native/styles';
import { ColorPalette } from '../../../base/styles/components/styles/ColorPalette';
import { createStyleSheet } from '../../../base/styles/functions.native';
import BaseTheme from '../../../base/ui/components/BaseTheme.native';

export default createStyleSheet({
    participantNameContainer: {
        alignItems: 'center',
        borderBottomColor: BaseTheme.palette.ui07,
        borderBottomWidth: 0.4,
        borderTopLeftRadius: 16,
        borderTopRightRadius: 16,
        flexDirection: 'row',
        height: MD_ITEM_HEIGHT,
        paddingLeft: MD_ITEM_MARGIN_PADDING
    },

    participantNameLabel: {
        color: ColorPalette.lightGrey,
        flexShrink: 1,
        fontSize: MD_FONT_SIZE,
        marginLeft: MD_ITEM_MARGIN_PADDING,
        opacity: 0.90
    },

    statsTitleText: {
        color: BaseTheme.palette.text01,
        fontSize: 16,
        fontWeight: 'bold',
        marginRight: 3
    },

    statsInfoText: {
        color: BaseTheme.palette.text01,
        fontSize: 16,
        marginRight: 2,
        marginLeft: 2
    },

    statsInfoCell: {
        alignItems: 'center',
        flexDirection: 'row',
        height: 30,
        justifyContent: 'flex-start'
    },

    statsWrapper: {
        margin: BaseTheme.spacing[3]
    },

    volumeSliderContainer: {
        alignItems: 'center',
        flexDirection: 'row',
        marginHorizontal: BaseTheme.spacing[3],
        marginVertical: BaseTheme.spacing[2]
    },

    sliderContainer: {
        marginLeft: BaseTheme.spacing[3],
        minWidth: '80%'
    },

    divider: {
        backgroundColor: BaseTheme.palette.ui07
    },

    dividerDialog: {
        backgroundColor: BaseTheme.palette.ui07,
        marginBottom: BaseTheme.spacing[3]
    },

    contextMenuItem: {
        alignItems: 'center',
        display: 'flex',
        flexDirection: 'row',
        height: BaseTheme.spacing[7],
        marginLeft: BaseTheme.spacing[3]
    },

    contextMenuItemText: {
        ...BaseTheme.typography.bodyShortRegularLarge,
        color: BaseTheme.palette.text01,
        marginLeft: BaseTheme.spacing[4]
    }
});


################################################################################

## File: .\jitsi-meet\react\features\video-quality\actions.ts

import { IStore } from '../app/types';

import {
    SET_MAX_RECEIVER_VIDEO_QUALITY_FOR_LARGE_VIDEO,
    SET_MAX_RECEIVER_VIDEO_QUALITY_FOR_SCREEN_SHARING_FILMSTRIP,
    SET_MAX_RECEIVER_VIDEO_QUALITY_FOR_STAGE_FILMSTRIP,
    SET_MAX_RECEIVER_VIDEO_QUALITY_FOR_TILE_VIEW,
    SET_MAX_RECEIVER_VIDEO_QUALITY_FOR_VERTICAL_FILMSTRIP,
    SET_PREFERRED_VIDEO_QUALITY
} from './actionTypes';
import { MAX_VIDEO_QUALITY, VIDEO_QUALITY_LEVELS } from './constants';
import logger from './logger';

/**
 * Sets the max frame height that should be received for the large video.
 *
 * @param {number} maxReceiverVideoQuality - The max video frame height to
 * receive.
 * @returns {{
 *     type: SET_MAX_RECEIVER_VIDEO_QUALITY_FOR_LARGE_VIDEO,
 *     maxReceiverVideoQuality: number
 * }}
 */
export function setMaxReceiverVideoQualityForLargeVideo(maxReceiverVideoQuality: number) {
    return {
        type: SET_MAX_RECEIVER_VIDEO_QUALITY_FOR_LARGE_VIDEO,
        maxReceiverVideoQuality
    };
}

/**
 * Sets the max frame height that should be received for the screen sharing filmstrip particpant.
 *
 * @param {number} maxReceiverVideoQuality - The max video frame height to
 * receive.
 * @returns {{
 *     type: SET_MAX_RECEIVER_VIDEO_QUALITY_FOR_SCREEN_SHARING_FILMSTRIP,
 *     maxReceiverVideoQuality: number
 * }}
 */
export function setMaxReceiverVideoQualityForScreenSharingFilmstrip(maxReceiverVideoQuality: number) {
    return {
        type: SET_MAX_RECEIVER_VIDEO_QUALITY_FOR_SCREEN_SHARING_FILMSTRIP,
        maxReceiverVideoQuality
    };
}

/**
 * Sets the max frame height that should be received from remote videos for the stage filmstrip.
 *
 * @param {number} maxReceiverVideoQuality - The max video frame height to
 * receive.
 * @returns {{
 *     type: SET_MAX_RECEIVER_VIDEO_QUALITY_FOR_STAGE_FILMSTRIP,
 *     maxReceiverVideoQuality: number
 * }}
 */
export function setMaxReceiverVideoQualityForStageFilmstrip(maxReceiverVideoQuality: number) {
    return {
        type: SET_MAX_RECEIVER_VIDEO_QUALITY_FOR_STAGE_FILMSTRIP,
        maxReceiverVideoQuality
    };
}

/**
 * Sets the max frame height that should be received from remote videos in tile view.
 *
 * @param {number} maxReceiverVideoQuality - The max video frame height to
 * receive.
 * @returns {{
 *     type: SET_MAX_RECEIVER_VIDEO_QUALITY_FOR_TILE_VIEW,
 *     maxReceiverVideoQuality: number
 * }}
 */
export function setMaxReceiverVideoQualityForTileView(maxReceiverVideoQuality: number) {
    return {
        type: SET_MAX_RECEIVER_VIDEO_QUALITY_FOR_TILE_VIEW,
        maxReceiverVideoQuality
    };
}

/**
 * Sets the max frame height that should be received from remote videos for the vertical filmstrip.
 *
 * @param {number} maxReceiverVideoQuality - The max video frame height to
 * receive.
 * @returns {{
 *     type: SET_MAX_RECEIVER_VIDEO_QUALITY_FOR_VERTICAL_FILMSTRIP,
 *     maxReceiverVideoQuality: number
 * }}
 */
export function setMaxReceiverVideoQualityForVerticalFilmstrip(maxReceiverVideoQuality: number) {
    return {
        type: SET_MAX_RECEIVER_VIDEO_QUALITY_FOR_VERTICAL_FILMSTRIP,
        maxReceiverVideoQuality
    };
}

/**
 * Sets the max frame height the user prefers to send and receive from the
 * remote participants.
 *
 * @param {number} preferredVideoQuality - The max video resolution to send and
 * receive.
 * @returns {{
 *     type: SET_PREFERRED_VIDEO_QUALITY,
 *     preferredVideoQuality: number
 * }}
 */
export function setPreferredVideoQuality(preferredVideoQuality: number) {
    return {
        type: SET_PREFERRED_VIDEO_QUALITY,
        preferredVideoQuality
    };
}

/**
 * Sets the maximum video size the local participant should send and receive from
 * remote participants.
 *
 * @param {number} frameHeight - The user preferred max frame height for send and
 * receive video.
 * @returns {void}
 */
export function setVideoQuality(frameHeight: number) {
    return (dispatch: IStore['dispatch']) => {
        if (frameHeight < VIDEO_QUALITY_LEVELS.LOW) {
            logger.error(`Invalid frame height for video quality - ${frameHeight}`);

            return;
        }

        dispatch(setPreferredVideoQuality(Math.min(frameHeight, MAX_VIDEO_QUALITY)));
    };
}


################################################################################

## File: .\jitsi-meet\react\features\video-quality\actionTypes.ts

/**
 * The type of (redux) action which sets the maximum video height that should be
 * received from remote participants for the large video, even if the user prefers a larger video
 * height.
 *
 * {
 *     type: SET_MAX_RECEIVER_VIDEO_QUALITY_FOR_LARGE_VIDEO,
 *     maxReceiverVideoQuality: number
 * }
 */
export const SET_MAX_RECEIVER_VIDEO_QUALITY_FOR_LARGE_VIDEO = 'SET_MAX_RECEIVER_VIDEO_QUALITY_FOR_LARGE_VIDEO';



/**
 * The type of (redux) action which sets the maximum video height that should be
 * received from remote participants for the screen sharing filmstrip, even if the user prefers a larger video
 * height.
 *
 * {
 *     type: SET_MAX_RECEIVER_VIDEO_QUALITY_FOR_SCREEN_SHARING_FILMSTRIP,
 *     maxReceiverVideoQuality: number
 * }
 */
export const SET_MAX_RECEIVER_VIDEO_QUALITY_FOR_SCREEN_SHARING_FILMSTRIP = 'SET_MAX_RECEIVER_VIDEO_QUALITY_FOR_SCREEN_SHARING_FILMSTRIP';

/**
 * The type of (redux) action which sets the maximum video height that should be
 * received from remote participants for stage filmstrip, even if the user prefers a larger video
 * height.
 *
 * {
 *     type: SET_MAX_RECEIVER_VIDEO_QUALITY_FOR_STAGE_FILMSTRIP,
 *     maxReceiverVideoQuality: number
 * }
 */
export const SET_MAX_RECEIVER_VIDEO_QUALITY_FOR_STAGE_FILMSTRIP = 'SET_MAX_RECEIVER_VIDEO_QUALITY_FOR_STAGE_FILMSTRIP';

/**
 * The type of (redux) action which sets the maximum video height that should be
 * received from remote participants for tile view, even if the user prefers a larger video
 * height.
 *
 * {
 *     type: SET_MAX_RECEIVER_VIDEO_QUALITY_FOR_TILE_VIEW,
 *     maxReceiverVideoQuality: number
 * }
 */
export const SET_MAX_RECEIVER_VIDEO_QUALITY_FOR_TILE_VIEW = 'SET_MAX_RECEIVER_VIDEO_QUALITY_FOR_TILE_VIEW';

/**
 * The type of (redux) action which sets the maximum video height that should be
 * received from remote participants for vertical filmstrip, even if the user prefers a larger video
 * height.
 *
 * {
 *     type: SET_MAX_RECEIVER_VIDEO_QUALITY_FOR_VERTICAL_FILMSTRIP,
 *     maxReceiverVideoQuality: number
 * }
 */
export const SET_MAX_RECEIVER_VIDEO_QUALITY_FOR_VERTICAL_FILMSTRIP = 'SET_MAX_RECEIVER_VIDEO_QUALITY_FOR_VERTICAL_FILMSTRIP';

/**
 * The type of (redux) action which sets the preferred maximum video height that
 * should be sent to and received from remote participants.
 *
 * {
 *     type: SET_PREFERRED_VIDEO_QUALITY,
 *     preferredVideoQuality: number
 * }
 */
export const SET_PREFERRED_VIDEO_QUALITY = 'SET_PREFERRED_VIDEO_QUALITY';

################################################################################

## File: .\jitsi-meet\react\features\video-quality\constants.ts

/**
 * Default last-n value used to be used for "HD" video quality setting when no channelLastN value is specified.
 *
 * @type {number}
 */
export const DEFAULT_LAST_N = 20;

/**
 * The supported video codecs.
 *
 * @type {enum}
 */
export enum VIDEO_CODEC {
    AV1 = 'av1',
    H264 = 'h264',
    VP8 = 'vp8',
    VP9 = 'vp9'
}

/**
 * The supported remote video resolutions. The values are currently based on
 * available simulcast layers.
 *
 * @type {object}
 */
export const VIDEO_QUALITY_LEVELS = {
    ULTRA: 2160,
    HIGH: 720,
    STANDARD: 360,
    LOW: 180,
    NONE: 0
};

/**
 * Indicates unlimited video quality.
 */
export const VIDEO_QUALITY_UNLIMITED = -1;

/**
 * The maximum video quality from the VIDEO_QUALITY_LEVELS map.
 */
export const MAX_VIDEO_QUALITY = Math.max(...Object.values(VIDEO_QUALITY_LEVELS));

/**
 * Maps quality level names used in the config.videoQuality.minHeightForQualityLvl to the quality level constants used
 * by the application.
 *
 * @type {Object}
 */
export const CFG_LVL_TO_APP_QUALITY_LVL = {
    'low': VIDEO_QUALITY_LEVELS.LOW,
    'standard': VIDEO_QUALITY_LEVELS.STANDARD,
    'high': VIDEO_QUALITY_LEVELS.HIGH,
    'ultra': VIDEO_QUALITY_LEVELS.ULTRA
};


################################################################################

## File: .\jitsi-meet\react\features\video-quality\functions.ts

import { CFG_LVL_TO_APP_QUALITY_LVL, VIDEO_QUALITY_LEVELS } from './constants';

/**
 * Selects {@code VIDEO_QUALITY_LEVELS} for the given {@link availableHeight} and threshold to quality mapping.
 *
 * @param {number} availableHeight - The height to which a matching video quality level should be found.
 * @param {Map<number, number>} heightToLevel - The threshold to quality level mapping. The keys are sorted in the
 * ascending order.
 * @returns {number} The matching value from {@code VIDEO_QUALITY_LEVELS}.
 */
export function getReceiverVideoQualityLevel(availableHeight: number, heightToLevel: Map<number, number>): number {
    let selectedLevel = VIDEO_QUALITY_LEVELS.LOW;

    for (const [ levelThreshold, level ] of heightToLevel.entries()) {
        if (availableHeight >= levelThreshold) {
            selectedLevel = level;
        }
    }

    return selectedLevel;
}

/**
 * Converts {@code Object} passed in the config which represents height thresholds to vide quality level mapping to
 * a {@code Map}.
 *
 * @param {Object} minHeightForQualityLvl - The 'config.videoQuality.minHeightForQualityLvl' Object from
 * the configuration. See config.js for more details.
 * @returns {Map<number, number>|undefined} - A mapping of minimal thumbnail height required for given quality level or
 * {@code undefined} if the map contains invalid values.
 */
export function validateMinHeightForQualityLvl(minHeightForQualityLvl?: { [key: number]: string; }) {
    if (typeof minHeightForQualityLvl !== 'object'
        || Object.keys(minHeightForQualityLvl).map(lvl => Number(lvl))
            .find(lvl => lvl === null || isNaN(lvl) || lvl < 0)) {
        return undefined;
    }

    const levelsSorted
        = Object.keys(minHeightForQualityLvl)
            .map(k => Number(k))
            .sort((a, b) => a - b);
    const map = new Map();

    Object.values(VIDEO_QUALITY_LEVELS).sort()
        .forEach(value => {
            if (value > VIDEO_QUALITY_LEVELS.NONE) {
                map.set(value, value);
            }
        });

    for (const level of levelsSorted) {
        const configQuality = minHeightForQualityLvl[level];
        const appQuality = CFG_LVL_TO_APP_QUALITY_LVL[configQuality as keyof typeof CFG_LVL_TO_APP_QUALITY_LVL];

        if (!appQuality) {
            return undefined;
        }

        map.delete(appQuality);
        map.set(level, appQuality);
    }

    return map;
}


################################################################################

## File: .\jitsi-meet\react\features\video-quality\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/video-quality');


################################################################################

## File: .\jitsi-meet\react\features\video-quality\middleware.ts

import { CONFERENCE_JOINED } from '../base/conference/actionTypes';
import { SET_CONFIG } from '../base/config/actionTypes';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';

import { setPreferredVideoQuality } from './actions';
import logger from './logger';

import './subscriber';

/**
 * Implements the middleware of the feature video-quality.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(({ dispatch, getState }) => next => action => {
    const result = next(action);

    switch (action.type) {
    case CONFERENCE_JOINED: {
        if (navigator.product === 'ReactNative') {
            const { resolution } = getState()['features/base/config'];

            if (typeof resolution !== 'undefined') {
                dispatch(setPreferredVideoQuality(Number.parseInt(`${resolution}`, 10)));
                logger.info(`Configured preferred receiver video frame height to: ${resolution}`);
            }
        }
        break;
    }
    case SET_CONFIG: {
        const state = getState();
        const { videoQuality = {} } = state['features/base/config'];
        const { persistedPrefferedVideoQuality } = state['features/video-quality-persistent-storage'];

        if (videoQuality.persist && typeof persistedPrefferedVideoQuality !== 'undefined') {
            dispatch(setPreferredVideoQuality(persistedPrefferedVideoQuality));
        }

        break;
    }
    }

    return result;
});


################################################################################

## File: .\jitsi-meet\react\features\video-quality\reducer.ts

import { SET_CONFIG } from '../base/config/actionTypes';
import { IConfig } from '../base/config/configType';
import PersistenceRegistry from '../base/redux/PersistenceRegistry';
import ReducerRegistry from '../base/redux/ReducerRegistry';
import { set } from '../base/redux/functions';

import {
    SET_MAX_RECEIVER_VIDEO_QUALITY_FOR_LARGE_VIDEO,
    SET_MAX_RECEIVER_VIDEO_QUALITY_FOR_SCREEN_SHARING_FILMSTRIP,
    SET_MAX_RECEIVER_VIDEO_QUALITY_FOR_STAGE_FILMSTRIP,
    SET_MAX_RECEIVER_VIDEO_QUALITY_FOR_TILE_VIEW,
    SET_MAX_RECEIVER_VIDEO_QUALITY_FOR_VERTICAL_FILMSTRIP,
    SET_PREFERRED_VIDEO_QUALITY
} from './actionTypes';
import { VIDEO_QUALITY_LEVELS } from './constants';
import { validateMinHeightForQualityLvl } from './functions';
import logger from './logger';

const DEFAULT_STATE = {
    maxReceiverVideoQualityForLargeVideo: VIDEO_QUALITY_LEVELS.ULTRA,
    maxReceiverVideoQualityForScreenSharingFilmstrip: VIDEO_QUALITY_LEVELS.HIGH,
    maxReceiverVideoQualityForStageFilmstrip: VIDEO_QUALITY_LEVELS.HIGH,
    maxReceiverVideoQualityForTileView: VIDEO_QUALITY_LEVELS.STANDARD,
    maxReceiverVideoQualityForVerticalFilmstrip: VIDEO_QUALITY_LEVELS.LOW,
    minHeightForQualityLvl: new Map(),
    preferredVideoQuality: VIDEO_QUALITY_LEVELS.ULTRA
};


Object.values(VIDEO_QUALITY_LEVELS).sort()
    .forEach(value => {
        if (value > VIDEO_QUALITY_LEVELS.NONE) {
            DEFAULT_STATE.minHeightForQualityLvl.set(value, value);
        }
    });

export interface IVideoQualityState {
    maxReceiverVideoQualityForLargeVideo: number;
    maxReceiverVideoQualityForScreenSharingFilmstrip: number;
    maxReceiverVideoQualityForStageFilmstrip: number;
    maxReceiverVideoQualityForTileView: number;
    maxReceiverVideoQualityForVerticalFilmstrip: number;
    minHeightForQualityLvl: Map<number, number>;
    preferredVideoQuality: number;
}

export interface IVideoQualityPersistedState {
    persistedPrefferedVideoQuality?: number;
}


// When the persisted state is initialized the current state (for example the default state) is erased.
// In order to workaround this issue we need additional state for the persisted properties.
PersistenceRegistry.register('features/video-quality-persistent-storage');

ReducerRegistry.register<IVideoQualityPersistedState>('features/video-quality-persistent-storage',
(state = {}, action): IVideoQualityPersistedState => {
    switch (action.type) {
    case SET_PREFERRED_VIDEO_QUALITY: {
        const { preferredVideoQuality } = action;

        return {
            ...state,
            persistedPrefferedVideoQuality: preferredVideoQuality
        };
    }
    }

    return state;
});

ReducerRegistry.register<IVideoQualityState>('features/video-quality',
(state = DEFAULT_STATE, action): IVideoQualityState => {
    switch (action.type) {
    case SET_CONFIG:
        return _setConfig(state, action);
    case SET_MAX_RECEIVER_VIDEO_QUALITY_FOR_LARGE_VIDEO:
        return set(state,
            'maxReceiverVideoQualityForLargeVideo',
            action.maxReceiverVideoQuality);
    case SET_MAX_RECEIVER_VIDEO_QUALITY_FOR_SCREEN_SHARING_FILMSTRIP:
        return set(state,
            'maxReceiverVideoQualityForScreenSharingFilmstrip',
            action.maxReceiverVideoQuality);
    case SET_MAX_RECEIVER_VIDEO_QUALITY_FOR_STAGE_FILMSTRIP:
        return set(
            state,
            'maxReceiverVideoQualityForStageFilmstrip',
            action.maxReceiverVideoQuality);
    case SET_MAX_RECEIVER_VIDEO_QUALITY_FOR_TILE_VIEW:
        return set(
            state,
            'maxReceiverVideoQualityForTileView',
            action.maxReceiverVideoQuality);
    case SET_MAX_RECEIVER_VIDEO_QUALITY_FOR_VERTICAL_FILMSTRIP:
        return set(
            state,
            'maxReceiverVideoQualityForVerticalFilmstrip',
            action.maxReceiverVideoQuality);
    case SET_PREFERRED_VIDEO_QUALITY: {
        const { preferredVideoQuality } = action;

        return {
            ...state,
            preferredVideoQuality
        };
    }
    }

    return state;
});

/**
 * Extracts the height to quality level mapping from the new config.
 *
 * @param {Object} state - The Redux state of feature base/lastn.
 * @param {Action} action - The Redux action SET_CONFIG to reduce.
 * @private
 * @returns {Object} The new state after the reduction of the specified action.
 */
function _setConfig(state: IVideoQualityState, { config }: { config: IConfig; }) {
    const configuredMap = config?.videoQuality?.minHeightForQualityLvl;
    const convertedMap = validateMinHeightForQualityLvl(configuredMap);

    if (configuredMap && !convertedMap) {
        logger.error('Invalid config value videoQuality.minHeightForQualityLvl');
    }

    return convertedMap ? set(state, 'minHeightForQualityLvl', convertedMap) : state;
}


################################################################################

## File: .\jitsi-meet\react\features\video-quality\selector.ts

import { IReduxState } from '../app/types';

/**
 * Selects the thumbnail height to the quality level mapping from the config.
 *
 * @param {Object} state - The redux state.
 * @returns {Map<number,number>}
 */
export function getMinHeightForQualityLvlMap(state: IReduxState): Map<number, number> {
    return state['features/video-quality'].minHeightForQualityLvl;
}


################################################################################

## File: .\jitsi-meet\react\features\video-quality\subscriber.ts

import { debounce } from 'lodash-es';

import { IReduxState, IStore } from '../app/types';
import { _handleParticipantError } from '../base/conference/functions';
import { getSsrcRewritingFeatureFlag } from '../base/config/functions.any';
import { MEDIA_TYPE, VIDEO_TYPE } from '../base/media/constants';
import {
    getLocalParticipant,
    getSourceNamesByMediaTypeAndParticipant,
    getSourceNamesByVideoTypeAndParticipant
} from '../base/participants/functions';
import StateListenerRegistry from '../base/redux/StateListenerRegistry';
import { getTrackSourceNameByMediaTypeAndParticipant } from '../base/tracks/functions';
import { reportError } from '../base/util/helpers';
import {
    getActiveParticipantsIds,
    getScreenshareFilmstripParticipantId,
    isTopPanelEnabled
} from '../filmstrip/functions';
import { LAYOUTS } from '../video-layout/constants';
import {
    getCurrentLayout,
    getVideoQualityForLargeVideo,
    getVideoQualityForResizableFilmstripThumbnails,
    getVideoQualityForScreenSharingFilmstrip,
    getVideoQualityForStageThumbnails,
    shouldDisplayTileView
} from '../video-layout/functions';

import {
    setMaxReceiverVideoQualityForLargeVideo,
    setMaxReceiverVideoQualityForScreenSharingFilmstrip,
    setMaxReceiverVideoQualityForStageFilmstrip,
    setMaxReceiverVideoQualityForTileView,
    setMaxReceiverVideoQualityForVerticalFilmstrip
} from './actions';
import { MAX_VIDEO_QUALITY, VIDEO_QUALITY_LEVELS, VIDEO_QUALITY_UNLIMITED } from './constants';
import { getReceiverVideoQualityLevel } from './functions';
import logger from './logger';
import { getMinHeightForQualityLvlMap } from './selector';

/**
 * Handles changes in the visible participants in the filmstrip. The listener is debounced
 * so that the client doesn't end up sending too many bridge messages when the user is
 * scrolling through the thumbnails prompting updates to the selected endpoints.
 */
StateListenerRegistry.register(
    /* selector */ state => state['features/filmstrip'].visibleRemoteParticipants,
    /* listener */ debounce((visibleRemoteParticipants, store) => {
        _updateReceiverVideoConstraints(store);
    }, 100));

StateListenerRegistry.register(
    /* selector */ state => state['features/base/tracks'],
    /* listener */(remoteTracks, store) => {
        _updateReceiverVideoConstraints(store);
    });

/**
 * Handles the use case when the on-stage participant has changed.
 */
StateListenerRegistry.register(
    state => state['features/large-video'].participantId,
    (participantId, store) => {
        _updateReceiverVideoConstraints(store);
    }
);

/**
 * Handles the use case when we have set some of the constraints in redux but the conference object wasn't available
 * and we haven't been able to pass the constraints to lib-jitsi-meet.
 */
StateListenerRegistry.register(
    state => state['features/base/conference'].conference,
    (conference, store) => {
        _updateReceiverVideoConstraints(store);
    }
);

/**
 * StateListenerRegistry provides a reliable way of detecting changes to
 * lastn state and dispatching additional actions.
 */
StateListenerRegistry.register(
    /* selector */ state => state['features/base/lastn'].lastN,
    /* listener */ (lastN, store) => {
        _updateReceiverVideoConstraints(store);
    });

/**
 * Updates the receiver constraints when the stage participants change.
 */
StateListenerRegistry.register(
    state => getActiveParticipantsIds(state).sort(),
    (_, store) => {
        _updateReceiverVideoConstraints(store);
    }, {
        deepEquals: true
    }
);

/**
 * Updates the receiver constraints when new video sources are added to the conference.
 */
StateListenerRegistry.register(
    /* selector */ state => state['features/base/participants'].remoteVideoSources,
    /* listener */ (remoteVideoSources, store) => {
        getSsrcRewritingFeatureFlag(store.getState()) && _updateReceiverVideoConstraints(store);
    });

/**
 * StateListenerRegistry provides a reliable way of detecting changes to
 * maxReceiverVideoQuality* and preferredVideoQuality state and dispatching additional actions.
 */
StateListenerRegistry.register(
    /* selector */ state => {
        const {
            maxReceiverVideoQualityForLargeVideo,
            maxReceiverVideoQualityForScreenSharingFilmstrip,
            maxReceiverVideoQualityForStageFilmstrip,
            maxReceiverVideoQualityForTileView,
            maxReceiverVideoQualityForVerticalFilmstrip,
            preferredVideoQuality
        } = state['features/video-quality'];

        return {
            maxReceiverVideoQualityForLargeVideo,
            maxReceiverVideoQualityForScreenSharingFilmstrip,
            maxReceiverVideoQualityForStageFilmstrip,
            maxReceiverVideoQualityForTileView,
            maxReceiverVideoQualityForVerticalFilmstrip,
            preferredVideoQuality
        };
    },
    /* listener */ (currentState, store, previousState = {}) => {
        const { preferredVideoQuality } = currentState;
        const changedPreferredVideoQuality = preferredVideoQuality !== previousState.preferredVideoQuality;

        if (changedPreferredVideoQuality) {
            _setSenderVideoConstraint(preferredVideoQuality, store);
            typeof APP !== 'undefined' && APP.API.notifyVideoQualityChanged(preferredVideoQuality);
        }
        _updateReceiverVideoConstraints(store);
    }, {
        deepEquals: true
    });

/**
 * Implements a state listener in order to calculate max receiver video quality.
 */
StateListenerRegistry.register(
    /* selector */ state => {
        const { reducedUI } = state['features/base/responsive-ui'];
        const _shouldDisplayTileView = shouldDisplayTileView(state);
        const tileViewThumbnailSize = state['features/filmstrip']?.tileViewDimensions?.thumbnailSize;
        const { visibleRemoteParticipants } = state['features/filmstrip'];
        const { height: largeVideoHeight } = state['features/large-video'];
        const activeParticipantsIds = getActiveParticipantsIds(state);
        const {
            screenshareFilmstripDimensions: {
                thumbnailSize
            }
        } = state['features/filmstrip'];
        const screenshareFilmstripParticipantId = getScreenshareFilmstripParticipantId(state);

        return {
            activeParticipantsCount: activeParticipantsIds?.length,
            displayTileView: _shouldDisplayTileView,
            largeVideoHeight,
            participantCount: visibleRemoteParticipants?.size || 0,
            reducedUI,
            screenSharingFilmstripHeight:
                screenshareFilmstripParticipantId && getCurrentLayout(state) === LAYOUTS.STAGE_FILMSTRIP_VIEW
                    ? thumbnailSize?.height : undefined,
            stageFilmstripThumbnailHeight: state['features/filmstrip'].stageFilmstripDimensions?.thumbnailSize?.height,
            tileViewThumbnailHeight: tileViewThumbnailSize?.height,
            verticalFilmstripThumbnailHeight:
                state['features/filmstrip'].verticalViewDimensions?.gridView?.thumbnailSize?.height
        };
    },
    /* listener */ ({
        activeParticipantsCount,
        displayTileView,
        largeVideoHeight,
        participantCount,
        reducedUI,
        screenSharingFilmstripHeight,
        stageFilmstripThumbnailHeight,
        tileViewThumbnailHeight,
        verticalFilmstripThumbnailHeight
    }, store, previousState = {}) => {
        const { dispatch, getState } = store;
        const state = getState();
        const {
            maxReceiverVideoQualityForLargeVideo,
            maxReceiverVideoQualityForScreenSharingFilmstrip,
            maxReceiverVideoQualityForStageFilmstrip,
            maxReceiverVideoQualityForTileView,
            maxReceiverVideoQualityForVerticalFilmstrip
        } = state['features/video-quality'];
        const { maxFullResolutionParticipants = 2 } = state['features/base/config'];
        let maxVideoQualityChanged = false;


        if (displayTileView) {
            let newMaxRecvVideoQuality = VIDEO_QUALITY_LEVELS.STANDARD;

            if (reducedUI) {
                newMaxRecvVideoQuality = VIDEO_QUALITY_LEVELS.LOW;
            } else if (typeof tileViewThumbnailHeight === 'number' && !Number.isNaN(tileViewThumbnailHeight)) {
                newMaxRecvVideoQuality
                    = getReceiverVideoQualityLevel(tileViewThumbnailHeight, getMinHeightForQualityLvlMap(state));

                // Override HD level calculated for the thumbnail height when # of participants threshold is exceeded
                if (maxFullResolutionParticipants !== -1) {
                    const override
                        = participantCount > maxFullResolutionParticipants
                            && newMaxRecvVideoQuality > VIDEO_QUALITY_LEVELS.STANDARD;

                    logger.info(`Video quality level for thumbnail height: ${tileViewThumbnailHeight}, `
                        + `is: ${newMaxRecvVideoQuality}, `
                        + `override: ${String(override)}, `
                        + `max full res N: ${maxFullResolutionParticipants}`);

                    if (override) {
                        newMaxRecvVideoQuality = VIDEO_QUALITY_LEVELS.STANDARD;
                    }
                }
            }

            if (maxReceiverVideoQualityForTileView !== newMaxRecvVideoQuality) {
                maxVideoQualityChanged = true;
                dispatch(setMaxReceiverVideoQualityForTileView(newMaxRecvVideoQuality));
            }
        } else {
            let newMaxRecvVideoQualityForStageFilmstrip;
            let newMaxRecvVideoQualityForVerticalFilmstrip;
            let newMaxRecvVideoQualityForLargeVideo;
            let newMaxRecvVideoQualityForScreenSharingFilmstrip;

            if (reducedUI) {
                newMaxRecvVideoQualityForVerticalFilmstrip
                    = newMaxRecvVideoQualityForStageFilmstrip
                    = newMaxRecvVideoQualityForLargeVideo
                    = newMaxRecvVideoQualityForScreenSharingFilmstrip
                    = VIDEO_QUALITY_LEVELS.LOW;
            } else {
                newMaxRecvVideoQualityForStageFilmstrip
                    = getVideoQualityForStageThumbnails(stageFilmstripThumbnailHeight, state);
                newMaxRecvVideoQualityForVerticalFilmstrip
                    = getVideoQualityForResizableFilmstripThumbnails(verticalFilmstripThumbnailHeight, state);
                newMaxRecvVideoQualityForLargeVideo = getVideoQualityForLargeVideo(largeVideoHeight);
                newMaxRecvVideoQualityForScreenSharingFilmstrip
                    = getVideoQualityForScreenSharingFilmstrip(screenSharingFilmstripHeight, state);

                // Override HD level calculated for the thumbnail height when # of participants threshold is exceeded
                if (maxFullResolutionParticipants !== -1) {
                    if (activeParticipantsCount > 0
                        && newMaxRecvVideoQualityForStageFilmstrip > VIDEO_QUALITY_LEVELS.STANDARD) {
                        const isScreenSharingFilmstripParticipantFullResolution
                            = newMaxRecvVideoQualityForScreenSharingFilmstrip > VIDEO_QUALITY_LEVELS.STANDARD;

                        if (activeParticipantsCount > maxFullResolutionParticipants
                            - (isScreenSharingFilmstripParticipantFullResolution ? 1 : 0)) {
                            newMaxRecvVideoQualityForStageFilmstrip = VIDEO_QUALITY_LEVELS.STANDARD;
                            newMaxRecvVideoQualityForVerticalFilmstrip
                                = Math.min(VIDEO_QUALITY_LEVELS.STANDARD, newMaxRecvVideoQualityForVerticalFilmstrip);
                        } else if (newMaxRecvVideoQualityForVerticalFilmstrip > VIDEO_QUALITY_LEVELS.STANDARD
                                && participantCount > maxFullResolutionParticipants - activeParticipantsCount) {
                            newMaxRecvVideoQualityForVerticalFilmstrip = VIDEO_QUALITY_LEVELS.STANDARD;
                        }
                    } else if (newMaxRecvVideoQualityForVerticalFilmstrip > VIDEO_QUALITY_LEVELS.STANDARD
                            && participantCount > maxFullResolutionParticipants
                                - (newMaxRecvVideoQualityForLargeVideo > VIDEO_QUALITY_LEVELS.STANDARD ? 1 : 0)) {
                        newMaxRecvVideoQualityForVerticalFilmstrip = VIDEO_QUALITY_LEVELS.STANDARD;
                    }
                }
            }

            if (maxReceiverVideoQualityForStageFilmstrip !== newMaxRecvVideoQualityForStageFilmstrip) {
                maxVideoQualityChanged = true;
                dispatch(setMaxReceiverVideoQualityForStageFilmstrip(newMaxRecvVideoQualityForStageFilmstrip));
            }

            if (maxReceiverVideoQualityForVerticalFilmstrip !== newMaxRecvVideoQualityForVerticalFilmstrip) {
                maxVideoQualityChanged = true;
                dispatch(setMaxReceiverVideoQualityForVerticalFilmstrip(newMaxRecvVideoQualityForVerticalFilmstrip));
            }

            if (maxReceiverVideoQualityForLargeVideo !== newMaxRecvVideoQualityForLargeVideo) {
                maxVideoQualityChanged = true;
                dispatch(setMaxReceiverVideoQualityForLargeVideo(newMaxRecvVideoQualityForLargeVideo));
            }

            if (maxReceiverVideoQualityForScreenSharingFilmstrip !== newMaxRecvVideoQualityForScreenSharingFilmstrip) {
                maxVideoQualityChanged = true;
                dispatch(
                    setMaxReceiverVideoQualityForScreenSharingFilmstrip(
                        newMaxRecvVideoQualityForScreenSharingFilmstrip));
            }
        }

        if (!maxVideoQualityChanged && Boolean(displayTileView) !== Boolean(previousState.displayTileView)) {
            _updateReceiverVideoConstraints(store);
        }

    }, {
        deepEquals: true
    });

/**
 * Returns the source names asociated with the given participants list.
 *
 * @param {Array<string>} participantList - The list of participants.
 * @param {Object} state - The redux state.
 * @returns {Array<string>}
 */
function _getSourceNames(participantList: Array<string>, state: IReduxState): Array<string> {
    const { remoteScreenShares } = state['features/video-layout'];
    const tracks = state['features/base/tracks'];
    const sourceNamesList: string[] = [];

    participantList.forEach(participantId => {
        if (getSsrcRewritingFeatureFlag(state)) {
            const sourceNames: string[]
                = getSourceNamesByMediaTypeAndParticipant(state, participantId, MEDIA_TYPE.VIDEO);

            sourceNames.length && sourceNamesList.push(...sourceNames);
        } else {
            let sourceName: string;

            if (remoteScreenShares.includes(participantId)) {
                sourceName = participantId;
            } else {
                sourceName = getTrackSourceNameByMediaTypeAndParticipant(tracks, MEDIA_TYPE.VIDEO, participantId);
            }

            if (sourceName) {
                sourceNamesList.push(sourceName);
            }
        }
    });

    return sourceNamesList;
}

/**
 * Helper function for updating the preferred sender video constraint, based on the user preference.
 *
 * @param {number} preferred - The user preferred max frame height.
 * @returns {void}
 */
function _setSenderVideoConstraint(preferred: number, { getState }: IStore) {
    const state = getState();
    const { conference } = state['features/base/conference'];

    if (!conference) {
        return;
    }

    logger.info(`Setting sender resolution to ${preferred}`);
    conference.setSenderVideoConstraint(preferred)
        .catch((error: any) => {
            _handleParticipantError(error);
            reportError(error, `Changing sender resolution to ${preferred} failed.`);
        });
}

/**
 * Private helper to calculate the receiver video constraints and set them on the bridge channel.
 *
 * @param {*} store - The redux store.
 * @returns {void}
 */
function _updateReceiverVideoConstraints({ getState }: IStore) {
    const state = getState();
    const { conference } = state['features/base/conference'];

    if (!conference) {
        return;
    }
    const { lastN } = state['features/base/lastn'];
    const {
        maxReceiverVideoQualityForTileView,
        maxReceiverVideoQualityForStageFilmstrip,
        maxReceiverVideoQualityForVerticalFilmstrip,
        maxReceiverVideoQualityForLargeVideo,
        maxReceiverVideoQualityForScreenSharingFilmstrip,
        preferredVideoQuality
    } = state['features/video-quality'];
    const { participantId: largeVideoParticipantId = '' } = state['features/large-video'];
    const maxFrameHeightForTileView = Math.min(maxReceiverVideoQualityForTileView, preferredVideoQuality);
    const maxFrameHeightForStageFilmstrip = Math.min(maxReceiverVideoQualityForStageFilmstrip, preferredVideoQuality);
    const maxFrameHeightForVerticalFilmstrip
        = Math.min(maxReceiverVideoQualityForVerticalFilmstrip, preferredVideoQuality);
    const maxFrameHeightForLargeVideo
        = Math.min(maxReceiverVideoQualityForLargeVideo, preferredVideoQuality);
    const maxFrameHeightForScreenSharingFilmstrip
        = Math.min(maxReceiverVideoQualityForScreenSharingFilmstrip, preferredVideoQuality);
    const { remoteScreenShares } = state['features/video-layout'];
    const { visibleRemoteParticipants } = state['features/filmstrip'];
    const tracks = state['features/base/tracks'];
    const localParticipantId = getLocalParticipant(state)?.id;
    const activeParticipantsIds = getActiveParticipantsIds(state);
    const screenshareFilmstripParticipantId = isTopPanelEnabled(state) && getScreenshareFilmstripParticipantId(state);

    const receiverConstraints: any = {
        constraints: {},
        defaultConstraints: { 'maxHeight': VIDEO_QUALITY_LEVELS.NONE },
        lastN
    };

    let activeParticipantsSources: string[] = [];
    let visibleRemoteTrackSourceNames: string[] = [];
    let largeVideoSourceName: string | undefined;

    receiverConstraints.onStageSources = [];
    receiverConstraints.selectedSources = [];

    if (visibleRemoteParticipants?.size) {
        visibleRemoteTrackSourceNames = _getSourceNames(Array.from(visibleRemoteParticipants), state);
    }

    if (activeParticipantsIds?.length > 0) {
        activeParticipantsSources = _getSourceNames(activeParticipantsIds, state);
    }

    if (localParticipantId !== largeVideoParticipantId) {
        if (remoteScreenShares.includes(largeVideoParticipantId)) {
            largeVideoSourceName = largeVideoParticipantId;
        } else {
            largeVideoSourceName = getSsrcRewritingFeatureFlag(state)
                ? getSourceNamesByVideoTypeAndParticipant(state, largeVideoParticipantId, VIDEO_TYPE.CAMERA)[0]
                : getTrackSourceNameByMediaTypeAndParticipant(tracks, MEDIA_TYPE.VIDEO, largeVideoParticipantId);
        }
    }

    // Tile view.
    if (shouldDisplayTileView(state)) {
        if (!visibleRemoteTrackSourceNames?.length) {
            return;
        }

        visibleRemoteTrackSourceNames.forEach(sourceName => {
            receiverConstraints.constraints[sourceName] = { 'maxHeight': maxFrameHeightForTileView };
        });

        // Prioritize screenshare in tile view.
        if (remoteScreenShares?.length) {
            receiverConstraints.selectedSources = remoteScreenShares;
        }

    // Stage view.
    } else {
        if (!visibleRemoteTrackSourceNames?.length && !largeVideoSourceName && !activeParticipantsSources?.length) {
            return;
        }

        if (visibleRemoteTrackSourceNames?.length) {
            visibleRemoteTrackSourceNames.forEach(sourceName => {
                receiverConstraints.constraints[sourceName] = { 'maxHeight': maxFrameHeightForVerticalFilmstrip };
            });
        }

        if (getCurrentLayout(state) === LAYOUTS.STAGE_FILMSTRIP_VIEW && activeParticipantsSources.length > 0) {
            const selectedSources: string[] = [];
            const onStageSources: string[] = [];

            // If more than one video source is pinned to the stage filmstrip, they need to be added to the
            // 'selectedSources' so that the bridge can allocate bandwidth for all the sources as opposed to doing
            // greedy allocation for the sources (which happens when they are added to 'onStageSources').
            if (activeParticipantsSources.length > 1) {
                selectedSources.push(...activeParticipantsSources);
            } else {
                onStageSources.push(activeParticipantsSources[0]);
            }

            activeParticipantsSources.forEach(sourceName => {
                const isScreenSharing = remoteScreenShares.includes(sourceName);
                const quality
                    = isScreenSharing && preferredVideoQuality >= MAX_VIDEO_QUALITY
                        ? VIDEO_QUALITY_UNLIMITED : maxFrameHeightForStageFilmstrip;

                receiverConstraints.constraints[sourceName] = { 'maxHeight': quality };
            });

            if (screenshareFilmstripParticipantId) {
                onStageSources.push(screenshareFilmstripParticipantId);
                receiverConstraints.constraints[screenshareFilmstripParticipantId]
                    = {
                        'maxHeight':
                            preferredVideoQuality >= MAX_VIDEO_QUALITY
                                ? VIDEO_QUALITY_UNLIMITED : maxFrameHeightForScreenSharingFilmstrip
                    };
            }

            receiverConstraints.onStageSources = onStageSources;
            receiverConstraints.selectedSources = selectedSources;
        } else if (largeVideoSourceName) {
            let quality = VIDEO_QUALITY_UNLIMITED;

            if (preferredVideoQuality < MAX_VIDEO_QUALITY
                || !remoteScreenShares.find(id => id === largeVideoParticipantId)) {
                quality = maxFrameHeightForLargeVideo;
            }
            receiverConstraints.constraints[largeVideoSourceName] = { 'maxHeight': quality };
            receiverConstraints.onStageSources = [ largeVideoSourceName ];
        }
    }

    try {
        conference.setReceiverConstraints(receiverConstraints);
    } catch (error: any) {
        _handleParticipantError(error);
        reportError(error, `Failed to set receiver video constraints ${JSON.stringify(receiverConstraints)}`);
    }
}


################################################################################

## File: .\jitsi-meet\react\features\video-quality\components\styles.ts

import { ColorPalette } from '../../base/styles/components/styles/ColorPalette';
import { createStyleSheet } from '../../base/styles/functions.any';
import BaseTheme from '../../base/ui/components/BaseTheme.native';

export const AUD_LABEL_COLOR = ColorPalette.green;

/**
 * The styles of the React {@code Components} of the feature video-quality.
 */
export default createStyleSheet({

    /**
     * Style for the audio-only indicator.
     */
    indicatorAudioOnly: {
        backgroundColor: AUD_LABEL_COLOR,
        borderRadius: BaseTheme.shape.borderRadius,
        height: 32
    }
});


################################################################################

## File: .\jitsi-meet\react\features\video-quality\components\VideoQualityButton.native.ts



################################################################################

## File: .\jitsi-meet\react\features\video-quality\components\VideoQualityButton.web.ts

import { connect } from 'react-redux';

import { createToolbarEvent } from '../../analytics/AnalyticsEvents';
import { sendAnalytics } from '../../analytics/functions';
import { openDialog } from '../../base/dialog/actions';
import { translate } from '../../base/i18n/functions';
import { IconPerformance } from '../../base/icons/svg';
import AbstractButton, { IProps as AbstractButtonProps } from '../../base/toolbox/components/AbstractButton';

import VideoQualityDialog from './VideoQualityDialog.web';

/**
 * The type of the React {@code Component} props of
 * {@link VideoQualityButton}.
 */
interface IProps extends AbstractButtonProps {

    /**
     * Whether or not audio only mode is currently enabled.
     */
    _audioOnly: boolean;

    /**
     * The currently configured maximum quality resolution to be received from
     * and sent to remote participants.
     */
    _videoQuality: number;
}

/**
 * React {@code Component} responsible for displaying a button in the overflow
 * menu of the toolbar, including an icon showing the currently selected
 * max receive quality.
 *
 * @augments Component
 */
class VideoQualityButton extends AbstractButton<IProps> {
    accessibilityLabel = 'toolbar.accessibilityLabel.callQuality';
    label = 'videoStatus.performanceSettings';
    tooltip = 'videoStatus.performanceSettings';
    icon = IconPerformance;

    /**
    * Handles clicking the button, and opens the video quality dialog.
    *
    * @private
    * @returns {void}
    */
    _handleClick() {
        const { dispatch } = this.props;

        sendAnalytics(createToolbarEvent('video.quality'));

        dispatch(openDialog(VideoQualityDialog));
    }
}

export default connect()(translate(VideoQualityButton));


################################################################################

## File: .\jitsi-meet\react\features\video-quality\components\VideoQualityDialog.native.ts



################################################################################

## File: .\jitsi-meet\react\features\video-quality\components\VideoQualityExpandedLabel.native.ts

import { WithTranslation } from 'react-i18next';

import { translate } from '../../base/i18n/functions';
import ExpandedLabel, { IProps as AbstractProps } from '../../base/label/components/native/ExpandedLabel';

import { AUD_LABEL_COLOR } from './styles';

type Props = AbstractProps & WithTranslation;

/**
 * A react {@code Component} that implements an expanded label as tooltip-like
 * component to explain the meaning of the {@code VideoQualityLabel}.
 */
class VideoQualityExpandedLabel extends ExpandedLabel<Props> {
    /**
     * Returns the color this expanded label should be rendered with.
     *
     * @returns {string}
     */
    _getColor() {
        return AUD_LABEL_COLOR;
    }

    /**
     * Returns the label specific text of this {@code ExpandedLabel}.
     *
     * @returns {string}
     */
    _getLabel() {
        return this.props.t('videoStatus.audioOnlyExpanded');
    }
}

export default translate(VideoQualityExpandedLabel);


################################################################################

## File: .\jitsi-meet\react\features\video-quality\components\VideoQualityExpandedLabel.web.ts



################################################################################

## File: .\jitsi-meet\react\features\video-quality\components\VideoQualitySlider.native.ts



################################################################################

## File: .\jitsi-meet\react\features\videosipgw\actions.ts

import { SIP_GW_INVITE_ROOMS } from './actionTypes';

/**
 * Invites room participants to the conference through the SIP Jibri service.
 *
 * @param {JitsiMeetConference} conference - The conference to which the rooms
 * will be invited to.
 * @param {Immutable.List} rooms - The list of the "videosipgw" type items to
 * invite.
 * @returns {void}
 */
export function inviteVideoRooms(
        conference: Object,
        rooms: Object) {
    return {
        type: SIP_GW_INVITE_ROOMS,
        conference,
        rooms
    };
}


################################################################################

## File: .\jitsi-meet\react\features\videosipgw\actionTypes.ts

/**
 * The type of (redux) action which signals that sip GW service change its
 * availability status.
 *
 * {
 *     type: SIP_GW_AVAILABILITY_CHANGED,
 *     status: string
 * }
 */
export const SIP_GW_AVAILABILITY_CHANGED
    = 'SIP_GW_AVAILABILITY_CHANGED';

/**
 * The type of the action which signals to invite room participants to the
 * conference through the SIP Jibri service.
 *
 * {
 *     type: SIP_GW_INVITE_ROOMS,
 *     conference: JitsiConference,
 *     rooms: {Immutable.List}
 * }
 */
export const SIP_GW_INVITE_ROOMS = 'SIP_GW_INVITE_ROOMS';


################################################################################

## File: .\jitsi-meet\react\features\videosipgw\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/videosipgw');


################################################################################

## File: .\jitsi-meet\react\features\videosipgw\middleware.ts

import { IStore } from '../app/types';
import { CONFERENCE_JOIN_IN_PROGRESS } from '../base/conference/actionTypes';
import { IJitsiConference } from '../base/conference/reducer';
import {
    JitsiConferenceEvents,
    JitsiSIPVideoGWStatus
} from '../base/lib-jitsi-meet';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import {
    showErrorNotification,
    showNotification,
    showWarningNotification
} from '../notifications/actions';
import { NOTIFICATION_TIMEOUT_TYPE } from '../notifications/constants';

import {
    SIP_GW_AVAILABILITY_CHANGED,
    SIP_GW_INVITE_ROOMS
} from './actionTypes';
import logger from './logger';
import { ISipRoom, ISipSessionChangedEvent } from './types';

/**
 * Middleware that captures conference video sip gw events and stores
 * the global sip gw availability in redux or show appropriate notification
 * for sip gw sessions.
 * Captures invitation actions that create sip gw sessions or display
 * appropriate error/warning notifications.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register(({ dispatch }) => next => action => {
    const result = next(action);

    switch (action.type) {
    case CONFERENCE_JOIN_IN_PROGRESS: {
        const { conference } = action;

        conference.on(
            JitsiConferenceEvents.VIDEO_SIP_GW_AVAILABILITY_CHANGED,
            (status: string) => dispatch(_availabilityChanged(status)));
        conference.on(
            JitsiConferenceEvents.VIDEO_SIP_GW_SESSION_STATE_CHANGED,
            (event: ISipSessionChangedEvent) => {
                const toDispatch = _sessionStateChanged(event);

                // sessionStateChanged can decide there is nothing to dispatch
                if (toDispatch) {
                    dispatch(toDispatch);
                }
            });

        break;
    }
    case SIP_GW_INVITE_ROOMS:
        _inviteRooms(action.rooms, action.conference, dispatch);
        break;
    }

    return result;
});

/**
 * Signals that sip gw availability had changed.
 *
 * @param {string} status - The new status of the service.
 * @returns {{
 *     type: SIP_GW_AVAILABILITY_CHANGED,
 *     status: string
 * }}
 * @private
 */
function _availabilityChanged(status: string) {
    return {
        type: SIP_GW_AVAILABILITY_CHANGED,
        status
    };
}

/**
 * Processes the action from the actionType {@code SIP_GW_INVITE_ROOMS} by
 * inviting rooms into the conference or showing an error message.
 *
 * @param {Array} rooms - The conference rooms to invite.
 * @param {Object} conference - The JitsiConference to invite the rooms to.
 * @param {Function} dispatch - The redux dispatch function for emitting state
 * changes (queuing error notifications).
 * @private
 * @returns {void}
 */
function _inviteRooms(rooms: ISipRoom[], conference: IJitsiConference, dispatch: IStore['dispatch']) {
    for (const room of rooms) {
        const { id: sipAddress, name: displayName } = room;

        if (sipAddress && displayName) {
            const newSession = conference
                .createVideoSIPGWSession(sipAddress, displayName);

            if (newSession instanceof Error) {
                const e = newSession;

                switch (e.message) {
                case JitsiSIPVideoGWStatus.ERROR_NO_CONNECTION: {
                    dispatch(showErrorNotification({
                        descriptionKey: 'videoSIPGW.errorInvite',
                        titleKey: 'videoSIPGW.errorInviteTitle'
                    }, NOTIFICATION_TIMEOUT_TYPE.LONG));

                    return;
                }
                case JitsiSIPVideoGWStatus.ERROR_SESSION_EXISTS: {
                    dispatch(showWarningNotification({
                        titleKey: 'videoSIPGW.errorAlreadyInvited',
                        titleArguments: { displayName }
                    }, NOTIFICATION_TIMEOUT_TYPE.LONG));

                    return;
                }
                }

                logger.error(
                    'Unknown error trying to create sip videogw session',
                    e);

                return;
            }

            newSession.start();
        } else {
            logger.error(`No display name or sip number for ${
                JSON.stringify(room)}`);
        }
    }
}

/**
 * Signals that a session we created has a change in its status.
 *
 * @param {string} event - The event describing the session state change.
 * @returns {Object|null} - A notification action.
 * @private
 */
function _sessionStateChanged(
        event: ISipSessionChangedEvent) {
    switch (event.newState) {
    case JitsiSIPVideoGWStatus.STATE_PENDING: {
        return showNotification({
            titleKey: 'videoSIPGW.pending',
            titleArguments: {
                displayName: event.displayName
            }
        }, NOTIFICATION_TIMEOUT_TYPE.SHORT);
    }
    case JitsiSIPVideoGWStatus.STATE_FAILED: {
        return showErrorNotification({
            titleKey: 'videoSIPGW.errorInviteFailedTitle',
            titleArguments: {
                displayName: event.displayName
            },
            descriptionKey: 'videoSIPGW.errorInviteFailed'
        }, NOTIFICATION_TIMEOUT_TYPE.LONG);
    }
    case JitsiSIPVideoGWStatus.STATE_OFF: {
        if (event.failureReason === JitsiSIPVideoGWStatus.STATUS_BUSY) {
            return showErrorNotification({
                descriptionKey: 'videoSIPGW.busy',
                titleKey: 'videoSIPGW.busyTitle'
            }, NOTIFICATION_TIMEOUT_TYPE.LONG);
        } else if (event.failureReason) {
            logger.error(`Unknown sip videogw error ${event.newState} ${
                event.failureReason}`);
        }
    }
    }

    // nothing to show
    return null;
}


################################################################################

## File: .\jitsi-meet\react\features\videosipgw\reducer.ts

import ReducerRegistry from '../base/redux/ReducerRegistry';

import { SIP_GW_AVAILABILITY_CHANGED } from './actionTypes';

export interface IVideoSipGW {
    status?: string;
}

ReducerRegistry.register<IVideoSipGW>(
    'features/videosipgw', (state = {}, action): IVideoSipGW => {
        switch (action.type) {
        case SIP_GW_AVAILABILITY_CHANGED: {
            return {
                ...state,
                status: action.status
            };
        }
        }

        return state;
    });


################################################################################

## File: .\jitsi-meet\react\features\videosipgw\types.ts

export interface ISipRoom {
    id: string;
    name: string;
}

export interface ISipSessionChangedEvent {
    displayName: string;
    failureReason: string;
    newState: string;
}


################################################################################

## File: .\jitsi-meet\react\features\virtual-background\actions.ts

import { IStore } from '../app/types';
import { createVirtualBackgroundEffect } from '../stream-effects/virtual-background';

import { BACKGROUND_ENABLED, SET_VIRTUAL_BACKGROUND } from './actionTypes';
import { VIRTUAL_BACKGROUND_TYPE } from './constants';
import logger from './logger';
import { IVirtualBackground } from './reducer';

/**
 * Signals the local participant activate the virtual background video or not.
 *
 * @param {Object} options - Represents the virtual background set options.
 * @param {Object} jitsiTrack - Represents the jitsi track that will have backgraund effect applied.
 * @returns {Promise}
 */
export function toggleBackgroundEffect(options: IVirtualBackground, jitsiTrack: any) {
    return async function(dispatch: IStore['dispatch'], getState: IStore['getState']) {
        dispatch(backgroundEnabled(options.backgroundEffectEnabled));
        dispatch(setVirtualBackground(options));
        const state = getState();
        const virtualBackground = state['features/virtual-background'];

        if (jitsiTrack) {
            try {
                if (options.backgroundEffectEnabled) {
                    await jitsiTrack.setEffect(await createVirtualBackgroundEffect(virtualBackground, dispatch));
                } else {
                    await jitsiTrack.setEffect(undefined);
                    dispatch(backgroundEnabled(false));
                }
            } catch (error) {
                dispatch(backgroundEnabled(false));
                logger.error('Error on apply background effect:', error);
            }
        }
    };
}

/**
 * Sets the selected virtual background image object.
 *
 * @param {Object} options - Represents the virtual background set options.
 * @returns {{
 *     type: SET_VIRTUAL_BACKGROUND,
 *     virtualSource: string,
 *     blurValue: number,
 *     type: string,
 * }}
 */
export function setVirtualBackground(options?: IVirtualBackground) {
    return {
        type: SET_VIRTUAL_BACKGROUND,
        virtualSource: options?.virtualSource,
        blurValue: options?.blurValue,
        backgroundType: options?.backgroundType,
        selectedThumbnail: options?.selectedThumbnail
    };
}

/**
 * Signals the local participant that the background effect has been enabled.
 *
 * @param {boolean} backgroundEffectEnabled - Indicate if virtual background effect is activated.
 * @returns {{
 *      type: BACKGROUND_ENABLED,
 *      backgroundEffectEnabled: boolean
 * }}
 */
export function backgroundEnabled(backgroundEffectEnabled?: boolean) {
    return {
        type: BACKGROUND_ENABLED,
        backgroundEffectEnabled
    };
}

/**
 * Simulates blurred background selection/removal on video background. Used by API only.
 *
 * @param {JitsiLocalTrack} videoTrack - The targeted video track.
 * @param {string} [blurType] - Blur type to apply. Accepted values are 'slight-blur', 'blur' or 'none'.
 * @param {boolean} muted - Muted state of the video track.
 * @returns {Promise}
 */
export function toggleBlurredBackgroundEffect(videoTrack: any, blurType: 'slight-blur' | 'blur' | 'none',
        muted: boolean) {
    return async function(dispatch: IStore['dispatch'], _getState: IStore['getState']) {
        if (muted || !videoTrack || !blurType) {
            return;
        }

        if (blurType === 'none') {
            dispatch(toggleBackgroundEffect({
                backgroundEffectEnabled: false,
                selectedThumbnail: blurType
            }, videoTrack));
        } else {
            dispatch(toggleBackgroundEffect({
                backgroundEffectEnabled: true,
                backgroundType: VIRTUAL_BACKGROUND_TYPE.BLUR,
                blurValue: blurType === 'blur' ? 25 : 8,
                selectedThumbnail: blurType
            }, videoTrack));
        }
    };
}


################################################################################

## File: .\jitsi-meet\react\features\virtual-background\actionTypes.ts

/**
 * The type of redux action dispatched which represents that the background
 * effect is enabled or not.
 *
 * @returns {{
 *     type: BACKGROUND_ENABLED,
 *     backgroundEffectEnabled: boolean
 * }}
 */
export const BACKGROUND_ENABLED = 'BACKGROUND_ENABLED';

/**
 * The type of the action which enables or disables virtual background
 *
 * @returns {{
 *     type: SET_VIRTUAL_BACKGROUND,
 *     virtualSource: string,
 *     blurValue: number,
 *     backgroundType: string,
 *     selectedThumbnail: string
 * }}
 */
export const SET_VIRTUAL_BACKGROUND = 'SET_VIRTUAL_BACKGROUND';


################################################################################

## File: .\jitsi-meet\react\features\virtual-background\constants.ts

/**
 * An enumeration of the different virtual background types.
 *
 * @enum {string}
 */
export const VIRTUAL_BACKGROUND_TYPE = {
    IMAGE: 'image',
    BLUR: 'blur',
    NONE: 'none'
};


export type Image = {
    id: string;
    src: string;
    tooltip?: string;
};

// The limit of virtual background uploads is 24. When the number
// of uploads is 25 we trigger the deleteStoredImage function to delete
// the first/oldest uploaded background.
export const BACKGROUNDS_LIMIT = 25;


export const IMAGES: Array<Image> = [
    {
        tooltip: 'image1',
        id: '1',
        src: 'images/virtual-background/background-1.jpg'
    },
    {
        tooltip: 'image2',
        id: '2',
        src: 'images/virtual-background/background-2.jpg'
    },
    {
        tooltip: 'image3',
        id: '3',
        src: 'images/virtual-background/background-3.jpg'
    },
    {
        tooltip: 'image4',
        id: '4',
        src: 'images/virtual-background/background-4.jpg'
    },
    {
        tooltip: 'image5',
        id: '5',
        src: 'images/virtual-background/background-5.jpg'
    },
    {
        tooltip: 'image6',
        id: '6',
        src: 'images/virtual-background/background-6.jpg'
    },
    {
        tooltip: 'image7',
        id: '7',
        src: 'images/virtual-background/background-7.jpg'
    }
];


################################################################################

## File: .\jitsi-meet\react\features\virtual-background\functions.ts

import { IReduxState } from '../app/types';

let filterSupport: boolean | undefined;

/**
 * Checks context filter support.
 *
 * @returns {boolean} True if the filter is supported and false if the filter is not supported by the browser.
 */
export function checkBlurSupport() {
    if (typeof filterSupport === 'undefined') {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        filterSupport = typeof ctx?.filter !== 'undefined';

        canvas.remove();
    }

    return filterSupport;
}

/**
 * Checks if virtual background is enabled.
 *
 * @param {IReduxState} state - The state of the app.
 * @returns {boolean} True if virtual background is enabled and false if virtual background is disabled.
 */
export function checkVirtualBackgroundEnabled(state: IReduxState) {
    return state['features/base/config'].disableVirtualBackground !== true;
}

/**
 * Convert blob to base64.
 *
 * @param {Blob} blob - The link to add info with.
 * @returns {Promise<string>}
 */
export const blobToData = (blob: Blob) =>
    new Promise(resolve => {
        const reader = new FileReader();

        reader.onloadend = () => resolve(reader.result?.toString());
        reader.readAsDataURL(blob);
    });

/**
 * Convert blob to base64.
 *
 * @param {string} url - The image url.
 * @returns {Object} - Returns the converted blob to base64.
 */
export const toDataURL = async (url: string) => {
    const response = await fetch(url);
    const blob = await response.blob();
    const resData = await blobToData(blob);

    return resData;
};

/**
 * Resize image and adjust original aspect ratio.
 *
 * @param {Object} base64image - Base64 image extraction.
 * @param {number} width - Value for resizing the image width.
 * @param {number} height - Value for resizing the image height.
 * @returns {Promise<string>}
 */
export function resizeImage(base64image: any, width = 1920, height = 1080): Promise<string> {

    // In order to work on Firefox browser we need to handle the asynchronous nature of image loading;  We need to use
    // a promise mechanism. The reason why it 'works' without this mechanism in Chrome is actually 'by accident' because
    // the image happens to be in the cache and the browser is able to deliver the uncompressed/decoded image
    // before using the image in the drawImage call.
    return new Promise(resolve => {
        const img = document.createElement('img');

        img.onload = function() {
            // Create an off-screen canvas.
            const canvas = document.createElement('canvas');

            // Set its dimension to target size.
            const context = canvas.getContext('2d');

            canvas.width = width;
            canvas.height = height;

            // Draw source image into the off-screen canvas.
            // TODO: keep aspect ratio and implement object-fit: cover.
            context?.drawImage(img as any, 0, 0, width, height);

            // Encode image to data-uri with base64 version of compressed image.
            resolve(canvas.toDataURL('image/jpeg', 0.5));
        };
        img.src = base64image;
    });
}

/**
 * Creating a wrapper for promises on a specific time interval.
 *
 * @param {number} milliseconds - The number of milliseconds to wait the specified
 * {@code promise} to settle before automatically rejecting the returned
 * {@code Promise}.
 * @param {Promise} promise - The {@code Promise} for which automatic rejecting
 * after the specified timeout is to be implemented.
 * @returns {Promise}
 */
export function timeout(milliseconds: number, promise: Promise<any>): Promise<Object> {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            reject(new Error('408'));

            return;
        }, milliseconds);

        promise.then(resolve, reject);
    });
}


################################################################################

## File: .\jitsi-meet\react\features\virtual-background\hooks.ts

import { useSelector } from 'react-redux';

import { isScreenVideoShared } from '../screen-share/functions';

import VideoBackgroundButton from './components/VideoBackgroundButton';
import { checkBlurSupport, checkVirtualBackgroundEnabled } from './functions';

const virtualBackground = {
    key: 'select-background',
    Content: VideoBackgroundButton,
    group: 3
};

/**
 * A hook that returns the virtual background button if it is enabled and undefined otherwise.
 *
 *  @returns {Object | undefined}
 */
export function useVirtualBackgroundButton() {
    const _checkBlurSupport = checkBlurSupport();
    const _isScreenVideoShared = useSelector(isScreenVideoShared);
    const _checkVirtualBackgroundEnabled = useSelector(checkVirtualBackgroundEnabled);

    if (_checkBlurSupport && !_isScreenVideoShared && _checkVirtualBackgroundEnabled) {
        return virtualBackground;
    }
}


################################################################################

## File: .\jitsi-meet\react\features\virtual-background\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/virtual-background');


################################################################################

## File: .\jitsi-meet\react\features\virtual-background\reducer.ts

import PersistenceRegistry from '../base/redux/PersistenceRegistry';
import ReducerRegistry from '../base/redux/ReducerRegistry';

import { BACKGROUND_ENABLED, SET_VIRTUAL_BACKGROUND } from './actionTypes';

const STORE_NAME = 'features/virtual-background';

export interface IVirtualBackground {
    backgroundEffectEnabled?: boolean;
    backgroundType?: string;
    blurValue?: number;
    selectedThumbnail?: string;
    virtualSource?: string;
}

/**
 * Reduces redux actions which activate/deactivate virtual background image, or
 * indicate if the virtual image background is activated/deactivated. The
 * backgroundEffectEnabled flag indicate if virtual background effect is activated.
 *
 * @param {State} state - The current redux state.
 * @param {Action} action - The redux action to reduce.
 * @param {string} action.type - The type of the redux action to reduce..
 * @returns {State} The next redux state that is the result of reducing the
 * specified action.
 */
ReducerRegistry.register<IVirtualBackground>(STORE_NAME, (state = {}, action): IVirtualBackground => {
    const { virtualSource, backgroundEffectEnabled, blurValue, backgroundType, selectedThumbnail } = action;

    /**
     * Sets up the persistence of the feature {@code virtual-background}.
     */
    PersistenceRegistry.register(STORE_NAME);

    switch (action.type) {
    case SET_VIRTUAL_BACKGROUND: {
        return {
            ...state,
            virtualSource,
            blurValue,
            backgroundType,
            selectedThumbnail
        };
    }
    case BACKGROUND_ENABLED: {
        return {
            ...state,
            backgroundEffectEnabled
        };
    }
    }

    return state;
});


################################################################################

## File: .\jitsi-meet\react\features\virtual-background\components\VideoBackgroundButton.ts

import { connect } from 'react-redux';

import { IReduxState } from '../../app/types';
import { translate } from '../../base/i18n/functions';
import { IconImage } from '../../base/icons/svg';
import AbstractButton, { IProps as AbstractButtonProps } from '../../base/toolbox/components/AbstractButton';
import { isScreenVideoShared } from '../../screen-share/functions';
import { openSettingsDialog } from '../../settings/actions';
import { SETTINGS_TABS } from '../../settings/constants';
import { checkBlurSupport, checkVirtualBackgroundEnabled } from '../functions';

/**
 * The type of the React {@code Component} props of {@link VideoBackgroundButton}.
 */
interface IProps extends AbstractButtonProps {

    /**
     * True if the video background is blurred or false if it is not.
     */
    _isBackgroundEnabled: boolean;
}

/**
 * An abstract implementation of a button that toggles the video background dialog.
 */
class VideoBackgroundButton extends AbstractButton<IProps> {
    accessibilityLabel = 'toolbar.accessibilityLabel.selectBackground';
    icon = IconImage;
    label = 'toolbar.selectBackground';
    tooltip = 'toolbar.selectBackground';

    /**
     * Handles clicking / pressing the button, and toggles the virtual background dialog
     * state accordingly.
     *
     * @protected
     * @returns {void}
     */
    _handleClick() {
        const { dispatch } = this.props;

        dispatch(openSettingsDialog(SETTINGS_TABS.VIRTUAL_BACKGROUND));
    }

    /**
     * Returns {@code boolean} value indicating if the background effect is
     * enabled or not.
     *
     * @protected
     * @returns {boolean}
     */
    _isToggled() {
        return this.props._isBackgroundEnabled;
    }
}

/**
 * Maps (parts of) the redux state to the associated props for the
 * {@code VideoBackgroundButton} component.
 *
 * @param {Object} state - The Redux state.
 * @private
 * @returns {{
 *     _isBackgroundEnabled: boolean
 * }}
 */
function _mapStateToProps(state: IReduxState) {

    return {
        _isBackgroundEnabled: Boolean(state['features/virtual-background'].backgroundEffectEnabled),
        visible: checkBlurSupport()
        && !isScreenVideoShared(state)
        && checkVirtualBackgroundEnabled(state)
    };
}

export default translate(connect(_mapStateToProps)(VideoBackgroundButton));


################################################################################

## File: .\jitsi-meet\react\features\visitors\actions.ts

import { createRemoteVideoMenuButtonEvent } from '../analytics/AnalyticsEvents';
import { sendAnalytics } from '../analytics/functions';
import { IStore } from '../app/types';
import { getCurrentConference } from '../base/conference/functions';
import { connect, disconnect, setPreferVisitor } from '../base/connection/actions';
import { getLocalParticipant } from '../base/participants/functions';

import {
    CLEAR_VISITOR_PROMOTION_REQUEST,
    I_AM_VISITOR_MODE,
    SET_IN_VISITORS_QUEUE,
    SET_VISITORS_SUPPORTED,
    SET_VISITOR_DEMOTE_ACTOR,
    UPDATE_VISITORS_COUNT,
    UPDATE_VISITORS_IN_QUEUE_COUNT,
    VISITOR_PROMOTION_REQUEST
} from './actionTypes';
import logger from './logger';
import { IPromotionRequest } from './types';

/**
 * Action used to admit multiple participants in the conference.
 *
 * @param {Array<Object>} requests - A list of visitors requests.
 * @returns {Function}
 */
export function admitMultiple(requests: Array<IPromotionRequest>): Function {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const conference = getCurrentConference(getState);

        conference?.sendMessage({
            type: 'visitors',
            action: 'promotion-response',
            approved: true,
            ids: requests.map(r => r.from)
        });
    };
}

/**
 * Approves the request of a visitor to join the main meeting.
 *
 * @param {IPromotionRequest} request - The request from the visitor.
 * @returns {Function}
 */
export function approveRequest(request: IPromotionRequest) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const conference = getCurrentConference(getState);

        conference?.sendMessage({
            type: 'visitors',
            action: 'promotion-response',
            approved: true,
            id: request.from
        });

        dispatch(clearPromotionRequest(request));
    };
}

/**
 * Denies the request of a visitor to join the main meeting.
 *
 * @param {IPromotionRequest} request - The request from the visitor.
 * @returns {Function}
 */
export function denyRequest(request: IPromotionRequest) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const conference = getCurrentConference(getState);

        conference?.sendMessage({
            type: 'visitors',
            action: 'promotion-response',
            approved: false,
            id: request.from
        });

        dispatch(clearPromotionRequest(request));
    };
}

/**
 * Sends a demote request to a main participant to join the meeting as a visitor.
 *
 * @param {string} id - The ID for the participant.
 * @returns {Function}
 */
export function demoteRequest(id: string) {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const conference = getCurrentConference(getState);
        const localParticipant = getLocalParticipant(getState());

        sendAnalytics(createRemoteVideoMenuButtonEvent('demote.button', { 'participant_id': id }));

        if (id === localParticipant?.id) {
            dispatch(disconnect(true))
                .then(() => {
                    dispatch(setPreferVisitor(true));
                    logger.info('Dispatching connect to demote the local participant.');

                    return dispatch(connect());
                });
        } else {
            conference?.sendMessage({
                type: 'visitors',
                action: 'demote-request',
                id,
                actor: localParticipant?.id
            });
        }
    };
}

/**
 * Removes a promotion request from the state.
 *
 * @param {IPromotionRequest} request - The request.
 * @returns {{
 *     type: CLEAR_VISITOR_PROMOTION_REQUEST,
 *     request: IPromotionRequest
 * }}
 */
export function clearPromotionRequest(request: IPromotionRequest) {
    return {
        type: CLEAR_VISITOR_PROMOTION_REQUEST,
        request
    };
}

/**
 * Visitor has sent us a promotion request.
 *
 * @param {IPromotionRequest} request - The request.
 * @returns {{
 *     type: VISITOR_PROMOTION_REQUEST,
 * }}
 */
export function promotionRequestReceived(request: IPromotionRequest) {
    return {
        type: VISITOR_PROMOTION_REQUEST,
        request
    };
}

/**
 * Sets Visitors mode on or off.
 *
 * @param {boolean} enabled - The new visitors mode state.
 * @returns {{
 *     type: I_AM_VISITOR_MODE,
 * }}
 */
export function setIAmVisitor(enabled: boolean) {
    return {
        type: I_AM_VISITOR_MODE,
        enabled
    };
}

/**
 * Sets in visitor's queue.
 *
 * @param {boolean} value - The new value.
 * @returns {{
 *     type: SET_IN_VISITORS_QUEUE,
 * }}
 */
export function setInVisitorsQueue(value: boolean) {
    return {
        type: SET_IN_VISITORS_QUEUE,
        value
    };
}

/**
 * Sets visitor demote actor.
 *
 * @param {string|undefined} displayName - The display name of the participant.
 * @returns {{
 *     type: SET_VISITOR_DEMOTE_ACTOR,
 * }}
 */
export function setVisitorDemoteActor(displayName: string | undefined) {
    return {
        type: SET_VISITOR_DEMOTE_ACTOR,
        displayName
    };
}

/**
 * Visitors count has been updated.
 *
 * @param {boolean} value - The new value whether visitors are supported.
 * @returns {{
 *     type: SET_VISITORS_SUPPORTED,
 * }}
 */
export function setVisitorsSupported(value: boolean) {
    return {
        type: SET_VISITORS_SUPPORTED,
        value
    };
}

/**
 * Visitors count has been updated.
 *
 * @param {number} count - The new visitors count.
 * @returns {{
 *     type: UPDATE_VISITORS_COUNT,
 * }}
 */
export function updateVisitorsCount(count: number) {
    return {
        type: UPDATE_VISITORS_COUNT,
        count
    };
}

/**
 * Visitors in queue count has been updated.
 *
 * @param {number} count - The new visitors in queue count.
 * @returns {{
 *     type: UPDATE_VISITORS_IN_QUEUE_COUNT,
 * }}
 */
export function updateVisitorsInQueueCount(count: number) {
    return {
        type: UPDATE_VISITORS_IN_QUEUE_COUNT,
        count
    };
}

/**
 * Closes the overflow menu if opened.
 *
 * @private
 * @returns {void}
 */
export function goLive() {
    return (_: IStore['dispatch'], getState: IStore['getState']) => {
        const { conference } = getState()['features/base/conference'];

        conference?.getMetadataHandler().setMetadata('visitors', {
            live: true
        });
    };
}


################################################################################

## File: .\jitsi-meet\react\features\visitors\actionTypes.ts

/**
 * The type of (redux) action to update visitors count.
 *
 * {
 *     type: UPDATE_VISITORS_COUNT,
 *     count: number
 * }
 */
export const UPDATE_VISITORS_COUNT = 'UPDATE_VISITORS_COUNT';

/**
 * The type of (redux) action to update visitors in queue count.
 *
 * {
 *     type: UPDATE_VISITORS_IN_QUEUE_COUNT,
 *     count: number
 * }
 */
export const UPDATE_VISITORS_IN_QUEUE_COUNT = 'UPDATE_VISITORS_IN_QUEUE_COUNT';

/**
 * The type of (redux) action which enables/disables visitors UI mode.
 *
 * {
 *     type: I_AM_VISITOR_MODE,
 *     enabled: boolean
 * }
 */
export const I_AM_VISITOR_MODE = 'I_AM_VISITOR_MODE';

/**
 * The type of (redux) action which indicates that a promotion request was received from a visitor.
 *
 * {
 *     type: VISITOR_PROMOTION_REQUEST,
 *     nick: string,
 *     from: string
 * }
 */
export const VISITOR_PROMOTION_REQUEST = 'VISITOR_PROMOTION_REQUEST';

/**
 * The type of (redux) action which indicates that a promotion response denied was received.
 *
 * {
 *     type: CLEAR_VISITOR_PROMOTION_REQUEST,
 *     request: IPromotionRequest
 * }
 */
export const CLEAR_VISITOR_PROMOTION_REQUEST = 'CLEAR_VISITOR_PROMOTION_REQUEST';

/**
 * The type of (redux) action which sets in visitor's queue.
 *
 * {
 *     type: SET_IN_VISITORS_QUEUE,
 *     value: boolean
 * }
 */
export const SET_IN_VISITORS_QUEUE = 'SET_IN_VISITORS_QUEUE';

/**
 * The type of (redux) action which sets visitor demote actor.
 *
 * {
 *     type: SET_VISITOR_DEMOTE_ACTOR,
 *     displayName: string
 * }
 */
export const SET_VISITOR_DEMOTE_ACTOR = 'SET_VISITOR_DEMOTE_ACTOR';

/**
 * The type of (redux) action which sets visitors support.
 *
 * {
 *     type: SET_VISITORS_SUPPORTED,
 *     value: string
 * }
 */
export const SET_VISITORS_SUPPORTED = 'SET_VISITORS_SUPPORTED';


################################################################################

## File: .\jitsi-meet\react\features\visitors\functions.ts

import { IReduxState } from '../app/types';
import { IStateful } from '../base/app/types';
import { toState } from '../base/redux/functions';

/**
 * A short string to represent the number of visitors.
 * Over 100 we show numbers like 0.2 K or 9.5 K.
 *
 * @param {number} visitorsCount - The number of visitors to shorten.
 *
 * @returns {string} Short string representing the number of visitors.
 */
export function getVisitorsShortText(visitorsCount: number) {
    return visitorsCount > 100 ? `${Math.round(visitorsCount / 100) / 10} K` : String(visitorsCount);
}

/**
 * Selector to return a list of promotion requests from visitors.
 *
 * @param {IReduxState} state - State object.
 * @returns {Array<Object>}
 */
export function getPromotionRequests(state: IReduxState) {
    return state['features/visitors'].promotionRequests;
}

/**
 * Whether current UI is in visitor mode.
 *
 * @param {Function|Object} stateful - The redux store or {@code getState}
 * function.
 * @returns {boolean} Whether iAmVisitor is set.
 */
export function iAmVisitor(stateful: IStateful) {
    return toState(stateful)['features/visitors'].iAmVisitor;
}

/**
 * Returns the number of visitors.
 *
 * @param {Function|Object} stateful - The redux store or {@code getState}
 * function.
 * @returns {number} - The number of visitors.
 */
export function getVisitorsCount(stateful: IStateful) {
    return toState(stateful)['features/visitors'].count ?? 0;
}

/**
 * Returns the number of visitors that are waiting in queue.
 *
 * @param {Function|Object} stateful - The redux store or {@code getState}
 * function.
 * @returns {number} - The number of visitors in queue.
 */
export function getVisitorsInQueueCount(stateful: IStateful) {
    return toState(stateful)['features/visitors'].inQueueCount ?? 0;
}

/**
 * Whether visitor mode is supported.
 *
 * @param {Function|Object} stateful - The redux store or {@code getState}
 * function.
 * @returns {boolean} Whether visitor moder is supported.
 */
export function isVisitorsSupported(stateful: IStateful) {
    return toState(stateful)['features/visitors'].supported;
}

/**
 * Whether visitor mode is live.
 *
 * @param {Function|Object} stateful - The redux store or {@code getState}
 * function.
 * @returns {boolean} Whether visitor moder is live.
 */
export function isVisitorsLive(stateful: IStateful) {
    return toState(stateful)['features/base/conference'].metadata?.visitors?.live;
}

/**
 * Whether to show visitor queue screen.
 *
 * @param {Function|Object} stateful - The redux store or {@code getState}
 * function.
 * @returns {boolean} Whether current participant is visitor and is in queue.
 */
export function showVisitorsQueue(stateful: IStateful) {
    return toState(stateful)['features/visitors'].inQueue;
}


################################################################################

## File: .\jitsi-meet\react\features\visitors\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/visitors');


################################################################################

## File: .\jitsi-meet\react\features\visitors\middleware.ts

import i18n from 'i18next';
import { batch } from 'react-redux';

import { IStore } from '../app/types';
import { IStateful } from '../base/app/types';
import {
    CONFERENCE_JOINED,
    CONFERENCE_JOIN_IN_PROGRESS,
    ENDPOINT_MESSAGE_RECEIVED,
    UPDATE_CONFERENCE_METADATA
} from '../base/conference/actionTypes';
import { SET_CONFIG } from '../base/config/actionTypes';
import { CONNECTION_FAILED } from '../base/connection/actionTypes';
import { connect, setPreferVisitor } from '../base/connection/actions';
import { disconnect } from '../base/connection/actions.any';
import { openDialog } from '../base/dialog/actions';
import { JitsiConferenceEvents, JitsiConnectionErrors } from '../base/lib-jitsi-meet';
import { PARTICIPANT_UPDATED } from '../base/participants/actionTypes';
import { raiseHand } from '../base/participants/actions';
import {
    getLocalParticipant,
    getParticipantById,
    isLocalParticipantModerator
} from '../base/participants/functions';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import { toState } from '../base/redux/functions';
import { BUTTON_TYPES } from '../base/ui/constants.any';
import { hideNotification, showNotification } from '../notifications/actions';
import {
    NOTIFICATION_ICON,
    NOTIFICATION_TIMEOUT_TYPE,
    VISITORS_NOT_LIVE_NOTIFICATION_ID,
    VISITORS_PROMOTION_NOTIFICATION_ID
} from '../notifications/constants';
import { INotificationProps } from '../notifications/types';
import { open as openParticipantsPane } from '../participants-pane/actions';
import { joinConference } from '../prejoin/actions';

import { UPDATE_VISITORS_IN_QUEUE_COUNT } from './actionTypes';
import {
    approveRequest,
    clearPromotionRequest,
    denyRequest,
    goLive,
    promotionRequestReceived,
    setInVisitorsQueue,
    setVisitorDemoteActor,
    setVisitorsSupported,
    updateVisitorsCount,
    updateVisitorsInQueueCount
} from './actions';
import { JoinMeetingDialog } from './components';
import { getPromotionRequests, getVisitorsCount, getVisitorsInQueueCount } from './functions';
import logger from './logger';
import { WebsocketClient } from './websocket-client';

MiddlewareRegistry.register(({ dispatch, getState }) => next => action => {
    switch (action.type) {
    case CONFERENCE_JOIN_IN_PROGRESS: {
        const { conference } = action;

        conference.on(JitsiConferenceEvents.PROPERTIES_CHANGED, (properties: { 'visitor-count': number; }) => {
            const visitorCount = Number(properties?.['visitor-count']);

            if (!isNaN(visitorCount) && getVisitorsCount(getState) !== visitorCount) {
                dispatch(updateVisitorsCount(visitorCount));
            }
        });
        break;
    }
    case CONFERENCE_JOINED: {
        const { conference } = action;

        if (getState()['features/visitors'].iAmVisitor) {

            const { demoteActorDisplayName } = getState()['features/visitors'];

            if (demoteActorDisplayName) {
                const notificationParams: INotificationProps = {
                    titleKey: 'visitors.notification.title',
                    descriptionKey: 'visitors.notification.demoteDescription',
                    descriptionArguments: {
                        actor: demoteActorDisplayName
                    }
                };

                batch(() => {
                    dispatch(showNotification(notificationParams, NOTIFICATION_TIMEOUT_TYPE.STICKY));
                    dispatch(setVisitorDemoteActor(undefined));
                });
            } else {
                dispatch(openDialog(JoinMeetingDialog));
            }

        } else {
            dispatch(setVisitorsSupported(conference.isVisitorsSupported()));
            conference.on(JitsiConferenceEvents.VISITORS_SUPPORTED_CHANGED, (value: boolean) => {
                dispatch(setVisitorsSupported(value));
            });
        }

        conference.on(JitsiConferenceEvents.VISITORS_MESSAGE, (
                msg: { action: string; actor: string; from: string; id: string; nick: string; on: boolean; }) => {

            if (msg.action === 'demote-request') {
                // we need it before the disconnect
                const participantById = getParticipantById(getState, msg.actor);
                const localParticipant = getLocalParticipant(getState);

                if (localParticipant && localParticipant.id === msg.id) {
                    // handle demote
                    dispatch(disconnect(true))
                        .then(() => {
                            dispatch(setPreferVisitor(true));

                            // we need to set the name, so we can use it later in the notification
                            if (participantById) {
                                dispatch(setVisitorDemoteActor(participantById.name));
                            }

                            logger.info('Dispatching connect on demote request visitor message for local participant.');

                            return dispatch(connect());
                        });
                }
            } else if (msg.action === 'promotion-request') {
                const request = {
                    from: msg.from,
                    nick: msg.nick
                };

                if (msg.on) {
                    dispatch(promotionRequestReceived(request));
                } else {
                    dispatch(clearPromotionRequest(request));
                }
                _handlePromotionNotification({
                    dispatch,
                    getState
                });
            } else {
                logger.error('Unknown action:', msg.action);
            }
        });

        conference.on(JitsiConferenceEvents.VISITORS_REJECTION, () => {
            dispatch(raiseHand(false));
        });

        break;
    }
    case ENDPOINT_MESSAGE_RECEIVED: {
        const { data } = action;

        if (data?.action === 'promotion-response' && data.approved) {
            const request = getPromotionRequests(getState())
                .find((r: any) => r.from === data.id);

            request && dispatch(clearPromotionRequest(request));
        }
        break;
    }
    case CONNECTION_FAILED: {
        const { error } = action;

        if (error?.name !== JitsiConnectionErrors.NOT_LIVE_ERROR) {
            break;
        }

        const { hosts, visitors: visitorsConfig } = getState()['features/base/config'];
        const { locationURL, preferVisitor } = getState()['features/base/connection'];

        if (!visitorsConfig?.queueService || !locationURL || !preferVisitor) {
            break;
        }

        // let's subscribe for visitor waiting queue
        const { room } = getState()['features/base/conference'];
        const conferenceJid = `${room}@${hosts?.muc}`;

        WebsocketClient.getInstance()
            .connect(`wss://${visitorsConfig?.queueService}/visitor/websocket`,
                `/secured/conference/visitor/topic.${conferenceJid}`,
                msg => {
                    if ('status' in msg && msg.status === 'live') {
                        logger.info('The conference is now live!');

                        WebsocketClient.getInstance().disconnect()
                            .then(() => {
                                let delay = 0;

                                // now let's connect to meeting
                                if ('randomDelayMs' in msg) {
                                    delay = msg.randomDelayMs;
                                }

                                if (WebsocketClient.getInstance().connectCount > 1) {
                                    // if we keep connecting/disconnecting, let's slow it down
                                    delay = 30 * 1000;
                                }

                                setTimeout(() => {
                                    logger.info('Dispatching joinConference on conference live event.');
                                    dispatch(joinConference());
                                    dispatch(setInVisitorsQueue(false));
                                }, Math.random() * delay);
                            });
                    }
                },

                getState()['features/base/jwt'].jwt,
                () => {
                    dispatch(setInVisitorsQueue(true));
                });

        break;
    }
    case PARTICIPANT_UPDATED: {
        const { visitors: visitorsConfig } = toState(getState)['features/base/config'];

        if (visitorsConfig?.queueService && isLocalParticipantModerator(getState)) {
            const { metadata } = getState()['features/base/conference'];

            if (metadata?.visitors?.live === false && !WebsocketClient.getInstance().isActive()) {
                // when go live is available and false, we should subscribe
                // to the service if available to listen for waiting visitors
                _subscribeQueueStats(getState(), dispatch);
            }
        }

        break;
    }
    case SET_CONFIG: {
        const result = next(action);
        const { preferVisitor } = action.config;

        if (preferVisitor !== undefined) {
            setPreferVisitor(preferVisitor);
        }

        return result;
    }
    case UPDATE_CONFERENCE_METADATA: {
        const { metadata } = action;
        const { visitors: visitorsConfig } = toState(getState)['features/base/config'];

        if (!visitorsConfig?.queueService) {
            break;
        }

        if (isLocalParticipantModerator(getState)) {
            if (metadata?.visitors?.live === false) {
                if (!WebsocketClient.getInstance().isActive()) {
                    // if metadata go live changes to goLive false and local is moderator
                    // we should subscribe to the service if available to listen for waiting visitors
                    _subscribeQueueStats(getState(), dispatch);
                }

                _showNotLiveNotification(dispatch, getVisitorsInQueueCount(getState));
            } else if (metadata?.visitors?.live) {
                dispatch(hideNotification(VISITORS_NOT_LIVE_NOTIFICATION_ID));
                WebsocketClient.getInstance().disconnect();
            }
        }

        break;
    }
    case UPDATE_VISITORS_IN_QUEUE_COUNT: {
        _showNotLiveNotification(dispatch, action.count);

        break;
    }
    }

    return next(action);
});

/**
 * Shows a notification that the meeting is not live.
 *
 * @param {Dispatch} dispatch - The Redux dispatch function.
 * @param {number} count - The count of visitors waiting.
 * @returns {void}
 */
function _showNotLiveNotification(dispatch: IStore['dispatch'], count: number): void {
    // let's show notification
    dispatch(showNotification({
        titleKey: 'notify.waitingVisitorsTitle',
        descriptionKey: 'notify.waitingVisitors',
        descriptionArguments: {
            waitingVisitors: count
        },
        disableClosing: true,
        uid: VISITORS_NOT_LIVE_NOTIFICATION_ID,
        customActionNameKey: [ 'participantsPane.actions.goLive' ],
        customActionType: [ BUTTON_TYPES.PRIMARY ],
        customActionHandler: [ () => batch(() => {
            dispatch(hideNotification(VISITORS_NOT_LIVE_NOTIFICATION_ID));
            dispatch(goLive());
        }) ],
        icon: NOTIFICATION_ICON.PARTICIPANTS
    }, NOTIFICATION_TIMEOUT_TYPE.STICKY));
}

/**
 * Subscribe for moderator stats.
 *
 * @param {Function|Object} stateful - The redux store or {@code getState}
 * function.
 * @param {Dispatch} dispatch - The Redux dispatch function.
 * @returns {void}
 */
function _subscribeQueueStats(stateful: IStateful, dispatch: IStore['dispatch']) {
    const { hosts } = toState(stateful)['features/base/config'];
    const { room } = toState(stateful)['features/base/conference'];
    const conferenceJid = `${room}@${hosts?.muc}`;

    const { visitors: visitorsConfig } = toState(stateful)['features/base/config'];

    WebsocketClient.getInstance()
        .connect(`wss://${visitorsConfig?.queueService}/visitor/websocket`,
            `/secured/conference/state/topic.${conferenceJid}`,
            msg => {
                if ('visitorsWaiting' in msg) {
                    dispatch(updateVisitorsInQueueCount(msg.visitorsWaiting));
                }
            },
            toState(stateful)['features/base/jwt'].jwt);
}

/**
 * Function to handle the promotion notification.
 *
 * @param {Object} store - The Redux store.
 * @returns {void}
 */
function _handlePromotionNotification(
        { dispatch, getState }: { dispatch: IStore['dispatch']; getState: IStore['getState']; }) {
    const requests = getPromotionRequests(getState());

    if (requests.length === 0) {
        dispatch(hideNotification(VISITORS_PROMOTION_NOTIFICATION_ID));

        return;
    }

    let notificationTitle;
    let customActionNameKey;
    let customActionHandler;
    let customActionType;
    let descriptionKey;
    let icon;

    if (requests.length === 1) {
        const firstRequest = requests[0];

        descriptionKey = 'notify.participantWantsToJoin';
        notificationTitle = firstRequest.nick;
        icon = NOTIFICATION_ICON.PARTICIPANT;
        customActionNameKey = [ 'participantsPane.actions.admit', 'participantsPane.actions.reject' ];
        customActionType = [ BUTTON_TYPES.PRIMARY, BUTTON_TYPES.DESTRUCTIVE ];
        customActionHandler = [ () => batch(() => {
            dispatch(hideNotification(VISITORS_PROMOTION_NOTIFICATION_ID));
            dispatch(approveRequest(firstRequest));
        }),
        () => batch(() => {
            dispatch(hideNotification(VISITORS_PROMOTION_NOTIFICATION_ID));
            dispatch(denyRequest(firstRequest));
        }) ];
    } else {
        descriptionKey = 'notify.participantsWantToJoin';
        notificationTitle = i18n.t('notify.waitingParticipants', {
            waitingParticipants: requests.length
        });
        icon = NOTIFICATION_ICON.PARTICIPANTS;
        customActionNameKey = [ 'notify.viewVisitors' ];
        customActionType = [ BUTTON_TYPES.PRIMARY ];
        customActionHandler = [ () => batch(() => {
            dispatch(hideNotification(VISITORS_PROMOTION_NOTIFICATION_ID));
            dispatch(openParticipantsPane());
        }) ];
    }

    dispatch(showNotification({
        title: notificationTitle,
        descriptionKey,
        uid: VISITORS_PROMOTION_NOTIFICATION_ID,
        customActionNameKey,
        customActionType,
        customActionHandler,
        icon
    }, NOTIFICATION_TIMEOUT_TYPE.STICKY));
}


################################################################################

## File: .\jitsi-meet\react\features\visitors\reducer.ts

import { CONFERENCE_WILL_LEAVE } from '../base/conference/actionTypes';
import ReducerRegistry from '../base/redux/ReducerRegistry';

import {
    CLEAR_VISITOR_PROMOTION_REQUEST,
    I_AM_VISITOR_MODE,
    SET_IN_VISITORS_QUEUE,
    SET_VISITORS_SUPPORTED,
    SET_VISITOR_DEMOTE_ACTOR,
    UPDATE_VISITORS_COUNT,
    UPDATE_VISITORS_IN_QUEUE_COUNT,
    VISITOR_PROMOTION_REQUEST
} from './actionTypes';
import { IPromotionRequest } from './types';

const DEFAULT_STATE = {
    count: 0,
    iAmVisitor: false,
    inQueue: false,
    inQueueCount: 0,
    showNotification: false,
    supported: false,
    promotionRequests: []
};

export interface IVisitorsState {
    count?: number;
    demoteActorDisplayName?: string;
    iAmVisitor: boolean;
    inQueue: boolean;
    inQueueCount?: number;
    promotionRequests: IPromotionRequest[];
    supported: boolean;
}
ReducerRegistry.register<IVisitorsState>('features/visitors', (state = DEFAULT_STATE, action): IVisitorsState => {
    switch (action.type) {
    case CONFERENCE_WILL_LEAVE: {
        return {
            ...state,
            ...DEFAULT_STATE,

            // If the action was called because a visitor was promoted don't clear the iAmVisitor field. It will be set
            // to false with the I_AM_VISITOR_MODE action and we will be able to distinguish leaving the conference use
            // case and promoting a visitor use case.
            iAmVisitor: action.isRedirect ? state.iAmVisitor : DEFAULT_STATE.iAmVisitor
        };
    }
    case UPDATE_VISITORS_COUNT: {
        if (state.count === action.count) {
            return state;
        }

        return {
            ...state,
            count: action.count
        };
    }
    case UPDATE_VISITORS_IN_QUEUE_COUNT: {
        if (state.count === action.count) {
            return state;
        }

        return {
            ...state,
            inQueueCount: action.count
        };
    }
    case I_AM_VISITOR_MODE: {
        return {
            ...state,
            iAmVisitor: action.enabled
        };
    }
    case SET_IN_VISITORS_QUEUE: {
        return {
            ...state,
            inQueue: action.value
        };
    }
    case SET_VISITOR_DEMOTE_ACTOR: {
        return {
            ...state,
            demoteActorDisplayName: action.displayName
        };
    }
    case SET_VISITORS_SUPPORTED: {
        return {
            ...state,
            supported: action.value
        };
    }
    case VISITOR_PROMOTION_REQUEST: {
        const currentRequests = state.promotionRequests || [];

        return {
            ...state,
            promotionRequests: [ ...currentRequests, action.request ]
        };
    }
    case CLEAR_VISITOR_PROMOTION_REQUEST: {
        let currentRequests = state.promotionRequests || [];

        currentRequests = currentRequests.filter(r => r.from !== action.request.from);

        return {
            ...state,
            promotionRequests: currentRequests
        };
    }
    }

    return state;
});


################################################################################

## File: .\jitsi-meet\react\features\visitors\types.ts

export interface IPromotionRequest {
    from: string;
    nick: string;
}


################################################################################

## File: .\jitsi-meet\react\features\visitors\websocket-client.ts

/* eslint-disable @typescript-eslint/naming-convention */
import { Client } from '@stomp/stompjs';

import logger from './logger';

interface QueueServiceResponse {
    conference: string;
}
export interface StateResponse extends QueueServiceResponse {
    randomDelayMs: number;
    status: string;
}

export interface VisitorResponse extends QueueServiceResponse {
    visitorsWaiting: number;
}

/**
 * Websocket client impl, used for visitors queue.
 * Uses STOMP for authenticating (https://stomp.github.io/).
 */
export class WebsocketClient {
    private stompClient: Client | undefined;

    private static instance: WebsocketClient;

    private retriesCount = 0;

    private _connectCount = 0;

    /**
     *  WebsocketClient getInstance.
     *
     * @static
     * @returns {WebsocketClient}  - WebsocketClient instance.
     */
    static getInstance(): WebsocketClient {
        if (!this.instance) {
            this.instance = new WebsocketClient();
        }

        return this.instance;
    }

    /**
     * Connect to endpoint.
     *
     * @param {string} queueServiceURL - The service URL to use.
     * @param {string} endpoint - The endpoint to subscribe to.
     * @param {Function} callback - The callback to execute when we receive a message from the endpoint.
     * @param {string} token - The token, if any, to be used for authorization.
     * @param {Function?} connectCallback - The callback to execute when successfully connected.
     *
     * @returns {void}
     */
    connect(queueServiceURL: string, // eslint-disable-line max-params
            endpoint: string,
            callback: (response: StateResponse | VisitorResponse) => void,
            token: string | undefined,
            connectCallback?: () => void): void {
        this.stompClient = new Client({
            brokerURL: queueServiceURL,
            forceBinaryWSFrames: true,
            appendMissingNULLonIncoming: true
        });

        const errorConnecting = (error: any) => {
            if (this.retriesCount > 3) {
                this.stompClient?.deactivate();
                this.stompClient = undefined;

                return;
            }

            this.retriesCount++;

            logger.error(`Error connecting to ${queueServiceURL} ${JSON.stringify(error)}`);
        };

        this.stompClient.onWebSocketError = errorConnecting;

        this.stompClient.onStompError = frame => {
            errorConnecting(frame.headers.message);
        };

        if (token) {
            this.stompClient.connectHeaders = {
                Authorization: `Bearer ${token}`
            };
        }

        this.stompClient.onConnect = () => {
            if (!this.stompClient) {
                return;
            }

            this.retriesCount = 0;

            logger.info(`Connected to:${endpoint}`);
            this._connectCount++;
            connectCallback?.();

            this.stompClient.subscribe(endpoint, message => {
                try {
                    callback(JSON.parse(message.body));
                } catch (e) {
                    logger.error(`Error parsing response: ${message}`, e);
                }
            });
        };

        this.stompClient.activate();
    }

    /**
     * Disconnects the current stomp  client instance and clears it.
     *
     * @returns {Promise}
     */
    disconnect(): Promise<any> {
        if (!this.stompClient) {
            return Promise.resolve();
        }

        const url = this.stompClient.brokerURL;

        return this.stompClient.deactivate().then(() => {
            logger.info(`disconnected from: ${url}`);
            this.stompClient = undefined;
        });
    }

    /**
     * Checks whether the instance is created and connected or in connecting state.
     *
     * @returns {boolean} Whether the connect method was executed.
     */
    isActive() {
        return this.stompClient !== undefined;
    }

    /**
     * Returns the number of connections.
     *
     * @returns {number} The number of connections for the life of the app.
     */
    get connectCount(): number {
        return this._connectCount;
    }
}


################################################################################

## File: .\jitsi-meet\react\features\visitors\components\index.native.ts

export { default as JoinMeetingDialog } from './native/JoinMeetingDialog';


################################################################################

## File: .\jitsi-meet\react\features\visitors\components\index.web.ts

export { default as JoinMeetingDialog } from './web/JoinMeetingDialog';


################################################################################

## File: .\jitsi-meet\react\features\visitors\components\native\styles.ts

/**
 * The styles of the feature visitors.
 */
export default {

    raiseHandButton: {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        width: '100%'
    }
};


################################################################################

## File: .\jitsi-meet\react\features\web-hid\actions.ts

import { CLOSE_HID_DEVICE, INIT_DEVICE, REQUEST_HID_DEVICE, UPDATE_DEVICE } from './actionTypes';
import { IDeviceInfo } from './types';

/**
 * Action used to init device.
 *
 * @param {IDeviceInfo} deviceInfo - Telephony device information.
 * @returns {Object}
 */
export function initDeviceInfo(deviceInfo: IDeviceInfo) {
    return {
        type: INIT_DEVICE,
        deviceInfo
    };
}

/**
 * Request hid device.
 *
 * @returns {Object}
 */
export function closeHidDevice() {
    return {
        type: CLOSE_HID_DEVICE
    };
}

/**
 * Request hid device.
 *
 * @param {IDeviceInfo} deviceInfo - Telephony device information.
 * @returns {Object}
 */
export function requestHidDevice() {
    return {
        type: REQUEST_HID_DEVICE
    };
}

/**
 * Action used to init device.
 *
 * @param {IDeviceInfo} deviceInfo - Telephony device information.
 * @returns {Object}
 */
export function updateDeviceInfo(deviceInfo: IDeviceInfo) {
    return {
        type: UPDATE_DEVICE,
        updates: deviceInfo
    };
}


################################################################################

## File: .\jitsi-meet\react\features\web-hid\actionTypes.ts

/**
 * Action type to INIT_DEVICE.
 */
export const INIT_DEVICE = 'INIT_DEVICE';

/**
 * Action type to CLOSE_HID_DEVICE.
 */
export const CLOSE_HID_DEVICE = 'CLOSE_HID_DEVICE';

/**
 * Action type to REQUEST_HID_DEVICE.
 */
export const REQUEST_HID_DEVICE = 'REQUEST_HID_DEVICE';

/**
 * Action type to UPDATE_DEVICE.
 */
export const UPDATE_DEVICE = 'UPDATE_DEVICE';



################################################################################

## File: .\jitsi-meet\react\features\web-hid\functions.ts

import { IReduxState, IStore } from '../app/types';
import { MEDIA_TYPE } from '../base/media/constants';
import { muteLocal } from '../video-menu/actions.any';

import { updateDeviceInfo } from './actions';
import { ACTION_HOOK_TYPE_NAME, EVENT_TYPE, IDeviceInfo } from './types';
import WebHidManager from './webhid-manager';

/**
 * Attach web hid event listeners.
 *
 * @param {Function} initDeviceListener - Init hid device listener.
 * @param {Function} updateDeviceListener - Update hid device listener.
 * @returns {void}
 */
export function attachHidEventListeners(
        initDeviceListener: EventListenerOrEventListenerObject,
        updateDeviceListener: EventListenerOrEventListenerObject
) {
    const hidManager = getWebHidInstance();

    if (typeof initDeviceListener === 'function') {
        hidManager.addEventListener(EVENT_TYPE.INIT_DEVICE, initDeviceListener);
    }
    if (typeof updateDeviceListener === 'function') {
        hidManager.addEventListener(EVENT_TYPE.UPDATE_DEVICE, updateDeviceListener);
    }
}

/**
 * Returns instance of web hid manager.
 *
* @returns {WebHidManager}  - WebHidManager instance.
 */
export function getWebHidInstance(): WebHidManager {
    const hidManager = WebHidManager.getInstance();

    return hidManager;
}

/**
 * Returns root conference state.
 *
 * @param {IReduxState} state - Global state.
 * @returns {Object} Conference state.
 */
export const getWebHidState = (state: IReduxState) => state['features/web-hid'];

/**
 * Returns true if hid is supported.
 *
 * @returns {boolean}
 */
export function isDeviceHidSupported(): boolean {
    const hidManager = getWebHidInstance();

    return hidManager.isSupported();
}

/**
 * Returns device info from state.
 *
 * @param {IReduxState} state - Global state.
 * @returns {boolean}
 */
export function getDeviceInfo(state: IReduxState): IDeviceInfo {
    const hidState = getWebHidState(state);

    return hidState.deviceInfo;
}

/**
 * Handles updating hid device.
 *
 * @param {Function} dispatch - Redux dispatch.
 * @param {Function} customEventData - Custom event data.
 * @returns {void}
 */
export function handleUpdateHidDevice(
        dispatch: IStore['dispatch'],
        customEventData: CustomEvent<{ actionResult?: { eventName: string; }; deviceInfo: IDeviceInfo; }>
) {
    dispatch(updateDeviceInfo(customEventData.detail.deviceInfo));

    if (customEventData.detail?.actionResult?.eventName === ACTION_HOOK_TYPE_NAME.MUTE_SWITCH_ON) {
        dispatch(muteLocal(true, MEDIA_TYPE.AUDIO));
    } else if (customEventData.detail?.actionResult?.eventName === ACTION_HOOK_TYPE_NAME.MUTE_SWITCH_OFF) {
        dispatch(muteLocal(false, MEDIA_TYPE.AUDIO));
    }
}

/**
 * Remove web hid event listeners.
 *
 * @param {Function} initDeviceListener - Init hid device listener.
 * @param {Function} updateDeviceListener - Update hid device listener.
 * @returns {void}
 */
export function removeHidEventListeners(
        initDeviceListener: EventListenerOrEventListenerObject,
        updateDeviceListener: EventListenerOrEventListenerObject
) {
    const hidManager = getWebHidInstance();

    if (typeof initDeviceListener === 'function') {
        hidManager.removeEventListener(EVENT_TYPE.INIT_DEVICE, initDeviceListener);
    }
    if (typeof updateDeviceListener === 'function') {
        hidManager.removeEventListener(EVENT_TYPE.UPDATE_DEVICE, updateDeviceListener);
    }
}

/**
 * Returns true if there is no device info provided.
 *
 * @param {IDeviceInfo} deviceInfo - Device info state.
 * @returns {boolean}
 */
export function shouldRequestHIDDevice(deviceInfo: IDeviceInfo): boolean {
    return !deviceInfo?.device || Object.keys(deviceInfo).length === 0;
}


################################################################################

## File: .\jitsi-meet\react\features\web-hid\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/hid');


################################################################################

## File: .\jitsi-meet\react\features\web-hid\middleware.ts

import { IStore } from '../app/types';
import { APP_WILL_MOUNT, APP_WILL_UNMOUNT } from '../base/app/actionTypes';
import { getWebHIDFeatureConfig } from '../base/config/functions.web';
import { SET_AUDIO_MUTED } from '../base/media/actionTypes';
import { isAudioMuted } from '../base/media/functions';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';

import { CLOSE_HID_DEVICE, REQUEST_HID_DEVICE } from './actionTypes';
import { initDeviceInfo } from './actions';
import {
    attachHidEventListeners,
    getWebHidInstance,
    handleUpdateHidDevice,
    isDeviceHidSupported,
    removeHidEventListeners
} from './functions';
import logger from './logger';
import { COMMANDS, IDeviceInfo } from './types';

/**
 * A listener for initialising the webhid device.
 */
let initDeviceListener: (e: any) => void;

/**
 * A listener for updating the webhid device.
 */
let updateDeviceListener: (e: any) => void;

/**
 * The redux middleware for {@link WebHid}.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register((store: IStore) => next => action => {
    const { dispatch, getState } = store;

    if (!getWebHIDFeatureConfig(getState())) {
        return next(action);
    }

    switch (action.type) {
    case APP_WILL_MOUNT: {
        const hidManager = getWebHidInstance();

        if (!hidManager.isSupported()) {
            logger.warn('HID is not supported');

            break;
        }

        const _initDeviceListener = (e: CustomEvent<{ deviceInfo: IDeviceInfo; }>) =>
            dispatch(initDeviceInfo(e.detail.deviceInfo));
        const _updateDeviceListener
            = (e: CustomEvent<{ actionResult: { eventName: string; }; deviceInfo: IDeviceInfo; }>) =>
                handleUpdateHidDevice(dispatch, e);


        initDeviceListener = _initDeviceListener;
        updateDeviceListener = _updateDeviceListener;

        hidManager.listenToConnectedHid();
        attachHidEventListeners(initDeviceListener, updateDeviceListener);

        break;
    }
    case APP_WILL_UNMOUNT: {
        const hidManager = getWebHidInstance();

        if (!isDeviceHidSupported()) {
            break;
        }

        removeHidEventListeners(initDeviceListener, updateDeviceListener);
        hidManager.close();

        break;
    }
    case CLOSE_HID_DEVICE: {
        const hidManager = getWebHidInstance();

        // cleanup event handlers when hid device is removed from Settings.
        removeHidEventListeners(initDeviceListener, updateDeviceListener);

        hidManager.close();

        break;
    }
    case REQUEST_HID_DEVICE: {
        _onRequestHIDDevice(store);

        break;
    }
    case SET_AUDIO_MUTED: {
        const hidManager = getWebHidInstance();

        if (!isDeviceHidSupported()) {
            break;
        }

        hidManager.sendDeviceReport({ command: action.muted ? COMMANDS.MUTE_ON : COMMANDS.MUTE_OFF });
        break;
    }
    }

    return next(action);
});

/**
 * Handles HID device requests.
 *
 * @param {IStore} store - The redux store.
 * @returns {Promise}
 */
async function _onRequestHIDDevice(store: IStore) {
    const { dispatch } = store;
    const hidManager = getWebHidInstance();
    const availableDevices = await hidManager.requestHidDevices();

    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain
    if (!availableDevices || !availableDevices.length) {
        logger.info('HID device not available');

        return;
    }

    const _initDeviceListener = (e: CustomEvent<{ deviceInfo: IDeviceInfo; }>) =>
        dispatch(initDeviceInfo(e.detail.deviceInfo));
    const _updateDeviceListener
        = (e: CustomEvent<{ actionResult: { eventName: string; }; deviceInfo: IDeviceInfo; }>) => {
            handleUpdateHidDevice(dispatch, e);
        };

    initDeviceListener = _initDeviceListener;
    updateDeviceListener = _updateDeviceListener;

    attachHidEventListeners(initDeviceListener, updateDeviceListener);
    await hidManager.listenToConnectedHid();

    // sync headset to mute if participant is already muted.
    if (isAudioMuted(store.getState())) {
        hidManager.sendDeviceReport({ command: COMMANDS.MUTE_ON });
    }
}


################################################################################

## File: .\jitsi-meet\react\features\web-hid\reducer.ts

import ReducerRegistry from '../base/redux/ReducerRegistry';

import { CLOSE_HID_DEVICE, INIT_DEVICE, UPDATE_DEVICE } from './actionTypes';
import { IDeviceInfo } from './types';

/**
 * The initial state of the web-hid feature.
*/
const DEFAULT_STATE = {
    deviceInfo: {} as IDeviceInfo
};

export interface IWebHid {
    deviceInfo: IDeviceInfo;
}


ReducerRegistry.register<IWebHid>(
'features/web-hid',
(state: IWebHid = DEFAULT_STATE, action): IWebHid => {
    switch (action.type) {
    case INIT_DEVICE:
        return {
            ...state,
            deviceInfo: action.deviceInfo
        };
    case UPDATE_DEVICE:
        return {
            ...state,
            deviceInfo: {
                ...state.deviceInfo,
                ...action.updates
            }
        };
    case CLOSE_HID_DEVICE:
        return {
            ...state,
            deviceInfo: DEFAULT_STATE.deviceInfo
        };
    default:
        return state;
    }
});


################################################################################

## File: .\jitsi-meet\react\features\web-hid\types.ts

export const EVENT_TYPE = {
    INIT_DEVICE: 'INIT_DEVICE',
    UPDATE_DEVICE: 'UPDATE_DEVICE'
};

export const HOOK_STATUS = {
    ON: 'on',
    OFF: 'off'
};

export const COMMANDS = {
    ON_HOOK: 'onHook',
    OFF_HOOK: 'offHook',
    MUTE_OFF: 'muteOff',
    MUTE_ON: 'muteOn',
    ON_RING: 'onRing',
    OFF_RING: 'offRing',
    ON_HOLD: 'onHold',
    OFF_HOLD: 'offHold'
};

export const INPUT_REPORT_EVENT_NAME = {
    ON_DEVICE_HOOK_SWITCH: 'ondevicehookswitch',
    ON_DEVICE_MUTE_SWITCH: 'ondevicemuteswitch'
};

export const ACTION_HOOK_TYPE_NAME = {
    HOOK_SWITCH_ON: 'HOOK_SWITCH_ON',
    HOOK_SWITCH_OFF: 'HOOK_SWITCH_OFF',
    MUTE_SWITCH_ON: 'MUTE_SWITCH_ON',
    MUTE_SWITCH_OFF: 'MUTE_SWITCH_OFF',
    VOLUME_CHANGE_UP: 'VOLUME_CHANGE_UP',
    VOLUME_CHANGE_DOWN: 'VOLUME_CHANGE_DOWN'
};

export interface IDeviceInfo {

    // @ts-ignore
    device: HIDDevice;
    hold: boolean;
    hookStatus: string;
    muted: boolean;
    ring: boolean;
}


################################################################################

## File: .\jitsi-meet\react\features\web-hid\utils.ts

/**
 * Telephony usage actions based on HID Usage tables for Universal Serial Bus (page 112.).
 *
 */
export const TELEPHONY_DEVICE_USAGE_PAGE = 11;

/** Telephony usages
 *  - used to parse HIDDevice UsageId collections
 ** - outputReports has mute and offHook
 ** - inputReports exists hookSwitch and phoneMute.
 **/
export const DEVICE_USAGE = {
    /* outputReports. */
    mute: {
        usageId: 0x080009,
        usageName: 'Mute'
    },
    offHook: {
        usageId: 0x080017,
        usageName: 'Off Hook'
    },
    ring: {
        usageId: 0x080018,
        usageName: 'Ring'
    },
    hold: {
        usageId: 0x080020,
        usageName: 'Hold'
    },

    /* inputReports. */
    hookSwitch: {
        usageId: 0x0b0020,
        usageName: 'Hook Switch'
    },
    phoneMute: {
        usageId: 0x0b002f,
        usageName: 'Phone Mute'
    }
};

/**
 * Filter with telephony devices based on HID Usage tables for Universal Serial Bus (page 17).
 *
 * @type {{ filters: { usagePage: string }; exclusionFilters: {}; }}
 */
export const requestTelephonyHID = {
    filters: [ {
        usagePage: TELEPHONY_DEVICE_USAGE_PAGE
    } ],
    exclusionFilters: []
};


################################################################################

## File: .\jitsi-meet\react\features\web-hid\webhid-manager.ts

import logger from './logger';
import {
    ACTION_HOOK_TYPE_NAME,
    COMMANDS,
    EVENT_TYPE,
    HOOK_STATUS,
    IDeviceInfo,
    INPUT_REPORT_EVENT_NAME
} from './types';
import {
    DEVICE_USAGE,
    TELEPHONY_DEVICE_USAGE_PAGE,
    requestTelephonyHID
} from './utils';

/**
 * WebHID manager that incorporates all hid specific logic.
 *
 * @class WebHidManager
 */
export default class WebHidManager extends EventTarget {
    hidSupport: boolean;
    deviceInfo: IDeviceInfo;
    availableDevices: HIDDevice[];
    isParseDescriptorsSuccess: boolean;
    outputEventGenerators: { [key: string]: Function; };
    deviceCommand = {
        outputReport: {
            mute: {
                reportId: 0,
                usageOffset: -1
            },
            offHook: {
                reportId: 0,
                usageOffset: -1
            },
            ring: {
                reportId: 0,
                usageOffset: 0
            },
            hold: {
                reportId: 0,
                usageOffset: 0
            }
        },
        inputReport: {
            hookSwitch: {
                reportId: 0,
                usageOffset: -1,
                isAbsolute: false
            },
            phoneMute: {
                reportId: 0,
                usageOffset: -1,
                isAbsolute: false
            }
        }
    };

    private static instance: WebHidManager;

    /**
     *  WebHidManager getInstance.
     *
     * @static
     * @returns {WebHidManager}  - WebHidManager instance.
     */
    static getInstance(): WebHidManager {
        if (!this.instance) {
            this.instance = new WebHidManager();
        }

        return this.instance;
    }

    /**
     * Creates an instance of WebHidManager.
     *
     */
    constructor() {
        super();

        this.deviceInfo = {} as IDeviceInfo;
        this.hidSupport = this.isSupported();
        this.availableDevices = [];
        this.isParseDescriptorsSuccess = false;
        this.outputEventGenerators = {};
    }

    /**
     * Check support of hid in navigator.
     * - experimental API in Chrome.
     *
     * @returns {boolean} - True if supported, otherwise false.
     */
    isSupported(): boolean {
        // @ts-ignore
        return Boolean(window.navigator.hid?.requestDevice);
    }

    /**
     * Handler for requesting telephony hid devices.
     *
     * @returns {HIDDevice[]|null}
     */
    async requestHidDevices() {
        if (!this.hidSupport) {
            logger.warn('The WebHID API is NOT supported!');

            return null;
        }

        if (this.deviceInfo?.device && this.deviceInfo.device.opened) {
            await this.close();
        }

        // @ts-ignore
        const devices = await navigator.hid.requestDevice(requestTelephonyHID);

        if (!devices?.length) {
            logger.warn('No HID devices selected.');

            return false;
        }

        this.availableDevices = devices;

        return devices;
    }

    /**
     * Handler for listen to already connected hid.
     *
     * @returns {void}
     */
    async listenToConnectedHid() {
        const devices = await this.loadPairedDevices();

        if (!devices?.length) {
            logger.warn('No hid device found.');

            return;
        }

        const telephonyDevice = this.getTelephonyDevice(devices);

        if (!telephonyDevice) {
            logger.warn('No HID device to request');

            return;
        }

        await this.open(telephonyDevice);

        // restore the default state of hook and mic LED
        this.resetDeviceState();

        // switch headsets to OFF_HOOK for mute/unmute commands
        this.sendDeviceReport({ command: COMMANDS.OFF_HOOK });
    }

    /**
     * Get first telephony device from availableDevices.
     *
     * @param {HIDDevice[]} availableDevices -.
     * @returns {HIDDevice} -.
     */
    private getTelephonyDevice(availableDevices: HIDDevice[]) {
        if (!availableDevices?.length) {
            logger.warn('No HID device to request');

            return undefined;
        }

        return availableDevices?.find(device => this.findTelephonyCollectionInfo(device.collections));
    }

    /**
     * Find telephony collection info from a list of collection infos.
     *
     * @private
     * @param {HIDCollectionInfo[]} deviceCollections -.
     * @returns {HIDCollectionInfo} - Hid collection info.
     */
    private findTelephonyCollectionInfo(deviceCollections: HIDCollectionInfo[]) {
        return deviceCollections?.find(
                (collection: HIDCollectionInfo) => collection.usagePage === TELEPHONY_DEVICE_USAGE_PAGE
        );
    }

    /**
     * Open the hid device and start listening to inputReport events.
     *
     * @param {HIDDevice} telephonyDevice -.
     * @returns {void} -.
     */
    private async open(telephonyDevice: HIDDevice) {
        try {
            this.deviceInfo = { device: telephonyDevice } as IDeviceInfo;

            if (!this.deviceInfo?.device) {
                logger.warn('no HID device found');

                return;
            }

            if (!this.deviceInfo.device.opened) {
                await this.deviceInfo.device.open();
            }

            this.isParseDescriptorsSuccess = await this.parseDeviceDescriptors(this.deviceInfo.device);

            if (!this.isParseDescriptorsSuccess) {
                logger.warn('Failed to parse webhid');

                return;
            }

            this.dispatchEvent(new CustomEvent(EVENT_TYPE.INIT_DEVICE, { detail: {
                deviceInfo: {
                    ...this.deviceInfo
                } as IDeviceInfo } }));

            //  listen for input reports by registering an oninputreport event listener
            this.deviceInfo.device.oninputreport = await this.handleInputReport.bind(this);

            this.resetDeviceState();
        } catch (e) {
            logger.error(`Error content open device:${e}`);
        }
    }

    /**
     * Close device and reset state.
     *
     * @returns {void}
     */
    async close() {
        try {
            await this.resetDeviceState();

            if (this.availableDevices) {
                logger.info('clear available devices list');
                this.availableDevices = [];
            }

            if (!this.deviceInfo) {
                return;
            }

            if (this.deviceInfo?.device?.opened) {
                await this.deviceInfo.device.close();
            }

            if (this.deviceInfo.device) {
                this.deviceInfo.device.oninputreport = null;
            }
            this.deviceInfo = {} as IDeviceInfo;
        } catch (e) {
            logger.error(e);
        }
    }

    /**
     * Get paired hid devices.
     *
     * @returns {HIDDevice[]}
     */
    async loadPairedDevices() {
        try {
            // @ts-ignore
            const devices = await navigator.hid.getDevices();

            this.availableDevices = devices;

            return devices;
        } catch (e) {
            logger.error('loadPairedDevices error:', e);
        }
    }

    /**
     * Parse device descriptors - input and output reports.
     *
     * @param {HIDDevice} device -.
     * @returns {boolean} - True if descriptors have been parsed with success.
     */
    parseDeviceDescriptors(device: HIDDevice) {
        try {
            this.outputEventGenerators = {};

            if (!device?.collections) {
                logger.error('Undefined device collection');

                return false;
            }

            const telephonyCollection = this.findTelephonyCollectionInfo(device.collections);

            if (!telephonyCollection || Object.keys(telephonyCollection).length === 0) {
                logger.error('No telephony collection');

                return false;
            }

            if (telephonyCollection.inputReports) {
                if (!this.parseInputReports(telephonyCollection.inputReports)) {
                    logger.warn('parse inputReports failed');

                    return false;
                }
                logger.warn('parse inputReports success');

            }

            if (telephonyCollection.outputReports) {
                if (!this.parseOutputReports(telephonyCollection.outputReports)) {
                    logger.warn('parse outputReports failed');

                    return false;
                }
                logger.warn('parse outputReports success');

                return true;

            }

            logger.warn('parseDeviceDescriptors: returns false, end');

            return false;
        } catch (e) {
            logger.error(`parseDeviceDescriptors error:${JSON.stringify(e, null, '    ')}`);

            return false;
        }
    }

    /**
     * HandleInputReport.
     *
     * @param {HIDInputReportEvent} event -.
     * @returns {void} -.
     */
    handleInputReport(event: HIDInputReportEvent) {
        try {
            const { data, device, reportId } = event;

            if (reportId === 0) {
                logger.warn('handleInputReport: ignore invalid reportId');

                return;
            }

            const inputReport = this.deviceCommand.inputReport;

            logger.warn(`current inputReport:${JSON.stringify(inputReport, null, '    ')}, reporId: ${reportId}`);
            if (reportId !== inputReport.hookSwitch.reportId && reportId !== inputReport.phoneMute.reportId) {
                logger.warn('handleInputReport:ignore unknown reportId');

                return;
            }

            let hookStatusChange = false;
            let muteStatusChange = false;

            const reportData = new Uint8Array(data.buffer);
            const needReply = true;

            if (reportId === inputReport.hookSwitch.reportId) {
                const item = inputReport.hookSwitch;
                const byteIndex = Math.trunc(item.usageOffset / 8);
                const bitPosition = item.usageOffset % 8;
                // eslint-disable-next-line no-bitwise
                const usageOn = (data.getUint8(byteIndex) & (0x01 << bitPosition)) !== 0;

                logger.warn('recv hookSwitch ', usageOn ? HOOK_STATUS.OFF : HOOK_STATUS.ON);
                if (inputReport.hookSwitch.isAbsolute) {
                    if (this.deviceInfo.hookStatus === HOOK_STATUS.ON && usageOn) {
                        this.deviceInfo.hookStatus = HOOK_STATUS.OFF;
                        hookStatusChange = true;
                    } else if (this.deviceInfo.hookStatus === HOOK_STATUS.OFF && !usageOn) {
                        this.deviceInfo.hookStatus = HOOK_STATUS.ON;
                        hookStatusChange = true;
                    }
                } else if (usageOn) {
                    this.deviceInfo.hookStatus = this.deviceInfo.hookStatus === HOOK_STATUS.OFF
                        ? HOOK_STATUS.ON : HOOK_STATUS.OFF;
                    hookStatusChange = true;
                }
            }

            if (reportId === inputReport.phoneMute.reportId) {
                const item = inputReport.phoneMute;
                const byteIndex = Math.trunc(item.usageOffset / 8);
                const bitPosition = item.usageOffset % 8;
                // eslint-disable-next-line no-bitwise
                const usageOn = (data.getUint8(byteIndex) & (0x01 << bitPosition)) !== 0;

                logger.warn('recv phoneMute ', usageOn ? HOOK_STATUS.ON : HOOK_STATUS.OFF);
                if (inputReport.phoneMute.isAbsolute) {
                    if (this.deviceInfo.muted !== usageOn) {
                        this.deviceInfo.muted = usageOn;
                        muteStatusChange = true;
                    }
                } else if (usageOn) {
                    this.deviceInfo.muted = !this.deviceInfo.muted;
                    muteStatusChange = true;
                }
            }

            const inputReportData = {
                productName: device.productName,
                reportId: this.getHexByte(reportId),
                reportData,
                eventName: '',
                isMute: false,
                hookStatus: ''
            };

            if (hookStatusChange) {
                // Answer key state change
                inputReportData.eventName = INPUT_REPORT_EVENT_NAME.ON_DEVICE_HOOK_SWITCH;
                inputReportData.hookStatus = this.deviceInfo.hookStatus;
                logger.warn(`hook status change: ${this.deviceInfo.hookStatus}`);
            }

            if (muteStatusChange) {
                // Mute key state change
                inputReportData.eventName = INPUT_REPORT_EVENT_NAME.ON_DEVICE_MUTE_SWITCH;
                inputReportData.isMute = this.deviceInfo.muted;
                logger.warn(`mute status change: ${this.deviceInfo.muted}`);
            }

            const actionResult = this.extractActionResult(inputReportData);

            this.dispatchEvent(
                new CustomEvent(EVENT_TYPE.UPDATE_DEVICE, {
                    detail: {
                        actionResult,
                        deviceInfo: this.deviceInfo
                    }
                })
            );

            logger.warn(
                `hookStatusChange=${
                    hookStatusChange
                }, muteStatusChange=${
                    muteStatusChange
                }, needReply=${
                    needReply}`
            );
            if (needReply && (hookStatusChange || muteStatusChange)) {
                let newOffHook;

                if (this.deviceInfo.hookStatus === HOOK_STATUS.OFF) {
                    newOffHook = true;
                } else if (this.deviceInfo.hookStatus === HOOK_STATUS.ON) {
                    newOffHook = false;
                } else {
                    logger.warn('Invalid hook status');

                    return;
                }
                this.sendReplyReport(reportId, newOffHook, this.deviceInfo.muted);
            } else {
                logger.warn(`Not sending reply report: needReply ${needReply},
                hookStatusChange: ${hookStatusChange}, muteStatusChange: ${muteStatusChange}`);
            }
        } catch (e) {
            logger.error(e);
        }
    }

    /**
     * Extract action result.
     *
     * @private
     * @param {*} data -.
     * @returns {{eventName: string}} - EventName.
     */
    private extractActionResult(data: any) {
        switch (data.eventName) {
        case INPUT_REPORT_EVENT_NAME.ON_DEVICE_HOOK_SWITCH:
            return {
                eventName: data.hookStatus === HOOK_STATUS.ON
                    ? ACTION_HOOK_TYPE_NAME.HOOK_SWITCH_ON : ACTION_HOOK_TYPE_NAME.HOOK_SWITCH_OFF
            };
        case INPUT_REPORT_EVENT_NAME.ON_DEVICE_MUTE_SWITCH:
            return {
                eventName: data.isMute ? ACTION_HOOK_TYPE_NAME.MUTE_SWITCH_ON : ACTION_HOOK_TYPE_NAME.MUTE_SWITCH_OFF
            };
        case 'ondevicevolumechange':
            return {
                eventName: data.volumeStatus === 'up'
                    ? ACTION_HOOK_TYPE_NAME.VOLUME_CHANGE_UP : ACTION_HOOK_TYPE_NAME.VOLUME_CHANGE_DOWN
            };
        default:
            break;
        }
    }

    /**
     * Reset device state.
     *
     * @returns {void} -.
     */
    resetDeviceState() {
        if (!this.deviceInfo?.device || !this.deviceInfo?.device?.opened) {
            return;
        }

        this.deviceInfo.hookStatus = HOOK_STATUS.ON;
        this.deviceInfo.muted = false;
        this.deviceInfo.ring = false;
        this.deviceInfo.hold = false;

        this.sendDeviceReport({ command: COMMANDS.ON_HOOK });
        this.sendDeviceReport({ command: COMMANDS.MUTE_OFF });
    }

    /**
     * Parse input reports.
     *
     * @param {HIDReportInfo[]} inputReports -.
     * @returns {void} -.
     */
    private parseInputReports(inputReports: HIDReportInfo[]) {
        inputReports.forEach(report => {
            if (!report?.items?.length || report.reportId === undefined) {
                return;
            }

            let usageOffset = 0;

            report.items.forEach((item: HIDReportItem) => {
                if (
                    item.usages === undefined
                    || item.reportSize === undefined
                    || item.reportCount === undefined
                    || item.isAbsolute === undefined
                ) {
                    logger.warn('parseInputReports invalid parameters!');

                    return;
                }

                const reportSize = item.reportSize ?? 0;
                const reportId = report.reportId ?? 0;

                item.usages.forEach((usage: number, i: number) => {
                    switch (usage) {
                    case DEVICE_USAGE.hookSwitch.usageId:
                        this.deviceCommand.inputReport.hookSwitch = {
                            reportId,
                            usageOffset: usageOffset + (i * reportSize),
                            isAbsolute: item.isAbsolute ?? false
                        };
                        break;
                    case DEVICE_USAGE.phoneMute.usageId:
                        this.deviceCommand.inputReport.phoneMute = {
                            reportId,
                            usageOffset: usageOffset + (i * reportSize),
                            isAbsolute: item.isAbsolute ?? false
                        };
                        break;
                    default:
                        break;
                    }
                });

                usageOffset += item.reportCount * item.reportSize;
            });
        });

        if (!this.deviceCommand.inputReport.phoneMute || !this.deviceCommand.inputReport.hookSwitch) {
            logger.warn('parseInputReports - no phoneMute or hookSwitch. Skip. Returning false');

            return false;
        }

        return true;
    }

    /**
     * Parse output reports.
     *
     * @private
     * @param {HIDReportInfo[]} outputReports -.
     * @returns {void} -.
     */
    private parseOutputReports(outputReports: HIDReportInfo[]) {
        outputReports.forEach((report: HIDReportInfo) => {
            if (!report?.items?.length || report.reportId === undefined) {
                return;
            }

            let usageOffset = 0;
            const usageOffsetMap: Map<number, number> = new Map();

            report.items.forEach(item => {
                if (item.usages === undefined || item.reportSize === undefined || item.reportCount === undefined) {
                    logger.warn('parseOutputReports  invalid parameters!');

                    return;
                }

                const reportSize = item.reportSize ?? 0;
                const reportId = report.reportId ?? 0;

                item.usages.forEach((usage: number, i: number) => {
                    switch (usage) {
                    case DEVICE_USAGE.mute.usageId:
                        this.deviceCommand.outputReport.mute = {
                            reportId,
                            usageOffset: usageOffset + (i * reportSize)
                        };
                        usageOffsetMap.set(usage, usageOffset + (i * reportSize));
                        break;
                    case DEVICE_USAGE.offHook.usageId:
                        this.deviceCommand.outputReport.offHook = {
                            reportId,
                            usageOffset: usageOffset + (i * reportSize)
                        };
                        usageOffsetMap.set(usage, usageOffset + (i * reportSize));
                        break;
                    case DEVICE_USAGE.ring.usageId:
                        this.deviceCommand.outputReport.ring = {
                            reportId,
                            usageOffset: usageOffset + (i * reportSize)
                        };
                        usageOffsetMap.set(usage, usageOffset + (i * reportSize));
                        break;
                    case DEVICE_USAGE.hold.usageId:
                        this.deviceCommand.outputReport.hold = {
                            reportId,
                            usageOffset: usageOffset = i * reportSize
                        };
                        usageOffsetMap.set(usage, usageOffset + (i * reportSize));
                        break;
                    default:
                        break;
                    }
                });

                usageOffset += item.reportCount * item.reportSize;
            });

            const reportLength = usageOffset;

            for (const [ usage, offset ] of usageOffsetMap) {
                this.outputEventGenerators[usage] = (val: number) => {
                    const reportData = new Uint8Array(reportLength / 8);

                    if (offset >= 0 && val) {
                        const byteIndex = Math.trunc(offset / 8);
                        const bitPosition = offset % 8;

                        // eslint-disable-next-line no-bitwise
                        reportData[byteIndex] = 1 << bitPosition;
                    }

                    return reportData;
                };
            }
        });

        let hook, mute, ring;

        for (const item in this.outputEventGenerators) {
            if (Object.prototype.hasOwnProperty.call(this.outputEventGenerators, item)) {
                let newItem = this.getHexByte(item);

                newItem = `0x0${newItem}`;
                if (DEVICE_USAGE.mute.usageId === Number(newItem)) {
                    mute = this.outputEventGenerators[DEVICE_USAGE.mute.usageId];
                } else if (DEVICE_USAGE.offHook.usageId === Number(newItem)) {
                    hook = this.outputEventGenerators[DEVICE_USAGE.offHook.usageId];
                } else if (DEVICE_USAGE.ring.usageId === Number(newItem)) {
                    ring = this.outputEventGenerators[DEVICE_USAGE.ring.usageId];
                }
            }
        }
        if (!mute && !ring && !hook) {
            return false;
        }

        return true;
    }

    /**
     * Send device report.
     *
     * @param {{ command: string }} data -.
     * @returns {void} -.
     */
    async sendDeviceReport(data: { command: string; }) {
        if (!data?.command || !this.deviceInfo
            || !this.deviceInfo.device || !this.deviceInfo.device.opened || !this.isParseDescriptorsSuccess) {
            logger.warn('There are currently non-compliant conditions');

            return;
        }

        logger.warn(`sendDeviceReport data.command: ${data.command}`);

        if (data.command === COMMANDS.MUTE_ON || data.command === COMMANDS.MUTE_OFF) {
            if (!this.outputEventGenerators[DEVICE_USAGE.mute.usageId]) {
                logger.warn('current no parse mute event');

                return;
            }
        } else if (data.command === COMMANDS.ON_HOOK || data.command === COMMANDS.OFF_HOOK) {
            if (!this.outputEventGenerators[DEVICE_USAGE.offHook.usageId]) {
                logger.warn('current no parse offHook event');

                return;
            }
        } else if (data.command === COMMANDS.ON_RING || data.command === COMMANDS.OFF_RING) {
            if (!this.outputEventGenerators[DEVICE_USAGE.ring.usageId]) {
                logger.warn('current no parse ring event');

                return;
            }
        }

        let oldOffHook;
        let newOffHook;
        let newMuted;
        let newRing;
        let newHold;
        let offHookReport;
        let muteReport;
        let ringReport;
        let holdReport;
        let reportData = new Uint8Array();

        const reportId = this.matchReportId(data.command);

        if (reportId === 0) {
            logger.warn(`Unsupported command ${data.command}`);

            return;
        }

        /* keep old status. */
        const oldMuted = this.deviceInfo.muted;

        if (this.deviceInfo.hookStatus === HOOK_STATUS.OFF) {
            oldOffHook = true;
        } else if (this.deviceInfo.hookStatus === HOOK_STATUS.ON) {
            oldOffHook = false;
        } else {
            logger.warn('Invalid hook status');

            return;
        }

        const oldRing = this.deviceInfo.ring;
        const oldHold = this.deviceInfo.hold;

        logger.warn(
            `send device command: old_hook=${oldOffHook}, old_muted=${oldMuted}, old_ring=${oldRing}`
        );

        /* get new status. */
        switch (data.command) {
        case COMMANDS.MUTE_ON:
            newMuted = true;
            break;
        case COMMANDS.MUTE_OFF:
            newMuted = false;
            break;
        case COMMANDS.ON_HOOK:
            newOffHook = false;
            break;
        case COMMANDS.OFF_HOOK:
            newOffHook = true;
            break;
        case COMMANDS.ON_RING:
            newRing = true;
            break;
        case COMMANDS.OFF_RING:
            newRing = false;
            break;
        case COMMANDS.ON_HOLD:
            newHold = true;
            break;
        case COMMANDS.OFF_HOLD:
            newHold = false;
            break;
        default:
            logger.info(`Unknown command ${data.command}`);

            return;
        }
        logger.warn(
            `send device command: new_hook = ${newOffHook}, new_muted = ${newMuted},
             new_ring = ${newRing} new_hold = ${newHold}`
        );

        if (this.outputEventGenerators[DEVICE_USAGE.mute.usageId]) {
            if (newMuted === undefined) {
                muteReport = this.outputEventGenerators[DEVICE_USAGE.mute.usageId](oldMuted);
            } else {
                muteReport = this.outputEventGenerators[DEVICE_USAGE.mute.usageId](newMuted);
            }
        }

        if (this.outputEventGenerators[DEVICE_USAGE.offHook.usageId]) {
            if (newOffHook === undefined) {
                offHookReport = this.outputEventGenerators[DEVICE_USAGE.offHook.usageId](oldOffHook);
            } else {
                offHookReport = this.outputEventGenerators[DEVICE_USAGE.offHook.usageId](newOffHook);
            }
        }

        if (this.outputEventGenerators[DEVICE_USAGE.ring.usageId]) {
            if (newRing === undefined) {
                ringReport = this.outputEventGenerators[DEVICE_USAGE.ring.usageId](oldRing);
            } else {
                ringReport = this.outputEventGenerators[DEVICE_USAGE.ring.usageId](newRing);
            }
        }

        if (this.outputEventGenerators[DEVICE_USAGE.hold.usageId]) {
            holdReport = this.outputEventGenerators[DEVICE_USAGE.hold.usageId](oldHold);
        }

        if (reportId === this.deviceCommand.outputReport.mute.reportId) {
            reportData = new Uint8Array(muteReport);
        }

        if (reportId === this.deviceCommand.outputReport.offHook.reportId) {
            reportData = new Uint8Array(offHookReport);
        }

        if (reportId === this.deviceCommand.outputReport.ring.reportId) {
            reportData = new Uint8Array(ringReport);
        }

        if (reportId === this.deviceCommand.outputReport.hold.reportId) {
            reportData = new Uint8Array(holdReport);
        }

        logger.warn(`[sendDeviceReport] send device command (before call webhid API)
         ${data.command}: reportId=${reportId}, reportData=${reportData}`);
        logger.warn(`reportData is ${JSON.stringify(reportData, null, '    ')}`);
        await this.deviceInfo.device.sendReport(reportId, reportData);

        /* update new status. */
        this.updateDeviceStatus(data);
    }

    /**
     * Update device status.
     *
     * @private
     * @param {{ command: string; }} data -.
     * @returns {void}
     */
    private updateDeviceStatus(data: { command: string; }) {
        switch (data.command) {
        case COMMANDS.MUTE_ON:
            this.deviceInfo.muted = true;
            break;
        case COMMANDS.MUTE_OFF:
            this.deviceInfo.muted = false;
            break;
        case COMMANDS.ON_HOOK:
            this.deviceInfo.hookStatus = HOOK_STATUS.ON;
            break;
        case COMMANDS.OFF_HOOK:
            this.deviceInfo.hookStatus = HOOK_STATUS.OFF;
            break;
        case COMMANDS.ON_RING:
            this.deviceInfo.ring = true;
            break;
        case COMMANDS.OFF_RING:
            this.deviceInfo.ring = false;
            break;
        case COMMANDS.ON_HOLD:
            this.deviceInfo.hold = true;
            break;
        case 'offHold':
            this.deviceInfo.hold = false;
            break;
        default:
            logger.warn(`Unknown command ${data.command}`);
            break;
        }
        logger.warn(
            `[updateDeviceStatus] device status after send command: hook=${this.deviceInfo.hookStatus},
            muted=${this.deviceInfo.muted}, ring=${this.deviceInfo.ring}`
        );
    }

    /**
     * Math given command with known commands.
     *
     * @private
     * @param {string} command -.
     * @returns {number} ReportId.
     */
    private matchReportId(command: string) {
        switch (command) {
        case COMMANDS.MUTE_ON:
        case COMMANDS.MUTE_OFF:
            return this.deviceCommand.outputReport.mute.reportId;
        case COMMANDS.ON_HOOK:
        case COMMANDS.OFF_HOOK:
            return this.deviceCommand.outputReport.offHook.reportId;
        case COMMANDS.ON_RING:
        case COMMANDS.OFF_RING:
            return this.deviceCommand.outputReport.ring.reportId;
        case COMMANDS.ON_HOLD:
        case COMMANDS.OFF_HOLD:
            return this.deviceCommand.outputReport.hold.reportId;
        default:
            logger.info(`Unknown command ${command}`);

            return 0;
        }
    }

    /**
     * Send reply report to device.
     *
     * @param {number} inputReportId -.
     * @param {(string | boolean | undefined)} curOffHook -.
     * @param {(string | undefined)} curMuted -.
     * @returns {void} -.
     */
    private async sendReplyReport(
            inputReportId: number,
            curOffHook: string | boolean | undefined,
            curMuted: boolean | string | undefined
    ) {
        const reportId = this.retriveInputReportId(inputReportId);


        if (!this.deviceInfo?.device || !this.deviceInfo?.device?.opened) {
            logger.warn('[sendReplyReport] device is not opened or does not exist');

            return;
        }

        if (reportId === 0 || curOffHook === undefined || curMuted === undefined) {
            logger.warn(`[sendReplyReport] return, provided data not valid,
                reportId: ${reportId}, curOffHook: ${curOffHook}, curMuted: ${curMuted}`);

            return;
        }

        let reportData = new Uint8Array();
        let muteReport;
        let offHookReport;
        let ringReport;

        if (this.deviceCommand.outputReport.offHook.reportId === this.deviceCommand.outputReport.mute.reportId) {
            muteReport = this.outputEventGenerators[DEVICE_USAGE.mute.usageId](curMuted);
            offHookReport = this.outputEventGenerators[DEVICE_USAGE.offHook.usageId](curOffHook);
            reportData = new Uint8Array(offHookReport);
            for (const [ i, data ] of muteReport.entries()) {
                // eslint-disable-next-line no-bitwise
                reportData[i] |= data;
            }
        } else if (reportId === this.deviceCommand.outputReport.offHook.reportId) {
            offHookReport = this.outputEventGenerators[DEVICE_USAGE.offHook.usageId](curOffHook);
            reportData = new Uint8Array(offHookReport);
        } else if (reportId === this.deviceCommand.outputReport.mute.reportId) {
            muteReport = this.outputEventGenerators[DEVICE_USAGE.mute.usageId](curMuted);
            reportData = new Uint8Array(muteReport);
        } else if (reportId === this.deviceCommand.outputReport.ring.reportId) {
            ringReport = this.outputEventGenerators[DEVICE_USAGE.mute.usageId](curMuted);
            reportData = new Uint8Array(ringReport);
        }

        logger.warn(`[sendReplyReport] send device reply: reportId=${reportId}, reportData=${reportData}`);
        await this.deviceInfo.device.sendReport(reportId, reportData);
    }

    /**
     * Retrieve input report id.
     *
     * @private
     * @param {number} inputReportId -.
     * @returns {number} ReportId -.
     */
    private retriveInputReportId(inputReportId: number) {
        let reportId = 0;

        if (this.deviceCommand.outputReport.offHook.reportId === this.deviceCommand.outputReport.mute.reportId) {
            reportId = this.deviceCommand.outputReport.offHook.reportId;
        } else if (inputReportId === this.deviceCommand.inputReport.hookSwitch.reportId) {
            reportId = this.deviceCommand.outputReport.offHook.reportId;
        } else if (inputReportId === this.deviceCommand.inputReport.phoneMute.reportId) {
            reportId = this.deviceCommand.outputReport.mute.reportId;
        }

        return reportId;
    }

    /**
     * Get the hexadecimal bytes.
     *
     * @param {number|string} data -.
     * @returns {string}
     */
    getHexByte(data: number | string) {
        let hex = Number(data).toString(16);

        while (hex.length < 2) {
            hex = `0${hex}`;
        }

        return hex;
    }
}


################################################################################

## File: .\jitsi-meet\react\features\welcome\functions.ts

import { IStateful } from '../base/app/types';
import { WELCOME_PAGE_ENABLED } from '../base/flags/constants';
import { getFeatureFlag } from '../base/flags/functions';
import { toState } from '../base/redux/functions';


/**
 * Determines whether the {@code WelcomePage} is enabled.
 *
 * @param {IStateful} stateful - The redux state or {@link getState}
 * function.
 * @returns {boolean} If the {@code WelcomePage} is enabled by the app, then
 * {@code true}; otherwise, {@code false}.
 */
export function isWelcomePageEnabled(stateful: IStateful) {
    if (navigator.product === 'ReactNative') {
        return getFeatureFlag(stateful, WELCOME_PAGE_ENABLED, false);
    }

    const config = toState(stateful)['features/base/config'];

    return !config.welcomePage?.disabled;
}

/**
 * Returns the configured custom URL (if any) to redirect to instead of the normal landing page.
 *
 * @param {IStateful} stateful - The redux state or {@link getState}.
 * @returns {string} - The custom URL.
 */
export function getCustomLandingPageURL(stateful: IStateful) {
    return toState(stateful)['features/base/config'].welcomePage?.customUrl;
}


################################################################################

## File: .\jitsi-meet\react\features\welcome\components\AbstractWelcomePage.ts

// @ts-expect-error
import { generateRoomWithoutSeparator } from '@jitsi/js-utils/random';
import { Component } from 'react';
import { WithTranslation } from 'react-i18next';

import { createWelcomePageEvent } from '../../analytics/AnalyticsEvents';
import { sendAnalytics } from '../../analytics/functions';
import { appNavigate } from '../../app/actions';
import { IReduxState, IStore } from '../../app/types';
import { IDeeplinkingConfig } from '../../base/config/configType';
import isInsecureRoomName from '../../base/util/isInsecureRoomName';
import { isCalendarEnabled } from '../../calendar-sync/functions';
import { isUnsafeRoomWarningEnabled } from '../../prejoin/functions';
import { isRecentListEnabled } from '../../recent-list/functions';

/**
 * {@code AbstractWelcomePage}'s React {@code Component} prop types.
 */
export interface IProps extends WithTranslation {

    /**
     * Whether the calendar functionality is enabled or not.
     */
    _calendarEnabled: boolean;

    /**
     * The deeplinking config.
     */
    _deeplinkingCfg: IDeeplinkingConfig;

    /**
     * Whether the insecure room name functionality is enabled or not.
     */
    _enableInsecureRoomNameWarning: boolean;

    /**
     * URL for the moderated rooms microservice, if available.
     */
    _moderatedRoomServiceUrl?: string;

    /**
     * Whether the recent list is enabled.
     */
    _recentListEnabled: Boolean;

    /**
     * Room name to join to.
     */
    _room: string;

    /**
     * The current settings.
     */
    _settings: Object;

    /**
     * The Redux dispatch Function.
     */
    dispatch: IStore['dispatch'];
}

interface IState {
    _fieldFocused?: boolean;
    animateTimeoutId?: number;
    generateRoomNames?: string;
    generatedRoomName: string;
    hintBoxAnimation?: any;
    insecureRoomName: boolean;
    isSettingsScreenFocused?: boolean;
    joining: boolean;
    room: string;
    roomNameInputAnimation?: any;
    roomPlaceholder: string;
    updateTimeoutId?: number;
}

/**
 * Base (abstract) class for container component rendering the welcome page.
 *
 * @abstract
 */
export class AbstractWelcomePage<P extends IProps> extends Component<P, IState> {
    _mounted: boolean | undefined;

    /**
     * Save room name into component's local state.
     *
     * @type {Object}
     * @property {number|null} animateTimeoutId - Identifier of the letter
     * animation timeout.
     * @property {string} generatedRoomName - Automatically generated room name.
     * @property {string} room - Room name.
     * @property {string} roomPlaceholder - Room placeholder that's used as a
     * placeholder for input.
     * @property {number|null} updateTimeoutId - Identifier of the timeout
     * updating the generated room name.
     */
    state: IState = {
        animateTimeoutId: undefined,
        generatedRoomName: '',
        generateRoomNames: undefined,
        insecureRoomName: false,
        joining: false,
        room: '',
        roomPlaceholder: '',
        updateTimeoutId: undefined,
        _fieldFocused: false,
        isSettingsScreenFocused: false,
        roomNameInputAnimation: 0,
        hintBoxAnimation: 0
    };

    /**
     * Initializes a new {@code AbstractWelcomePage} instance.
     *
     * @param {Props} props - The React {@code Component} props to initialize
     * the new {@code AbstractWelcomePage} instance with.
     */
    constructor(props: P) {
        super(props);

        // Bind event handlers so they are only bound once per instance.
        this._animateRoomNameChanging
            = this._animateRoomNameChanging.bind(this);
        this._onJoin = this._onJoin.bind(this);
        this._onRoomChange = this._onRoomChange.bind(this);
        this._renderInsecureRoomNameWarning = this._renderInsecureRoomNameWarning.bind(this);
        this._updateRoomName = this._updateRoomName.bind(this);
    }

    /**
     * Implements React's {@link Component#componentDidMount()}. Invoked
     * immediately after mounting occurs.
     *
     * @inheritdoc
     */
    componentDidMount() {
        this._mounted = true;
        sendAnalytics(createWelcomePageEvent('viewed', undefined, { value: 1 }));
    }

    /**
     * Implements React's {@link Component#componentWillUnmount()}. Invoked
     * immediately before this component is unmounted and destroyed.
     *
     * @inheritdoc
     */
    componentWillUnmount() {
        this._clearTimeouts();
        this._mounted = false;
    }

    /**
     * Animates the changing of the room name.
     *
     * @param {string} word - The part of room name that should be added to
     * placeholder.
     * @private
     * @returns {void}
     */
    _animateRoomNameChanging(word: string) {
        let animateTimeoutId;
        const roomPlaceholder = this.state.roomPlaceholder + word.substr(0, 1);

        if (word.length > 1) {
            animateTimeoutId
                = window.setTimeout(
                    () => {
                        this._animateRoomNameChanging(
                            word.substring(1, word.length));
                    },
                    70);
        }
        this.setState({
            animateTimeoutId,
            roomPlaceholder
        });
    }

    /**
     * Method that clears timeouts for animations and updates of room name.
     *
     * @private
     * @returns {void}
     */
    _clearTimeouts() {
        this.state.animateTimeoutId && clearTimeout(this.state.animateTimeoutId);
        this.state.updateTimeoutId && clearTimeout(this.state.updateTimeoutId);
    }

    /**
     * Renders the insecure room name warning.
     *
     * @returns {ReactElement}
     */
    _doRenderInsecureRoomNameWarning(): JSX.Element | null {
        return null;
    }

    /**
     * Handles joining. Either by clicking on 'Join' button
     * or by pressing 'Enter' in room name input field.
     *
     * @protected
     * @returns {void}
     */
    _onJoin() {
        const room = this.state.room || this.state.generatedRoomName;

        sendAnalytics(
            createWelcomePageEvent('clicked', 'joinButton', {
                isGenerated: !this.state.room,
                room
            }));

        if (room) {
            this.setState({ joining: true });

            // By the time the Promise of appNavigate settles, this component
            // may have already been unmounted.
            const onAppNavigateSettled
                = () => this._mounted && this.setState({ joining: false });

            this.props.dispatch(appNavigate(room))
                .then(onAppNavigateSettled, onAppNavigateSettled);
        }
    }

    /**
     * Handles 'change' event for the room name text input field.
     *
     * @param {string} value - The text typed into the respective text input
     * field.
     * @protected
     * @returns {void}
     */
    _onRoomChange(value: string) {
        this.setState({
            room: value,
            insecureRoomName: Boolean(this.props._enableInsecureRoomNameWarning && value && isInsecureRoomName(value))
        });
    }

    /**
     * Renders the insecure room name warning if needed.
     *
     * @returns {ReactElement}
     */
    _renderInsecureRoomNameWarning() {
        if (this.props._enableInsecureRoomNameWarning && this.state.insecureRoomName) {
            return this._doRenderInsecureRoomNameWarning();
        }

        return null;
    }

    /**
     * Triggers the generation of a new room name and initiates an animation of
     * its changing.
     *
     * @protected
     * @returns {void}
     */
    _updateRoomName() {
        const generatedRoomName = generateRoomWithoutSeparator();
        const roomPlaceholder = '';
        const updateTimeoutId = window.setTimeout(this._updateRoomName, 10000);

        this._clearTimeouts();
        this.setState(
            {
                generatedRoomName,
                roomPlaceholder,
                updateTimeoutId
            },
            () => this._animateRoomNameChanging(generatedRoomName));
    }
}

/**
 * Maps (parts of) the redux state to the React {@code Component} props of
 * {@code AbstractWelcomePage}.
 *
 * @param {Object} state - The redux state.
 * @protected
 * @returns {IProps}
 */
export function _mapStateToProps(state: IReduxState) {
    return {
        _calendarEnabled: isCalendarEnabled(state),
        _deeplinkingCfg: state['features/base/config'].deeplinking || {},
        _enableInsecureRoomNameWarning: isUnsafeRoomWarningEnabled(state),
        _moderatedRoomServiceUrl: state['features/base/config'].moderatedRoomServiceUrl,
        _recentListEnabled: isRecentListEnabled(),
        _room: state['features/base/conference'].room ?? '',
        _settings: state['features/base/settings']
    };
}


################################################################################

## File: .\jitsi-meet\react\features\welcome\components\BlankPage.web.ts

export default undefined;


################################################################################

## File: .\jitsi-meet\react\features\welcome\components\styles.native.ts

import { StyleSheet } from 'react-native';

import { BoxModel } from '../../base/styles/components/styles/BoxModel';
import BaseTheme from '../../base/ui/components/BaseTheme.native';

export const AVATAR_SIZE = 104;

/**
 * The default color of text on the WelcomePage.
 */
const TEXT_COLOR = BaseTheme.palette.text01;

/**
 * The styles of the React {@code Components} of the feature welcome including
 * {@code WelcomePage} and {@code BlankPage}.
 */
export default {

    blankPageText: {
        color: TEXT_COLOR,
        fontSize: 18
    },

    /**
     * View that is rendered when there is no welcome page.
     */
    blankPageWrapper: {
        ...StyleSheet.absoluteFillObject,
        alignItems: 'center',
        backgroundColor: BaseTheme.palette.uiBackground,
        flex: 1,
        flexDirection: 'column',
        justifyContent: 'center'
    },

    /**
     * Join button style.
     */
    button: {
        backgroundColor: BaseTheme.palette.action01,
        borderColor: BaseTheme.palette.action01,
        borderRadius: BaseTheme.shape.borderRadius,
        borderWidth: 1,
        height: BaseTheme.spacing[7],
        justifyContent: 'center',
        paddingHorizontal: BaseTheme.spacing[4]
    },

    joinButtonLabel: {
        textTransform: 'uppercase'
    },

    joinButtonText: {
        alignSelf: 'center',
        color: BaseTheme.palette.text01,
        fontSize: 14
    },

    enterRoomText: {
        color: TEXT_COLOR,
        fontSize: 18,
        marginBottom: BoxModel.margin
    },

    /**
     * Container for the button on the hint box.
     */
    hintButtonContainer: {
        flexDirection: 'row',
        justifyContent: 'center'
    },

    /**
     * Container for the hint box.
     */
    hintContainer: {
        flexDirection: 'column',
        overflow: 'hidden'
    },

    /**
     * The text of the hint box.
     */
    hintText: {
        color: BaseTheme.palette.text01,
        textAlign: 'center'
    },

    /**
     * Container for the text on the hint box.
     */
    hintTextContainer: {
        marginBottom: 2 * BoxModel.margin
    },

    /**
     * Container for the items in the side bar.
     */
    itemContainer: {
        flexDirection: 'column',
        paddingTop: 10
    },

    /**
     * A view that contains the field and hint box.
     */
    joinControls: {
        padding: BoxModel.padding
    },

    messageContainer: {
        backgroundColor: BaseTheme.palette.ui03,
        borderRadius: BaseTheme.shape.borderRadius,
        marginVertical: BaseTheme.spacing[1],
        paddingHorizontal: BaseTheme.spacing[2],
        paddingVertical: 2 * BaseTheme.spacing[2]
    },

    roomNameInputContainer: {
        height: '0%'
    },

    /**
     * Top-level screen style.
     */
    page: {
        flex: 1,
        flexDirection: 'column'
    },

    /**
     * The styles for reduced UI mode.
     */
    reducedUIContainer: {
        alignItems: 'center',
        backgroundColor: BaseTheme.palette.link01,
        flex: 1,
        justifyContent: 'center'
    },

    reducedUIText: {
        color: TEXT_COLOR,
        fontSize: 12
    },

    /**
     * Container for room name input box and 'join' button.
     */
    roomContainer: {
        alignSelf: 'stretch',
        flexDirection: 'column',
        marginHorizontal: BaseTheme.spacing[2]
    },

    /**
     * The container of the label of the audio-video switch.
     */
    switchLabel: {
        paddingHorizontal: 3
    },

    /**
     * Room input style.
     */
    textInput: {
        backgroundColor: 'transparent',
        borderColor: BaseTheme.palette.ui10,
        borderRadius: 4,
        borderWidth: 1,
        color: TEXT_COLOR,
        fontSize: 23,
        height: 50,
        padding: 4,
        textAlign: 'center'
    },

    /**
     * Application title style.
     */
    title: {
        color: TEXT_COLOR,
        fontSize: 25,
        marginBottom: 2 * BoxModel.margin,
        textAlign: 'center'
    },

    insecureRoomNameWarningContainer: {
        alignItems: 'center',
        flexDirection: 'row',
        paddingHorizontal: BaseTheme.spacing[1]
    },

    insecureRoomNameWarningIcon: {
        color: BaseTheme.palette.warning02,
        fontSize: 24,
        marginRight: 10
    },

    insecureRoomNameWarningText: {
        color: BaseTheme.palette.text01,
        flex: 1
    },

    /**
     * The style of the top-level container of {@code WelcomePage}.
     */
    welcomePage: {
        backgroundColor: BaseTheme.palette.uiBackground,
        flex: 1,
        overflow: 'hidden'
    },

    customInput: {
        fontSize: 18,
        letterSpacing: 0,
        textAlign: 'center'
    },

    recentList: {
        backgroundColor: BaseTheme.palette.uiBackground,
        flex: 1,
        overflow: 'hidden'
    },

    recentListDisabled: {
        backgroundColor: BaseTheme.palette.uiBackground,
        flex: 1,
        opacity: 0.8,
        overflow: 'hidden'
    }
};


################################################################################

## File: .\jitsi-meet\react\features\whiteboard\actions.any.ts

import { IStore } from '../app/types';
import { showWarningNotification } from '../notifications/actions';
import { NOTIFICATION_TIMEOUT_TYPE } from '../notifications/constants';

import {
    RESET_WHITEBOARD,
    SETUP_WHITEBOARD,
    SET_WHITEBOARD_OPEN
} from './actionTypes';
import { IWhiteboardAction } from './reducer';

/**
 * Configures the whiteboard collaboration details.
 *
 * @param {Object} payload - The whiteboard settings.
 * @returns {{
 *     type: SETUP_WHITEBOARD,
 *     collabDetails: { roomId: string, roomKey: string },
 *     collabServerUrl: string
 * }}
 */
export const setupWhiteboard = ({ collabDetails, collabServerUrl }: {
    collabDetails: { roomId: string; roomKey: string; };
    collabServerUrl?: string;
}): IWhiteboardAction => {
    return {
        type: SETUP_WHITEBOARD,
        collabDetails,
        collabServerUrl
    };
};

/**
 * Cleans up the whiteboard collaboration settings.
 * To be used only on native for cleanup in between conferences.
 *
 * @returns {{
 *     type: RESET_WHITEBOARD
 * }}
 */
export const resetWhiteboard = (): IWhiteboardAction => {
    return { type: RESET_WHITEBOARD };
};

/**
 * Sets the whiteboard visibility status.
 *
 * @param {boolean} isOpen - The whiteboard visibility flag.
 * @returns {{
 *      type: SET_WHITEBOARD_OPEN,
 *      isOpen
 * }}
 */
export const setWhiteboardOpen = (isOpen: boolean): IWhiteboardAction => {
    return {
        type: SET_WHITEBOARD_OPEN,
        isOpen
    };
};

/**
 * Shows a warning notification about the whiteboard user limit.
 *
 * @returns {Function}
 */
export const notifyWhiteboardLimit = () => (dispatch: IStore['dispatch']) => {
    dispatch(showWarningNotification({
        titleKey: 'notify.whiteboardLimitTitle',
        descriptionKey: 'notify.whiteboardLimitDescription'
    }, NOTIFICATION_TIMEOUT_TYPE.LONG));
};


################################################################################

## File: .\jitsi-meet\react\features\whiteboard\actions.native.ts

import { createRestrictWhiteboardEvent } from '../analytics/AnalyticsEvents';
import { sendAnalytics } from '../analytics/functions';
import { IStore } from '../app/types';
import {
    navigate
} from '../mobile/navigation/components/conference/ConferenceNavigationContainerRef';
import { screen } from '../mobile/navigation/routes';


import { resetWhiteboard } from './actions.any';

export * from './actions.any';

/**
 * Restricts the whiteboard usage.
 *
 * @param {boolean} shouldCloseWhiteboard - Whether to dismiss the whiteboard.
 * @returns {Function}
 */
export const restrictWhiteboard = (shouldCloseWhiteboard = true) => (dispatch: IStore['dispatch']) => {
    if (shouldCloseWhiteboard) {
        navigate(screen.conference.root);
    }
    dispatch(resetWhiteboard());
    sendAnalytics(createRestrictWhiteboardEvent());
};


################################################################################

## File: .\jitsi-meet\react\features\whiteboard\actions.web.ts

import { createRestrictWhiteboardEvent } from '../analytics/AnalyticsEvents';
import { sendAnalytics } from '../analytics/functions';
import { IStore } from '../app/types';

import { resetWhiteboard, setWhiteboardOpen } from './actions.any';
import { isWhiteboardAllowed, isWhiteboardOpen, isWhiteboardVisible } from './functions';
import { WhiteboardStatus } from './types';

export * from './actions.any';

/**
 * API to toggle the whiteboard.
 *
 * @returns {Function}
 */
export function toggleWhiteboard() {
    return (dispatch: IStore['dispatch'], getState: IStore['getState']) => {
        const state = getState();
        const isAllowed = isWhiteboardAllowed(state);
        const isOpen = isWhiteboardOpen(state);

        if (isAllowed) {
            if (isOpen && !isWhiteboardVisible(state)) {
                dispatch(setWhiteboardOpen(true));
            } else if (isOpen && isWhiteboardVisible(state)) {
                dispatch(setWhiteboardOpen(false));
            } else if (!isOpen) {
                dispatch(setWhiteboardOpen(true));
            }
        } else if (typeof APP !== 'undefined') {
            APP.API.notifyWhiteboardStatusChanged(WhiteboardStatus.FORBIDDEN);
        }
    };
}

/**
 * Restricts the whiteboard usage.
 *
 * @param {boolean} shouldCloseWhiteboard - Whether to dismiss the whiteboard.
 * @returns {Function}
 */
export const restrictWhiteboard = (shouldCloseWhiteboard = true) => (dispatch: IStore['dispatch']) => {
    if (shouldCloseWhiteboard) {
        dispatch(setWhiteboardOpen(false));
    }
    dispatch(resetWhiteboard());
    sendAnalytics(createRestrictWhiteboardEvent());
};


################################################################################

## File: .\jitsi-meet\react\features\whiteboard\actionTypes.ts

/**
 * Close the whiteboard collaboration session.
 * {{
 *      type: RESET_WHITEBOARD
 * }}
 */
export const RESET_WHITEBOARD: string = 'RESET_WHITEBOARD';

/**
 * Configure the whiteboard collaboration details.
 * {{
 *      type: SETUP_WHITEBOARD,
 *      collabDetails
 * }}
 */
 export const SETUP_WHITEBOARD: string = 'SETUP_WHITEBOARD';

/**
 * Sets the whiteboard visibility state.
 * {{
 *      type: SET_WHITEBOARD_OPEN,
 *      isOpen
 * }}
 */
export const SET_WHITEBOARD_OPEN: string = 'SET_WHITEBOARD_OPEN';


################################################################################

## File: .\jitsi-meet\react\features\whiteboard\constants.ts

/**
 * Fixed name of the whiteboard fake participant.
 */
export const WHITEBOARD_PARTICIPANT_NAME = 'Whiteboard';

/**
 * Whiteboard ID.
 */
export const WHITEBOARD_ID = 'whiteboard';

/**
 * Whiteboard UI Options.
 */
export const WHITEBOARD_UI_OPTIONS = {
    canvasActions: {
        allowedShapes: [
            'arrow', 'diamond', 'ellipse', 'freedraw', 'line', 'rectangle', 'selection', 'text'
        ],
        allowedShortcuts: [
            'cut', 'deleteSelectedElements', 'redo', 'selectAll', 'undo'
        ],
        disableAlignItems: true,
        disableFileDrop: true,
        disableGrouping: true,
        disableHints: true,
        disableLink: true,
        disableShortcuts: true,
        disableVerticalAlignOptions: true,
        fontSizeOptions: [ 's', 'm', 'l' ],
        hideArrowHeadsOptions: true,
        hideColorInput: true,
        hideClearCanvas: true,
        hideFontFamily: true,
        hideHelpDialog: true,
        hideIOActions: true,
        hideLayers: true,
        hideLibraries: true,
        hideLockButton: true,
        hideOpacityInput: true,
        hideSharpness: true,
        hideStrokeStyle: true,
        hideTextAlign: true,
        hideThemeControls: true,
        hideUserList: true,
        saveAsImageOptions: {
            defaultBackgroundValue: true,
            disableScale: true,
            disableSelection: true,
            disableClipboard: true,
            disableSceneEmbed: true,
            hideTheme: true
        }
    }
};

/**
 * Whiteboard default lower limit.
 */
export const MIN_USER_LIMIT = 10;

/**
 * Whiteboard soft limit diff.
 */
export const USER_LIMIT_THRESHOLD = 5;

/**
 * The pathName for the whiteboard page.
 *
 * @type {string}
 */
export const WHITEBOARD_PATH_NAME = 'static/whiteboard.html';


################################################################################

## File: .\jitsi-meet\react\features\whiteboard\functions.ts

import md5 from 'js-md5';

import { getParticipantCount, getPinnedParticipant } from '../../features/base/participants/functions';
import { IReduxState } from '../app/types';
import { getCurrentConference } from '../base/conference/functions';
import { IWhiteboardConfig } from '../base/config/configType';
import { getRemoteParticipants, isLocalParticipantModerator } from '../base/participants/functions';
import { encodeToBase64URL } from '../base/util/httpUtils';
import { appendURLHashParam, appendURLParam, getBackendSafePath } from '../base/util/uri';
import { getCurrentRoomId, isInBreakoutRoom } from '../breakout-rooms/functions';

import { MIN_USER_LIMIT, USER_LIMIT_THRESHOLD, WHITEBOARD_ID, WHITEBOARD_PATH_NAME } from './constants';
import { IWhiteboardState } from './reducer';

const getWhiteboardState = (state: IReduxState): IWhiteboardState => state['features/whiteboard'];

export const getWhiteboardConfig = (state: IReduxState): IWhiteboardConfig =>
    state['features/base/config'].whiteboard || {};

const getWhiteboardUserLimit = (state: IReduxState): number => {
    const userLimit = getWhiteboardConfig(state).userLimit || Infinity;

    return userLimit === Infinity
        ? userLimit
        : Math.max(Number(getWhiteboardConfig(state).userLimit || 1), MIN_USER_LIMIT);
};

/**
 * Returns the whiteboard collaboration details.
 *
 * @param {IReduxState} state - The state from the Redux store.
 * @returns {{ roomId: string, roomKey: string}|undefined}
 */
export const getCollabDetails = (state: IReduxState): {
    roomId: string; roomKey: string;
} | undefined => getWhiteboardState(state).collabDetails;

/**
 * Indicates whether the whiteboard collaboration details are available.
 *
 * @param {IReduxState} state - The state from the Redux store.
 * @returns {boolean}
 */
const hasCollabDetails = (state: IReduxState): boolean => Boolean(
    getCollabDetails(state)?.roomId && getCollabDetails(state)?.roomKey
);

/**
 * Indicates whether the whiteboard is enabled.
 *
 * @param {IReduxState} state - The state from the Redux store.
 * @returns {boolean}
 */
export const isWhiteboardEnabled = (state: IReduxState): boolean =>
    (getWhiteboardConfig(state).enabled || hasCollabDetails(state))
    && getWhiteboardConfig(state).collabServerBaseUrl
    && getCurrentConference(state)?.getMetadataHandler()
?.isSupported();

/**
 * Indicates whether the whiteboard is open.
 *
 * @param {IReduxState} state - The state from the Redux store.
 * @returns {boolean}
 */
export const isWhiteboardOpen = (state: IReduxState): boolean => getWhiteboardState(state).isOpen;

/**
 * Indicates whether the whiteboard button is visible.
 *
 * @param {IReduxState} state - The state from the Redux store.
 * @returns {boolean}
 */
export const isWhiteboardButtonVisible = (state: IReduxState): boolean =>
    isWhiteboardEnabled(state) && (isLocalParticipantModerator(state) || isWhiteboardOpen(state));

/**
 * Indicates whether the whiteboard is present as a meeting participant.
 *
 * @param {IReduxState} state - The state from the Redux store.
 * @returns {boolean}
 */
export const isWhiteboardPresent = (state: IReduxState): boolean => getRemoteParticipants(state).has(WHITEBOARD_ID);

/**
 * Builds the whiteboard collaboration server url.
 *
 * @param {IReduxState} state - The state from the Redux store.
 * @returns {string}
 */
export const generateCollabServerUrl = (state: IReduxState): string | undefined => {
    const collabServerBaseUrl = getWhiteboardConfig(state).collabServerBaseUrl;

    if (!collabServerBaseUrl) {
        return;
    }

    const { locationURL } = state['features/base/connection'];
    const inBreakoutRoom = isInBreakoutRoom(state);
    const roomId = getCurrentRoomId(state);
    const room = md5.hex(
        `${locationURL?.origin}${getBackendSafePath(locationURL?.pathname)}${inBreakoutRoom ? `|${roomId}` : ''}`
    );

    return appendURLParam(collabServerBaseUrl, 'room', room);
};

/**
 * Returns the whiteboard collaboration server url.
 *
 * @param {IReduxState} state - The state from the Redux store.
 * @returns {string}
 */
export const getCollabServerUrl = (state: IReduxState): string | undefined =>
    getWhiteboardState(state).collabServerUrl;

/**
 * Whether the whiteboard is visible on stage.
 *
 * @param {IReduxState} state - The state from the Redux store.
 * @returns {boolean}
 */
export const isWhiteboardVisible = (state: IReduxState): boolean =>
    getPinnedParticipant(state)?.id === WHITEBOARD_ID
    || state['features/large-video'].participantId === WHITEBOARD_ID;

/**
* Indicates whether the whiteboard is accessible to a participant that has a moderator role.
*
* @param {IReduxState} state - The state from the Redux store.
* @returns {boolean}
*/
export const isWhiteboardAllowed = (state: IReduxState): boolean =>
    isWhiteboardEnabled(state) && isLocalParticipantModerator(state);

/**
 * Whether to enforce the whiteboard user limit.
 *
 * @param {IReduxState} state - The state from the Redux store.
 * @returns {boolean}
 */
export const shouldEnforceUserLimit = (state: IReduxState): boolean => {
    const userLimit = getWhiteboardUserLimit(state);

    if (userLimit === Infinity) {
        return false;
    }

    const participantCount = getParticipantCount(state);

    return participantCount > userLimit;
};

/**
 * Whether to show a warning about the whiteboard user limit.
 *
 * @param {IReduxState} state - The state from the Redux store.
 * @returns {boolean}
 */
export const shouldNotifyUserLimit = (state: IReduxState): boolean => {
    const userLimit = getWhiteboardUserLimit(state);

    if (userLimit === Infinity) {
        return false;
    }

    const participantCount = getParticipantCount(state);

    return participantCount + USER_LIMIT_THRESHOLD > userLimit;
};

/**
 * Generates the URL for the static whiteboard page.
 *
 * @param {string} locationUrl - The window location href.
 * @param {string} collabServerUrl - The whiteboard collaboration server url.
 * @param {Object} collabDetails - The whiteboard collaboration details.
 * @param {string} localParticipantName - The local participant name.
 * @returns {string}
 */
export function getWhiteboardInfoForURIString(
        locationUrl: any,
        collabServerUrl: string,
        collabDetails: { roomId: string; roomKey: string; },
        localParticipantName: string
): string | undefined {
    if (!collabServerUrl || !locationUrl) {
        return undefined;
    }

    let state = {};
    let url = `${locationUrl.substring(0, locationUrl.lastIndexOf('/'))}/${WHITEBOARD_PATH_NAME}`;

    if (collabDetails?.roomId) {
        state = {
            ...state,
            roomId: collabDetails.roomId
        };
    }

    if (collabDetails?.roomKey) {
        state = {
            ...state,
            roomKey: collabDetails.roomKey
        };
    }

    state = {
        ...state,
        collabServerUrl,
        localParticipantName
    };

    url = appendURLHashParam(url, 'state', encodeToBase64URL(JSON.stringify(state)));

    return url;
}


################################################################################

## File: .\jitsi-meet\react\features\whiteboard\hooks.ts

import { useSelector } from 'react-redux';

import WhiteboardButton from './components/web/WhiteboardButton';
import { isWhiteboardButtonVisible } from './functions';

const whiteboard = {
    key: 'whiteboard',
    Content: WhiteboardButton,
    group: 3
};

/**
 * A hook that returns the whiteboard button if it is enabled and undefined otherwise.
 *
 *  @returns {Object | undefined}
 */
export function useWhiteboardButton() {
    const _isWhiteboardButtonVisible = useSelector(isWhiteboardButtonVisible);

    if (_isWhiteboardButtonVisible) {
        return whiteboard;
    }
}


################################################################################

## File: .\jitsi-meet\react\features\whiteboard\logger.ts

import { getLogger } from '../base/logging/functions';

export default getLogger('features/whiteboard');


################################################################################

## File: .\jitsi-meet\react\features\whiteboard\middleware.any.ts

import { createOpenWhiteboardEvent } from '../analytics/AnalyticsEvents';
import { sendAnalytics } from '../analytics/functions';
import { IStore } from '../app/types';
import { UPDATE_CONFERENCE_METADATA } from '../base/conference/actionTypes';
import { getCurrentConference } from '../base/conference/functions';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import StateListenerRegistry from '../base/redux/StateListenerRegistry';

import { SET_WHITEBOARD_OPEN } from './actionTypes';
import {
    notifyWhiteboardLimit,
    resetWhiteboard,
    restrictWhiteboard,
    setWhiteboardOpen,
    setupWhiteboard
} from './actions';
import { WHITEBOARD_ID } from './constants';
import {
    generateCollabServerUrl,
    isWhiteboardOpen,
    shouldEnforceUserLimit,
    shouldNotifyUserLimit
} from './functions';

MiddlewareRegistry.register((store: IStore) => next => action => {
    const state = store.getState();

    switch (action.type) {
    case SET_WHITEBOARD_OPEN: {
        const enforceUserLimit = shouldEnforceUserLimit(state);
        const notifyUserLimit = shouldNotifyUserLimit(state);

        if (action.isOpen && !enforceUserLimit && !notifyUserLimit) {
            sendAnalytics(createOpenWhiteboardEvent());

            return next(action);
        }

        break;
    }

    case UPDATE_CONFERENCE_METADATA: {
        const { metadata } = action;

        if (metadata?.[WHITEBOARD_ID]) {
            store.dispatch(setupWhiteboard({
                collabDetails: metadata[WHITEBOARD_ID].collabDetails,
                collabServerUrl: generateCollabServerUrl(store.getState())
            }));
            store.dispatch(setWhiteboardOpen(true));
        }

        break;
    }
    }

    return next(action);
});

/**
 * Set up state change listener to perform maintenance tasks when the conference
 * is left or failed, e.g. Disable the whiteboard if it's left open.
 */
StateListenerRegistry.register(
    state => getCurrentConference(state),
    (conference, { dispatch }, previousConference): void => {
        if (conference !== previousConference) {
            dispatch(resetWhiteboard());
        }
    });

/**
 * Set up state change listener to limit whiteboard access.
 */
StateListenerRegistry.register(
    state => shouldEnforceUserLimit(state),
    (enforceUserLimit, { dispatch, getState }): void => {
        if (isWhiteboardOpen(getState()) && enforceUserLimit) {
            dispatch(restrictWhiteboard());
        }
    }
);

/**
 * Set up state change listener to notify about whiteboard usage.
 */
StateListenerRegistry.register(
    state => shouldNotifyUserLimit(state),
    (notifyUserLimit, { dispatch, getState }, prevNotifyUserLimit): void => {
        if (isWhiteboardOpen(getState()) && notifyUserLimit && !prevNotifyUserLimit) {
            dispatch(notifyWhiteboardLimit());
        }
    }
);


################################################################################

## File: .\jitsi-meet\react\features\whiteboard\middleware.native.ts

import { AnyAction } from 'redux';

import { IStore } from '../app/types';
import { hideDialog, openDialog } from '../base/dialog/actions';
import { isDialogOpen } from '../base/dialog/functions';
import { getLocalParticipant } from '../base/participants/functions';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import {
    navigate
} from '../mobile/navigation/components/conference/ConferenceNavigationContainerRef';
import { screen } from '../mobile/navigation/routes';

import { SET_WHITEBOARD_OPEN } from './actionTypes';
import {
    notifyWhiteboardLimit,
    restrictWhiteboard
} from './actions';
import WhiteboardLimitDialog from './components/native/WhiteboardLimitDialog';
import {
    generateCollabServerUrl,
    getCollabDetails,
    shouldEnforceUserLimit,
    shouldNotifyUserLimit
} from './functions';
import './middleware.any';

/**
 * Middleware which intercepts whiteboard actions to handle changes to the related state.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register((store: IStore) => (next: Function) => (action: AnyAction) => {
    const { dispatch, getState } = store;
    const state = getState();

    switch (action.type) {
    case SET_WHITEBOARD_OPEN: {
        const { isOpen } = action;

        const enforceUserLimit = shouldEnforceUserLimit(state);
        const notifyUserLimit = shouldNotifyUserLimit(state);

        if (enforceUserLimit) {
            dispatch(restrictWhiteboard(false));
            dispatch(openDialog(WhiteboardLimitDialog));

            return next(action);
        }

        if (isOpen) {
            if (enforceUserLimit) {
                dispatch(restrictWhiteboard());

                return next(action);
            }

            if (notifyUserLimit) {
                dispatch(notifyWhiteboardLimit());
            }

            if (isDialogOpen(state, WhiteboardLimitDialog)) {
                dispatch(hideDialog(WhiteboardLimitDialog));
            }

            const collabDetails = getCollabDetails(state);
            const collabServerUrl = generateCollabServerUrl(state);
            const localParticipantName = getLocalParticipant(state)?.name;

            navigate(screen.conference.whiteboard, {
                collabDetails,
                collabServerUrl,
                localParticipantName
            });

            return next(action);
        }

        break;
    }
    }

    return next(action);
});


################################################################################

## File: .\jitsi-meet\react\features\whiteboard\middleware.web.ts

import { generateCollaborationLinkData } from '@jitsi/excalidraw';
import { AnyAction } from 'redux';

import { IStore } from '../app/types';
import { getCurrentConference } from '../base/conference/functions';
import { hideDialog, openDialog } from '../base/dialog/actions';
import { isDialogOpen } from '../base/dialog/functions';
import { participantJoined, participantLeft, pinParticipant } from '../base/participants/actions';
import { FakeParticipant } from '../base/participants/types';
import MiddlewareRegistry from '../base/redux/MiddlewareRegistry';
import { getCurrentRoomId } from '../breakout-rooms/functions';
import { addStageParticipant } from '../filmstrip/actions.web';
import { isStageFilmstripAvailable } from '../filmstrip/functions.web';

import { RESET_WHITEBOARD, SET_WHITEBOARD_OPEN } from './actionTypes';
import {
    notifyWhiteboardLimit,
    restrictWhiteboard,
    setupWhiteboard
} from './actions';
import WhiteboardLimitDialog from './components/web/WhiteboardLimitDialog';
import { WHITEBOARD_ID, WHITEBOARD_PARTICIPANT_NAME } from './constants';
import {
    generateCollabServerUrl,
    getCollabDetails,
    isWhiteboardPresent,
    shouldEnforceUserLimit,
    shouldNotifyUserLimit
} from './functions';
import { WhiteboardStatus } from './types';

import './middleware.any';

const focusWhiteboard = (store: IStore) => {
    const { dispatch, getState } = store;
    const state = getState();
    const conference = getCurrentConference(state);
    const stageFilmstrip = isStageFilmstripAvailable(state);
    const isPresent = isWhiteboardPresent(state);

    if (!isPresent) {
        dispatch(participantJoined({
            conference,
            fakeParticipant: FakeParticipant.Whiteboard,
            id: WHITEBOARD_ID,
            name: WHITEBOARD_PARTICIPANT_NAME
        }));
    }
    if (stageFilmstrip) {
        dispatch(addStageParticipant(WHITEBOARD_ID, true));
    } else {
        dispatch(pinParticipant(WHITEBOARD_ID));
    }
};

/**
 * Middleware which intercepts whiteboard actions to handle changes to the related state.
 *
 * @param {Store} store - The redux store.
 * @returns {Function}
 */
MiddlewareRegistry.register((store: IStore) => (next: Function) => (action: AnyAction) => {
    const { dispatch, getState } = store;
    const state = getState();
    const conference = getCurrentConference(state);

    switch (action.type) {
    case SET_WHITEBOARD_OPEN: {
        const existingCollabDetails = getCollabDetails(state);
        const enforceUserLimit = shouldEnforceUserLimit(state);
        const notifyUserLimit = shouldNotifyUserLimit(state);
        const iAmRecorder = Boolean(state['features/base/config'].iAmRecorder);

        if (enforceUserLimit) {
            dispatch(restrictWhiteboard(false));
            dispatch(openDialog(WhiteboardLimitDialog));
            iAmRecorder && setTimeout(() => dispatch(hideDialog(WhiteboardLimitDialog)), 3000);

            return next(action);
        }

        if (!existingCollabDetails) {
            setNewWhiteboardOpen(store);

            return next(action);
        }

        if (action.isOpen) {
            if (enforceUserLimit) {
                dispatch(restrictWhiteboard());

                return next(action);
            }

            if (notifyUserLimit) {
                dispatch(notifyWhiteboardLimit());
            }

            if (isDialogOpen(state, WhiteboardLimitDialog)) {
                dispatch(hideDialog(WhiteboardLimitDialog));
            }

            focusWhiteboard(store);
            raiseWhiteboardNotification(WhiteboardStatus.SHOWN);

            return next(action);
        }

        dispatch(participantLeft(WHITEBOARD_ID, conference, { fakeParticipant: FakeParticipant.Whiteboard }));
        raiseWhiteboardNotification(WhiteboardStatus.HIDDEN);

        break;
    }
    case RESET_WHITEBOARD: {
        dispatch(participantLeft(WHITEBOARD_ID, conference, { fakeParticipant: FakeParticipant.Whiteboard }));
        raiseWhiteboardNotification(WhiteboardStatus.RESET);

        break;
    }
    }

    return next(action);
});

/**
 * Raises the whiteboard status notifications changes (if API is enabled).
 *
 * @param {WhiteboardStatus} status - The whiteboard changed status.
 * @returns {Function}
 */
function raiseWhiteboardNotification(status: WhiteboardStatus) {
    if (typeof APP !== 'undefined') {
        APP.API.notifyWhiteboardStatusChanged(status);
    }
}

/**
 * Sets a new whiteboard open.
 *
 * @param {IStore} store - The redux store.
 * @returns {Promise}
 */
async function setNewWhiteboardOpen(store: IStore) {
    const { dispatch, getState } = store;
    const collabLinkData = await generateCollaborationLinkData();
    const state = getState();
    const conference = getCurrentConference(state);
    const collabServerUrl = generateCollabServerUrl(state);
    const roomId = getCurrentRoomId(state);
    const collabData = {
        collabDetails: {
            roomId,
            roomKey: collabLinkData.roomKey
        },
        collabServerUrl
    };

    focusWhiteboard(store);
    dispatch(setupWhiteboard(collabData));
    conference?.getMetadataHandler().setMetadata(WHITEBOARD_ID, collabData);
    raiseWhiteboardNotification(WhiteboardStatus.INSTANTIATED);
}


################################################################################

## File: .\jitsi-meet\react\features\whiteboard\reducer.ts

import ReducerRegistry from '../base/redux/ReducerRegistry';

import { RESET_WHITEBOARD, SETUP_WHITEBOARD } from './actionTypes';

export interface IWhiteboardState {

    /**
     * The whiteboard collaboration details.
     */
    collabDetails?: { roomId: string; roomKey: string; };

    /**
     * The whiteboard collaboration url.
     */
    collabServerUrl?: string;

    /**
     * The indicator which determines whether the whiteboard is open.
     *
     * @type {boolean}
     */
    isOpen: boolean;
}

const DEFAULT_STATE: IWhiteboardState = {
    isOpen: false,
    collabDetails: undefined,
    collabServerUrl: undefined
};

export interface IWhiteboardAction extends Partial<IWhiteboardState> {

    /**
     * The whiteboard collaboration details.
     */
    collabDetails?: { roomId: string; roomKey: string; };

    /**
     * The whiteboard collaboration url.
     */
    collabServerUrl?: string;

    /**
     * The action type.
     */
    type: string;
}

ReducerRegistry.register(
    'features/whiteboard',
    (state: IWhiteboardState = DEFAULT_STATE, action: IWhiteboardAction) => {
        switch (action.type) {
        case SETUP_WHITEBOARD: {
            return {
                ...state,
                isOpen: true,
                collabDetails: action.collabDetails,
                collabServerUrl: action.collabServerUrl
            };
        }
        case RESET_WHITEBOARD:
            return DEFAULT_STATE;
        }

        return state;
    });


################################################################################

## File: .\jitsi-meet\react\features\whiteboard\types.ts


/**
 * Whiteboard statuses used to raise the notification when it's changed.
 *
 * @enum
 */
export enum WhiteboardStatus {
    FORBIDDEN = 'FORBIDDEN',
    HIDDEN = 'HIDDEN',
    INSTANTIATED = 'INSTANTIATED',
    RESET = 'RESET',
    SHOWN = 'SHOWN'
}


################################################################################

## File: .\jitsi-meet\react\features\whiteboard\components\native\styles.ts

import BaseTheme from '../../../base/ui/components/BaseTheme.native';

export const INDICATOR_COLOR = BaseTheme.palette.ui07;

const WV_BACKGROUND = BaseTheme.palette.ui03;

export default {

    backDrop: {
        backgroundColor: WV_BACKGROUND,
        flex: 1
    },

    indicatorWrapper: {
        alignItems: 'center',
        backgroundColor: BaseTheme.palette.ui10,
        height: '100%',
        justifyContent: 'center'
    },

    webView: {
        backgroundColor: WV_BACKGROUND,
        flex: 1
    },

    limitUrlText: {
        alignItems: 'center',
        display: 'flex',
        marginBottom: BaseTheme.spacing[2],
        textAlign: 'center'
    },

    limitUrl: {
        color: BaseTheme.palette.link01,
        fontWeight: 'bold'
    }
};


################################################################################

## File: .\jitsi-meet\react-native-sdk\prepare_sdk.js

const fs = require('fs');
const path = require('path');

const androidSourcePath = '../android/sdk/src/main/java/org/jitsi/meet/sdk';
const androidMainSourcePath = '../android/sdk/src/main/res';
const androidTargetPath = './android/src/main/java/org/jitsi/meet/sdk';
const androidMainTargetPath = './android/src/main/res';
const iosSrcPath = '../ios/sdk/src';
const iosDestPath = './ios/src';


/**
 * Copies a specified file in a way that recursive copy is possible.
 */
function copyFileSync(source, target) {

    let targetFile = target;

    // If target is a directory, a new file with the same name will be created
    if (fs.existsSync(target)) {
        if (fs.lstatSync(target).isDirectory()) {
            targetFile = path.join(target, path.basename(source));
        }
    }

    fs.copyFileSync(source, targetFile);
}


/**
 * Copies a specified directory recursively.
 */
function copyFolderRecursiveSync(source, target) {
    let files = [];
    const targetFolder = path.join(target, path.basename(source));

    if (!fs.existsSync(targetFolder)) {
        fs.mkdirSync(targetFolder, { recursive: true });
    }

    if (fs.lstatSync(source).isDirectory()) {
        files = fs.readdirSync(source);
        files.forEach(file => {
            const curSource = path.join(source, file);

            if (fs.lstatSync(curSource).isDirectory()) {
                copyFolderRecursiveSync(curSource, targetFolder);
            } else {
                copyFileSync(curSource, targetFolder);
            }
        });
    }
}

copyFolderRecursiveSync(
    '../images',
    '.'
);
copyFolderRecursiveSync(
    '../sounds',
    '.'
);
copyFolderRecursiveSync(
    '../lang',
    '.'
);
copyFolderRecursiveSync(
    '../modules',
    '.'
);
copyFolderRecursiveSync(
    '../react',
    '.'
);
copyFolderRecursiveSync(
    '../ios/sdk/sdk.xcodeproj',
    './ios'
);
copyFolderRecursiveSync(
    `${iosSrcPath}/callkit`,
    iosDestPath
);
copyFolderRecursiveSync(
    `${iosSrcPath}/dropbox`,
    iosDestPath
);
fs.copyFileSync(
    `${iosSrcPath}/AppInfo.m`,
    `${iosDestPath}/AppInfo.m`
);
fs.copyFileSync(
    `${iosSrcPath}/AudioMode.m`,
    `${iosDestPath}/AudioMode.m`
);
fs.copyFileSync(
    `${iosSrcPath}/InfoPlistUtil.m`,
    `${iosDestPath}/InfoPlistUtil.m`
);
fs.copyFileSync(
    `${iosSrcPath}/InfoPlistUtil.h`,
    `${iosDestPath}/InfoPlistUtil.h`
);
fs.copyFileSync(
    `${iosSrcPath}/JavaScriptSandbox.m`,
    `${iosDestPath}/JavaScriptSandbox.m`
);
fs.copyFileSync(
    `${iosSrcPath}/JitsiAudioSession.m`,
    `${iosDestPath}/JitsiAudioSession.m`
);
fs.copyFileSync(
    `${iosSrcPath}/JitsiAudioSession.h`,
    `${iosDestPath}/JitsiAudioSession.h`
);
fs.copyFileSync(
    `${iosSrcPath}/JitsiAudioSession+Private.h`,
    `${iosDestPath}/JitsiAudioSession+Private.h`
);
fs.copyFileSync(
    `${iosSrcPath}/LocaleDetector.m`,
    `${iosDestPath}/LocaleDetector.m`
);
fs.copyFileSync(
    `${iosSrcPath}/POSIX.m`,
    `${iosDestPath}/POSIX.m`
);
fs.copyFileSync(
    `${iosSrcPath}/Proximity.m`,
    `${iosDestPath}/Proximity.m`
);
copyFolderRecursiveSync(
    `${androidSourcePath}/log`,
     `${androidTargetPath}/log`
);
copyFolderRecursiveSync(
    `${androidMainSourcePath}/values`,
    `${androidMainTargetPath}`
);
copyFolderRecursiveSync(
    `${androidMainSourcePath}/drawable-hdpi`,
     `${androidMainTargetPath}`
);
copyFolderRecursiveSync(
    `${androidMainSourcePath}/drawable-mdpi`,
     `${androidMainTargetPath}`
);
copyFolderRecursiveSync(
    `${androidMainSourcePath}/drawable-xhdpi`,
     `${androidMainTargetPath}`
);
copyFolderRecursiveSync(
    `${androidMainSourcePath}/drawable-xxhdpi`,
     `${androidMainTargetPath}`
);
copyFolderRecursiveSync(
    `${androidMainSourcePath}/drawable-xxxhdpi`,
     `${androidMainTargetPath}`
);
copyFolderRecursiveSync(
    `${androidSourcePath}/net`,
    `${androidTargetPath}/log`
);
fs.copyFileSync(
    `${androidSourcePath}/AndroidSettingsModule.java`,
    `${androidTargetPath}/AndroidSettingsModule.java`
);
fs.copyFileSync(
    `${androidSourcePath}/AppInfoModule.java`,
    `${androidTargetPath}/AppInfoModule.java`
);
fs.copyFileSync(
    `${androidSourcePath}/AudioDeviceHandlerConnectionService.java`,
    `${androidTargetPath}/AudioDeviceHandlerConnectionService.java`
);
fs.copyFileSync(
    `${androidSourcePath}/AudioDeviceHandlerGeneric.java`,
    `${androidTargetPath}/AudioDeviceHandlerGeneric.java`
);
fs.copyFileSync(
    `${androidSourcePath}/AudioModeModule.java`,
    `${androidTargetPath}/AudioModeModule.java`
);
fs.copyFileSync(
    `${androidSourcePath}/ConnectionService.java`,
    `${androidTargetPath}/ConnectionService.java`
);
fs.copyFileSync(
    `${androidSourcePath}/JavaScriptSandboxModule.java`,
    `${androidTargetPath}/JavaScriptSandboxModule.java`
);
fs.copyFileSync(
    `${androidSourcePath}/LocaleDetector.java`,
    `${androidTargetPath}/LocaleDetector.java`
);
fs.copyFileSync(
    `${androidSourcePath}/LogBridgeModule.java`,
    `${androidTargetPath}/LogBridgeModule.java`
);
fs.copyFileSync(
    `${androidSourcePath}/PictureInPictureModule.java`,
    `${androidTargetPath}/PictureInPictureModule.java`
);
fs.copyFileSync(
    `${androidSourcePath}/ProximityModule.java`,
    `${androidTargetPath}/ProximityModule.java`
);
fs.copyFileSync(
    `${androidSourcePath}/RNConnectionService.java`,
    `${androidTargetPath}/RNConnectionService.java`
);


################################################################################

## File: .\jitsi-meet\react-native-sdk\sdk_instructions.js

console.log('Run node node_modules/@jitsi/react-native-sdk/update_dependencies.js '
    + 'script to update the necessary dependencies');


################################################################################

## File: .\jitsi-meet\react-native-sdk\update_dependencies.js

/* eslint-disable guard-for-in, no-continue */
/* global __dirname */

const fs = require('fs');
const path = require('path');
const semver = require('semver');


const pathToPackageJSON = path.resolve(__dirname, '../../../package.json');

const packageJSON = require(pathToPackageJSON);

const RNSDKpackageJSON = require(path.resolve(__dirname, './package.json'));


/**
 * Updates dependencies from the app package.json with the peer dependencies of the RNSDK package.json.
 */
function updateDependencies() {
    let updated = false;

    for (const key in RNSDKpackageJSON.peerDependencies) {
        if (!packageJSON.dependencies.hasOwnProperty(key)) {
            packageJSON.dependencies[key] = RNSDKpackageJSON.peerDependencies[key];
            updated = true;
        }

        if (!semver.valid(packageJSON.dependencies[key])
            && packageJSON.dependencies[key] !== RNSDKpackageJSON.peerDependencies[key]) {
            packageJSON.dependencies[key] = RNSDKpackageJSON.peerDependencies[key];
            updated = true;

            console.log(`
⚠️We changed ${key} version number from ${packageJSON.dependencies[key]} to ${RNSDKpackageJSON.peerDependencies[key]}`
            );

            continue;
        }

        if (semver.satisfies(RNSDKpackageJSON.peerDependencies[key], `=${packageJSON.dependencies[key]}`)) {
            continue;
        }

        if (semver.satisfies(RNSDKpackageJSON.peerDependencies[key], `>${packageJSON.dependencies[key]}`)) {
            packageJSON.dependencies[key] = RNSDKpackageJSON.peerDependencies[key];
            updated = true;

            console.log(`${key} is now set to ${RNSDKpackageJSON.peerDependencies[key]}`);
        }

        if (!semver.valid(RNSDKpackageJSON.peerDependencies[key])
            && RNSDKpackageJSON.peerDependencies[key].includes('github')
            && packageJSON.dependencies[key] !== RNSDKpackageJSON.peerDependencies[key]) {
            packageJSON.dependencies[key] = RNSDKpackageJSON.peerDependencies[key];
            updated = true;

            console.log(
`A fix for ${key} is available on ${RNSDKpackageJSON.peerDependencies[key]}.
This is now set on your end.`
            );
        }
    }

    packageJSON.overrides = packageJSON.overrides || {};

    for (const key in RNSDKpackageJSON.overrides) {
        if (!packageJSON.overrides.hasOwnProperty(key)) {
            packageJSON.overrides[key] = RNSDKpackageJSON.overrides[key];
            updated = true;
        }
    }

    if (!updated) {
        console.log('All your dependencies are up to date!');

        return;
    }

    console.log(`
=========================
🚀 Your project was updated!
🛠 Make sure you run npm install
📱 If you are building for iOS run cd ios && pod install to link them.
=========================
`);

    packageJSON.dependencies = Object.keys(packageJSON.dependencies)
        .sort()
        .reduce((item, itemKey) => {
            item[itemKey] = packageJSON.dependencies[itemKey];

            return item;
        }, {});

    fs.writeFileSync(pathToPackageJSON, JSON.stringify(packageJSON, null, 2));

    console.log(
        'All needed dependencies have been updated. \nPlease run npm install.'
    );
}

updateDependencies();


################################################################################

## File: .\jitsi-meet\react-native-sdk\update_sdk_dependencies.js

const fs = require('fs');

const packageJSON = require('../package.json');

const SDKPackageJSON = require('./package.json');

/**
 * Merges the dependency versions from the root package.json with the dependencies of the SDK package.json.
 */
function mergeDependencyVersions() {

    // Updates SDK dependencies to match project dependencies.
    for (const key in SDKPackageJSON.dependencies) {
        if (SDKPackageJSON.dependencies.hasOwnProperty(key)) {
            SDKPackageJSON.dependencies[key] = packageJSON.dependencies[key] || packageJSON.devDependencies[key];
        }
    }

    // Updates SDK peer dependencies.
    for (const key in packageJSON.dependencies) {
        if (SDKPackageJSON.peerDependencies.hasOwnProperty(key)) {

            // Updates all peer dependencies except react and react-native.
            if (key !== 'react' && key !== 'react-native') {
                SDKPackageJSON.peerDependencies[key] = packageJSON.dependencies[key];
            }
        }
    }

    // Updates SDK overrides dependencies.
    for (const key in packageJSON.overrides) {
        if (SDKPackageJSON.overrides.hasOwnProperty(key)) {
            SDKPackageJSON.overrides[key] = packageJSON.overrides[key];
        }
    }

    const data = JSON.stringify(SDKPackageJSON, null, 4);

    fs.writeFileSync('package.json', data);
}

mergeDependencyVersions();


################################################################################

## File: .\jitsi-meet\resources\robots.txt

User-agent: *
Allow: /$
Disallow: /


################################################################################

## File: .\jitsi-meet\resources\waiting-queue\examples\main.css



################################################################################

## File: .\jitsi-meet\resources\waiting-queue\examples\visitor.html

<!DOCTYPE html>
<html>
<head>
    <title>Conference WebSocket</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link href="./main.css" rel="stylesheet">
    <script src="https://code.jquery.com/jquery-3.1.1.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@stomp/stompjs@7.0.0/bundles/stomp.umd.min.js"></script>
    <script src="./visitor.js"></script>
</head>
<body>
<noscript><h2 style="color: #ff0000">Seems your browser doesn't support Javascript! Websocket relies on Javascript being
    enabled. Please enable
    Javascript and reload this page!</h2></noscript>
<div id="main-content" class="container">
    <div class="row">
        <div class="col-md-6">
            <form class="form-inline">
                <div class="form-group">
                    <label for="connect">WebSocket connection:</label>
                    <button id="connect" class="btn btn-default" type="submit">Connect</button>
                    <label for="conference">What is your conference?</label>
                    <input type="text" id="conference" class="form-control" placeholder="Your conference here...">
                    <button id="disconnect" class="btn btn-default" type="submit" disabled="disabled">Disconnect
                    </button>
                </div>
            </form>
        </div>
    </div>
    <div class="row">
        <div class="col-md-12">
            <table id="conference" class="table table-striped">
                <thead>
                <tr>
                    <th>Messages</th>
                </tr>
                </thead>
                <tbody id="messages">
                </tbody>
            </table>
        </div>
    </div>
</div>
</body>
</html>

################################################################################

## File: .\jitsi-meet\resources\waiting-queue\examples\visitor.js

const token = 'JWT_TOKEN_GOES_HERE'

const stompClient = new StompJs.Client({
    brokerURL: 'ws://localhost:8060/waiting-queue/visitor/websocket',
});

stompClient.onWebSocketError = (error) => {
        console.error('Error with websocket', error);
};

stompClient.onStompError = (frame) => {
    console.error('Broker reported error: ' + frame.headers['message']);
    console.error('Additional details: ' + frame.body);
};

function setConnected(connected) {
    $("#connect").prop("disabled", connected);
    $("#disconnect").prop("disabled", !connected);
    if (connected) {
        $("#conversation").show();
    }
    else {
        $("#conversation").hide();
    }
    $("#messages").html("");
}

function connect(conference) {
    console.log("Connecting to conference " + conference);

    headers = {
        Authorization: 'Bearer ' + token
    };

    stompClient.connectHeaders = headers;

    stompClient.onConnect = (frame) => {
        setConnected(true);
        console.log('Connected: ' + frame);

        stompClient.subscribe('/secured/conference/visitor/topic.' + conference, (message) => {
            showMessage(message.body);
        }, headers);
    };

    stompClient.activate();
}

function disconnect() {
    stompClient.deactivate();
    setConnected(false);
    console.log("Disconnected");
}

function showMessage(message) {
    $("#messages").append("<tr><td>" + message + "</td></tr>");
}

$(function () {
    $("form").on('submit', (e) => e.preventDefault());
    $( "#connect" ).click(() => connect($("#conference").val()));
    $( "#disconnect" ).click(() => disconnect());
});

################################################################################

## File: .\jitsi-meet\static\404.html

<html>
<head>
    <!--#include virtual="/base.html" -->
    <link rel="stylesheet" href="css/all.css"/>
    <!--#include virtual="/title.html" -->
</head>
<body>
    <div class="error_page">
        <h2>404 Not Found</h2>
        <p class="error_page__message">You can create a new conversation <a class="link" onclick="window.location = window.location.protocol + '//' + window.location.hostname">here</a></p>
    </div>
</body>
</html>


################################################################################

## File: .\jitsi-meet\static\close.html

<html>
<head>
    <!--#include virtual="/base.html" -->
    <link rel="stylesheet" href="css/all.css"/>
    <!--#include virtual="/title.html" -->
    <script><!--#include virtual="/interface_config.js" --></script>
    <script src="static/close.js"></script>
</head>
<body>
<div class="redirectPageMessage">
    <div class="thanks-msg">
        <p>Thank you for your feedback!</p>
    </div>
    <div class="hint-msg">
        <p>
            <span id="hintQuestion">Did you know?</span>
            <span class="hint-msg__holder" id="hintMessage"></span>
        </p>
        <div class="happy-software"></div>
    </div>
</div>
</body>
</html>


################################################################################

## File: .\jitsi-meet\static\close.js

/* global interfaceConfig */
// list of tips
const hints = [
    'You can pin participants by clicking on their thumbnails.',
    'You can tell others you have something to say by using the "Raise Hand" '
        + 'feature',
    'You can learn about key shortcuts by pressing Shift+?',
    'You can learn more about the state of everyone\'s connection by hovering '
        + 'on the bars in their thumbnail',
    'You can hide all thumbnails by using the button in the bottom right corner'
];

/**
 * Get a random hint message from hint array.
 *
 * @return {string} the hint message.
 */
function getHint() {
    const l = hints.length - 1;
    const n = Math.round(Math.random() * l);

    return hints[n];
}

/**
 * Inserts text message
 * into DOM element
 *
 * @param id {string} element identificator
 * @param msg {string} text message
 */
function insertTextMsg(id, msg) {
    const el = document.getElementById(id);

    if (el) {
        el.innerHTML = msg;
    }
}

/**
 * Sets the hint and thanks messages. Will be executed on load event.
 */
function onLoad() {
    // Intentionally use string concatenation as this file does not go through
    // babel but IE11 is still supported.
    // eslint-disable-next-line prefer-template
    const thankYouMessage = 'Thank you for using ' + interfaceConfig.APP_NAME;

    // Works only for close2.html because close.html doesn't have this element.
    insertTextMsg('thanksMessage', thankYouMessage);

    // If there is a setting show a special message only for the guests
    if (interfaceConfig.CLOSE_PAGE_GUEST_HINT) {
        if (window.sessionStorage.getItem('guest') === 'true') {
            const element = document.getElementById('hintQuestion');

            element.classList.add('hide');
            insertTextMsg('hintMessage', interfaceConfig.CLOSE_PAGE_GUEST_HINT);

            return;
        }
    }

    insertTextMsg('hintMessage', getHint());
}

window.onload = onLoad;


################################################################################

## File: .\jitsi-meet\static\close2.html

<html>
<head>
    <!--#include virtual="/base.html" -->
    <link rel="stylesheet" href="css/all.css"/>
    <!--#include virtual="/title.html" -->
    <script><!--#include virtual="/interface_config.js" --></script>
    <script src="static/close.js"></script>
</head>
<body>
    <div class="redirectPageMessage">
        <div class="thanks-msg">
            <p id="thanksMessage"></p>
        </div>
        <div class="hint-msg">
            <p>
                <span id="hintQuestion">Did you know?</span>
                <span class="hint-msg__holder" id="hintMessage"></span>
            </p>
            <div class="happy-software"></div>
        </div>
    </div>
</body>
</html>


################################################################################

## File: .\jitsi-meet\static\close3.html



################################################################################

## File: .\jitsi-meet\static\close3.js



################################################################################

## File: .\jitsi-meet\static\dialInInfo.html

<html xmlns="http://www.w3.org/1999/html">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="content-type" content="text/html;charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--#include virtual="/base.html" -->
    <link rel="stylesheet" href="css/all.css">
    <script>
      window.EXCALIDRAW_ASSET_PATH = 'libs/';
      document.addEventListener('DOMContentLoaded', () => {
          if (!JitsiMeetJS.app) {
            return;
          }

          JitsiMeetJS.app.renderEntryPoint({
              Component: JitsiMeetJS.app.entryPoints.DIALIN
          });
      });
    </script>
    <!--#include virtual="/title.html" -->
    <script><!--#include virtual="/config.js" --></script>
    <script><!--#include virtual="/interface_config.js" --></script>
    <script src="libs/lib-jitsi-meet.min.js?v=139"></script>
    <script src="libs/app.bundle.min.js?v=139"></script>
  </head>
  <body>
    <div id="react" role="main"></div>
  </body>
</html>


################################################################################

## File: .\jitsi-meet\static\msredirect.html

<!DOCTYPE html>
<html>
<body>
<script>
window.opener
    && window.opener.postMessage({
            type: 'ms-login',
            url: window.location.href
        }, window.location.origin);
</script>
</body>
</html>


################################################################################

## File: .\jitsi-meet\static\oauth.html

<html itemscope itemtype="http://schema.org/Product" prefix="og: http://ogp.me/ns#" xmlns="http://www.w3.org/1999/html">
<head>
    <meta charset="utf-8">
    <meta http-equiv="content-type" content="text/html;charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--#include virtual="/base.html" -->
    <!--#include virtual="/title.html" -->
    <script>
        (function() {
            var windowName = window.name;
            window.opener && window.opener.postMessage({
                type: 'dropbox-login',
                windowName,
                url: window.location.href
            }, window.location.origin);
        })();
    </script>
</head>
<body>
</body>
</html>


################################################################################

## File: .\jitsi-meet\static\offline.html

<html>

<head>
  <head>
    <!--#include virtual="/head.html" -->
    <meta charset="utf-8">
    <meta http-equiv="content-type" content="text/html;charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--#include virtual="/base.html" -->

    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <!--#include virtual="/title.html" -->
  </head>
  <style>
    body,
    .content {
      display: flex;
    }

    .content {
      align-items: center;
      flex-direction: column;
      font-family: Arial, Helvetica, sans-serif;
      font-size: 14px;
      font-weight: 400;
      line-height: 19px;
      margin: auto;
      max-width: 376px;
      text-align: center;
    }

    h4 {
      font-size: 24px;
      font-weight: 600;
      line-height: 32px;
      margin: 24px auto;
    }

    .icon {
      background-color: #FDD13A;
      border-radius: 50%;
      box-sizing: border-box;
      height: 56px;
      padding: 16px;
      width: 56px;
    }
  </style>
</head>

<body>
  <div class="content">
    <div class="icon">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path fill-rule="evenodd" clip-rule="evenodd"
          d="M21.8799 19.5904L12.8501 3.49284C12.7614 3.33481 12.6288 3.20474 12.4676 3.11782C11.9982 2.86467 11.4083 3.03257 11.1502 3.49284L2.1202 19.5904C2.04143 19.7309 2.00012 19.8885 2.00012 20.0488C2.00012 20.5741 2.43443 20.9999 2.97017 20.9999H21.0299C21.1934 20.9999 21.3542 20.9594 21.4974 20.8822C21.9668 20.629 22.138 20.0507 21.8799 19.5904ZM4.61072 19.0976L12 5.92477L19.3892 19.0976H4.61072ZM11.0302 16.2445C11.0302 15.7192 11.456 15.2934 11.9813 15.2934H12.0191C12.5444 15.2934 12.9702 15.7192 12.9702 16.2445C12.9702 16.7698 12.5444 17.1956 12.0191 17.1956H11.9813C11.456 17.1956 11.0302 16.7698 11.0302 16.2445ZM12.0002 10.5378C11.4645 10.5378 11.0302 10.9721 11.0302 11.5078V13.3722C11.0302 13.9079 11.4645 14.3422 12.0002 14.3422C12.5359 14.3422 12.9702 13.9079 12.9702 13.3722V11.5078C12.9702 10.9721 12.5359 10.5378 12.0002 10.5378Z"
          fill="#131519" fill-opacity="0.87" />
      </svg>
    </div>
    <h4>Connection error</h4>
    Your device may be offline or our servers may be experiencing problems.
  </div>
</body>

</html>


################################################################################

## File: .\jitsi-meet\static\planLimit.html



################################################################################

## File: .\jitsi-meet\static\prejoin.html

<html xmlns="http://www.w3.org/1999/html">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="content-type" content="text/html;charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--#include virtual="/base.html" -->
    <link rel="stylesheet" href="css/all.css">
    <script>
      window.EXCALIDRAW_ASSET_PATH = 'libs/';
      document.addEventListener('DOMContentLoaded', () => {
          if (!JitsiMeetJS.app) {
            return;
          }

          const url = new URL(window.location.href);
          const params = new URLSearchParams(url.search);
          const styleType = params.get('styleType');

          JitsiMeetJS.app.renderEntryPoint({
              Component: JitsiMeetJS.app.entryPoints.PREJOIN,
              props: {
                styleType
              }
          })
      })
    </script>
    <!--#include virtual="/title.html" -->
    <script><!--#include virtual="/config.js" --></script>
    <script><!--#include virtual="/interface_config.js" --></script>
    <script src="libs/lib-jitsi-meet.min.js?v=139"></script>
    <script src="libs/app.bundle.min.js?v=139"></script>
  </head>
  <body>
    <div id="react" role="main"></div>
  </body>
</html>


################################################################################

## File: .\jitsi-meet\static\recommendedBrowsers.html

<html>
<head>
    <!--#include virtual="/base.html" -->
    <link rel="stylesheet" href="css/all.css"/>
    <!--#include virtual="/title.html" -->
</head>
<body>
    <div class = 'unsupported-desktop-browser'>
        <h2 class = 'unsupported-desktop-browser__title'>
            It looks like you're using a browser we don't fully support.
        </h2>
        <p class ='unsupported-desktop-browser__description'>
            We recommend to try with the latest version of&nbsp;
            <a
                className = 'unsupported-desktop-browser__link'
                href = 'https://www.google.com/chrome/' >Chrome</a>&nbsp;or&nbsp;
            <a
                class = 'unsupported-desktop-browser__link'
                href = 'https://www.chromium.org/'>Chromium</a>
        </p>
    </div>
</body>
</html>


################################################################################

## File: .\jitsi-meet\static\settingsToolbarAdditionalContent.html

<template id="settings-toolbar-additional-content-template"></template>


################################################################################

## File: .\jitsi-meet\static\welcomePageAdditionalCard.html

<template id = "welcome-page-additional-card-template"></template>


################################################################################

## File: .\jitsi-meet\static\welcomePageAdditionalContent.html

<template id = "welcome-page-additional-content-template"></template>


################################################################################

## File: .\jitsi-meet\static\whiteboard.html

<html xmlns="http://www.w3.org/1999/html">

<head>
    <meta charset="utf-8">
    <meta http-equiv="content-type" content="text/html;charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--#include virtual="/base.html" -->
    <link rel="stylesheet" href="css/all.css">
    <script>
        window.EXCALIDRAW_ASSET_PATH = 'libs/';

        document.addEventListener('DOMContentLoaded', async () => {
            if (!JitsiMeetJS.app) {
                return;
            }

            JitsiMeetJS.app.renderEntryPoint({
                Component: JitsiMeetJS.app.entryPoints.WHITEBOARD
            });
        });
    </script>
    <!--#include virtual="/title.html" -->
    <script><!--#include virtual="/config.js" --></script>
    <script><!--#include virtual="/interface_config.js" --></script>
    <script src="libs/lib-jitsi-meet.min.js?v=139"></script>
    <script src="libs/app.bundle.min.js?v=139"></script>
</head>

<body>
    <div id="react" role="main"></div>
</body>

</html>

################################################################################

